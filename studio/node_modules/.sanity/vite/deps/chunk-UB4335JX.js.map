{
  "version": 3,
  "sources": ["../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/schema.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/merge.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/normalize.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/info.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/types.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/defined-info.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/create.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/aria.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/case-sensitive-transform.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/case-insensitive-transform.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/html.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/svg.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/xlink.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/xmlns.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/xml.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/lib/find.js", "../../../.pnpm/property-information@7.1.0/node_modules/property-information/index.js", "../../../.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js", "../../../.pnpm/hast-util-parse-selector@4.0.0/node_modules/hast-util-parse-selector/lib/index.js", "../../../.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js", "../../../.pnpm/hastscript@9.0.1/node_modules/hastscript/lib/create-h.js", "../../../.pnpm/hastscript@9.0.1/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js", "../../../.pnpm/hastscript@9.0.1/node_modules/hastscript/lib/index.js", "../../../.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js", "../../../.pnpm/character-reference-invalid@2.0.1/node_modules/character-reference-invalid/index.js", "../../../.pnpm/is-decimal@2.0.1/node_modules/is-decimal/index.js", "../../../.pnpm/is-hexadecimal@2.0.1/node_modules/is-hexadecimal/index.js", "../../../.pnpm/is-alphabetical@2.0.1/node_modules/is-alphabetical/index.js", "../../../.pnpm/is-alphanumerical@2.0.1/node_modules/is-alphanumerical/index.js", "../../../.pnpm/decode-named-character-reference@1.2.0/node_modules/decode-named-character-reference/index.dom.js", "../../../.pnpm/parse-entities@4.0.2/node_modules/parse-entities/lib/index.js", "../../../.pnpm/refractor@5.0.0/node_modules/refractor/lib/prism-core.js", "../../../.pnpm/refractor@5.0.0/node_modules/refractor/lib/core.js", "../../../.pnpm/unist-util-is@6.0.1/node_modules/unist-util-is/lib/index.js", "../../../.pnpm/unist-util-filter@5.0.1/node_modules/unist-util-filter/lib/index.js", "../../../.pnpm/unist-util-visit-parents@6.0.2/node_modules/unist-util-visit-parents/lib/color.js", "../../../.pnpm/unist-util-visit-parents@6.0.2/node_modules/unist-util-visit-parents/lib/index.js", "../../../.pnpm/react-refractor@4.0.0_react@19.2.0/node_modules/react-refractor/src/addMarkers.ts", "../../../.pnpm/react-refractor@4.0.0_react@19.2.0/node_modules/react-refractor/src/mapChildren.ts", "../../../.pnpm/react-refractor@4.0.0_react@19.2.0/node_modules/react-refractor/src/Refractor.tsx"],
  "sourcesContent": ["/**\n * @import {Schema as SchemaType, Space} from 'property-information'\n */\n\n/** @type {SchemaType} */\nexport class Schema {\n  /**\n   * @param {SchemaType['property']} property\n   *   Property.\n   * @param {SchemaType['normal']} normal\n   *   Normal.\n   * @param {Space | undefined} [space]\n   *   Space.\n   * @returns\n   *   Schema.\n   */\n  constructor(property, normal, space) {\n    this.normal = normal\n    this.property = property\n\n    if (space) {\n      this.space = space\n    }\n  }\n}\n\nSchema.prototype.normal = {}\nSchema.prototype.property = {}\nSchema.prototype.space = undefined\n", "/**\n * @import {Info, Space} from 'property-information'\n */\n\nimport {Schema} from './schema.js'\n\n/**\n * @param {ReadonlyArray<Schema>} definitions\n *   Definitions.\n * @param {Space | undefined} [space]\n *   Space.\n * @returns {Schema}\n *   Schema.\n */\nexport function merge(definitions, space) {\n  /** @type {Record<string, Info>} */\n  const property = {}\n  /** @type {Record<string, string>} */\n  const normal = {}\n\n  for (const definition of definitions) {\n    Object.assign(property, definition.property)\n    Object.assign(normal, definition.normal)\n  }\n\n  return new Schema(property, normal, space)\n}\n", "/**\n * Get the cleaned case insensitive form of an attribute or property.\n *\n * @param {string} value\n *   An attribute-like or property-like name.\n * @returns {string}\n *   Value that can be used to look up the properly cased property on a\n *   `Schema`.\n */\nexport function normalize(value) {\n  return value.toLowerCase()\n}\n", "/**\n * @import {Info as InfoType} from 'property-information'\n */\n\n/** @type {InfoType} */\nexport class Info {\n  /**\n   * @param {string} property\n   *   Property.\n   * @param {string} attribute\n   *   Attribute.\n   * @returns\n   *   Info.\n   */\n  constructor(property, attribute) {\n    this.attribute = attribute\n    this.property = property\n  }\n}\n\nInfo.prototype.attribute = ''\nInfo.prototype.booleanish = false\nInfo.prototype.boolean = false\nInfo.prototype.commaOrSpaceSeparated = false\nInfo.prototype.commaSeparated = false\nInfo.prototype.defined = false\nInfo.prototype.mustUseProperty = false\nInfo.prototype.number = false\nInfo.prototype.overloadedBoolean = false\nInfo.prototype.property = ''\nInfo.prototype.spaceSeparated = false\nInfo.prototype.space = undefined\n", "let powers = 0\n\nexport const boolean = increment()\nexport const booleanish = increment()\nexport const overloadedBoolean = increment()\nexport const number = increment()\nexport const spaceSeparated = increment()\nexport const commaSeparated = increment()\nexport const commaOrSpaceSeparated = increment()\n\nfunction increment() {\n  return 2 ** ++powers\n}\n", "/**\n * @import {Space} from 'property-information'\n */\n\nimport {Info} from './info.js'\nimport * as types from './types.js'\n\nconst checks = /** @type {ReadonlyArray<keyof typeof types>} */ (\n  Object.keys(types)\n)\n\nexport class DefinedInfo extends Info {\n  /**\n   * @constructor\n   * @param {string} property\n   *   Property.\n   * @param {string} attribute\n   *   Attribute.\n   * @param {number | null | undefined} [mask]\n   *   Mask.\n   * @param {Space | undefined} [space]\n   *   Space.\n   * @returns\n   *   Info.\n   */\n  constructor(property, attribute, mask, space) {\n    let index = -1\n\n    super(property, attribute)\n\n    mark(this, 'space', space)\n\n    if (typeof mask === 'number') {\n      while (++index < checks.length) {\n        const check = checks[index]\n        mark(this, checks[index], (mask & types[check]) === types[check])\n      }\n    }\n  }\n}\n\nDefinedInfo.prototype.defined = true\n\n/**\n * @template {keyof DefinedInfo} Key\n *   Key type.\n * @param {DefinedInfo} values\n *   Info.\n * @param {Key} key\n *   Key.\n * @param {DefinedInfo[Key]} value\n *   Value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction mark(values, key, value) {\n  if (value) {\n    values[key] = value\n  }\n}\n", "/**\n * @import {Info, Space} from 'property-information'\n */\n\n/**\n * @typedef Definition\n *   Definition of a schema.\n * @property {Record<string, string> | undefined} [attributes]\n *   Normalzed names to special attribute case.\n * @property {ReadonlyArray<string> | undefined} [mustUseProperty]\n *   Normalized names that must be set as properties.\n * @property {Record<string, number | null>} properties\n *   Property names to their types.\n * @property {Space | undefined} [space]\n *   Space.\n * @property {Transform} transform\n *   Transform a property name.\n */\n\n/**\n * @callback Transform\n *   Transform.\n * @param {Record<string, string>} attributes\n *   Attributes.\n * @param {string} property\n *   Property.\n * @returns {string}\n *   Attribute.\n */\n\nimport {normalize} from '../normalize.js'\nimport {DefinedInfo} from './defined-info.js'\nimport {Schema} from './schema.js'\n\n/**\n * @param {Definition} definition\n *   Definition.\n * @returns {Schema}\n *   Schema.\n */\nexport function create(definition) {\n  /** @type {Record<string, Info>} */\n  const properties = {}\n  /** @type {Record<string, string>} */\n  const normals = {}\n\n  for (const [property, value] of Object.entries(definition.properties)) {\n    const info = new DefinedInfo(\n      property,\n      definition.transform(definition.attributes || {}, property),\n      value,\n      definition.space\n    )\n\n    if (\n      definition.mustUseProperty &&\n      definition.mustUseProperty.includes(property)\n    ) {\n      info.mustUseProperty = true\n    }\n\n    properties[property] = info\n\n    normals[normalize(property)] = property\n    normals[normalize(info.attribute)] = property\n  }\n\n  return new Schema(properties, normals, definition.space)\n}\n", "import {create} from './util/create.js'\nimport {booleanish, number, spaceSeparated} from './util/types.js'\n\nexport const aria = create({\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: booleanish,\n    ariaAutoComplete: null,\n    ariaBusy: booleanish,\n    ariaChecked: booleanish,\n    ariaColCount: number,\n    ariaColIndex: number,\n    ariaColSpan: number,\n    ariaControls: spaceSeparated,\n    ariaCurrent: null,\n    ariaDescribedBy: spaceSeparated,\n    ariaDetails: null,\n    ariaDisabled: booleanish,\n    ariaDropEffect: spaceSeparated,\n    ariaErrorMessage: null,\n    ariaExpanded: booleanish,\n    ariaFlowTo: spaceSeparated,\n    ariaGrabbed: booleanish,\n    ariaHasPopup: null,\n    ariaHidden: booleanish,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: spaceSeparated,\n    ariaLevel: number,\n    ariaLive: null,\n    ariaModal: booleanish,\n    ariaMultiLine: booleanish,\n    ariaMultiSelectable: booleanish,\n    ariaOrientation: null,\n    ariaOwns: spaceSeparated,\n    ariaPlaceholder: null,\n    ariaPosInSet: number,\n    ariaPressed: booleanish,\n    ariaReadOnly: booleanish,\n    ariaRelevant: null,\n    ariaRequired: booleanish,\n    ariaRoleDescription: spaceSeparated,\n    ariaRowCount: number,\n    ariaRowIndex: number,\n    ariaRowSpan: number,\n    ariaSelected: booleanish,\n    ariaSetSize: number,\n    ariaSort: null,\n    ariaValueMax: number,\n    ariaValueMin: number,\n    ariaValueNow: number,\n    ariaValueText: null,\n    role: null\n  },\n  transform(_, property) {\n    return property === 'role'\n      ? property\n      : 'aria-' + property.slice(4).toLowerCase()\n  }\n})\n", "/**\n * @param {Record<string, string>} attributes\n *   Attributes.\n * @param {string} attribute\n *   Attribute.\n * @returns {string}\n *   Transformed attribute.\n */\nexport function caseSensitiveTransform(attributes, attribute) {\n  return attribute in attributes ? attributes[attribute] : attribute\n}\n", "import {caseSensitiveTransform} from './case-sensitive-transform.js'\n\n/**\n * @param {Record<string, string>} attributes\n *   Attributes.\n * @param {string} property\n *   Property.\n * @returns {string}\n *   Transformed property.\n */\nexport function caseInsensitiveTransform(attributes, property) {\n  return caseSensitiveTransform(attributes, property.toLowerCase())\n}\n", "import {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\nimport {create} from './util/create.js'\nimport {\n  booleanish,\n  boolean,\n  commaSeparated,\n  number,\n  overloadedBoolean,\n  spaceSeparated\n} from './util/types.js'\n\nexport const html = create({\n  attributes: {\n    acceptcharset: 'accept-charset',\n    classname: 'class',\n    htmlfor: 'for',\n    httpequiv: 'http-equiv'\n  },\n  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: commaSeparated,\n    acceptCharset: spaceSeparated,\n    accessKey: spaceSeparated,\n    action: null,\n    allow: null,\n    allowFullScreen: boolean,\n    allowPaymentRequest: boolean,\n    allowUserMedia: boolean,\n    alt: null,\n    as: null,\n    async: boolean,\n    autoCapitalize: null,\n    autoComplete: spaceSeparated,\n    autoFocus: boolean,\n    autoPlay: boolean,\n    blocking: spaceSeparated,\n    capture: null,\n    charSet: null,\n    checked: boolean,\n    cite: null,\n    className: spaceSeparated,\n    cols: number,\n    colSpan: null,\n    content: null,\n    contentEditable: booleanish,\n    controls: boolean,\n    controlsList: spaceSeparated,\n    coords: number | commaSeparated,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: boolean,\n    defer: boolean,\n    dir: null,\n    dirName: null,\n    disabled: boolean,\n    download: overloadedBoolean,\n    draggable: booleanish,\n    encType: null,\n    enterKeyHint: null,\n    fetchPriority: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: boolean,\n    formTarget: null,\n    headers: spaceSeparated,\n    height: number,\n    hidden: overloadedBoolean,\n    high: number,\n    href: null,\n    hrefLang: null,\n    htmlFor: spaceSeparated,\n    httpEquiv: spaceSeparated,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inert: boolean,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: boolean,\n    itemId: null,\n    itemProp: spaceSeparated,\n    itemRef: spaceSeparated,\n    itemScope: boolean,\n    itemType: spaceSeparated,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: boolean,\n    low: number,\n    manifest: null,\n    max: null,\n    maxLength: number,\n    media: null,\n    method: null,\n    min: null,\n    minLength: number,\n    multiple: boolean,\n    muted: boolean,\n    name: null,\n    nonce: null,\n    noModule: boolean,\n    noValidate: boolean,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeToggle: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: boolean,\n    optimum: number,\n    pattern: null,\n    ping: spaceSeparated,\n    placeholder: null,\n    playsInline: boolean,\n    popover: null,\n    popoverTarget: null,\n    popoverTargetAction: null,\n    poster: null,\n    preload: null,\n    readOnly: boolean,\n    referrerPolicy: null,\n    rel: spaceSeparated,\n    required: boolean,\n    reversed: boolean,\n    rows: number,\n    rowSpan: number,\n    sandbox: spaceSeparated,\n    scope: null,\n    scoped: boolean,\n    seamless: boolean,\n    selected: boolean,\n    shadowRootClonable: boolean,\n    shadowRootDelegatesFocus: boolean,\n    shadowRootMode: null,\n    shape: null,\n    size: number,\n    sizes: null,\n    slot: null,\n    span: number,\n    spellCheck: booleanish,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: number,\n    step: null,\n    style: null,\n    tabIndex: number,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: boolean,\n    useMap: null,\n    value: booleanish,\n    width: number,\n    wrap: null,\n    writingSuggestions: null,\n\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null, // Several. Use CSS `text-align` instead,\n    aLink: null, // `<body>`. Use CSS `a:active {color}` instead\n    archive: spaceSeparated, // `<object>`. List of URIs to archives\n    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null, // `<body>`. Use CSS `background-image` instead\n    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead\n    border: number, // `<table>`. Use CSS `border-width` instead,\n    borderColor: null, // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: number, // `<body>`\n    cellPadding: null, // `<table>`\n    cellSpacing: null, // `<table>`\n    char: null, // Several table elements. When `align=char`, sets the character to align on\n    charOff: null, // Several table elements. When `char`, offsets the alignment\n    classId: null, // `<object>`\n    clear: null, // `<br>`. Use CSS `clear` instead\n    code: null, // `<object>`\n    codeBase: null, // `<object>`\n    codeType: null, // `<object>`\n    color: null, // `<font>` and `<hr>`. Use CSS instead\n    compact: boolean, // Lists. Use CSS to reduce space between items instead\n    declare: boolean, // `<object>`\n    event: null, // `<script>`\n    face: null, // `<font>`. Use CSS instead\n    frame: null, // `<table>`\n    frameBorder: null, // `<iframe>`. Use CSS `border` instead\n    hSpace: number, // `<img>` and `<object>`\n    leftMargin: number, // `<body>`\n    link: null, // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null, // `<img>`. Use a `<picture>`\n    marginHeight: number, // `<body>`\n    marginWidth: number, // `<body>`\n    noResize: boolean, // `<frame>`\n    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: boolean, // `<hr>`. Use background-color and height instead of borders\n    noWrap: boolean, // `<td>` and `<th>`\n    object: null, // `<applet>`\n    profile: null, // `<head>`\n    prompt: null, // `<isindex>`\n    rev: null, // `<link>`\n    rightMargin: number, // `<body>`\n    rules: null, // `<table>`\n    scheme: null, // `<meta>`\n    scrolling: booleanish, // `<frame>`. Use overflow in the child context\n    standby: null, // `<object>`\n    summary: null, // `<table>`\n    text: null, // `<body>`. Use CSS `color` instead\n    topMargin: number, // `<body>`\n    valueType: null, // `<param>`\n    version: null, // `<html>`. Use a doctype.\n    vAlign: null, // Several. Use CSS `vertical-align` instead\n    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: number, // `<img>` and `<object>`\n\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: boolean,\n    disableRemotePlayback: boolean,\n    prefix: null,\n    property: null,\n    results: number,\n    security: null,\n    unselectable: null\n  },\n  space: 'html',\n  transform: caseInsensitiveTransform\n})\n", "import {caseSensitiveTransform} from './util/case-sensitive-transform.js'\nimport {create} from './util/create.js'\nimport {\n  boolean,\n  commaOrSpaceSeparated,\n  commaSeparated,\n  number,\n  spaceSeparated\n} from './util/types.js'\n\nexport const svg = create({\n  attributes: {\n    accentHeight: 'accent-height',\n    alignmentBaseline: 'alignment-baseline',\n    arabicForm: 'arabic-form',\n    baselineShift: 'baseline-shift',\n    capHeight: 'cap-height',\n    className: 'class',\n    clipPath: 'clip-path',\n    clipRule: 'clip-rule',\n    colorInterpolation: 'color-interpolation',\n    colorInterpolationFilters: 'color-interpolation-filters',\n    colorProfile: 'color-profile',\n    colorRendering: 'color-rendering',\n    crossOrigin: 'crossorigin',\n    dataType: 'datatype',\n    dominantBaseline: 'dominant-baseline',\n    enableBackground: 'enable-background',\n    fillOpacity: 'fill-opacity',\n    fillRule: 'fill-rule',\n    floodColor: 'flood-color',\n    floodOpacity: 'flood-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    fontSizeAdjust: 'font-size-adjust',\n    fontStretch: 'font-stretch',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    glyphName: 'glyph-name',\n    glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n    glyphOrientationVertical: 'glyph-orientation-vertical',\n    hrefLang: 'hreflang',\n    horizAdvX: 'horiz-adv-x',\n    horizOriginX: 'horiz-origin-x',\n    horizOriginY: 'horiz-origin-y',\n    imageRendering: 'image-rendering',\n    letterSpacing: 'letter-spacing',\n    lightingColor: 'lighting-color',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    navDown: 'nav-down',\n    navDownLeft: 'nav-down-left',\n    navDownRight: 'nav-down-right',\n    navLeft: 'nav-left',\n    navNext: 'nav-next',\n    navPrev: 'nav-prev',\n    navRight: 'nav-right',\n    navUp: 'nav-up',\n    navUpLeft: 'nav-up-left',\n    navUpRight: 'nav-up-right',\n    onAbort: 'onabort',\n    onActivate: 'onactivate',\n    onAfterPrint: 'onafterprint',\n    onBeforePrint: 'onbeforeprint',\n    onBegin: 'onbegin',\n    onCancel: 'oncancel',\n    onCanPlay: 'oncanplay',\n    onCanPlayThrough: 'oncanplaythrough',\n    onChange: 'onchange',\n    onClick: 'onclick',\n    onClose: 'onclose',\n    onCopy: 'oncopy',\n    onCueChange: 'oncuechange',\n    onCut: 'oncut',\n    onDblClick: 'ondblclick',\n    onDrag: 'ondrag',\n    onDragEnd: 'ondragend',\n    onDragEnter: 'ondragenter',\n    onDragExit: 'ondragexit',\n    onDragLeave: 'ondragleave',\n    onDragOver: 'ondragover',\n    onDragStart: 'ondragstart',\n    onDrop: 'ondrop',\n    onDurationChange: 'ondurationchange',\n    onEmptied: 'onemptied',\n    onEnd: 'onend',\n    onEnded: 'onended',\n    onError: 'onerror',\n    onFocus: 'onfocus',\n    onFocusIn: 'onfocusin',\n    onFocusOut: 'onfocusout',\n    onHashChange: 'onhashchange',\n    onInput: 'oninput',\n    onInvalid: 'oninvalid',\n    onKeyDown: 'onkeydown',\n    onKeyPress: 'onkeypress',\n    onKeyUp: 'onkeyup',\n    onLoad: 'onload',\n    onLoadedData: 'onloadeddata',\n    onLoadedMetadata: 'onloadedmetadata',\n    onLoadStart: 'onloadstart',\n    onMessage: 'onmessage',\n    onMouseDown: 'onmousedown',\n    onMouseEnter: 'onmouseenter',\n    onMouseLeave: 'onmouseleave',\n    onMouseMove: 'onmousemove',\n    onMouseOut: 'onmouseout',\n    onMouseOver: 'onmouseover',\n    onMouseUp: 'onmouseup',\n    onMouseWheel: 'onmousewheel',\n    onOffline: 'onoffline',\n    onOnline: 'ononline',\n    onPageHide: 'onpagehide',\n    onPageShow: 'onpageshow',\n    onPaste: 'onpaste',\n    onPause: 'onpause',\n    onPlay: 'onplay',\n    onPlaying: 'onplaying',\n    onPopState: 'onpopstate',\n    onProgress: 'onprogress',\n    onRateChange: 'onratechange',\n    onRepeat: 'onrepeat',\n    onReset: 'onreset',\n    onResize: 'onresize',\n    onScroll: 'onscroll',\n    onSeeked: 'onseeked',\n    onSeeking: 'onseeking',\n    onSelect: 'onselect',\n    onShow: 'onshow',\n    onStalled: 'onstalled',\n    onStorage: 'onstorage',\n    onSubmit: 'onsubmit',\n    onSuspend: 'onsuspend',\n    onTimeUpdate: 'ontimeupdate',\n    onToggle: 'ontoggle',\n    onUnload: 'onunload',\n    onVolumeChange: 'onvolumechange',\n    onWaiting: 'onwaiting',\n    onZoom: 'onzoom',\n    overlinePosition: 'overline-position',\n    overlineThickness: 'overline-thickness',\n    paintOrder: 'paint-order',\n    panose1: 'panose-1',\n    pointerEvents: 'pointer-events',\n    referrerPolicy: 'referrerpolicy',\n    renderingIntent: 'rendering-intent',\n    shapeRendering: 'shape-rendering',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strikethroughPosition: 'strikethrough-position',\n    strikethroughThickness: 'strikethrough-thickness',\n    strokeDashArray: 'stroke-dasharray',\n    strokeDashOffset: 'stroke-dashoffset',\n    strokeLineCap: 'stroke-linecap',\n    strokeLineJoin: 'stroke-linejoin',\n    strokeMiterLimit: 'stroke-miterlimit',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    tabIndex: 'tabindex',\n    textAnchor: 'text-anchor',\n    textDecoration: 'text-decoration',\n    textRendering: 'text-rendering',\n    transformOrigin: 'transform-origin',\n    typeOf: 'typeof',\n    underlinePosition: 'underline-position',\n    underlineThickness: 'underline-thickness',\n    unicodeBidi: 'unicode-bidi',\n    unicodeRange: 'unicode-range',\n    unitsPerEm: 'units-per-em',\n    vAlphabetic: 'v-alphabetic',\n    vHanging: 'v-hanging',\n    vIdeographic: 'v-ideographic',\n    vMathematical: 'v-mathematical',\n    vectorEffect: 'vector-effect',\n    vertAdvY: 'vert-adv-y',\n    vertOriginX: 'vert-origin-x',\n    vertOriginY: 'vert-origin-y',\n    wordSpacing: 'word-spacing',\n    writingMode: 'writing-mode',\n    xHeight: 'x-height',\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: 'playbackorder',\n    timelineBegin: 'timelinebegin'\n  },\n  properties: {\n    about: commaOrSpaceSeparated,\n    accentHeight: number,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: number,\n    amplitude: number,\n    arabicForm: null,\n    ascent: number,\n    attributeName: null,\n    attributeType: null,\n    azimuth: number,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: number,\n    by: null,\n    calcMode: null,\n    capHeight: number,\n    className: spaceSeparated,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: number,\n    diffuseConstant: number,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: number,\n    dominantBaseline: null,\n    download: boolean,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: number,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: number,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: number,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: commaSeparated,\n    g2: commaSeparated,\n    glyphName: commaSeparated,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: number,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: number,\n    horizOriginX: number,\n    horizOriginY: number,\n    id: null,\n    ideographic: number,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: number,\n    k: number,\n    k1: number,\n    k2: number,\n    k3: number,\n    k4: number,\n    kernelMatrix: commaOrSpaceSeparated,\n    kernelUnitLength: null,\n    keyPoints: null, // SEMI_COLON_SEPARATED\n    keySplines: null, // SEMI_COLON_SEPARATED\n    keyTimes: null, // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: number,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: number,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: number,\n    overlineThickness: number,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: number,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: spaceSeparated,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: number,\n    pointsAtY: number,\n    pointsAtZ: number,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: commaOrSpaceSeparated,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: commaOrSpaceSeparated,\n    rev: commaOrSpaceSeparated,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: commaOrSpaceSeparated,\n    requiredFeatures: commaOrSpaceSeparated,\n    requiredFonts: commaOrSpaceSeparated,\n    requiredFormats: commaOrSpaceSeparated,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: number,\n    specularExponent: number,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: number,\n    strikethroughThickness: number,\n    string: null,\n    stroke: null,\n    strokeDashArray: commaOrSpaceSeparated,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: number,\n    strokeOpacity: number,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: number,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: commaOrSpaceSeparated,\n    tabIndex: number,\n    tableValues: null,\n    target: null,\n    targetX: number,\n    targetY: number,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: commaOrSpaceSeparated,\n    to: null,\n    transform: null,\n    transformOrigin: null,\n    u1: null,\n    u2: null,\n    underlinePosition: number,\n    underlineThickness: number,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: number,\n    values: null,\n    vAlphabetic: number,\n    vMathematical: number,\n    vectorEffect: null,\n    vHanging: number,\n    vIdeographic: number,\n    version: null,\n    vertAdvY: number,\n    vertOriginX: number,\n    vertOriginY: number,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: number,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  },\n  space: 'svg',\n  transform: caseSensitiveTransform\n})\n", "import {create} from './util/create.js'\n\nexport const xlink = create({\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  },\n  space: 'xlink',\n  transform(_, property) {\n    return 'xlink:' + property.slice(5).toLowerCase()\n  }\n})\n", "import {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const xmlns = create({\n  attributes: {xmlnsxlink: 'xmlns:xlink'},\n  properties: {xmlnsXLink: null, xmlns: null},\n  space: 'xmlns',\n  transform: caseInsensitiveTransform\n})\n", "import {create} from './util/create.js'\n\nexport const xml = create({\n  properties: {xmlBase: null, xmlLang: null, xmlSpace: null},\n  space: 'xml',\n  transform(_, property) {\n    return 'xml:' + property.slice(3).toLowerCase()\n  }\n})\n", "/**\n * @import {Schema} from 'property-information'\n */\n\nimport {DefinedInfo} from './util/defined-info.js'\nimport {Info} from './util/info.js'\nimport {normalize} from './normalize.js'\n\nconst cap = /[A-Z]/g\nconst dash = /-[a-z]/g\nconst valid = /^data[-\\w.:]+$/i\n\n/**\n * Look up info on a property.\n *\n * In most cases the given `schema` contains info on the property.\n * All standard,\n * most legacy,\n * and some non-standard properties are supported.\n * For these cases,\n * the returned `Info` has hints about the value of the property.\n *\n * `name` can also be a valid data attribute or property,\n * in which case an `Info` object with the correctly cased `attribute` and\n * `property` is returned.\n *\n * `name` can be an unknown attribute,\n * in which case an `Info` object with `attribute` and `property` set to the\n * given name is returned.\n * It is not recommended to provide unsupported legacy or recently specced\n * properties.\n *\n *\n * @param {Schema} schema\n *   Schema;\n *   either the `html` or `svg` export.\n * @param {string} value\n *   An attribute-like or property-like name;\n *   it will be passed through `normalize` to hopefully find the correct info.\n * @returns {Info}\n *   Info.\n */\nexport function find(schema, value) {\n  const normal = normalize(value)\n  let property = value\n  let Type = Info\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]]\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase)\n      property = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4)\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab)\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes\n        }\n\n        value = 'data' + dashes\n      }\n    }\n\n    Type = DefinedInfo\n  }\n\n  return new Type(property, value)\n}\n\n/**\n * @param {string} $0\n *   Value.\n * @returns {string}\n *   Kebab.\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * @param {string} $0\n *   Value.\n * @returns {string}\n *   Camel.\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase()\n}\n", "// Note: types exposed from `index.d.ts`.\nimport {merge} from './lib/util/merge.js'\nimport {aria} from './lib/aria.js'\nimport {html as htmlBase} from './lib/html.js'\nimport {svg as svgBase} from './lib/svg.js'\nimport {xlink} from './lib/xlink.js'\nimport {xmlns} from './lib/xmlns.js'\nimport {xml} from './lib/xml.js'\n\nexport {hastToReact} from './lib/hast-to-react.js'\n\nexport const html = merge([aria, htmlBase, xlink, xmlns, xml], 'html')\n\nexport {find} from './lib/find.js'\nexport {normalize} from './lib/normalize.js'\n\nexport const svg = merge([aria, svgBase, xlink, xmlns, xml], 'svg')\n", "/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nexport function stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n", "/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n", "/**\n * @import {Element, Nodes, RootContent, Root} from 'hast'\n * @import {Info, Schema} from 'property-information'\n */\n\n/**\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n */\n\n/**\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n */\n\n/**\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n */\n\n/**\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\n/**\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n */\n\n/**\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n */\n\n/**\n * @typedef {Record<string, PropertyValue | Style>} Properties\n *   Acceptable value for element properties.\n */\n\n/**\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n */\n\n/**\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n */\n\n/**\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n */\n\nimport {parse as parseCommas} from 'comma-separated-tokens'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {find, normalize} from 'property-information'\nimport {parse as parseSpaces} from 'space-separated-tokens'\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    /** @type {Result} */\n    let node\n\n    if (selector === null || selector === undefined) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = parseSelector(selector, defaultTagName)\n      // Normalize the name.\n      const lower = node.tagName.toLowerCase()\n      const adjusted = adjust ? adjust.get(lower) : undefined\n      node.tagName = adjusted || lower\n\n      // Handle properties.\n      if (isChild(properties)) {\n        children.unshift(properties)\n      } else {\n        for (const [key, value] of Object.entries(properties)) {\n          addProperty(schema, node.properties, key, value)\n        }\n      }\n    }\n\n    // Handle children.\n    for (const child of children) {\n      addChild(node.children, child)\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true\n  }\n\n  // Never node without `type`; that’s the main discriminator.\n  if (typeof value.type !== 'string') return false\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */ (value)\n  const keys = Object.keys(value)\n\n  for (const key of keys) {\n    const value = record[key]\n\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true\n\n      const list = /** @type {ReadonlyArray<unknown>} */ (value)\n\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === null || value === undefined) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = parseSpaces(value)\n    } else if (info.commaSeparated) {\n      result = parseCommas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = parseSpaces(parseCommas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = [...value]\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    for (const item of result) {\n      // Assume no booleans in array.\n      finalResult.push(\n        /** @type {number | string} */ (\n          parsePrimitive(info, info.property, item)\n        )\n      )\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    result = properties.className.concat(\n      /** @type {Array<number | string> | number | string} */ (result)\n    )\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  if (value === null || value === undefined) {\n    // Empty.\n  } else if (typeof value === 'number' || typeof value === 'string') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    for (const child of value) {\n      addChild(nodes, child)\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} styles\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(styles) {\n  /** @type {Array<string>} */\n  const result = []\n\n  for (const [key, value] of Object.entries(styles)) {\n    result.push([key, value].join(': '))\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {ReadonlyArray<string>} values\n *   List of properly cased keys.\n * @returns {Map<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Map<string, string>} */\n  const result = new Map()\n\n  for (const value of values) {\n    result.set(value.toLowerCase(), value)\n  }\n\n  return result\n}\n", "/**\n * List of case-sensitive SVG tag names.\n *\n * @type {ReadonlyArray<string>}\n */\nexport const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n", "// Register the JSX namespace on `h`.\n/**\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n */\n\n// Register the JSX namespace on `s`.\n/**\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n */\n\nimport {html, svg} from 'property-information'\nimport {createH} from './create-h.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const h = createH(html, 'div')\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const s = createH(svg, 'g', svgCaseSensitiveTagNames)\n", "/**\n * List of legacy HTML named character references that don’t need a trailing semicolon.\n *\n * @type {Array<string>}\n */\nexport const characterEntitiesLegacy = [\n  'AElig',\n  'AMP',\n  'Aacute',\n  'Acirc',\n  'Agrave',\n  'Aring',\n  'Atilde',\n  'Auml',\n  'COPY',\n  'Ccedil',\n  'ETH',\n  'Eacute',\n  'Ecirc',\n  'Egrave',\n  'Euml',\n  'GT',\n  'Iacute',\n  'Icirc',\n  'Igrave',\n  'Iuml',\n  'LT',\n  'Ntilde',\n  'Oacute',\n  'Ocirc',\n  'Ograve',\n  'Oslash',\n  'Otilde',\n  'Ouml',\n  'QUOT',\n  'REG',\n  'THORN',\n  'Uacute',\n  'Ucirc',\n  'Ugrave',\n  'Uuml',\n  'Yacute',\n  'aacute',\n  'acirc',\n  'acute',\n  'aelig',\n  'agrave',\n  'amp',\n  'aring',\n  'atilde',\n  'auml',\n  'brvbar',\n  'ccedil',\n  'cedil',\n  'cent',\n  'copy',\n  'curren',\n  'deg',\n  'divide',\n  'eacute',\n  'ecirc',\n  'egrave',\n  'eth',\n  'euml',\n  'frac12',\n  'frac14',\n  'frac34',\n  'gt',\n  'iacute',\n  'icirc',\n  'iexcl',\n  'igrave',\n  'iquest',\n  'iuml',\n  'laquo',\n  'lt',\n  'macr',\n  'micro',\n  'middot',\n  'nbsp',\n  'not',\n  'ntilde',\n  'oacute',\n  'ocirc',\n  'ograve',\n  'ordf',\n  'ordm',\n  'oslash',\n  'otilde',\n  'ouml',\n  'para',\n  'plusmn',\n  'pound',\n  'quot',\n  'raquo',\n  'reg',\n  'sect',\n  'shy',\n  'sup1',\n  'sup2',\n  'sup3',\n  'szlig',\n  'thorn',\n  'times',\n  'uacute',\n  'ucirc',\n  'ugrave',\n  'uml',\n  'uuml',\n  'yacute',\n  'yen',\n  'yuml'\n]\n", "/**\n * Map of invalid numeric character references to their replacements, according to HTML.\n *\n * @type {Record<number, string>}\n */\nexport const characterReferenceInvalid = {\n  0: '�',\n  128: '€',\n  130: '‚',\n  131: 'ƒ',\n  132: '„',\n  133: '…',\n  134: '†',\n  135: '‡',\n  136: 'ˆ',\n  137: '‰',\n  138: 'Š',\n  139: '‹',\n  140: 'Œ',\n  142: 'Ž',\n  145: '‘',\n  146: '’',\n  147: '“',\n  148: '”',\n  149: '•',\n  150: '–',\n  151: '—',\n  152: '˜',\n  153: '™',\n  154: 'š',\n  155: '›',\n  156: 'œ',\n  158: 'ž',\n  159: 'Ÿ'\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is decimal.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is a decimal\n */\nexport function isDecimal(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return code >= 48 && code <= 57 /* 0-9 */\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is hexadecimal.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is hexadecimal\n */\nexport function isHexadecimal(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 /* a */ && code <= 102) /* z */ ||\n    (code >= 65 /* A */ && code <= 70) /* Z */ ||\n    (code >= 48 /* A */ && code <= 57) /* Z */\n  )\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is alphabetical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphabetical.\n */\nexport function isAlphabetical(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 && code <= 122) /* a-z */ ||\n    (code >= 65 && code <= 90) /* A-Z */\n  )\n}\n", "import {isAlphabetical} from 'is-alphabetical'\nimport {isDecimal} from 'is-decimal'\n\n/**\n * Check if the given character code, or the character code at the first\n * character, is alphanumerical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphanumerical.\n */\nexport function isAlphanumerical(character) {\n  return isAlphabetical(character) || isDecimal(character)\n}\n", "/// <reference lib=\"dom\" />\n\n/* global document */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string | false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const character = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&\n    value !== 'semi'\n  ) {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return character === characterReference ? false : character\n}\n", "/**\n * @import {Point} from 'unist'\n * @import {Options} from '../index.js'\n */\n\nimport {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterReferenceInvalid} from 'character-reference-invalid'\nimport {isDecimal} from 'is-decimal'\nimport {isHexadecimal} from 'is-hexadecimal'\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\n\n// Warning messages.\nconst messages = [\n  '',\n  /* 1: Non terminated (named) */\n  'Named character references must be terminated by a semicolon',\n  /* 2: Non terminated (numeric) */\n  'Numeric character references must be terminated by a semicolon',\n  /* 3: Empty (named) */\n  'Named character references cannot be empty',\n  /* 4: Empty (numeric) */\n  'Numeric character references cannot be empty',\n  /* 5: Unknown (named) */\n  'Named character references must be known',\n  /* 6: Disallowed (numeric) */\n  'Numeric character references cannot be disallowed',\n  /* 7: Prohibited (numeric) */\n  'Numeric character references cannot be outside the permissible Unicode range'\n]\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {Readonly<Options> | null | undefined} [options]\n */\nexport function parseEntities(value, options) {\n  const settings = options || {}\n  const additional =\n    typeof settings.additional === 'string'\n      ? settings.additional.charCodeAt(0)\n      : settings.additional\n  /** @type {Array<string>} */\n  const result = []\n  let index = 0\n  let lines = -1\n  let queue = ''\n  /** @type {Point | undefined} */\n  let point\n  /** @type {Array<number>|undefined} */\n  let indent\n\n  if (settings.position) {\n    if ('start' in settings.position || 'indent' in settings.position) {\n      // @ts-expect-error: points don’t have indent.\n      indent = settings.position.indent\n      // @ts-expect-error: points don’t have indent.\n      point = settings.position.start\n    } else {\n      point = settings.position\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1\n  let column = (point ? point.column : 0) || 1\n\n  // Cache the current point.\n  let previous = now()\n  /** @type {number|undefined} */\n  let character\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1)\n\n      // The behavior depends on the identity of the next character.\n      if (\n        following === 9 /* `\\t` */ ||\n        following === 10 /* `\\n` */ ||\n        following === 12 /* `\\f` */ ||\n        following === 32 /* ` ` */ ||\n        following === 38 /* `&` */ ||\n        following === 60 /* `<` */ ||\n        Number.isNaN(following) ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += String.fromCharCode(character)\n        column++\n        continue\n      }\n\n      const start = index + 1\n      let begin = start\n      let end = start\n      /** @type {string} */\n      let type\n\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end)\n\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal'\n          end = ++begin\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal'\n        }\n      } else {\n        // Named reference.\n        type = 'named'\n      }\n\n      let characterReferenceCharacters = ''\n      let characterReference = ''\n      let characters = ''\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test =\n        type === 'named'\n          ? isAlphanumerical\n          : type === 'decimal'\n            ? isDecimal\n            : isHexadecimal\n\n      end--\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += String.fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters)\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59 /* `;` */\n\n      if (terminated) {\n        end++\n\n        const namedReference =\n          type === 'named' ? decodeNamedCharacterReference(characters) : false\n\n        if (namedReference) {\n          characterReferenceCharacters = characters\n          characterReference = namedReference\n        }\n      }\n\n      let diff = 1 + end - start\n      let reference = ''\n\n      if (!terminated && settings.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff)\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1)\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters\n              ? 1 /* Non terminated (named) */\n              : 3 /* Empty (named) */\n\n            if (settings.attribute) {\n              const following = value.charCodeAt(end)\n\n              if (following === 61 /* `=` */) {\n                warning(reason, diff)\n                characterReference = ''\n              } else if (isAlphanumerical(following)) {\n                characterReference = ''\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = characterReference\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff)\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(\n          characters,\n          type === 'hexadecimal' ? 16 : 10\n        )\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff)\n          reference = String.fromCharCode(65533 /* `�` */)\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff)\n          reference = characterReferenceInvalid[referenceCode]\n        } else {\n          // Parse the number.\n          let output = ''\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff)\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000\n            output += String.fromCharCode(\n              (referenceCode >>> (10 & 0x3ff)) | 0xd800\n            )\n            referenceCode = 0xdc00 | (referenceCode & 0x3ff)\n          }\n\n          reference = output + String.fromCharCode(referenceCode)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush()\n\n        previous = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        const next = now()\n        next.offset++\n\n        if (settings.reference) {\n          settings.reference.call(\n            settings.referenceContext || undefined,\n            reference,\n            {start: previous, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        previous = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (Number.isNaN(character)) {\n        flush()\n      } else {\n        queue += String.fromCharCode(character)\n        column++\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    }\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position\n\n    if (settings.warning) {\n      position = now()\n      position.column += offset\n      position.offset += offset\n\n      settings.warning.call(\n        settings.warningContext || undefined,\n        messages[code],\n        position,\n        code\n      )\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (settings.text) {\n        settings.text.call(settings.textContext || undefined, queue, {\n          start: previous,\n          end: now()\n        })\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n", "// @ts-nocheck\n\n// This is a slimmed down version of `prism-core.js`, to remove globals,\n// document, workers, `util.encode`, `Token.stringify`\n\n// Private helper vars\nvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i\nvar uniqueId = 0\n\n// The grammar object for plaintext\nvar plainTextGrammar = {}\n\nvar _ = {\n  /**\n   * A namespace for utility methods.\n   *\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n   * change or disappear at any time.\n   *\n   * @namespace\n   * @memberof Prism\n   */\n  util: {\n    /**\n     * Returns the name of the type of the given value.\n     *\n     * @param {any} o\n     * @returns {string}\n     * @example\n     * type(null)      === 'Null'\n     * type(undefined) === 'Undefined'\n     * type(123)       === 'Number'\n     * type('foo')     === 'String'\n     * type(true)      === 'Boolean'\n     * type([1, 2])    === 'Array'\n     * type({})        === 'Object'\n     * type(String)    === 'Function'\n     * type(/abc+/)    === 'RegExp'\n     */\n    type: function (o) {\n      return Object.prototype.toString.call(o).slice(8, -1)\n    },\n\n    /**\n     * Returns a unique number for the given object. Later calls will still return the same number.\n     *\n     * @param {Object} obj\n     * @returns {number}\n     */\n    objId: function (obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', {value: ++uniqueId})\n      }\n      return obj['__id']\n    },\n\n    /**\n     * Creates a deep clone of the given object.\n     *\n     * The main intended use of this function is to clone language definitions.\n     *\n     * @param {T} o\n     * @param {Record<number, any>} [visited]\n     * @returns {T}\n     * @template T\n     */\n    clone: function deepClone(o, visited) {\n      visited = visited || {}\n\n      var clone\n      var id\n      switch (_.util.type(o)) {\n        case 'Object':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = /** @type {Record<string, any>} */ ({})\n          visited[id] = clone\n\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited)\n            }\n          }\n\n          return /** @type {any} */ (clone)\n\n        case 'Array':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = []\n          visited[id] = clone\n\n          ;/** @type {Array} */ (/** @type {any} */ (o)).forEach(\n            function (v, i) {\n              clone[i] = deepClone(v, visited)\n            }\n          )\n\n          return /** @type {any} */ (clone)\n\n        default:\n          return o\n      }\n    }\n  },\n\n  /**\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n   *\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  languages: {\n    /**\n     * The grammar for plain, unformatted text.\n     */\n    plain: plainTextGrammar,\n    plaintext: plainTextGrammar,\n    text: plainTextGrammar,\n    txt: plainTextGrammar,\n\n    /**\n     * Creates a deep copy of the language with the given id and appends the given tokens.\n     *\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n     * will be overwritten at its original position.\n     *\n     * ## Best practices\n     *\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n     *\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n     *\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n     * @param {Grammar} redef The new tokens to append.\n     * @returns {Grammar} The new language created.\n     * @public\n     * @example\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n     *     // at its original position\n     *     'comment': { ... },\n     *     // CSS doesn't have a 'color' token, so this token will be appended\n     *     'color': /\\b(?:red|green|blue)\\b/\n     * });\n     */\n    extend: function (id, redef) {\n      var lang = _.util.clone(_.languages[id])\n\n      for (var key in redef) {\n        lang[key] = redef[key]\n      }\n\n      return lang\n    },\n\n    /**\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\n     *\n     * ## Usage\n     *\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n     * this:\n     *\n     * ```js\n     * Prism.languages.markup.style = {\n     *     // token\n     * };\n     * ```\n     *\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n     * before existing tokens. For the CSS example above, you would use it like this:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'cdata', {\n     *     'style': {\n     *         // token\n     *     }\n     * });\n     * ```\n     *\n     * ## Special cases\n     *\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n     * will be ignored.\n     *\n     * This behavior can be used to insert tokens after `before`:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'comment', {\n     *     'comment': Prism.languages.markup.comment,\n     *     // tokens after 'comment'\n     * });\n     * ```\n     *\n     * ## Limitations\n     *\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n     * deleting properties which is necessary to insert at arbitrary positions.\n     *\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\n     *\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n     * you hold the target object in a variable, then the value of the variable will not change.\n     *\n     * ```js\n     * var oldMarkup = Prism.languages.markup;\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n     *\n     * assert(oldMarkup !== Prism.languages.markup);\n     * assert(newMarkup === Prism.languages.markup);\n     * ```\n     *\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n     * object to be modified.\n     * @param {string} before The key to insert before.\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n     * object to be modified.\n     *\n     * Defaults to `Prism.languages`.\n     * @returns {Grammar} The new grammar object.\n     * @public\n     */\n    insertBefore: function (inside, before, insert, root) {\n      root = root || /** @type {any} */ (_.languages)\n      var grammar = root[inside]\n      /** @type {Grammar} */\n      var ret = {}\n\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken]\n              }\n            }\n          }\n\n          // Do not insert token which also occur in insert. See #1525\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token]\n          }\n        }\n      }\n\n      var old = root[inside]\n      root[inside] = ret\n\n      // Update references in other language definitions\n      _.languages.DFS(_.languages, function (key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret\n        }\n      })\n\n      return ret\n    },\n\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type, visited) {\n      visited = visited || {}\n\n      var objId = _.util.objId\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i)\n\n          var property = o[i]\n          var propertyType = _.util.type(property)\n\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, null, visited)\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, i, visited)\n          }\n        }\n      }\n    }\n  },\n\n  plugins: {},\n\n  /**\n   * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n   * and the language definitions to use, and returns a string with the HTML produced.\n   *\n   * The following hooks will be run:\n   * 1. `before-tokenize`\n   * 2. `after-tokenize`\n   * 3. `wrap`: On each {@link Token}.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @param {string} language The name of the language definition passed to `grammar`.\n   * @returns {string} The highlighted HTML.\n   * @memberof Prism\n   * @public\n   * @example\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n   */\n  highlight: function (text, grammar, language) {\n    var env = {\n      code: text,\n      grammar: grammar,\n      language: language\n    }\n    _.hooks.run('before-tokenize', env)\n    if (!env.grammar) {\n      throw new Error('The language \"' + env.language + '\" has no grammar.')\n    }\n    env.tokens = _.tokenize(env.code, env.grammar)\n    _.hooks.run('after-tokenize', env)\n    return Token.stringify(_.util.encode(env.tokens), env.language)\n  },\n\n  /**\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n   * and the language definitions to use, and returns an array with the tokenized code.\n   *\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n   *\n   * This method could be useful in other contexts as well, as a very crude parser.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\n   * @memberof Prism\n   * @public\n   * @example\n   * let code = `var foo = 0;`;\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n   * tokens.forEach(token => {\n   *     if (token instanceof Prism.Token && token.type === 'number') {\n   *         console.log(`Found numeric literal: ${token.content}`);\n   *     }\n   * });\n   */\n  tokenize: function (text, grammar) {\n    var rest = grammar.rest\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token]\n      }\n\n      delete grammar.rest\n    }\n\n    var tokenList = new LinkedList()\n    addAfter(tokenList, tokenList.head, text)\n\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0)\n\n    return toArray(tokenList)\n  },\n\n  /**\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  hooks: {\n    all: {},\n\n    /**\n     * Adds the given callback to the list of callbacks for the given hook.\n     *\n     * The callback will be invoked when the hook it is registered for is run.\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n     *\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\n     *\n     * @param {string} name The name of the hook.\n     * @param {HookCallback} callback The callback function which is given environment variables.\n     * @public\n     */\n    add: function (name, callback) {\n      var hooks = _.hooks.all\n\n      hooks[name] = hooks[name] || []\n\n      hooks[name].push(callback)\n    },\n\n    /**\n     * Runs a hook invoking all registered callbacks with the given environment variables.\n     *\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\n     *\n     * @param {string} name The name of the hook.\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n     * @public\n     */\n    run: function (name, env) {\n      var callbacks = _.hooks.all[name]\n\n      if (!callbacks || !callbacks.length) {\n        return\n      }\n\n      for (var i = 0, callback; (callback = callbacks[i++]); ) {\n        callback(env)\n      }\n    }\n  },\n\n  Token: Token\n}\n\n// Typescript note:\n// The following can be used to import the Token type in JSDoc:\n//\n//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n/**\n * Creates a new token.\n *\n * @param {string} type See {@link Token#type type}\n * @param {string | TokenStream} content See {@link Token#content content}\n * @param {string|string[]} [alias] The alias(es) of the token.\n * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n * @class\n * @global\n * @public\n */\nfunction Token(type, content, alias, matchedStr) {\n  /**\n   * The type of the token.\n   *\n   * This is usually the key of a pattern in a {@link Grammar}.\n   *\n   * @type {string}\n   * @see GrammarToken\n   * @public\n   */\n  this.type = type\n  /**\n   * The strings or tokens contained by this token.\n   *\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\n   *\n   * @type {string | TokenStream}\n   * @public\n   */\n  this.content = content\n  /**\n   * The alias(es) of the token.\n   *\n   * @type {string|string[]}\n   * @see GrammarToken\n   * @public\n   */\n  this.alias = alias\n  // Copy of the full string this token was created from\n  this.length = (matchedStr || '').length | 0\n}\n\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n *\n * @typedef {Array<string | Token>} TokenStream\n * @global\n * @public\n */\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n * @returns {RegExpExecArray | null}\n */\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos\n  var match = pattern.exec(text)\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length\n    match.index += lookbehindLength\n    match[0] = match[0].slice(lookbehindLength)\n  }\n  return match\n}\n\n/**\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {any} grammar\n * @param {LinkedListNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n * @private\n *\n * @typedef RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue\n    }\n\n    var patterns = grammar[token]\n    patterns = Array.isArray(patterns) ? patterns : [patterns]\n\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + ',' + j) {\n        return\n      }\n\n      var patternObj = patterns[j]\n      var inside = patternObj.inside\n      var lookbehind = !!patternObj.lookbehind\n      var greedy = !!patternObj.greedy\n      var alias = patternObj.alias\n\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0]\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g')\n      }\n\n      /** @type {RegExp} */\n      var pattern = patternObj.pattern || patternObj\n\n      for (\n        // iterate the token list and keep track of the current token/string position\n        var currentNode = startNode.next, pos = startPos;\n        currentNode !== tokenList.tail;\n        pos += currentNode.value.length, currentNode = currentNode.next\n      ) {\n        if (rematch && pos >= rematch.reach) {\n          break\n        }\n\n        var str = currentNode.value\n\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return\n        }\n\n        if (str instanceof Token) {\n          continue\n        }\n\n        var removeCount = 1 // this is the to parameter of removeBetween\n        var match\n\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind)\n          if (!match || match.index >= text.length) {\n            break\n          }\n\n          var from = match.index\n          var to = match.index + match[0].length\n          var p = pos\n\n          // find the node that contains the match\n          p += currentNode.value.length\n          while (from >= p) {\n            currentNode = currentNode.next\n            p += currentNode.value.length\n          }\n          // adjust pos (and p)\n          p -= currentNode.value.length\n          pos = p\n\n          // the current node is a Token, then the match starts inside another Token, which is invalid\n          if (currentNode.value instanceof Token) {\n            continue\n          }\n\n          // find the last node which is affected by this match\n          for (\n            var k = currentNode;\n            k !== tokenList.tail && (p < to || typeof k.value === 'string');\n            k = k.next\n          ) {\n            removeCount++\n            p += k.value.length\n          }\n          removeCount--\n\n          // replace with the new match\n          str = text.slice(pos, p)\n          match.index -= pos\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind)\n          if (!match) {\n            continue\n          }\n        }\n\n        // eslint-disable-next-line no-redeclare\n        var from = match.index\n        var matchStr = match[0]\n        var before = str.slice(0, from)\n        var after = str.slice(from + matchStr.length)\n\n        var reach = pos + str.length\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach\n        }\n\n        var removeFrom = currentNode.prev\n\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before)\n          pos += before.length\n        }\n\n        removeRange(tokenList, removeFrom, removeCount)\n\n        var wrapped = new Token(\n          token,\n          inside ? _.tokenize(matchStr, inside) : matchStr,\n          alias,\n          matchStr\n        )\n        currentNode = addAfter(tokenList, removeFrom, wrapped)\n\n        if (after) {\n          addAfter(tokenList, currentNode, after)\n        }\n\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + ',' + j,\n            reach: reach\n          }\n          matchGrammar(\n            text,\n            tokenList,\n            grammar,\n            currentNode.prev,\n            pos,\n            nestedRematch\n          )\n\n          // the reach might have been extended because of the rematching\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * @typedef LinkedListNode\n * @property {T} value\n * @property {LinkedListNode<T> | null} prev The previous node.\n * @property {LinkedListNode<T> | null} next The next node.\n * @template T\n * @private\n */\n\n/**\n * @template T\n * @private\n */\nfunction LinkedList() {\n  /** @type {LinkedListNode<T>} */\n  var head = {value: null, prev: null, next: null}\n  /** @type {LinkedListNode<T>} */\n  var tail = {value: null, prev: head, next: null}\n  head.next = tail\n\n  /** @type {LinkedListNode<T>} */\n  this.head = head\n  /** @type {LinkedListNode<T>} */\n  this.tail = tail\n  this.length = 0\n}\n\n/**\n * Adds a new node with the given value to the list.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {T} value\n * @returns {LinkedListNode<T>} The added node.\n * @template T\n */\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next\n\n  var newNode = {value: value, prev: node, next: next}\n  node.next = newNode\n  next.prev = newNode\n  list.length++\n\n  return newNode\n}\n/**\n * Removes `count` nodes after the given node. The given node will not be removed.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {number} count\n * @template T\n */\nfunction removeRange(list, node, count) {\n  var next = node.next\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next\n  }\n  node.next = next\n  next.prev = node\n  list.length -= i\n}\n/**\n * @param {LinkedList<T>} list\n * @returns {T[]}\n * @template T\n */\nfunction toArray(list) {\n  var array = []\n  var node = list.head.next\n  while (node !== list.tail) {\n    array.push(node.value)\n    node = node.next\n  }\n  return array\n}\n\nexport const Prism = _\n", "/**\n * @import {Element, Root, Text} from 'hast'\n * @import {Grammar, Languages} from 'prismjs'\n */\n\n/**\n * @typedef _Token\n *   Hidden Prism token.\n * @property {string} alias\n *   Alias.\n * @property {string} content\n *   Content.\n * @property {number} length\n *   Length.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef _Env\n *   Hidden Prism environment.\n * @property {Record<string, string>} attributes\n *   Attributes.\n * @property {Array<string>} classes\n *   Classes.\n * @property {Array<Element | Text> | Element | Text} content\n *   Content.\n * @property {string} language\n *   Language.\n * @property {string} tag\n *   Tag.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef {((prism: Refractor) => undefined | void) & {aliases?: Array<string> | undefined, displayName: string}} Syntax\n *   Refractor syntax function.\n */\n\n/**\n * @typedef Refractor\n *   Virtual syntax highlighting\n * @property {typeof alias} alias\n * @property {Languages} languages\n * @property {typeof listLanguages} listLanguages\n * @property {typeof highlight} highlight\n * @property {typeof registered} registered\n * @property {typeof register} register\n */\n\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prism’s originals.\nimport {h} from 'hastscript'\nimport {parseEntities} from 'parse-entities'\nimport {Prism} from './prism-core.js'\n\n// Inherit.\nfunction Refractor() {}\n\nRefractor.prototype = Prism\n\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\nexport const refractor = new Refractor()\n\n// Create.\nrefractor.highlight = highlight\nrefractor.register = register\nrefractor.alias = alias\nrefractor.registered = registered\nrefractor.listLanguages = listLanguages\n\n// @ts-expect-error Overwrite Prism.\nrefractor.util.encode = encode\n// @ts-expect-error Overwrite Prism.\nrefractor.Token.stringify = stringify\n\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {Grammar | string} language\n *   Programming language name, alias, or grammar.\n * @returns {Root}\n *   Node representing highlighted code.\n */\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`')\n  }\n\n  /** @type {Grammar} */\n  let grammar\n  /** @type {string | undefined} */\n  let name\n\n  // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n  /* c8 ignore next 2 */\n  if (language && typeof language === 'object') {\n    grammar = language\n  } else {\n    name = language\n\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`')\n    }\n\n    if (Object.hasOwn(refractor.languages, name)) {\n      grammar = refractor.languages[name]\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered')\n    }\n  }\n\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: Prism.highlight.call(refractor, value, grammar, name)\n  }\n}\n\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {undefined}\n *   Nothing.\n */\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`')\n  }\n\n  // Do not duplicate registrations.\n  if (!Object.hasOwn(refractor.languages, syntax.displayName)) {\n    syntax(refractor)\n  }\n}\n\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, ReadonlyArray<string> | string> | string} language\n *   Language to alias.\n * @param {ReadonlyArray<string> | string | null | undefined} [alias]\n *   Aliases.\n * @returns {undefined}\n *   Nothing.\n */\nfunction alias(language, alias) {\n  const languages = refractor.languages\n  /** @type {Record<string, ReadonlyArray<string> | string>} */\n  let map = {}\n\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias\n    }\n  } else {\n    map = language\n  }\n\n  /** @type {string} */\n  let key\n\n  for (key in map) {\n    if (Object.hasOwn(map, key)) {\n      const value = map[key]\n      const list = typeof value === 'string' ? [value] : value\n      let index = -1\n\n      while (++index < list.length) {\n        languages[list[index]] = languages[key]\n      }\n    }\n  }\n}\n\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n *   Language or alias to check.\n * @returns {boolean}\n *   Whether the language is registered.\n */\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError(\n      'Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`'\n    )\n  }\n\n  return Object.hasOwn(refractor.languages, aliasOrLanguage)\n}\n\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n *   List of language names.\n */\nfunction listLanguages() {\n  const languages = refractor.languages\n  /** @type {Array<string>} */\n  const list = []\n  /** @type {string} */\n  let language\n\n  for (language in languages) {\n    if (\n      Object.hasOwn(languages, language) &&\n      typeof languages[language] === 'object'\n    ) {\n      list.push(language)\n    }\n  }\n\n  return list\n}\n\n/**\n * @param {Array<_Token | string> | _Token | string} value\n *   Token to stringify.\n * @param {string} language\n *   Language of the token.\n * @returns {Array<Element | Text> | Element | Text}\n *   Node representing the token.\n */\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {type: 'text', value}\n  }\n\n  if (Array.isArray(value)) {\n    /** @type {Array<Element | Text>} */\n    const result = []\n    let index = -1\n\n    while (++index < value.length) {\n      if (\n        value[index] !== null &&\n        value[index] !== undefined &&\n        value[index] !== ''\n      ) {\n        // Cast because we assume no sub-arrays.\n        result.push(\n          /** @type {Element | Text} */ (stringify(value[index], language))\n        )\n      }\n    }\n\n    return result\n  }\n\n  /** @type {_Env} */\n  const env = {\n    attributes: {},\n    classes: ['token', value.type],\n    content: stringify(value.content, language),\n    language,\n    tag: 'span',\n    type: value.type\n  }\n\n  if (value.alias) {\n    env.classes.push(\n      ...(typeof value.alias === 'string' ? [value.alias] : value.alias)\n    )\n  }\n\n  // @ts-expect-error Prism.\n  refractor.hooks.run('wrap', env)\n\n  return h(\n    env.tag + '.' + env.classes.join('.'),\n    attributes(env.attributes),\n    env.content\n  )\n}\n\n/**\n * @template {unknown} T\n *   Tokens.\n * @param {T} tokens\n *   Input.\n * @returns {T}\n *   Output, same as input.\n */\nfunction encode(tokens) {\n  return tokens\n}\n\n/**\n * @param {Record<string, string>} record\n *   Attributes.\n * @returns {Record<string, string>}\n *   Attributes.\n */\nfunction attributes(record) {\n  /** @type {string} */\n  let key\n\n  for (key in record) {\n    if (Object.hasOwn(record, key)) {\n      record[key] = parseEntities(record[key])\n    }\n  }\n\n  return record\n}\n", "/**\n * @import {Node, Parent} from 'unist'\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | ReadonlyArray<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends ReadonlyArray<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\n   *   (<Condition extends Array<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test)\n          ? anyFactory(test)\n          : // Cast because `ReadonlyArray` goes into the above but `isArray`\n            // narrows to `Array`.\n            propertiesFactory(/** @type {Props} */ (test))\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propertiesFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out (default: `true`).\n */\n\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a new `tree` of copies of all nodes that pass `test`.\n *\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @template {Node} Tree\n * @template {Test} Check\n *\n * @overload\n * @param {Tree} tree\n * @param {Options | null | undefined} options\n * @param {Check} test\n * @returns {import('./complex-types.js').Matches<Tree, Check>}\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} test\n * @returns {import('./complex-types.js').Matches<Tree, Check>}\n *\n * @overload\n * @param {Tree} tree\n * @param {null | undefined} [options]\n * @returns {Tree}\n *\n * @param {Node} tree\n *   Tree to filter.\n * @param {Options | Test} [options]\n *   Configuration (optional).\n * @param {Test} [test]\n *   `unist-util-is` compatible test.\n * @returns {Node | undefined}\n *   New filtered tree.\n *\n *   `undefined` is returned if `tree` itself didn’t pass the test, or is\n *   cascaded away.\n */\nexport function filter(tree, options, test) {\n  const is = convert(test || options)\n  const cascadeRaw =\n    options && typeof options === 'object' && 'cascade' in options\n      ? /** @type {boolean | null | undefined} */ (options.cascade)\n      : undefined\n  const cascade =\n    cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw\n\n  return preorder(tree)\n\n  /**\n   * @param {Node} node\n   *   Current node.\n   * @param {number | undefined} [index]\n   *   Index of `node` in `parent`.\n   * @param {Parent | undefined} [parentNode]\n   *   Parent node.\n   * @returns {Node | undefined}\n   *   Shallow copy of `node`.\n   */\n  function preorder(node, index, parentNode) {\n    /** @type {Array<Node>} */\n    const children = []\n\n    if (!is(node, index, parentNode)) return undefined\n\n    if (parent(node)) {\n      let childIndex = -1\n\n      while (++childIndex < node.children.length) {\n        const result = preorder(node.children[childIndex], childIndex, node)\n\n        if (result) {\n          children.push(result)\n        }\n      }\n\n      if (cascade && node.children.length > 0 && children.length === 0) {\n        return undefined\n      }\n    }\n\n    // Create a shallow clone, using the new children.\n    /** @type {typeof node} */\n    // @ts-expect-error all the fields will be copied over.\n    const next = {}\n    /** @type {string} */\n    let key\n\n    for (key in node) {\n      if (own.call(node, key)) {\n        // @ts-expect-error: Looks like a record.\n        next[key] = key === 'children' ? children : node[key]\n      }\n    }\n\n    return next\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {node is Parent}\n */\nfunction parent(node) {\n  return 'children' in node && node.children !== undefined\n}\n", "/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n", "/**\n * @import {Node as UnistNode, Parent as UnistParent} from 'unist'\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends ReadonlyArray<infer T>\n *   ? MatchesOne<Value, T>\n *   : Check extends Array<infer T>\n *   ? MatchesOne<Value, T>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn’t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n            typeof value.name === 'string'\n            ? value.name\n            : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n", "import type {\n  ElementContent,\n  Node,\n  Parent,\n  Element as RefractorElement,\n  Root as RefractorRoot,\n  RootContent,\n  Text,\n} from 'hast'\nimport {filter} from 'unist-util-filter'\nimport {visitParents} from 'unist-util-visit-parents'\n\nimport type {Marker} from './types.js'\n\nexport function addMarkers(\n  ast: RefractorRoot,\n  options: {markers: (Marker | number)[]},\n): RefractorRoot {\n  const markers = options.markers\n    .map((marker) => (typeof marker === 'number' ? {line: marker} : marker))\n    .sort((nodeA, nodeB) => nodeA.line - nodeB.line)\n\n  const numbered = lineNumberify(ast.children).nodes\n  if (markers.length === 0 || numbered.length === 0) {\n    return {...ast, children: numbered}\n  }\n\n  return wrapLines(numbered, markers, options)\n}\n\nfunction lineNumberify(ast: RootContent[], context = {lineNumber: 1}) {\n  const resultNodes: ElementContent[] = []\n  return ast.reduce(\n    (result, node) => {\n      if (node.type === 'doctype') {\n        return result // Doctypes are not relevant for line numbers\n      }\n\n      const lineStart = context.lineNumber\n\n      if (node.type === 'text') {\n        if (node.value.indexOf('\\n') === -1) {\n          setLineInfo(node, lineStart, lineStart)\n          result.nodes.push(node)\n          return result\n        }\n\n        const lines = node.value.split('\\n')\n        for (let i = 0; i < lines.length; i++) {\n          const lineNum = i === 0 ? context.lineNumber : ++context.lineNumber\n          const text: Text = {\n            type: 'text',\n            value: i === lines.length - 1 ? lines[i] : `${lines[i]}\\n`,\n          }\n          const withLineInfo = setLineInfo(text, lineNum, lineNum)\n          result.nodes.push(withLineInfo)\n        }\n\n        result.lineNumber = context.lineNumber\n        return result\n      }\n\n      if (node.type === 'element' && node.children) {\n        const processed = lineNumberify(node.children, context)\n        const firstChild = processed.nodes.find(isElementOrText)\n        const lastChild = processed.nodes.findLast(isElementOrText)\n        setLineInfo(\n          node,\n          firstChild ? getLineStart(firstChild, lineStart) : lineStart,\n          lastChild ? getLineEnd(lastChild, lineStart) : lineStart,\n        )\n        node.children = processed.nodes\n        result.lineNumber = processed.lineNumber\n        result.nodes.push(node)\n        return result\n      }\n\n      result.nodes.push(node)\n      return result\n    },\n    {nodes: resultNodes, lineNumber: context.lineNumber},\n  )\n}\n\nfunction isElementOrText(node: RootContent | Node): node is RefractorElement | Text {\n  return node.type === 'element' || node.type === 'text'\n}\n\nfunction getLineStart(node: Node, fallbackLineStart = 1) {\n  return node.data && typeof node.data.lineStart === 'number'\n    ? node.data.lineStart\n    : fallbackLineStart\n}\n\nfunction getLineEnd(node: Node, fallbackLineEnd = 1) {\n  return node.data && typeof node.data.lineEnd === 'number' ? node.data.lineEnd : fallbackLineEnd\n}\n\nfunction setLineInfo<T extends RefractorElement | Text | Parent>(\n  node: T,\n  lineStart: number,\n  lineEnd: number,\n): T {\n  if (!node.data) {\n    node.data = {}\n  }\n\n  node.data.lineStart = lineStart\n  node.data.lineEnd = lineEnd\n  return node\n}\n\nfunction unwrapLine(markerLine: number, nodes: RootContent[]) {\n  const tree: RefractorRoot = {type: 'root', children: nodes}\n\n  const headMap = new WeakMap()\n  const lineMap = new WeakMap()\n  const tailMap = new WeakMap()\n  const cloned: Node[] = []\n\n  function addCopy(\n    map: WeakMap<object, any>,\n    node: Text,\n    ancestors: Array<RefractorRoot | RefractorElement>,\n  ) {\n    cloned.push(node)\n\n    ancestors.forEach((ancestor) => {\n      if (!map.has(ancestor)) {\n        map.set(ancestor, Object.assign({}, ancestor, {children: []}))\n\n        if (ancestor !== tree) {\n          cloned.push(ancestor)\n        }\n      }\n    })\n\n    let i = ancestors.length\n    while (i--) {\n      const ancestor = map.get(ancestors[i])\n      if (!ancestor || !('children' in ancestor)) {\n        continue\n      }\n\n      const child = ancestors[i + 1]\n      const leaf = map.get(child) || node\n      if (ancestor.children.indexOf(leaf) === -1) {\n        ancestor.children.push(leaf)\n      }\n    }\n  }\n\n  visitParents(tree, (node, ancestors) => {\n    if ('children' in node || !isElementOrText(node)) {\n      return\n    }\n\n    // These nodes are on previous lines, but nested within the same structure\n    if (getLineStart(node) < markerLine) {\n      addCopy(headMap, node, ancestors)\n      return\n    }\n\n    // These nodes are on the target line\n    if (getLineStart(node) === markerLine) {\n      addCopy(lineMap, node, ancestors)\n      return\n    }\n\n    // If we have shared ancestors with some of the cloned elements,\n    // create another tree of the remaining nodes\n    if (getLineEnd(node) > markerLine && cloned.some((clone) => ancestors.includes(clone as any))) {\n      addCopy(tailMap, node, ancestors)\n    }\n  })\n\n  // Get the remaining nodes - the ones who were not part of the same tree\n  const filtered = filter(tree, (node) => cloned.indexOf(node as any) === -1)\n  const getChildren = (map: WeakMap<Node, Parent>) => {\n    const rootNode = map.get(tree)\n    if (!rootNode) {\n      return []\n    }\n\n    visitParents(rootNode, (leaf, ancestors) => {\n      if (isElementOrText(leaf) && 'children' in leaf) {\n        setLineInfo(leaf, 0, 0)\n        return\n      }\n\n      ancestors.forEach((ancestor) => {\n        setLineInfo(\n          ancestor,\n          Math.max(getLineStart(ancestor), getLineStart(leaf)),\n          Math.max(getLineEnd(ancestor), getLineEnd(leaf)),\n        )\n      })\n    })\n\n    return rootNode.children\n  }\n\n  const merged = [\n    ...getChildren(headMap),\n    ...getChildren(lineMap),\n    ...getChildren(tailMap),\n    ...(filtered ? filtered.children : []),\n  ]\n\n  return merged\n}\n\nfunction wrapBatch(\n  children: Array<ElementContent>,\n  marker: Marker,\n  options: {markers: (Marker | number)[]},\n): RefractorElement {\n  const className = marker.className || 'refractor-marker'\n  const baseData: RefractorElement['data'] = {\n    lineStart: marker.line,\n    lineEnd: getLineEnd(children[children.length - 1]),\n    isMarker: true,\n  }\n  return {\n    type: 'element',\n    tagName: 'div',\n    data: marker.component\n      ? {...baseData, component: marker.component, markerProperties: options}\n      : baseData,\n    properties: {className},\n    children,\n  }\n}\n\nfunction wrapLines(\n  treeNodes: RootContent[],\n  markers: Marker[],\n  options: {markers: (Marker | number)[]},\n): RefractorRoot {\n  const ast: Array<RootContent> = markers.reduce(\n    (acc, marker) => unwrapLine(marker.line, acc),\n    treeNodes,\n  )\n  const wrapped: Array<RootContent> = []\n\n  // Note: Markers are already sorted by line number (ascending)\n  let astIndex: number = 0\n  for (let m = 0; m < markers.length; m++) {\n    const marker = markers[m]\n\n    // Start by eating all AST nodes with line numbers up to the given marker\n    for (let node = ast[astIndex]; node && getLineEnd(node) < marker.line; node = ast[++astIndex]) {\n      wrapped.push(node)\n    }\n\n    // Now proceed to find all _contiguous_ nodes on the same line\n    const batch: Array<ElementContent> = []\n    for (\n      let node = ast[astIndex];\n      node && getLineEnd(node) === marker.line;\n      node = ast[++astIndex]\n    ) {\n      if (node.type !== 'doctype') {\n        batch.push(node)\n      }\n    }\n\n    // Now add that batch, if we have anything\n    if (batch.length > 0) {\n      wrapped.push(wrapBatch(batch, marker, options))\n    }\n  }\n\n  // Now add the remaining AST nodes\n  while (astIndex < ast.length) {\n    wrapped.push(ast[astIndex++])\n  }\n\n  return {type: 'root', children: wrapped}\n}\n", "import {createElement, type JSXElementConstructor, type ReactElement} from 'react'\nimport {type ElementContent, type RootContent} from 'hast'\nimport type {ReactRefractorMarkerDataWithComponent} from './types.js'\n\n/**\n * @internal\n */\nexport function mapWithDepth(\n  depth: number,\n): (\n  child: ElementContent | RootContent,\n  i: number,\n) => string | ReactElement<unknown, string | JSXElementConstructor<unknown>> | null {\n  return function mapChildrenWithDepth(child: ElementContent | RootContent, i: number) {\n    return mapChild(child, i, depth)\n  }\n}\n\nfunction mapChild(\n  child: ElementContent | RootContent,\n  i: number,\n  depth: number,\n): string | ReactElement | null {\n  if (child.type === 'doctype') {\n    return null\n  }\n\n  if (!('tagName' in child)) {\n    return child.value\n  }\n\n  let className = ''\n  if (typeof child.properties !== 'undefined') {\n    className = Array.isArray(child.properties.className)\n      ? child.properties.className.join(' ')\n      : `${child.properties.className}`\n  }\n\n  const key = `fract-${depth}-${i}`\n  const children = child.children && child.children.map(mapWithDepth(depth + 1))\n\n  if (!isReactRefractorMarkerDataWithComponent(child.data)) {\n    return createElement(child.tagName, {key, className}, children)\n  }\n\n  return createElement(\n    child.data.component,\n    {key, ...child.properties, ...child.data.markerProperties, className},\n    children,\n  )\n}\n\nfunction isReactRefractorMarkerDataWithComponent(\n  data: unknown,\n): data is ReactRefractorMarkerDataWithComponent {\n  return (\n    typeof data === 'object' && data !== null && 'component' in data && 'markerProperties' in data\n  )\n}\n", "import type {HTMLAttributes} from 'react'\nimport type {Syntax} from 'refractor'\nimport {refractor as fract} from 'refractor/core'\nimport {addMarkers} from './addMarkers.js'\nimport {mapWithDepth} from './mapChildren.js'\nimport type {RefractorProps} from './types.js'\n\nconst DEFAULT_CLASSNAME = 'refractor'\n\n/**\n * @public\n */\nexport function Refractor(props: RefractorProps) {\n  const className = props.className || DEFAULT_CLASSNAME\n  const langClassName = `language-${props.language}`\n  const codeProps: HTMLAttributes<HTMLElement> = {className: langClassName}\n  const preClass = [className, langClassName].filter(Boolean).join(' ')\n\n  if (props.inline) {\n    codeProps.style = {display: 'inline'}\n    codeProps.className = className\n  }\n\n  if (props.plainText) {\n    const code = <code {...codeProps}>{props.value}</code>\n    return props.inline ? code : <pre className={preClass}>{code}</pre>\n  }\n\n  let ast = fract.highlight(props.value, props.language)\n  if (props.markers && props.markers.length > 0) {\n    ast = addMarkers(ast, {markers: props.markers})\n  }\n\n  const value = ast.children.length === 0 ? props.value : ast.children.map(mapWithDepth(0))\n\n  const code = <code {...codeProps}>{value}</code>\n  return props.inline ? code : <pre className={preClass}>{code}</pre>\n}\n\n/**\n * @public\n */\nexport const registerLanguage = (lang: Syntax) => fract.register(lang)\n\n/**\n * @public\n */\nexport const hasLanguage = (lang: string) => fract.registered(lang)\n"],
  "mappings": "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AAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ACvBO,IAAM,IAAI,QAAQC,OAAM,KAAK;AAI7B,IAAM,IAAI,QAAQC,MAAK,KAAK,wBAAwB;;;ACrBpD,IAAM,0BAA0B;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;A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",
  "names": ["_", "attributes", "attributes", "_", "_", "html", "svg", "parse", "h", "value", "parse", "html", "svg", "following", "alias", "alias", "checks", "index", "parent", "is", "is", "__spreadProps", "__spreadValues", "Refractor", "code", "fract"]
}
