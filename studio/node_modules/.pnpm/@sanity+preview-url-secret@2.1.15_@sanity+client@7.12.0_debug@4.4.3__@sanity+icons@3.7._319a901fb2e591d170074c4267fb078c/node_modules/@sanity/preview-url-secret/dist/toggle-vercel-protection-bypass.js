import { vercelProtectionBypassSchemaId, vercelProtectionBypassSchemaType, tag, fetchVercelProtectionBypassSecret } from "./constants.js";
async function enableVercelProtectionBypass(client, secret) {
  const patch = client.patch(vercelProtectionBypassSchemaId).set({ secret });
  await client.transaction().createIfNotExists({ _id: vercelProtectionBypassSchemaId, _type: vercelProtectionBypassSchemaType }).patch(patch).commit({ tag });
}
async function disableVercelProtectionBypass(client) {
  const patch = client.patch(vercelProtectionBypassSchemaId).set({ secret: null });
  await client.transaction().createIfNotExists({ _id: vercelProtectionBypassSchemaId, _type: vercelProtectionBypassSchemaType }).patch(patch).commit({ tag });
}
function subcribeToVercelProtectionBypass(client, onChange) {
  let controller = new AbortController(), usedTags = [];
  async function fetchSecret(lastLiveEventId, signal) {
    const { result, syncTags } = await client.fetch(
      fetchVercelProtectionBypassSecret,
      {},
      {
        filterResponse: !1,
        lastLiveEventId,
        tag: "preview-url-secret.fetch-vercel-bypass-protection-secret"
      }
    );
    Array.isArray(syncTags) && (usedTags = syncTags), signal.aborted || onChange(result);
  }
  const subscription = client.live.events().subscribe({
    next: (event) => {
      event.type === "message" && (controller.abort(), controller = new AbortController(), event.tags.some((tag2) => usedTags.includes(tag2)) && fetchSecret(event.id, controller.signal));
    },
    // eslint-disable-next-line no-console
    error: (reason) => console.error(reason)
  });
  return fetchSecret(null, controller.signal), () => {
    subscription.unsubscribe(), controller.abort();
  };
}
export {
  disableVercelProtectionBypass,
  enableVercelProtectionBypass,
  subcribeToVercelProtectionBypass
};
//# sourceMappingURL=toggle-vercel-protection-bypass.js.map
