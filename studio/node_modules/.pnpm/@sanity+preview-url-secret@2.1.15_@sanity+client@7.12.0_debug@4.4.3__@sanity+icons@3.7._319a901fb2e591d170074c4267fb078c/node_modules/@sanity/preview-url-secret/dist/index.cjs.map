{"version":3,"file":"index.cjs","sources":["../src/createClientWithConfig.ts","../src/parsePreviewUrl.ts","../src/validateSecret.ts","../src/validatePreviewUrl.ts"],"sourcesContent":["import {apiVersion} from './constants'\nimport type {SanityClientLike} from './types'\n\n/**\n * Validates the passed in client instance, then clones it and reconfigures it to fit the needs and spec of\n * this package.\n * @internal\n */\nexport function createClientWithConfig(client: SanityClientLike): SanityClientLike {\n  if (!client) {\n    throw new TypeError('`client` is required')\n  }\n\n  if (!client.config().token) {\n    throw new TypeError('`client` must have a `token` specified')\n  }\n\n  return client.withConfig({\n    perspective: 'raw',\n    // Userland might be using an API version that's too old to use perspectives\n    apiVersion,\n    // We can't use the CDN, the secret is typically validated right after it's created\n    useCdn: false,\n    // Don't waste time returning a source map, we don't need it\n    resultSourceMap: false,\n    // @ts-expect-error - If stega is enabled, make sure it's disabled\n    stega: false,\n  })\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {\n  urlSearchParamPreviewPathname,\n  urlSearchParamPreviewPerspective,\n  urlSearchParamPreviewSecret,\n  urlSearchParamVercelProtectionBypass,\n  urlSearchParamVercelSetBypassCookie,\n} from './constants'\nimport type {ParsedPreviewUrl, VercelSetBypassCookieValue} from './types'\n\n/**\n * @internal\n */\nexport function parsePreviewUrl(unsafeUrl: string): ParsedPreviewUrl {\n  const url = new URL(unsafeUrl, 'http://localhost')\n  const secret = url.searchParams.get(urlSearchParamPreviewSecret)\n  if (!secret) {\n    throw new Error('Missing secret')\n  }\n  const studioPreviewPerspective = url.searchParams.get(urlSearchParamPreviewPerspective)\n  let redirectTo: string | undefined\n  const unsafeRedirectTo = url.searchParams.get(urlSearchParamPreviewPathname)\n  if (unsafeRedirectTo) {\n    const redirectUrl = new URL(unsafeRedirectTo, 'http://localhost')\n\n    // If there's a preview perspective in the URL we forward it to the redirect to ensure it's set\n    if (\n      studioPreviewPerspective &&\n      !redirectUrl.searchParams.has(urlSearchParamPreviewPerspective)\n    ) {\n      redirectUrl.searchParams.set(urlSearchParamPreviewPerspective, studioPreviewPerspective)\n    }\n\n    // If there's a vercel bypass secret in the redirect URL, we forward it to the redirect to ensure it's set\n    if (url.searchParams.has(urlSearchParamVercelProtectionBypass)) {\n      redirectUrl.searchParams.set(\n        urlSearchParamVercelProtectionBypass,\n        url.searchParams.get(urlSearchParamVercelProtectionBypass)!,\n      )\n      // samesitenone is required since the request is from an iframe\n      redirectUrl.searchParams.set(\n        urlSearchParamVercelSetBypassCookie,\n        'samesitenone' satisfies VercelSetBypassCookieValue,\n      )\n    }\n\n    const {pathname, search, hash} = redirectUrl\n    redirectTo = `${pathname}${search}${hash}`\n  }\n  return {secret, redirectTo, studioPreviewPerspective}\n}\n","import {fetchSecretQuery, fetchSharedAccessSecretQuery, tag} from './constants'\nimport type {\n  FetchPublicSecretQueryResponse,\n  FetchSecretQueryParams,\n  FetchSecretQueryResponse,\n  SanityClientLike,\n} from './types'\n\nexport type {SanityClientLike}\n\n/** @public */\nexport async function validateSecret(\n  client: SanityClientLike,\n  secret: string,\n  disableCacheNoStore: boolean,\n): Promise<{isValid: boolean; studioUrl: string | null}> {\n  // If we're in the Edge Runtime it's usually too quick and we need to delay fetching the secret a little bit\n  // @ts-expect-error -- this global exists if we're in the Edge Runtime\n  if (typeof EdgeRuntime !== 'undefined') {\n    await new Promise((resolve) => setTimeout(resolve, 300))\n  }\n  if (!secret || !secret.trim()) {\n    return {isValid: false, studioUrl: null}\n  }\n  const {private: privateSecret, public: publicSecret} = await client.fetch<\n    {\n      private: FetchSecretQueryResponse\n      public: FetchPublicSecretQueryResponse\n    },\n    FetchSecretQueryParams\n  >(\n    `{\n      \"private\": ${fetchSecretQuery},\n      \"public\": ${fetchSharedAccessSecretQuery}\n    }`,\n    {secret: secret},\n    {\n      tag,\n      // In CloudFlare Workers we can't pass the cache header\n      ...(!disableCacheNoStore ? {cache: 'no-store'} : undefined),\n    },\n  )\n  if (privateSecret) {\n    if (!privateSecret?._id || !privateSecret?._updatedAt || !privateSecret?.secret) {\n      return {isValid: false, studioUrl: null}\n    }\n    return {isValid: secret === privateSecret.secret, studioUrl: privateSecret.studioUrl}\n  }\n  if (!publicSecret?.secret) {\n    return {isValid: false, studioUrl: null}\n  }\n  return {isValid: secret === publicSecret.secret, studioUrl: publicSecret.studioUrl}\n}\n","import {isDev} from './constants'\nimport {createClientWithConfig} from './createClientWithConfig'\nimport {parsePreviewUrl} from './parsePreviewUrl'\nimport type {ParsedPreviewUrl, PreviewUrlValidateUrlResult, SanityClientLike} from './types'\nimport {validateSecret} from './validateSecret'\n\n/**\n * @public\n */\nexport async function validatePreviewUrl(\n  _client: SanityClientLike,\n  previewUrl: string,\n  /**\n   * @deprecated - this option is automatically determined based on the environment\n   */\n  // Default value based on https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent\n  disableCacheNoStore: boolean = globalThis.navigator?.userAgent === 'Cloudflare-Workers',\n): Promise<PreviewUrlValidateUrlResult> {\n  const client = createClientWithConfig(_client)\n  let parsedPreviewUrl: ParsedPreviewUrl\n  try {\n    parsedPreviewUrl = parsePreviewUrl(previewUrl)\n  } catch (error) {\n    if (isDev) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse preview URL', error, {\n        previewUrl,\n        client,\n      })\n    }\n    return {isValid: false}\n  }\n\n  const {isValid, studioUrl} = await validateSecret(\n    client,\n    parsedPreviewUrl.secret,\n    disableCacheNoStore,\n  )\n  const redirectTo = isValid ? parsedPreviewUrl.redirectTo : undefined\n  const studioPreviewPerspective = isValid ? parsedPreviewUrl.studioPreviewPerspective : undefined\n  let studioOrigin: string | undefined\n  if (isValid) {\n    try {\n      studioOrigin = new URL(studioUrl!).origin\n    } catch (error) {\n      if (isDev) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to parse studioUrl', error, {\n          previewUrl,\n          studioUrl,\n        })\n      }\n    }\n  }\n\n  return {isValid, redirectTo, studioOrigin, studioPreviewPerspective}\n}\n\nexport type {PreviewUrlValidateUrlResult, SanityClientLike}\n"],"names":["apiVersion","urlSearchParamPreviewSecret","urlSearchParamPreviewPerspective","urlSearchParamPreviewPathname","urlSearchParamVercelProtectionBypass","urlSearchParamVercelSetBypassCookie","fetchSecretQuery","fetchSharedAccessSecretQuery","tag","isDev"],"mappings":"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"}