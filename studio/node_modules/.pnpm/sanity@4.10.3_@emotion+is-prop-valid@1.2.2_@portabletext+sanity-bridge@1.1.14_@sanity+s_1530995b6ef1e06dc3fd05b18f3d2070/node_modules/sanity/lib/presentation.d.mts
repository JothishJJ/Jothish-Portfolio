import {ActionFunction} from 'xstate'
import {ActorRef} from 'xstate'
import {ActorRefFrom} from 'xstate'
import {ActorRefFromLogic} from 'xstate'
import {AnyActorLogic} from 'xstate'
import {AnyActorRef} from 'xstate'
import {AnyEventObject} from 'xstate'
import {ArraySchemaType} from '@sanity/types'
import {AssetMetadataType} from '@sanity/types'
import {AssetSource} from '@sanity/types'
import {AssetSourceSpec} from '@sanity/types'
import {BooleanSchemaType} from '@sanity/types'
import {ButtonTone} from '@sanity/ui'
import {ClientConfig} from '@sanity/client'
import {ClientPerspective} from '@sanity/client'
import {ComponentType} from 'react'
import {ConditionalRequired} from 'xstate'
import {CrossDatasetReferenceValue} from '@sanity/types'
import {CSSProperties} from 'react'
import {CurrentUser} from '@sanity/types'
import {DialogProps} from '@sanity/ui'
import {Diff} from '@sanity/diff'
import {DoneActorEvent} from 'xstate'
import {EditorChange} from '@portabletext/editor'
import {EditorSelection} from '@portabletext/editor'
import {ErrorActorEvent} from 'xstate'
import {ErrorInfo} from 'react'
import {EventObject} from 'xstate'
import {FileValue} from '@sanity/types'
import {FocusEvent as FocusEvent_2} from 'react'
import {FocusEventHandler} from 'react'
import {FormEventHandler} from 'react'
import {FormNodeValidation} from '@sanity/types'
import {GeopointValue} from '@sanity/types'
import {GetConcreteByKey} from 'xstate'
import {HotkeyOptions} from '@portabletext/editor'
import {I18nTextRecord} from '@sanity/types'
import {ImageUrlFitMode} from '@sanity/types'
import {ImageValue} from '@sanity/types'
import {InitialValueProperty} from '@sanity/types'
import {InitialValueResolverContext} from '@sanity/types'
import {InputFrom} from 'xstate'
import {IsNotNever} from 'xstate'
import {KeyedSegment} from '@sanity/types'
import {MachineSnapshot} from 'xstate'
import {MarkdownPluginConfig} from '@portabletext/editor/plugins'
import {MetaObject} from 'xstate'
import {MutableRefObject} from 'react'
import {NonReducibleUnknown} from 'xstate'
import {NumberSchemaType} from '@sanity/types'
import {ObjectSchemaType} from '@sanity/types'
import {Observable} from 'rxjs'
import {ObservableActorLogic} from 'xstate'
import {ObservableSnapshot} from 'xstate'
import {OnCopyFn} from '@portabletext/editor'
import {OnPasteFn} from '@portabletext/editor'
import {Path} from '@sanity/types'
import {PathSegment} from '@sanity/types'
import {PortableTextBlock} from '@sanity/types'
import {PortableTextEditor} from '@portabletext/editor'
import {PortableTextObject} from '@sanity/types'
import {PreviewUrlResolver} from '@sanity/preview-url-secret/define-preview-url'
import {PromiseActorLogic} from 'xstate'
import {RangeDecoration} from '@portabletext/editor'
import {ReactNode} from 'react'
import {ReferenceValue} from '@sanity/types'
import {RefObject} from 'react'
import {ReleaseDocument} from '@sanity/client'
import {RequiredActorOptions} from 'xstate'
import {RequiredLogicInput} from 'xstate'
import {RootTheme} from '@sanity/ui/theme'
import {Router} from 'sanity/router'
import {RouterState} from 'sanity/router'
import {SanityClient} from '@sanity/client'
import {SanityDocument} from '@sanity/types'
import {SanityDocumentLike} from '@sanity/types'
import {Schema} from '@sanity/types'
import {SchemaType} from '@sanity/types'
import {SchemaTypeDefinition} from '@sanity/types'
import {SearchStrategy} from '@sanity/types'
import {Serializable} from '@sanity/presentation-comlink'
import {SerializableArray} from '@sanity/presentation-comlink'
import {SerializableObject} from '@sanity/presentation-comlink'
import {SerializablePrimitive} from '@sanity/presentation-comlink'
import {SlugValue} from '@sanity/types'
import {SnapshotEvent} from 'xstate'
import {StackablePerspective} from '@sanity/client'
import {StateMachine} from 'xstate'
import {StateValue} from 'xstate'
import {StringSchemaType} from '@sanity/types'
import {TFunction} from 'i18next'
import {User} from '@sanity/types'
import {ValidationMarker} from '@sanity/types'
import {Values} from 'xstate'

declare interface Action extends NavbarActionBase {
  onAction: () => void
  selected: boolean
  title: string
  render?: undefined
}

/**
 * @hidden
 * @beta
 */
declare interface ActionComponent<ActionProps, ActionDescription> {
  (props: ActionProps): ActionDescription | null
}

declare interface ActionWithCustomRender extends NavbarActionBase {
  render: () => React.ReactElement
}

/**
 * @hidden
 * @beta */
declare interface ActiveToolLayoutProps {
  renderDefault: (props: ActiveToolLayoutProps) => React.JSX.Element
  activeTool: Tool
}

/**
 * @public
 * Config for the apps that are available in the studio.
 */
declare type AppsOptions = {
  canvas?: {
    enabled: boolean
    /**
     * To allow the "Link to canvas" action on localhost, or in studios not listed under Studios in sanity.io/manage
     * provide a fallback origin as a string.
     *
     * The string must be the exactly equal `name` as shown for the Studio in manage, and the studio must have create-manifest.json available.
     *
     * If the provided fallback Studio does not expose create-manifest.json "Link to canvas" will fail when using the fallback.
     *
     * Example: `wonderful.sanity.studio`
     *
     * Keep in mind that when fallback origin is used, Canvas will use the schema types and dataset in the *deployed* Studio,
     * not from localhost.
     *
     * To see data synced from Canvas in your localhost Studio, you must ensure that the deployed fallback studio uses the same
     * workspace and schemas as your local configuration.
     *
     */
    fallbackStudioOrigin?: string
  }
}

/**
 * @hidden
 * @public */
declare interface ArrayFieldProps extends BaseFieldProps {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfObjectsInputProps
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputCopyEvent<Item> {
  items: Item[]
}

/**
 * These are the props an implementation of the ArrayFunctions component will receive
 *
 *
 * @hidden
 * @beta
 */
declare interface ArrayInputFunctionsProps<Item, SchemaType extends ArraySchemaType> {
  children?: ReactNode
  onItemAppend: (itemValue: Item) => void
  onChange: (event: PatchEvent) => void
  onValueCreate: (type: SchemaType) => Item
  onItemPrepend: (itemValue: Item) => void
  readOnly?: boolean
  schemaType: SchemaType
  value?: Item[]
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputInsertEvent<Item> {
  items: Item[]
  position: 'before' | 'after'
  referenceItem: KeyedSegment | number
  skipInitialValue?: boolean
  open?: boolean
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputMoveItemEvent {
  fromIndex: number
  toIndex: number
}

/**
 * @hidden
 * @beta */
declare interface ArrayItemError {
  kind: 'error'
  key: string
  index: number
  error: InvalidItemTypeError
}

/** @public */
declare interface ArrayOfObjectsFormNode<
  T extends any[] = unknown[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfObjectsMember[]
}

/**
 * @hidden
 * @public */
declare interface ArrayOfObjectsInputProps<
  T extends {
    _key: string
  } = {
    _key: string
  },
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseInputProps,
    ArrayOfObjectsFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemMove: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: ArrayInputInsertEvent<T>) => void
  /**
   * @hidden
   * @beta */
  resolveInitialValue: (type: SchemaType, params: Record<string, unknown>) => Promise<T>
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<ObjectSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path, payload?: OnPathFocusPayload) => void
  /**
   * for array inputs using expand/collapse semantics for items
   *
   * @hidden
   * @beta
   */
  onItemCollapse: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemExpand: (itemKey: string) => void
  /**
   * for array inputs using modal open/close semantics for items
   *
   * @hidden
   * @beta
   */
  onItemOpen: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onItemClose: () => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfObjectsItemMember<Node extends ObjectArrayFormNode = ObjectArrayFormNode> {
  kind: 'item'
  key: string
  index: number
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare type ArrayOfObjectsMember = ArrayOfObjectsItemMember | ArrayItemError

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesElementType<T extends any[]> = T extends (infer K)[] ? K : unknown

/** @public */
declare interface ArrayOfPrimitivesFormNode<
  T extends (string | number | boolean)[] = (string | number | boolean)[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfPrimitivesMember[]
}

/**
 * @hidden
 * @public */
declare interface ArrayOfPrimitivesInputProps<
  T extends string | boolean | number = string | boolean | number,
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseInputProps,
    ArrayOfPrimitivesFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  onSetCollapsed: (collapsed: boolean) => void
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (index: number) => void
  /**
   * @hidden
   * @beta */
  onMoveItem: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: {items: T[]; position: 'before' | 'after'; referenceIndex: number}) => void
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<NumberSchemaType | BooleanSchemaType | StringSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onIndexFocus: (index: number) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfPrimitivesItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfPrimitivesItemMember<Node extends PrimitiveFormNode = PrimitiveFormNode> {
  kind: 'item'
  key: string
  index: number
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesMember = ArrayOfPrimitivesItemMember | ArrayItemError

/**
 * @hidden
 * @beta
 */
declare type AssetSourceResolver = ComposableOption<AssetSource[], ConfigContext>

/**
 * @hidden
 * @beta
 */
declare type AsyncComposableOption<TValue, TContext> = (
  prev: TValue,
  context: TContext,
) => Promise<TValue>

/**
 * Authentication options
 *
 * @public
 */
declare interface AuthConfig {
  /**
   * Login method to use for the studio. Can be one of:
   * - `dual` (default) - attempt to use cookies where possible, falling back to
   *   storing authentication token in `localStorage` otherwise
   * - `cookie` - explicitly disable `localStorage` method, relying only on cookies. May fail due
   *   to cookies being treated as third-party cookies in some browsers, thus the default is `dual`.
   * - `token` - explicitly disable cookies, relying only on `localStorage` method
   */
  loginMethod?: LoginMethod
  /**
   * Whether to append the providers specified in `providers` with the default providers from the
   * API, or replace the default providers with the ones specified.
   *
   * @deprecated Use the function form of `providers` instead for more control
   */
  mode?: 'append' | 'replace'
  /**
   * If true, the "Choose login provider" (eg "Google, "GitHub", "E-mail/password") screen
   * will be skipped if only a single provider is configured in the `providers` array -
   * instead it will redirect unauthenticated users straight to the authentication URL.
   */
  redirectOnSingle?: boolean
  /**
   * Array of authentication providers to use, or a function that takes an array of default
   * authentication providers (fetched from the Sanity API) and should return a new list of
   * providers. This can be used to selectively replace, add or remove providers from the
   * list of choices.
   *
   * @remarks If a static array of providers is provided, the `mode` property is taken into account
   *   when determining what to do with it - `append` will append the providers to the default set
   *   of providers, while `replace` will replace the default providers with the ones specified.
   *
   * If not set, the default providers will be used.
   */
  providers?: AuthProvider[] | ((prev: AuthProvider[]) => AuthProvider[] | Promise<AuthProvider[]>)
  /**
   * The API hostname for requests. Should usually be left undefined,
   * but can be set if using custom cname for API domain.
   */
  apiHost?: string
}

/**
 * A provider of authentication.
 *
 * By default, a list of providers for a project will be fetched from the
 * {@link https://api.sanity.io/v1/auth/providers | Sanity API}, but you may choose to limit this
 * list by explicitly defining the providers you want to allow, or add additional custom providers
 * that conforms to the authentication provider specification outlined in
 * {@link https://www.sanity.io/docs/third-party-login | the documentation}.
 *
 * @public
 */
declare interface AuthProvider {
  /**
   * URL-friendly identifier/name for the provider, eg `github`
   */
  name: string
  /**
   * Human friendly title for the provider, eg `GitHub`
   */
  title: string
  /**
   * URL for the authentication endpoint that will trigger the authentication flow
   */
  url: string
  /**
   * URL for a logo to display next to the provider in the login screen
   */
  logo?: string
}

/**
 * The unit an `AuthStore` emits to determine the user's authentication state.
 *
 * @beta
 * @hidden
 */
declare interface AuthState {
  /**
   * Similar to a logged-in flag. This state is used in places like the
   * `AuthBoundary` to determine whether or not it should render the
   * `NotAuthenticatedComponent`. Implementers may choose to set this to `true`
   * while also also emitting a `currentUser` of `null` if a `null` user is
   * accepted (e.g. a project that doesn't require a login)
   */
  authenticated: boolean
  /**
   * The value of the user logged in or `null` if none is provided
   */
  currentUser: CurrentUser | null
  /**
   * A client that is expected to be pre-configured to allow for any downstream
   * requests in the Studio
   */
  client: SanityClient
}

/**
 * The interface used by the Studio that produces a `SanityClient` and
 * `CurrentUser` that gets passed to the resulting `Workspace`s and `Source`s.
 *
 * NOTE: This interface is primarily for internal use. Refer to
 * `createAuthStore` instead.
 *
 * @beta
 * @hidden
 */
declare interface AuthStore {
  /**
   * Emits `AuthState`s. This should update when the user's auth state changes.
   * E.g. After a login, a new `AuthState` could be emitted with a non-null
   * `currentUser` and `authenticated: true`
   *
   * NOTE: all auth store implementations should emit on subscribe using
   * something like shareReplay(1) to ensure all new subscribers get an
   * `AuthState` value on subscribe
   */
  state: Observable<AuthState>
  /**
   * Emits auth tokens, or `null` if not configured to use them or they do not exist
   */
  token?: Observable<string | null>
  /**
   * Custom auth stores are expected to implement a UI that initiates the user's
   * authentication. For the typical case in `createAuthStore`, this means
   * loading the providers and showing them as options to the user.
   */
  LoginComponent?: ComponentType<LoginComponentProps>
  /**
   * Custom auth stores can implement a function that runs when the user logs
   * out. The implementation is expected to remove all credentials both locally
   * and on the server.
   */
  logout?: () => void
  /**
   * Custom auth stores can implement a function that is designated to run when
   * the Studio loads (e.g. to trade a session ID for a token in cookie-less
   * mode). Within the Studio, this is called within the `AuthBoundary`.
   */
  handleCallbackUrl?: () => Promise<void>
}

/**
 * @hidden
 * @beta
 */
declare interface BaseActionDescription {
  disabled?: boolean
  icon?: ReactNode | ComponentType
  label: string
  onHandle?: () => void
  title?: ReactNode
  tone?: ButtonTone
  shortcut?: string | null
  dialog?: unknown
}

/**
 * @hidden
 * @public */
declare interface BaseFieldProps {
  /** @beta */
  actions?: DocumentFieldAction[]
  /** @internal @deprecated DO NOT USE */
  __internal_comments?: FieldCommentsProps
  /** @internal @deprecated ONLY USED BY AI ASSIST PLUGIN */
  __internal_slot?: ReactNode
  schemaType: SchemaType
  title: string | undefined
  description: string | undefined
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  validation: FormNodeValidation[]
  level: number
  inputId: string
  value: unknown | undefined
  path: Path
  name: string
  index: number
  changed: boolean
  children: ReactNode
  version?: string
  renderDefault: (props: FieldProps) => React.JSX.Element
}

/**
 * @hidden
 * @public
 */
declare interface BaseFormNode<T = unknown, S extends SchemaType = SchemaType>
  extends NodeDiffProps<ProvenanceDiffAnnotation> {
  /** The unique identifier of the node. */
  id: string
  /** The schema type of the node. */
  schemaType: S
  /** The level of the node in the form hierarchy. */
  level: number
  /** The path of the node in the form hierarchy. */
  path: Path
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  /** The validation markers of the node. */
  validation: FormNodeValidation[]
  /** The value of the node. */
  value: T | undefined
  /** Whether the node is read-only. */
  readOnly?: boolean
  /** Whether the node is focused. */
  focused?: boolean
}

/**
 * @hidden
 * @public */
declare interface BaseInputProps extends NodeDiffProps<ProvenanceDiffAnnotation> {
  renderDefault: (props: InputProps) => React.JSX.Element
}

/**
 * Props for the base item component.
 *
 * @public
 */
declare interface BaseItemProps<T> extends NodeDiffProps<ProvenanceDiffAnnotation> {
  /** The schema type of the item. */
  schemaType: SchemaType
  /** The key of the item. */
  key: string
  /** The index of the item. */
  index: number
  /** The level of the item. */
  level: number
  /** The value of the item. */
  value: unknown
  /** The path of the item. */
  path: Path
  /** The title of the item. */
  title: string | undefined
  /** The description of the item. */
  description: string | undefined
  /** The ID of the input element. */
  inputId: string
  /** The function to call when the item receives focus. */
  onFocus: (event: FocusEvent_2) => void
  /** The function to call when the item loses focus. */
  onBlur: (event: FocusEvent_2) => void
  /** Whether the item is read-only. */
  readOnly?: boolean
  /** Whether the item is focused. */
  focused?: boolean
  /** The function to call when the item is removed. */
  onRemove: () => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: Omit<ArrayInputInsertEvent<T>, 'referenceItem'>) => void
  /**
   * @hidden
   * @beta */
  onCopy: (event: Omit<ArrayInputCopyEvent<T>, 'referenceItem'>) => void
  /** The children of the item. */
  children: ReactNode
  /** The validation markers for the item. */
  validation: FormNodeValidation[]
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  /** The function to call to render the default item. See {@link ItemProps} */
  renderDefault: (props: ItemProps) => React.JSX.Element
}

/**
 * @internal
 * Configuration for studio beta features.
 * */
declare interface BetaFeatures {
  /**
   * @beta
   * @hidden
   * @deprecated beta feature is no longer available.
   * */
  treeArrayEditing?: {
    /**
     * @deprecated beta feature is no longer available.
     */
    enabled: boolean
  }
  /**
   * @deprecated - The Start in Create flow has been removed and will be updated in an upcoming studio release.
   */
  create?: {
    /**
     * When true, a "Start in Sanity Create" action will be shown for all new documents, in place of regular document actions,
     * when the following are true:
     * - the origin of the current url is listed under Studios in sanity.to/manage (OR fallbackStudioOrigin is provided)
     * - [origin]/static/create-manifest.json is available over HTTP GET
     *
     * The manifest file is automatically created and deployed when deploying studios with `sanity deploy`
     *
     * @see #fallbackStudioOrigin
     */
    startInCreateEnabled?: boolean
    /**
     * To show the "Start in Create" button on localhost, or in studios not listed under Studios in sanity.io/manage
     * provide a fallback origin as a string.
     *
     * The string must be the exactly equal `name` as shown for the Studio in manage, and the studio must have create-manifest.json available.
     *
     * If the provided fallback Studio does not expose create-manifest.json "Start in Sanity Create" will fail when using the fallback.
     *
     * Example: `wonderful.sanity.studio`
     *
     * Keep in mind that when fallback origin is used, Sanity Create will used the schema types and dataset in the *deployed* Studio,
     * not from localhost.
     *
     * To see data synced from Sanity Create in your localhost Studio, you must ensure that the deployed fallback studio uses the same
     * workspace and schemas as your local configuration.
     *
     * @see #startInCreateEnabled
     */
    fallbackStudioOrigin?: string
  }
  /**
   * Config for the history events API .
   *
   * If enabled, it will use the new events API to fetch document history.
   *
   * If it is not enabled, it will continue using the legacy Timeline.
   */
  eventsAPI?: {
    documents?: boolean
    releases?: boolean
  }
}

/**
 * Props for rendering a Portable Text annotation
 *
 * @public
 * @remarks If you want to render a mix of the annotated text and non-text content, you have to attribute
 * the non-text containers with `contentEditable={false}`. See the second example.
 * @example Simple example of customizing the annotation text to render yellow.
 * ```ts
 * (props: BlockAnnotationProps) =>
 *   props.renderDefault({
 *     ...props,
 *     textElement: <span style={{color: 'yellow'}}>{props.textElement}</span>,
 *   })
 * ```
 * @example Simple example of rendering the annotation with a custom modal for editing.
 * Note that the form content container is attributed as `contentEditable={false}`.
 * This is to signal to the text editor that this content isn't part of the editable text.
 * ```ts
 * (props: BlockAnnotationProps) => {
 *   return (
 *     <>
 *       // Render the annotated text
 *       <span onClick={props.onOpen}>
 *         {props.textElement}
 *       </span>
 *       // Render the editing form if the object is opened
 *       {props.open && (
 *         <Dialog
 *           contentEditable={false} // Attribute this as non-editable to the text editor
 *           header={`Edit ${props.schemaType.title}`}
 *           id={`dialog-${props.value._key}`}
 *           onClickOutside={props.onClose}
 *           onClose={props.onClose}
 *         >
 *           <Box margin={2} padding={2}>
 *             {props.children}
 *           </Box>
 *         </Dialog>
 *      )}
 *     </>
 *   )
 * }
 * ```
 * */
declare interface BlockAnnotationProps {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element where the text for this annotation appears.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the annotated text.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * Wether the annotated text node has editor focus.
   * @remarks differs from `focused` which is wether the annotation object has form focus.
   */
  __unstable_textElementFocus?: boolean
  /**
   * The input form for the annotation object.
   * @remarks If you wrap this in something, you must make sure to put `contentEditable={false}` on the root container.
   * Otherwise the editor will think content is part of the editable text and will error.
   */
  children: ReactNode
  /**
   * If the editor form for this annotation object currently have form focus.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker[]
  /**
   * Closes the editing form connected to this annotation.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this annotation.
   */
  onOpen: () => void
  /**
   * Focus a form node in the object for this annotation.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the annotation object from the text.
   */
  onRemove: () => void
  /**
   * If the annotation is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type. For annotations this this the block type.
   */
  parentSchemaType: SchemaType
  /**
   * The full form path to this annotation from document root.
   */
  path: Path
  /**
   * Form presence for this annotation.
   */
  presence: FormNodePresence[]
  /**
   * Is the annotation object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderDefault: (props: BlockAnnotationProps) => React.JSX.Element
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback
  /**
   * The schema type for the annotation object.
   */
  schemaType: ObjectSchemaType & {
    i18nTitleKey?: string
  }
  /**
   * If the annotated text currently is selected by the user.
   */
  selected: boolean
  /**
   * React element of the text that is being annotated.
   */
  textElement: React.JSX.Element
  /**
   * Form validation for the annotation object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the annotation object.
   */
  value: PortableTextObject
}

/**
 * Props for rendering a Portable Text block
 *
 * @public
 */
declare interface BlockProps {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element for the block.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the block.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * The default rendering of the block (the text).
   */
  children: ReactNode
  /**
   * If the block currently is focused by the user.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker[]
  /**
   * Closes the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onOpen: () => void
  /**
   * Focus a form node in this block.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the block.
   */
  onRemove: () => void
  /**
   * If the block is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type (array type).
   */
  parentSchemaType: ArraySchemaType | ObjectSchemaType
  /**
   * The full form path to this block from document root.
   */
  path: Path
  /**
   * Form presence for this block.
   */
  presence: FormNodePresence[]
  /**
   * Is the block object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback (default rendering function of the block).
   */
  renderDefault: (props: BlockProps) => React.JSX.Element
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback
  /**
   * The schema type for the block.
   */
  schemaType: ObjectSchemaType
  /**
   * If the block is in the user's selection.
   */
  selected: boolean
  /**
   * Form validation for the block object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the block.
   */
  value: PortableTextBlock
}

/**
 * @hidden
 * @public */
declare interface BooleanFieldProps extends BaseFieldProps {
  schemaType: BooleanSchemaType
  value: boolean | undefined
  inputProps: BooleanInputProps
}

/** @public */
declare type BooleanFormNode<S extends BooleanSchemaType = BooleanSchemaType> = BaseFormNode<
  boolean,
  S
>

/**
 * @hidden
 * @public */
declare interface BooleanInputProps<S extends BooleanSchemaType = BooleanSchemaType>
  extends BaseInputProps,
    BooleanFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * A shorthand aggregation of any validation errors the input currently have
   * Will be falsey if no error.
   * In the case of multiple errors it will be a newline delimited string of each error message
   * For advanced use cases use the ´validation´ prop which contains more levels and details
   */
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @beta */
declare type BufferedDocumentEvent =
  | SnapshotEvent_2
  | DocumentRebaseEvent
  | DocumentMutationEvent
  | CommittedEvent

declare interface CheckPermissionInput {
  checkPermissionName: DocumentValuePermission
  document: Partial<SanityDocument> | null
}

/**
 * All possible URL search parameters used by the Presentation tool
 * @public
 */
export declare interface CombinedSearchParams
  extends StructureDocumentPaneParams,
    PresentationSearchParams {}

/**
 * @hidden
 * @beta */
declare interface CommittedEvent {
  type: 'committed'
}

/**
 * @hidden
 * @beta */
declare interface ComplexElementProps {
  'id': string
  'onFocus': FocusEventHandler
  'onBlur': FocusEventHandler
  'ref': MutableRefObject<any>
  'aria-describedby': string | undefined
}

/** @public */
declare type ComposableOption<TValue, TContext> = (prev: TValue, context: TContext) => TValue

/**
 * @public
 */
declare type ComputeDiff<Annotation> = (value: unknown) => Diff<Annotation>

/** @public */
declare interface ConfigContext {
  /**
   * The ID of the project.
   */
  projectId: string
  /**
   * The name of the dataset.
   */
  dataset: string
  /**
   * The schema for this source.
   */
  schema: Schema
  /**
   * The current user or `null` if not authenticated.
   */
  currentUser: CurrentUser | null
  /**
   * A function that returns a Sanity client with the {@link SourceClientOptions | specified options}.
   */
  getClient: (options: SourceClientOptions) => SanityClient
  /**
   * Localization resources
   */
  i18n: LocaleSource
  /** @internal */
  [QUOTA_EXCLUDED_RELEASES_ENABLED]?: boolean
  /** @beta */
  [DECISION_PARAMETERS_SCHEMA]?: DecisionParametersConfig
}

/**
 * Represents the connection status between the Sanity Studio and Presentation's preview iframe.
 * @public
 */
export declare type ConnectionStatus = 'connected' | 'connecting' | 'reconnecting' | 'idle'

declare interface Context {
  url: URL | null
  error: Error | null
  visualEditingOverlaysEnabled: boolean
}

declare interface Context_2 {
  initialUrl: URL | null
  previewUrl: URL | null
  allowOrigins: URLPattern[] | null
  error: Error | null
  previewSearchParam: string | null
  previewUrlSecret: {
    secret: string
    expiresAt: Date
  } | null
  previewAccessSharingCreatePermission: PermissionCheckResult | null
  previewAccessSharingReadPermission: PermissionCheckResult | null
  previewAccessSharingUpdatePermission: PermissionCheckResult | null
  previewUrlSecretPermission: PermissionCheckResult | null
  previewMode: PreviewUrlPreviewMode | null
}

/**
 * Generic function type used in `DocumentResolver` definitions that receives a `DocumentResolverContext` and returns a computed value.
 * @param context - `DocumentResolverContext` containing route information (origin, params, path)
 * @returns Computed value based on the context (typically a string for filters or an object for parameters)
 * @public
 */
export declare type ContextFn<T> = (context: DocumentResolverContext) => T

/**
 * Symbol for configuring decision parameters schema
 * @beta
 */
declare const DECISION_PARAMETERS_SCHEMA: unique symbol

/**
 * Configuration for decision parameters
 * @beta
 */
declare interface DecisionParametersConfig {
  [key: string]: string[]
}

/** @beta */
declare type DefaultPluginsWorkspaceOptions = {
  tasks: {
    enabled: boolean
  }
  scheduledPublishing: ScheduledPublishingPluginOptions
  releases: {
    enabled?: boolean
    /**
     * Limit the number of releases that can be created by this workspace.
     */
    limit?: number
    /**
     * Actions for releases.
     */
    actions?: ReleaseActionComponent[] | ReleaseActionsResolver
  }
  mediaLibrary?: MediaLibraryConfig
}

/**
 * Define documents for a given location.
 * This function doesn't do anything itself, it is used to provide type information.
 * @param resolvers - resolvers that return documents.
 * @public
 */
export declare function defineDocuments(resolvers: DocumentResolver[]): typeof resolvers

/**
 * Define locations for a given document type.
 * This function doesn't do anything itself, it is used to provide type information.
 * @param resolver - resolver that return locations for a document.
 * @public
 */
export declare function defineLocations<K extends string>(
  resolver: DocumentLocationResolverObject<K> | DocumentLocationsState,
): typeof resolver

/**
 * @deprecated the `previewUrl.initial`, `previewUrl.allowOrigins` and `previewUrl.previewMode.enable` supports async functions that offer advanced control over how preview URLs are resolved
 * @public
 */
declare type DeprecatedPreviewUrlResolver = PreviewUrlResolver<SanityClient>

/**
 * @hidden
 * @beta */
declare interface DocumentActionComponent
  extends ActionComponent<DocumentActionProps, DocumentActionDescription> {
  /**
   * An optional meta property that can used to replace this document action
   * with another. E.g.:
   *
   * ```js
   * import {defineConfig} from 'sanity'
   * import {MyPublishAction} from '...'
   *
   * export default defineConfig({
   *   document: {
   *     actions: (prev) =>
   *       prev.map((previousAction) =>
   *         previousAction.action === 'publish' ? MyPublishAction : previousAction
   *       ),
   *   },
   * })
   * ```
   */
  action?: SanityDefinedAction
  /**
   * For debugging purposes
   */
  displayName?: string
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionConfirmDialogProps {
  type: 'confirm'
  tone?: ButtonTone
  message: ReactNode
  onConfirm: () => void
  onCancel: () => void
  cancelButtonIcon?: ComponentType | ReactNode
  cancelButtonText?: string
  confirmButtonIcon?: ComponentType | ReactNode
  confirmButtonText?: string
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionCustomDialogComponentProps {
  type: 'custom'
  component: ReactNode
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentActionDescription
  extends GroupableActionDescription<DocumentActionGroup> {
  dialog?: DocumentActionDialogProps | false | null
}

/**
 * @hidden
 * @beta */
declare type DocumentActionDialogProps =
  | DocumentActionConfirmDialogProps
  | DocumentActionPopoverDialogProps
  | DocumentActionModalDialogProps
  | DocumentActionCustomDialogComponentProps

/**
 * @hidden
 * @beta */
declare type DocumentActionGroup = 'default' | 'paneActions'

/**
 * @hidden
 * @beta */
declare interface DocumentActionModalDialogProps {
  type?: 'dialog'
  content: ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  footer?: DialogProps['footer']
  /**
   *
   * @hidden
   * @beta
   */
  header?: ReactNode
  onClose: () => void
  showCloseButton?: boolean
  /**
   *
   * @hidden
   * @beta
   */
  width?: 'small' | 'medium' | 'large' | 'full'
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionPopoverDialogProps {
  type: 'popover'
  content: ReactNode
  onClose: () => void
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionProps extends EditStateFor {
  revision?: string
  onComplete: () => void
  /**
   * Whether the initial value has been resolved.
   */
  initialValueResolved: boolean
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentActionsContext extends ConfigContext {
  documentId?: string
  schemaType: string
  /** releaseId of the open document, it's undefined if it's published or the draft */
  releaseId: string | undefined
  /** the type of the currently active document. */
  versionType: DocumentActionsVersionType
  /** @internal */
  [QUOTA_EXCLUDED_RELEASES_ENABLED]?: boolean
}

/**
 * @hidden
 * @beta
 */
declare type DocumentActionsResolver = ComposableOption<
  DocumentActionComponent[],
  DocumentActionsContext
>

/**
 * @hidden
 * @beta
 */
declare type DocumentActionsVersionType =
  | 'published'
  | 'draft'
  | 'revision'
  | 'version'
  | 'scheduled-draft'

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeComponent
  extends HookCollectionActionHook<DocumentBadgeProps, DocumentBadgeDescription> {
  (props: DocumentBadgeProps): DocumentBadgeDescription | null
}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeDescription {
  title?: string
  label?: string | undefined
  color?: 'primary' | 'success' | 'warning' | 'danger'
  icon?: ReactNode | ComponentType
}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeProps extends EditStateFor {}

/**
 * @hidden
 * @beta
 */
declare interface DocumentBadgesContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta
 */
declare type DocumentBadgesResolver = ComposableOption<
  DocumentBadgeComponent[],
  DocumentBadgesContext
>

/** @hidden @beta */
declare interface DocumentCommentsEnabledContext {
  documentId?: string
  documentType: string
}

declare interface DocumentComponents {
  /** @internal */
  unstable_layout?: ComponentType<DocumentLayoutProps>
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldAction {
  name: string
  useAction: DocumentFieldActionHook
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionDivider {
  type: 'divider'
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionGroup {
  type: 'group'
  children: DocumentFieldActionNode[]
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  expanded?: boolean
  hidden?: boolean
  icon?: ComponentType
  renderAsButton?: boolean
  status?: DocumentFieldActionStatus
  title: string
  i18n?: I18nTextRecord<'title'>
  tone?: DocumentFieldActionTone
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionHook {
  (props: DocumentFieldActionProps): DocumentFieldActionItem | DocumentFieldActionGroup
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionItem {
  type: 'action'
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  hidden?: boolean
  icon?: ComponentType
  iconRight?: ComponentType
  onAction: () => void
  renderAsButton?: boolean
  selected?: boolean
  status?: DocumentFieldActionStatus
  title: string
  i18n?: I18nTextRecord<'title'>
  tone?: DocumentFieldActionTone
}

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionNode =
  | DocumentFieldActionItem
  | DocumentFieldActionGroup
  | DocumentFieldActionDivider

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionProps {
  documentId: string
  documentType: string
  path: Path
  schemaType: SchemaType
}

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionsResolver = ComposableOption<
  DocumentFieldAction[],
  DocumentFieldActionsResolverContext
>

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionsResolverContext extends ConfigContext {
  documentId: string
  documentType: string
  schemaType: SchemaType
}

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionStatus = 'info' | 'success' | 'warning' | 'error'

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionTone = 'primary' | 'positive' | 'caution' | 'critical'

declare interface DocumentInRelease {
  memoKey: string
  isPending?: boolean
  document: SanityDocument & {
    publishedDocumentExists: boolean
  }
  validation: DocumentValidationStatus
}

/** @hidden @beta */
declare interface DocumentInspector {
  name: string
  component: DocumentInspectorComponent
  /**
   * Hook for defining a menu item for the inspector.
   */
  useMenuItem?: (props: DocumentInspectorUseMenuItemProps) => DocumentInspectorMenuItem
  /**
   * Callback for when the inspector is closed, which can be used to clean up custom document pane
   * parameters.
   */
  onClose?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
  /**
   * Callback for when the inspector is opened, which can be used to set custom document pane
   * parameters.
   */
  onOpen?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
}

/** @hidden @beta */
declare type DocumentInspectorComponent = ComponentType<DocumentInspectorProps>

/** @hidden @beta */
declare interface DocumentInspectorContext extends ConfigContext {
  documentId?: string
  documentType: string
}

/** @hidden @beta */
declare interface DocumentInspectorMenuItem {
  hidden?: boolean
  hotkeys?: string[]
  icon?: ComponentType
  showAsAction?: boolean
  status?: ButtonTone
  title: string
  tone?: ButtonTone
}

/** @hidden @beta */
declare interface DocumentInspectorProps {
  documentId: string
  documentType: string
  onClose: () => void
}

/** @hidden @beta */
declare type DocumentInspectorsResolver = ComposableOption<
  DocumentInspector[],
  DocumentInspectorContext
>

/** @hidden @beta */
declare interface DocumentInspectorUseMenuItemProps {
  documentId: string
  documentType: string
}

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterComponent = ComponentType<{
  schemaType: ObjectSchemaType
}>

/**
 *
 * @hidden
 * @beta
 */
declare interface DocumentLanguageFilterContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterResolver = ComposableOption<
  DocumentLanguageFilterComponent[],
  DocumentLanguageFilterContext
>

/** @internal*/
declare interface DocumentLayoutProps {
  /**
   * The ID of the document. This is a read-only property and changing it will have no effect.
   */
  documentId: string
  /**
   * The type of the document. This is a read-only property and changing it will have no effect.
   */
  documentType: string
  renderDefault: (props: DocumentLayoutProps) => React.JSX.Element
}

/**
 * Represents a document location
 * @public
 */
export declare interface DocumentLocation {
  /**
   * Title of the document
   */
  title: string
  /**
   * URL of the document location
   */
  href: string
}

/**
 * Function used for advanced document location resolution
 * @param params - Object with document `id` and document `type` properties
 * @param context - Object with `documentStore` property for creating listenQuery subscriptions
 * @returns Document location state, optionally as an Observable, or null/undefined if no locations are available
 * @public
 */
export declare type DocumentLocationResolver = (
  params: {
    id: string
    type: string
    version: string | undefined
    perspectiveStack: StackablePerspective[]
  },
  context: {
    documentStore: DocumentStore
  },
) =>
  | DocumentLocationsState
  | null
  | undefined
  | Observable<DocumentLocationsState | null | undefined>

/**
 * Document location resolver object
 * @public
 */
export declare type DocumentLocationResolverObject<K extends string = string> = {
  /**
   * Object for selecting document fields
   */
  select: Record<K, string>
  /**
   * Function that accepts a document with the selected fields and returns an optional document location state
   */
  resolve: (value: Record<K, any> | null) => DocumentLocationsState | null | undefined | void
}

/**
 * Object of document location resolver definitions per document type
 * @public
 */
export declare type DocumentLocationResolvers = Record<
  string,
  DocumentLocationResolverObject | DocumentLocationsState
>

/**
 * State for describing document locations or providing a message if locations are unavailable
 * @public
 */
export declare interface DocumentLocationsState {
  /**
   * Array of document locations
   */
  locations?: DocumentLocation[]
  /**
   * Message to display if locations are unavailable
   */
  message?: string
  /**
   * Tone of the message
   */
  tone?: 'positive' | 'caution' | 'critical'
}

/**
 * @hidden
 * @beta */
declare interface DocumentMutationEvent {
  type: 'mutation'
  document: SanityDocument
  mutations: MutationPayload[]
  origin: 'local' | 'remote'
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentPluginOptions {
  badges?: DocumentBadgeComponent[] | DocumentBadgesResolver
  actions?: DocumentActionComponent[] | DocumentActionsResolver
  /**
   * Components for the document.
   * @internal
   */
  components?: DocumentComponents
  /** @internal */
  unstable_fieldActions?: DocumentFieldAction[] | DocumentFieldActionsResolver
  /** @hidden @beta */
  inspectors?: DocumentInspector[] | DocumentInspectorsResolver
  /**
   * @hidden
   * @beta
   */
  productionUrl?: AsyncComposableOption<string | undefined, ResolveProductionUrlContext>
  /**
   * @hidden
   * @beta
   */
  unstable_languageFilter?: DocumentLanguageFilterResolver
  /**
   * @hidden
   * @beta
   */
  newDocumentOptions?: NewDocumentOptionsResolver
  /** @deprecated Use `comments` instead */
  unstable_comments?: {
    enabled: boolean | ((context: DocumentCommentsEnabledContext) => boolean)
  }
  /** @internal */
  comments?: {
    enabled: boolean | ((context: DocumentCommentsEnabledContext) => boolean)
  }
  drafts?: {
    /**
     * Whether the workspace provides the draft model for interacting with documents.
     *
     * When switched off, documents may only be edited:
     *
     *  - Inside a release.
     *  - Outside a release if they support live-edit.
     */
    enabled?: boolean
  }
}

/**
 * @hidden
 * @beta */
declare interface DocumentRebaseEvent {
  type: 'rebase'
  document: SanityDocument
  remoteMutations: MutationPayload[]
  localMutations: MutationPayload[]
}

/**
 * @hidden
 * @beta */
declare interface DocumentRemoteMutationEvent {
  type: 'remoteMutation'
  head: SanityDocument
  transactionId: string
  author: string
  timestamp: Date
  effects: {
    apply: unknown
    revert: unknown
  }
}

/**
 * Configuration object for resolving documents based on URL route patterns.
 * Used to define the main document when navigating to specific URLs in
 * Presentation tool's preview iframe.
 *
 * Supports three different resolution strategies:
 *
 * **Simple type-based resolution:**
 * ```ts
 * {
 *   route: '/blog',
 *   type: 'blog'  // Useful for singleton documents
 * }
 * ```
 *
 * **GROQ filter-based resolution:**
 * ```ts
 * {
 *   route: '/blog/:category/:slug',
 *   filter: ({ params }) => `_type == "post" && slug.current == "${params.slug}"`,
 *   params: ({ params }) => ({ category: params.category })
 * }
 * ```
 *
 * **Advanced resolution with custom logic:**
 * ```ts
 * {
 *   route: '/products/:id',
 *   resolve: ({ params }) => ({
 *     filter: `_type == "product" && _id == $id`,
 *     params: { id: params.id }
 *   })
 * }
 * ```
 *
 * @public
 */
export declare type DocumentResolver =
  | {
      route: string | Array<string>
      type: string
      filter?: never
      params?: never
      resolve?: never
    }
  | {
      route: string | Array<string>
      type?: never
      filter: ContextFn<string> | string
      params?: ContextFn<Record<string, string>> | Record<string, string>
      resolve?: never
    }
  | {
      route: string | Array<string>
      type?: never
      filter?: never
      params?: never
      resolve: ContextFn<
        | {
            filter: string
            params?: Record<string, string>
          }
        | undefined
      >
    }

/**
 * Context object passed to functions used in `DocumentResolver` definitions.
 * Contains information about the current URL being matched against route patterns.
 *
 * @example
 * For a route pattern `/blog/:category/:slug` matching URL `https://example.com/blog/tech/hello-world`:
 * ```ts
 * {
 *   origin: 'https://example.com',
 *   params: { category: 'tech', slug: 'hello-world' },
 *   path: '/blog/tech/hello-world'
 * }
 * ```
 *
 * @public
 */
export declare interface DocumentResolverContext {
  /**
   * The origin (protocol + hostname + port) of the matched URL
   */
  origin: string
  /**
   * Extracted route parameters from URL path matching (e.g., `:slug` → `{slug: 'value'}`)
   */
  params: Record<string, string>
  /**
   * The pathname of the matched URL (without query parameters)
   */
  path: string
}

/**
 * Represents a document revision identifier.
 * Can be either a specific revision string
 * or 'lastRevision' to get the most recent revision.
 *
 * @beta
 */
declare type DocumentRevision = string | 'lastRevision'

/**
 * @hidden
 * @beta */
declare interface DocumentStore {
  /**
   * Checks out a document (with its published and draft version) for real-time editing.
   * Note that every call to this function will open a new listener to the server.
   * It's recommended to use the helper functions on `pair` below which will re-use a single connection.
   *
   * @internal
   **/
  checkoutPair: (idPair: IdPair) => Pair
  initialValue: (
    opts: InitialValueOptions,
    context: InitialValueResolverContext,
  ) => Observable<InitialValueMsg>
  listenQuery: (
    query:
      | string
      | {
          fetch: string
          listen: string
        },
    params: QueryParams,
    options: ListenQueryOptions,
  ) => Observable<any>
  resolveTypeForDocument: (id: string, specifiedType?: string) => Observable<string>
  pair: {
    consistencyStatus: (publishedId: string, type: string, version?: string) => Observable<boolean>
    /** @internal */
    documentEvents: (
      publishedId: string,
      type: string,
      version?: string,
    ) => Observable<DocumentVersionEvent>
    /** @internal */
    editOperations: (
      publishedId: string,
      type: string,
      version?: string,
    ) => Observable<OperationsAPI>
    editState: (publishedId: string, type: string, version?: string) => Observable<EditStateFor>
    operationEvents: (
      publishedId: string,
      type: string,
    ) => Observable<OperationSuccess | OperationError>
    validation: (
      publishedId: string,
      type: string,
      version?: string,
    ) => Observable<ValidationStatus>
  }
}

declare interface DocumentValidationStatus extends ValidationStatus {
  hasError: boolean
}

/**
 * @hidden
 * @beta */
declare type DocumentValuePermission = 'read' | 'create' | 'update' | 'history' | 'editHistory'

/**
 * Indicates the type of document variant, either `draft`, `version` or `published`.
 * Draft documents are prefixed with `drafts.`.
 * Version documents are prefixed with `versions.<versionName>`
 * The rest are considered published documents.
 * @public
 */
declare type DocumentVariantType = 'draft' | 'version' | 'published'

/**
 * @hidden
 * @beta */
declare interface DocumentVersion {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotVersionEvent>
  events: Observable<DocumentVersionEvent>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @hidden
 * @beta */
declare type DocumentVersionEvent = WithVersion<
  ReconnectEvent | BufferedDocumentEvent | WelcomeEvent
>

/**
 * This error may happen for arrays of objects where one or more of the members are having duplicate keys
 *
 * @public
 */
declare type DuplicateKeysError = {
  type: 'DUPLICATE_KEYS'
  schemaType: ArraySchemaType
  duplicates: [index: number, key: string][]
}

/**
 * @hidden
 * @beta */
declare interface EditStateFor {
  id: string
  type: string
  transactionSyncLock: TransactionSyncLockState | null
  draft: SanityDocument | null
  published: SanityDocument | null
  version: SanityDocument | null
  /**
   * Whether live edit is enabled. This may be true for various reasons:
   *
   * - The schema type has live edit enabled.
   * - A version of the document is checked out.
   */
  liveEdit: boolean
  /**
   * Whether the schema type has live edit enabled.
   */
  liveEditSchemaType: boolean
  ready: boolean
  /**
   * When editing a version, the name of the release the document belongs to.
   */
  release: string | undefined
}

/** @internal @deprecated DO NOT USE */
declare interface FieldCommentsProps {
  hasComments: boolean
  button: ReactNode
  isAddingComment: boolean
}

/**
 * Represents an error that occurred in a specific field of a data object.
 * @public
 *
 * @remarks
 * This interface is used to provide detailed information about the error,
 * including the field name, the error type, and the error message.
 */
declare interface FieldError {
  /**
   * The type of error that occurred.
   */
  kind: 'error'
  /**
   * The unique identifier for the error.
   */
  key: string
  /**
   * The name of the field that the error occurred in.
   */
  fieldName: string
  /**
   * The specific error that occurred.
   *
   * ```md
   * Possible error types include:
   * - IncompatibleTypeError
   * - TypeAnnotationMismatchError
   * - MissingKeysError
   * - DuplicateKeysError
   * - UndeclaredMembersError
   * - MixedArrayError
   * ```
   *
   * See {@link IncompatibleTypeError},
   * {@link TypeAnnotationMismatchError},
   * {@link MissingKeysError},
   * {@link DuplicateKeysError},
   * {@link UndeclaredMembersError} and
   * {@link MixedArrayError} for more information.
   *
   */
  error:
    | IncompatibleTypeError
    | TypeAnnotationMismatchError
    | MissingKeysError
    | DuplicateKeysError
    | UndeclaredMembersError
    | MixedArrayError
}

/**
 * Represents a field member in a form.
 * @public
 */
declare interface FieldMember<Node extends BaseFormNode = BaseFormNode> {
  /** The kind of the form node. */
  kind: 'field'
  /** The key of the field. */
  key: string
  /** The name of the field. */
  name: string
  /** The index of the field. */
  index: number
  /** Whether the field is collapsed. */
  collapsed: boolean | undefined
  /** Whether the field is collapsible. */
  collapsible: boolean | undefined
  /** Whether the field is open. */
  open: boolean
  /**
   * @internal
   * Whether this field is in the selected group.
   */
  inSelectedGroup: boolean
  /**
   * @internal
   * Names of the field groups this field is part of.
   */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The form node that represents this field.
   */
  field: Node
}

/**
 * @hidden
 * @public */
declare type FieldProps =
  | ObjectFieldProps
  | ObjectFieldProps<CrossDatasetReferenceValue>
  | ObjectFieldProps<FileValue>
  | ObjectFieldProps<GeopointValue>
  | ObjectFieldProps<ImageValue>
  | ObjectFieldProps<ReferenceValue>
  | ObjectFieldProps<SlugValue>
  | ArrayFieldProps
  | NumberFieldProps
  | BooleanFieldProps
  | StringFieldProps

/**
 * Represents a member of a field set.
 * @public
 */
declare interface FieldSetMember {
  /** The kind of member. */
  kind: 'fieldSet'
  /** The key of the member. */
  key: string
  /**
   * Indicates whether the member is included in the currently selected group.
   * If it's hidden and in the currently selected group, it should still be excluded from its group.
   * @internal
   */
  _inSelectedGroup: boolean
  /** The names of the field groups the member belongs to. */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The state of the field set.
   */
  fieldSet: FieldsetState
}

/**
 * @hidden
 * @beta */
declare interface FieldsetState {
  path: Path
  name: string
  level: number
  title?: string
  description?: string
  hidden?: boolean
  collapsible?: boolean
  collapsed?: boolean
  columns?: number | number[]
  members: (FieldMember | FieldError)[]
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FileLike {
  type: string
  name?: string
}

/**
 * Component for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type FormBuilderCustomMarkersComponent = ComponentType<{
  markers: PortableTextMarker[]
}>

/**
 *
 * @hidden
 * @beta
 */
declare type FormBuilderMarkersComponent = ComponentType<{
  markers: PortableTextMarker[]
  renderCustomMarkers?: RenderCustomMarkers
  validation: FormNodeValidation[]
}>

/**
 * @hidden
 * @beta */
declare interface FormComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  field?: ComponentType<FieldProps>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<InputProps>
  item?: ComponentType<ItemProps>
  preview?: ComponentType<PreviewProps_2>
  portableText?: {
    plugins?: ComponentType<PortableTextPluginsProps>
  }
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormDiffMatchPatch extends FormPatchBase {
  path: Path
  type: 'diffMatchPatch'
  origin?: FormPatchOrigin
  value: string
}

/**
 * @hidden
 * @beta */
declare interface FormFieldGroup {
  name: string
  selected?: boolean
  disabled?: boolean
  title?: string
  i18n?: I18nTextRecord<'title'>
  icon?: ComponentType
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormInsertPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'insert'
  position: FormInsertPatchPosition
  items: FormPatchJSONValue[]
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormInsertPatchPosition = 'before' | 'after'

/**
 * @hidden
 * @public */
declare interface FormNodePresence {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
  selection?: EditorSelection
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatch =
  | FormSetPatch
  | FormSetIfMissingPatch
  | FormUnsetPatch
  | FormInsertPatch
  | FormDiffMatchPatch

/**
 * @hidden
 * @beta */
declare interface FormPatchBase {
  /**
   * A property used to identify this as a Sanity patch type, eg "set", "unset", "insert", etc.
   * This allows us to potentially introduce new patch types in the future without breaking
   * existing code. This is an internal property/implementation detail and should not be used by
   * consumers.
   *
   * @internal
   */
  patchType: symbol
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchJSONValue =
  | number
  | string
  | boolean
  | {
      [key: string]: FormPatchJSONValue
    }
  | FormPatchJSONValue[]

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchOrigin = 'remote' | 'local' | 'internal'

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetIfMissingPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'setIfMissing'
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetPatch extends FormPatchBase {
  path: Path
  type: 'set'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormUnsetPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'unset'
}

/**
 * General preview layout key
 *
 * @public
 */
declare type GeneralPreviewLayoutKey = 'compact' | 'default' | 'media' | 'detail'

/**
 * @hidden
 * @beta
 */
declare interface GroupableActionDescription<GroupType = unknown> extends BaseActionDescription {
  group?: GroupType[]
}

declare type GuardedOperation = Operation<any[], 'NOT_READY'>

/**
 * Configuration options for Presentation tool's optional custom preview header component
 *
 * @public
 */
export declare interface HeaderOptions {
  /**
   * React component to render as the preview header, receives PreviewHeaderProps
   */
  component: ComponentType<PreviewHeaderProps>
}

/** @public */
declare interface HookCollectionActionHook<Args, State> {
  (args: Args): State | null
  displayName?: string | undefined
  action?: string
}

/** @internal */
declare interface IdPair {
  draftId: string
  publishedId: string
  versionId?: string
}

/**
 * A locale resource bundle where the locale is inherited from the parent locale definition.
 *
 * @public
 */
declare type ImplicitLocaleResourceBundle = Omit<LocaleResourceBundle, 'locale'>

/**
 * This error may happen if the member type is structurally incompatible with the defined schema type.
 * Some examples:
 *   - the schema type defines an array, but the actual value is an object (or vice versa)
 *   - the schema type defines a number, but the actual value is a string (or vice versa)
 *   - the schema type defines an object, but the actual value is a string (or vice versa)
 *
 * @public
 */
declare type IncompatibleTypeError = {
  type: 'INCOMPATIBLE_TYPE'
  expectedSchemaType: SchemaType
  resolvedValueType: string
  value: unknown
}

/**
 * @hidden
 * @beta */
declare interface InitialValueErrorMsg {
  type: 'error'
  error: Error
}

/**
 * @hidden
 * @beta */
declare interface InitialValueLoadingMsg {
  type: 'loading'
}

/**
 * @hidden
 * @beta */
declare type InitialValueMsg =
  | InitialValueLoadingMsg
  | InitialValueSuccessMsg
  | InitialValueErrorMsg

/**
 * @hidden
 * @beta */
declare interface InitialValueOptions {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, any>
}

/**
 * @hidden
 * @beta */
declare interface InitialValueSuccessMsg {
  type: 'success'
  value: SanityDocumentLike | null
}

declare type Input = Omit<SetPreviewSearchParamEvent, 'type'>

/**
 * @hidden
 * @public */
declare type InputProps =
  | ArrayOfObjectsInputProps
  | ArrayOfPrimitivesInputProps
  | BooleanInputProps
  | NumberInputProps
  | ObjectInputProps
  | ObjectInputProps<CrossDatasetReferenceValue>
  | ObjectInputProps<FileValue>
  | ObjectInputProps<GeopointValue>
  | ObjectInputProps<ImageValue>
  | ObjectInputProps<ReferenceValue>
  | ObjectInputProps<SlugValue>
  | PortableTextInputProps
  | StringInputProps

/**
 * parameters for the changes inspector
 * @public
 */
export declare interface InspectorTab {
  changesInspectorTab?: 'history' | 'review'
}

/**
 * This error may happen for arrays (of both objects and primitive values) if we encounter items that are not valid according to the schema definition
 *
 *
 * @hidden
 * @beta
 */
declare type InvalidItemTypeError = {
  type: 'INVALID_ITEM_TYPE'
  validTypes: SchemaType[]
  resolvedValueType: string
  value: unknown
}

/** @public */
declare type ItemProps =
  | ObjectItemProps
  | ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>
  | ObjectItemProps<FileValue & ObjectItem>
  | ObjectItemProps<GeopointValue & ObjectItem>
  | ObjectItemProps<ImageValue & ObjectItem>
  | ObjectItemProps<ReferenceValue & ObjectItem>
  | ObjectItemProps<SlugValue & ObjectItem>
  | PrimitiveItemProps

/**
 * @hidden
 * @beta */
declare interface LayoutProps {
  renderDefault: (props: LayoutProps) => React.JSX.Element
}

/**
 * @hidden
 * @beta */
declare interface ListenQueryOptions {
  tag?: string
  apiVersion?: string
  perspective?: ClientPerspective
  throttleTime?: number
  transitions?: ('update' | 'appear' | 'disappear')[]
}

/**
 * A locale representation
 *
 * @public
 */
declare interface Locale_2 {
  /**
   * The ID of the locale, eg `en-US`, `nb-NO`, `th-TH`…
   */
  id: string
  /**
   * The title of locale, eg `English (US)`, `Norsk (bokmål)`, `ไทย`…
   */
  title: string
  /**
   * Week information for this locale. Based on the `Intl.Locale['weekInfo']` type.
   */
  weekInfo: LocaleWeekInfo
}

/**
 * Context passed to locale config resolvers
 *
 * @public
 */
declare interface LocaleConfigContext {
  projectId: string
  dataset: string
}

/**
 * A locale definition, which describes a locale and its resources.
 *
 * @public
 */
declare interface LocaleDefinition extends Locale_2 {
  /**
   * Array of resource bundles for this locale, if any.
   *
   * Generally you'll want to provide some base resources, eg for the studio core namespace,
   * as well as for common namespaces like `structure` and `vision`. You can also provide resources
   * for other plugins/namespaces - but preferably the resources should be provided as an async
   * function that imports the resources, in order to lazy load them on use.
   */
  bundles?: (ImplicitLocaleResourceBundle | LocaleResourceBundle)[]
}

/**
 * An object of locale resources, or a string array of resources
 *
 * @public
 */
declare type LocaleNestedResource = LocaleResourceRecord | string[]

/**
 * Options that defines or adds resources to existing locales
 *
 * @public
 */
declare interface LocalePluginOptions {
  /**
   * Locales available for user selection.
   *
   * Titles and icons can be changed by using a function (reducer pattern) and transforming values.
   */
  locales?: LocalesOption
  /**
   * Bundles contain "resources" (strings) that yields translations for different locales
   * throughout the studio. The strings are scoped to a specific locale and namespace.
   * Namespaces in this context usually means a specific part of the studio, like a tool or plugin.
   */
  bundles?: LocalesBundlesOption
}

/**
 * A collection of locale resources for a given locale and namespace.
 * In other words, an object of translated locale strings.
 *
 * @public
 */
declare interface LocaleResourceBundle {
  /**
   * The locale ID the resources belong to, eg `en-US`, `nb-NO`, `th-TH`…
   */
  locale: string
  /**
   * The namespace the resources belong to, eg `vision`, `structure`, `studio`…
   */
  namespace: string
  /**
   * An object of locale resources, or a function that resolves to one.
   * The localization framework automatically handles ESM modules with a default export,
   * since a common use case is to dynamically load a resource file on use. This is the
   * preferred option, since it allows for lazy loading of locale resources on use.
   */
  resources:
    | LocaleResourceRecord
    | (() => Promise<
        | LocaleResourceRecord
        | {
            default: LocaleResourceRecord
          }
      >)
  /**
   * Whether the resources should be merged deeply (eg for nested objects). Default: true
   */
  deep?: boolean
  /**
   * Whether any existing resource keys for the namespace be overwritten. Default: true
   */
  overwrite?: boolean
}

/**
 * A locale resource key, which can be a leaf string, or a nested resource
 *
 * @public
 */
declare type LocaleResourceKey = string | LocaleNestedResource

/**
 * An object of locale resources.
 *
 * @public
 */
declare interface LocaleResourceRecord {
  [key: string]: LocaleResourceKey
}

/**
 * Either an array of locale resource bundles, or a resolver that returns one.
 *
 * @public
 */
declare type LocalesBundlesOption =
  | ((prev: LocaleResourceBundle[], context: LocaleConfigContext) => LocaleResourceBundle[])
  | LocaleResourceBundle[]

/**
 * Either an array of locale definitions, or a resolver that returns one.
 *
 * @public
 */
declare type LocalesOption =
  | ((prev: LocaleDefinition[], context: LocaleConfigContext) => LocaleDefinition[])
  | LocaleDefinition[]

/**
 * Internal representation of the available locale configuration.
 *
 * Generally not something you will want to use directly.
 *
 * @public
 */
declare interface LocaleSource {
  /**
   * Current locale ID (eg `en-US`, `nb-NO`, `th-TH`…)
   */
  currentLocale: Locale_2
  /**
   * Array of locale definitions
   */
  locales: Locale_2[]
  /**
   * Loads the given namespaces, if not already done.
   *
   * @param namespaces - Array of namespace names to load
   * @returns Promise which resolves once loaded.
   */
  loadNamespaces(namespaces: string[]): Promise<void>
  /**
   * Translation function, eg `t('some.key') => 'Some string'`
   */
  t: TFunction
}

/**
 * An object representing week information associated with the Locale data specified in
 * {@link https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Patterns_Week_Elements | UTS 35's Week Elements }
 *
 * @public
 */
declare interface LocaleWeekInfo {
  /**
   * An integer indicating the first day of the week for the locale.
   * Can be either 1 (Monday), 6 (Saturday) or 7 (Sunday).
   */
  firstDay: 1 | 6 | 7
  /**
   * An array of integers indicating the weekend days for the locale, where 1 is Monday and 7 is Sunday.
   */
  weekend: (1 | 2 | 3 | 4 | 5 | 6 | 7)[]
  /**
   * An integer between 1 and 7 indicating the minimal days required in the first week of a month or year, for calendar purposes.
   */
  minimalDays: 1 | 2 | 3 | 4 | 5 | 6 | 7
}

/**
 * @beta
 * @hidden
 */
declare type LoginComponentProps =
  | {
      projectId: string
      /** @deprecated use redirectPath instead */
      basePath: string
      redirectPath?: string
    }
  | {
      projectId: string
      redirectPath: string
      /** @deprecated use redirectPath instead */
      basePath?: string
    }

/**
 * Login methods that may be used for Studio authentication.
 *
 * @public
 */
declare type LoginMethod = 'dual' | 'cookie' | 'token'

/**
 * @hidden
 * @beta */
declare interface LogoProps {
  title: string
  renderDefault: (props: LogoProps) => React.JSX.Element
}

/** @public */
declare type MapDocument = (document: SanityDocumentLike) => SanityDocumentLike

/**
 * Config for the Sanity Media Library asset source integration.
 * @beta
 */
declare interface MediaLibraryConfig {
  /**
   * Whether the Media Library is enabled.
   */
  enabled?: boolean
  /**
   * The ID of the Media Library that is connected to the Studio.
   * If not provided, the Media Library will be automatically detected.
   */
  libraryId?: string
}

/**
 * This error may happen for arrays of objects where one or more of the members are missing a _key
 *
 * @public
 */
declare type MissingKeysError = {
  type: 'MISSING_KEYS'
  schemaType: ArraySchemaType
  value: {
    _key?: string
  }[]
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type MixedArrayError = {
  type: 'MIXED_ARRAY'
  schemaType: ArraySchemaType
  value: unknown[]
}

/**
 * @hidden
 * @beta */
declare interface MutationPayload {
  create?: any
  createIfNotExists?: any
  createOrReplace?: any
  delete?: any
  patch?: any
}

/**
 * @internal
 * @beta
 * An internal API for defining actions in the navbar.
 */
declare type NavbarAction = Action | ActionWithCustomRender

declare interface NavbarActionBase {
  icon?: React.ComponentType
  location: 'topbar' | 'sidebar'
  name: string
}

/**
 * @hidden
 * @beta */
declare interface NavbarProps {
  renderDefault: (props: NavbarProps) => React.JSX.Element
  /**
   * @internal
   * @beta */
  __internal_actions?: NavbarAction[]
}

/**
 * Configuration options for Presentation tool's optional navigator component
 * The navigator appears as a resizable sidebar panel
 *
 * @public
 */
export declare interface NavigatorOptions {
  /**
   * Minimum width of the navigator panel in pixels
   */
  minWidth?: number
  /**
   * Maximum width of the navigator panel in pixels
   */
  maxWidth?: number
  /**
   * React component to render in the navigator panel
   */
  component: ComponentType
}

/**
 * @hidden
 * @beta
 */
declare type NewDocumentCreationContext =
  | {
      type: 'global'
      documentId?: undefined
      schemaType?: undefined
    }
  | {
      type: 'document'
      documentId: string
      schemaType: string
    }
  | {
      type: 'structure'
      documentId?: undefined
      schemaType: string
    }

/**
 * @hidden
 * @beta
 */
declare interface NewDocumentOptionsContext extends ConfigContext {
  creationContext: NewDocumentCreationContext
}

/**
 * @hidden
 * @beta
 */
declare type NewDocumentOptionsResolver = ComposableOption<
  TemplateItem[],
  NewDocumentOptionsContext
>

/**
 * Props that encapsulate changes in the node's value.
 *
 * @public
 */
declare interface NodeDiffProps<Annotation> {
  /**
   * A function that takes any value and produces a diff between that value and the value the node
   * is being compared to.
   *
   * This can be used to compute a diff optimistically.
   *
   * This is marked as unstable because the API may need to evolve as we iterate on the advanced
   * version control functionality. It will be stabilised when that project has matured.
   */
  __unstable_computeDiff: ComputeDiff<Annotation>
  /**
   * Whether the current value is different to the value the node is being compared to.
   */
  changed: boolean
}

/**
 * @hidden
 * @public */
declare interface NumberFieldProps extends BaseFieldProps {
  schemaType: NumberSchemaType
  value: number | undefined
  inputProps: NumberInputProps
}

/** @public */
declare type NumberFormNode<S extends NumberSchemaType = NumberSchemaType> = BaseFormNode<number, S>

/**
 * @hidden
 * @public */
declare interface NumberInputProps<S extends NumberSchemaType = NumberSchemaType>
  extends BaseInputProps,
    NumberFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/** @public */
declare interface ObjectArrayFormNode<
  T extends ObjectItem = ObjectItem,
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  value: T
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
  changesOpen?: boolean
}

/**
 * @hidden
 * @public */
declare interface ObjectFieldProps<T = Record<string, unknown>> extends BaseFieldProps {
  schemaType: ObjectSchemaType
  value: T | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  inputProps: ObjectInputProps<T>
}

/** @public */
declare interface ObjectFormNode<
  T = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
}

/**
 * @hidden
 * @public */
declare interface ObjectInputProps<
  T = Record<string, any>,
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseInputProps,
    Omit<ObjectFormNode<T, S>, '_allMembers'> {
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onFieldCollapse: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldExpand: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetCollapse: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetExpand: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldGroupSelect: (groupName: string) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onFieldOpen: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldClose: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
  /**
   * @deprecated – DO NOT USE
   *
   * The node for the array editing modal.
   * This node renders the array editing modal as a child of the root input.
   * It is necessary for the array editing dialog to be a child of the root input
   * because the root input may be wrapped in a React context using the Components API,
   * which is utilized by inputs in the form.
   */
  __internal_arrayEditingModal?: ReactNode
}

/** @public */
declare type ObjectItem = {
  _type?: string
  _key: string
}

/**
 * Props for the ObjectItem component.
 * @public
 */
declare interface ObjectItemProps<Item extends ObjectItem = ObjectItem>
  extends BaseItemProps<Item> {
  /** Whether the item has changes in a draft. */
  changed: boolean
  /** The schema type of the object. */
  schemaType: ObjectSchemaType
  /** The schema type of the parent array. */
  parentSchemaType: ArraySchemaType
  /** Whether the item is collapsed. */
  collapsed: boolean | undefined
  /** Whether the item is collapsible. */
  collapsible: boolean | undefined
  /** Callback for when the item is collapsed. */
  onCollapse: () => void
  /** Callback for when the item is expanded. */
  onExpand: () => void
  /** Whether the item is open. */
  open: boolean
  /** Callback for when the item is closed. */
  onClose: () => void
  /** Callback for when the item is opened. */
  onOpen: () => void
  /** The value of the item. */
  value: Item
  /**
   * @hidden
   * @beta */
  inputProps: Omit<ObjectInputProps, 'renderDefault'>
}

/** @public */
declare type ObjectMember = FieldMember | FieldSetMember | FieldError

/**
 * @hidden
 * @beta */
declare interface OnPathFocusPayload {
  selection?: EditorSelection
}

/** @internal */
declare interface Operation<ExtraArgs extends any[] = [], ErrorStrings extends string = string> {
  disabled: false | ErrorStrings | 'NOT_READY'
  execute(...extra: ExtraArgs): void
}

/**
 * @hidden
 * @beta */
declare interface OperationError {
  type: 'error'
  /** @internal */
  op: keyof OperationsAPI
  id: string
  error: Error
}

/** @internal */
declare interface OperationsAPI {
  commit: Operation | GuardedOperation
  delete: Operation<[], 'NOTHING_TO_DELETE' | 'NOT_READY'>
  del: Operation<[], 'NOTHING_TO_DELETE'> | GuardedOperation
  publish:
    | Operation<[], 'LIVE_EDIT_ENABLED' | 'ALREADY_PUBLISHED' | 'NO_CHANGES'>
    | GuardedOperation
  patch: Operation<[patches: Patch[], initialDocument?: Record<string, any>]> | GuardedOperation
  discardChanges: Operation<[], 'NO_CHANGES' | 'NOT_PUBLISHED'> | GuardedOperation
  unpublish: Operation<[], 'LIVE_EDIT_ENABLED' | 'NOT_PUBLISHED'> | GuardedOperation
  duplicate:
    | Operation<
        [
          documentId: string,
          options?: {
            mapDocument?: MapDocument
          },
        ],
        'NOTHING_TO_DUPLICATE'
      >
    | GuardedOperation
  restore: Operation<[revision: DocumentRevision]> | GuardedOperation
}

/**
 * @hidden
 * @beta */
declare interface OperationSuccess {
  type: 'success'
  /** @internal */
  op: keyof OperationsAPI
  id: string
}

/**
 * @hidden
 * @beta */
declare type Pair = {
  /** @internal */
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  published: DocumentVersion
  draft: DocumentVersion
  version?: DocumentVersion
}

declare type Patch = any

/**
 *
 * @hidden
 * @beta
 */
declare type PatchArg = FormPatch | FormPatch[]

/**
 *
 * @hidden
 * @beta
 */
declare class PatchEvent {
  static from(input: PatchArg | PatchEvent): PatchEvent
  patches: Array<FormPatch>
  constructor(patches: Array<FormPatch>)
  prepend(...patches: PatchArg[]): PatchEvent
  append(...patches: PatchArg[]): PatchEvent
  prefixAll(segment: PathSegment): PatchEvent
}

/** @internal */
declare interface PendingMutationsEvent {
  type: 'pending'
  phase: 'begin' | 'end'
}

/**
 * @hidden
 * @beta */
declare interface PermissionCheckResult {
  granted: boolean
  reason: string
}

/**
 * @hidden
 * @beta
 */
declare type Plugin_2<TOptions = void> = (options: TOptions) => PluginOptions

/** @beta */
declare interface PluginOptions {
  name: string
  plugins?: PluginOptions[]
  schema?: SchemaPluginOptions
  document?: DocumentPluginOptions
  tools?: Tool[] | ComposableOption<Tool[], ConfigContext>
  form?: SanityFormConfig
  __internal_tasks?: {
    footerAction: ReactNode
  }
  studio?: {
    /**
     * Components for the studio.
     * @hidden
     * @beta
     */
    components?: StudioComponentsPluginOptions
  }
  /** @beta @hidden */
  i18n?: LocalePluginOptions
  search?: {
    unstable_partialIndexing?: {
      enabled: boolean
    }
    /**
     * Control the strategy used for searching documents. This should generally only be used if you
     * wish to try experimental search strategies.
     *
     * This option takes precedence over the deprecated `search.enableLegacySearch` option.
     *
     * Can be one of:
     *
     * - `"groqLegacy"` (default): Use client-side tokenization and schema introspection to search
     *   using the GROQ Query API.
     * - `"groq2024"`: (experimental) Perform full text searching using the GROQ Query API and its
     *   new `text::matchQuery` function.
     */
    strategy?: SearchStrategy
    /**
     * Enables the legacy Query API search strategy.
     *
     * @deprecated Use `search.strategy` instead.
     */
    enableLegacySearch?: boolean
  }
  /** @internal */
  __internal_serverDocumentActions?: WorkspaceOptions['__internal_serverDocumentActions']
  /** @internal */
  [QUOTA_EXCLUDED_RELEASES_ENABLED]?: WorkspaceOptions[typeof QUOTA_EXCLUDED_RELEASES_ENABLED]
  /** @beta */
  [DECISION_PARAMETERS_SCHEMA]?: DecisionParametersConfig
  /** Configuration for Content Releases */
  releases?: DefaultPluginsWorkspaceOptions['releases']
  /** Configuration for studio beta features.
   * @internal
   */
  beta?: BetaFeatures
  /** Configuration for error handling.
   * @beta
   */
  onUncaughtError?: (error: Error, errorInfo: ErrorInfo) => void
  /**
   * @hidden
   * @internal
   */
  announcements?: {
    enabled: boolean
  }
  /**
   * Config for the Sanity Media Library asset source integration.
   * @beta
   */
  mediaLibrary?: DefaultPluginsWorkspaceOptions['mediaLibrary']
  /**
   * Advanced version control provides features such as inline content diffs in Studio to make
   * resolving conflicts across document versions easier.
   *
   * @beta
   */
  advancedVersionControl?: {
    /**
     * Control whether advanced version control functionality is enabled.
     *
     * Advanced version control provides features such as inline content diffs in Studio to make
     * resolving conflicts across document versions easier.
     *
     * @beta
     */
    enabled?: boolean | ComposableOption<boolean, ConfigContext>
  }
}

/**
 * Component props for the {@link PortableTextInput} React component.
 *
 * Extends {@link ArrayOfObjectsInputProps}.
 *
 * @public
 * */
declare interface PortableTextInputProps
  extends ArrayOfObjectsInputProps<PortableTextBlock, ArraySchemaType<PortableTextBlock>> {
  /**
   * A React Ref that can reference the underlying editor instance
   */
  editorRef?: React.MutableRefObject<PortableTextEditor | null>
  /**
   * Option to hide the default toolbar
   */
  hideToolbar?: boolean
  /**
   * Assign hotkeys that can be attached to custom editing functions
   */
  hotkeys?: HotkeyOptions
  /**
   * Whether the input is activated and should receive events on mount.
   * By default, this value is set to `true`
   */
  initialActive?: boolean
  /**
   * Whether the input is _initially_ open in fullscreen mode
   */
  initialFullscreen?: boolean
  /**
   * Array of {@link PortableTextMarker} with meta data connected to the content.
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  markers?: PortableTextMarker[]
  /**
   * Returns changes from the underlying editor
   */
  onEditorChange?: (change: EditorChange, editor: PortableTextEditor) => void
  /**
   * Optional callback for when the editor goes into or out of full screen mode
   * @hidden
   * @beta
   */
  onFullScreenChange?: (isFullScreen: boolean) => void
  /**
   * Custom copy function
   */
  onCopy?: OnCopyFn
  /**
   * Custom paste function
   */
  onPaste?: OnPasteFn
  /**
   * Function to render custom block actions
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderBlockActions?: RenderBlockActionsCallback
  /**
   * Function to render custom markers
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderCustomMarkers?: RenderCustomMarkers
  /**
   * Array of {@link RangeDecoration} that can be used to decorate the content.
   */
  rangeDecorations?: RangeDecoration[]
}

/**
 * A generic marker for attaching metadata to specific nodes of the Portable Text input.
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 * @param type - a type name for this marker
 * @param data - some data connected to this marker
 * @param path - the path to the Portable Text content connected to this marker
 */
declare interface PortableTextMarker {
  type: string
  data?: unknown
  path: Path
}

/**
 * Props for rendering Portable Text plugins
 *
 * @beta
 */
declare interface PortableTextPluginsProps {
  renderDefault: (props: PortableTextPluginsProps) => React.JSX.Element
  plugins: {
    markdown: {
      config: MarkdownPluginConfig
    }
  }
}

/**
 * Portable text preview layout key
 *
 * @public
 */
declare type PortableTextPreviewLayoutKey = 'block' | 'blockImage' | 'inline'

declare const presentationMachine: StateMachine<
  Context,
  | {
      type: 'toggle visual editing overlays'
      enabled: boolean
    }
  | {
      type: 'iframe loaded'
    }
  | {
      type: 'iframe refresh'
    }
  | {
      type: 'iframe reload'
    },
  {},
  never,
  never,
  never,
  never,
  | 'error'
  | 'loading'
  | {
      loaded: 'idle' | 'refreshing' | 'reloading'
    },
  'error' | 'busy',
  NonReducibleUnknown,
  NonReducibleUnknown,
  EventObject,
  MetaObject,
  {
    /** @xstate-layout N4IgpgJg5mDOIC5QAUBOcwDsAuBDbAlgPaYAEAKkUQDYDEBAZqrgLZinrVG4QDaADAF1EoAA5FYBQiREgAHogAsAJgA0IAJ6IAHAEYAdIoCcJowFY9R-vzPLlAX3vq0GHPmJlKNfVx4FMUPRMrOy+EJACwkgg4pLSmLIKCLoAbIr6Zoop2tqKAMxpJnnF6loIZkbK+uZ5umapKXmK-Cm6js7osFh48RRU1D7c4RC02ERQUNTsAG4EsACuuNSkkFL+UKRE02Co1LgasJGysWsy0UnaZinVyrpGAOx1Rim2efeliPe3hma1Zvy6XT8W4OJwgFxdNy9LwDMKQILMNgcMBMOAACyO0RO8USiAK930LWU-3uiiB9yaKXemkQjW01V+txS-GKqUe7XBnW67hIfW8cJGjER7E4Q0xYgkpwS5zxVMJKWJ-FJ5Mp1LKFn4Pz+DSaLTaYIh3Oh-UGPEg+nQqNgaPWCJCpAF4pikpxMoQKWZ+gp+TSZLy1hSH3deXpNSZLNqVP1HVcPQ8fNhQ3Nor8ATtSMdQmOLo8uPdnu9BUUfoDQY1WrqOuarUcYMwRHC8Gihqh8Zh2biubdAFpAzSEL2OS247yYfodqgiKgO1K8yog7ptATFL9dFljMDrHkh1zW6OTWF1jPXaAkmY1YgKnktfxtC9dPd+Io9DvYzzPAekxBj13T3i7vKirKkqqpBsYVQ1HUFjFs0t6KK+kIjh+-JfvoBAQFMP5nH+CDaMo16KjYyjMvUNh5GWOT6MoLL8A8ygrk0dQIUabafmaEAWiinQ2gEWHSjhjJUYuj73Pcd63noQaNEYFb-Dk2S0cxe7IYm7GcYevFYjm2HyJeeQQb8tFkikVjGNoFGajUt73o+z61vYQA */
    readonly id: 'Presentation Tool'
    readonly context: {
      readonly url: null
      readonly error: null
      readonly visualEditingOverlaysEnabled: false
    }
    readonly on: {
      readonly 'iframe reload': {
        readonly actions: ActionFunction<
          Context,
          {
            type: 'iframe reload'
          },
          | {
              type: 'toggle visual editing overlays'
              enabled: boolean
            }
          | {
              type: 'iframe loaded'
            }
          | {
              type: 'iframe refresh'
            }
          | {
              type: 'iframe reload'
            },
          undefined,
          never,
          never,
          never,
          never,
          never
        >
        readonly target: '.loading'
      }
    }
    readonly states: {
      readonly error: {
        readonly description: 'Failed to load, either because of a misconfiguration, a network error, or an unexpected error'
        readonly tags: readonly ['error']
      }
      readonly loading: {
        readonly on: {
          readonly 'iframe loaded': {
            readonly target: 'loaded'
          }
        }
        readonly tags: readonly ['busy']
      }
      readonly loaded: {
        readonly on: {
          readonly 'toggle visual editing overlays': {
            readonly actions: ActionFunction<
              Context,
              {
                type: 'toggle visual editing overlays'
                enabled: boolean
              },
              | {
                  type: 'toggle visual editing overlays'
                  enabled: boolean
                }
              | {
                  type: 'iframe loaded'
                }
              | {
                  type: 'iframe refresh'
                }
              | {
                  type: 'iframe reload'
                },
              undefined,
              never,
              never,
              never,
              never,
              never
            >
          }
          readonly 'iframe refresh': {
            readonly target: '.refreshing'
          }
          readonly 'iframe reload': {
            readonly target: '.reloading'
          }
        }
        readonly states: {
          readonly idle: {}
          readonly refreshing: {
            readonly on: {
              readonly 'iframe loaded': {
                readonly target: 'idle'
              }
            }
            readonly tags: readonly ['busy']
          }
          readonly reloading: {
            readonly on: {
              readonly 'iframe loaded': {
                readonly target: 'idle'
              }
            }
            readonly tags: readonly ['busy']
          }
        }
        readonly initial: 'idle'
      }
    }
    readonly initial: 'loading'
  }
>

declare type PresentationMachineRef = ActorRefFrom<typeof presentationMachine>

/** @public */
export declare type PresentationNavigateContextValue = (
  preview: string | undefined,
  document?: {
    type: string
    id: string
  },
) => void

/**
 * All possible parameters that can be used to describe the state of the
 * Presentation tool, stored in the pathname and as search parameters of the URL
 * @public
 */
export declare interface PresentationParams extends PresentationStateParams, CombinedSearchParams {}

/** @public */
export declare type PresentationPerspective = Exclude<ClientPerspective, 'raw'>

/**
 * Configuration options for the Presentation tool.
 * @public
 */
export declare interface PresentationPluginOptions {
  devMode?: boolean | (() => boolean)
  icon?: ComponentType
  name?: string
  title?: string
  allowOrigins?: PreviewUrlAllowOption
  previewUrl: PreviewUrlOption
  /**
   * @deprecated use `resolve.locations` instead
   */
  locate?: DocumentLocationResolver
  resolve?: {
    mainDocuments?: DocumentResolver[]
    locations?: DocumentLocationResolvers | DocumentLocationResolver
  }
  components?: {
    unstable_header?: HeaderOptions
    unstable_navigator?: NavigatorOptions
  }
  /**
   * @deprecated this feature flag is no longer needed
   */
  unstable_showUnsafeShareUrl?: boolean
}

/**
 * Presentation specific URL search parameters, they should persist when
 * navigating between the document pane and document list pane
 * @public
 */
export declare interface PresentationSearchParams {
  preview?: string
  perspective?: string
  viewport?: string
}

/**
 * Presentation specific state that is stored in the pathname section of the URL
 * @public
 */
export declare interface PresentationStateParams {
  type?: string
  id?: string
  path?: string
}

/** @public */
export declare const presentationTool: Plugin_2<PresentationPluginOptions>

/** @public */
export declare type PresentationViewport = 'desktop' | 'mobile'

/** @public */
export declare interface PreviewHeaderProps extends PreviewProps {
  iframeRef: RefObject<HTMLIFrameElement | null>
  renderDefault: (props: PreviewHeaderProps) => React.JSX.Element
}

/**
 * Preview layout key. See also {@link GeneralPreviewLayoutKey} and {@link PortableTextPreviewLayoutKey}
 *
 * @public
 */
declare type PreviewLayoutKey = GeneralPreviewLayoutKey | PortableTextPreviewLayoutKey

/**
 * @hidden
 * @public
 */
declare interface PreviewMediaDimensions {
  aspect?: number
  dpr?: number
  fit?: ImageUrlFitMode
  height?: number
  width?: number
}

/** @public */
export declare interface PreviewProps {
  canSharePreviewAccess: boolean
  canToggleSharePreviewAccess: boolean
  canUseSharedPreviewAccess: boolean
  header?: HeaderOptions
  initialUrl: URL
  loadersConnection: ConnectionStatus
  navigatorEnabled: boolean
  onPathChange: (nextPath: string) => void
  onRefresh: (fallback: () => void) => void
  openPopup: (url: string) => void
  overlaysConnection: ConnectionStatus
  presentationRef: PresentationMachineRef
  perspective: PresentationPerspective
  previewUrl?: string
  setViewport: (mode: 'desktop' | 'mobile') => void
  targetOrigin: string
  toggleNavigator?: () => void
  toggleOverlay: () => void
  viewport: PresentationViewport
  vercelProtectionBypass: string | null
  previewUrlRef: PreviewUrlRef
}

/**
 * @hidden
 * @beta
 */
declare interface PreviewProps_2<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  description?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  error?: Error | null
  fallbackTitle?: ReactNode
  imageUrl?: string
  isPlaceholder?: boolean
  layout?: TLayoutKey
  media?:
    | ReactNode
    | ComponentType<{
        dimensions: PreviewMediaDimensions
        layout: TLayoutKey
      }>
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  subtitle?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  title?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType?: SchemaType
  renderDefault: (props: PreviewProps_2) => React.JSX.Element
}

/** @public */
declare type PreviewUrlAllowOption =
  | string
  | string[]
  | ((context: PreviewUrlAllowOptionContext) => string | string[] | Promise<string | string[]>)

/** @public */
declare interface PreviewUrlAllowOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
  /**
   * The initial URL of the preview
   */
  initialUrl: URL
}

/** @public */
declare type PreviewUrlInitialOption =
  | string
  | ((context: PreviewUrlInitialOptionContext) => string | Promise<string>)

/** @public */
declare interface PreviewUrlInitialOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
}

declare const previewUrlMachine: StateMachine<
  Context_2,
  SetPreviewSearchParamEvent,
  {
    [x: string]:
      | ActorRefFromLogic<
          PromiseActorLogic<
            URL,
            {
              initialUrl: URL
              previewSearchParam: string | null | undefined
              allowOrigins: URLPattern[]
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          ObservableActorLogic<PermissionCheckResult, CheckPermissionInput, EventObject>
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            URL,
            {
              previewSearchParam: string | null
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            URLPattern[],
            {
              initialUrl: URL
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            false | PreviewUrlPreviewMode,
            {
              targetOrigin: string
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            {
              secret: string
              expiresAt: Date
            },
            NonReducibleUnknown,
            EventObject
          >
        >
      | ActorRefFromLogic<PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>>
      | ActorRefFromLogic<PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>>
      | undefined
  },
  Values<{
    'resolve url from preview search param': {
      src: 'resolve url from preview search param'
      logic: PromiseActorLogic<
        URL,
        {
          initialUrl: URL
          previewSearchParam: string | null | undefined
          allowOrigins: URLPattern[]
        },
        EventObject
      >
      id: string | undefined
    }
    'check permission': {
      src: 'check permission'
      logic: ObservableActorLogic<PermissionCheckResult, CheckPermissionInput, EventObject>
      id: string | undefined
    }
    'resolve initial url': {
      src: 'resolve initial url'
      logic: PromiseActorLogic<
        URL,
        {
          previewSearchParam: string | null
        },
        EventObject
      >
      id: string | undefined
    }
    'resolve allow patterns': {
      src: 'resolve allow patterns'
      logic: PromiseActorLogic<
        URLPattern[],
        {
          initialUrl: URL
        },
        EventObject
      >
      id: string | undefined
    }
    'resolve preview mode': {
      src: 'resolve preview mode'
      logic: PromiseActorLogic<
        false | PreviewUrlPreviewMode,
        {
          targetOrigin: string
        },
        EventObject
      >
      id: string | undefined
    }
    'create preview secret': {
      src: 'create preview secret'
      logic: PromiseActorLogic<
        {
          secret: string
          expiresAt: Date
        },
        NonReducibleUnknown,
        EventObject
      >
      id: string | undefined
    }
    'read shared preview secret': {
      src: 'read shared preview secret'
      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
      id: string | undefined
    }
    'resolve preview mode url': {
      src: 'resolve preview mode url'
      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
      id: string | undefined
    }
  }>,
  Values<{
    'notify preview will likely fail': {
      type: 'notify preview will likely fail'
      params: NonReducibleUnknown
    }
    'assign preview search param': {
      type: 'assign preview search param'
      params: {
        previewSearchParam: string | null
      }
    }
    'assign error': {
      type: 'assign error'
      params: {
        message: string
        error: unknown
      }
    }
  }>,
  Values<{
    'has checked permissions': {
      type: 'has checked permissions'
      params: unknown
    }
    'search param has new origin': {
      type: 'search param has new origin'
      params: unknown
    }
    'can create preview secret': {
      type: 'can create preview secret'
      params: unknown
    }
    'has preview mode with created secret': {
      type: 'has preview mode with created secret'
      params: false | PreviewUrlPreviewMode
    }
    'has preview mode with share access': {
      type: 'has preview mode with share access'
      params: false | PreviewUrlPreviewMode
    }
    'has preview mode without permissions': {
      type: 'has preview mode without permissions'
      params: false | PreviewUrlPreviewMode
    }
  }>,
  'expiredSecret',
  | 'error'
  | 'success'
  | 'checkingPermissions'
  | 'resolvingInitialUrl'
  | 'resolvingAllowPatterns'
  | 'resolvingUrlFromPreviewSearchParam'
  | 'resolvingPreviewMode'
  | {
      previewMode:
        | 'error'
        | 'success'
        | 'createPreviewSecret'
        | 'resolvePreviewUrl'
        | 'readShareAccess'
    },
  'error' | 'busy',
  Input,
  NonReducibleUnknown,
  EventObject,
  MetaObject,
  {
    /** @xstate-layout N4IgpgJg5mDOIC5QAUBOYBuBLMB3ABAKoBKAMgMRiqoD2qAdAA4A2AhgC4BmdAtvWphwESpBFgB2GGgGMOWGuIDaABgC6K1YlCMasLO3nitIAB6IArAA56AZgCcAdkcBGS8vMAmO+YBszgDQgAJ6Izs4+9M7KACzKztGWHg4OPubmAL7pgQLYeERklNR0TGxcvPzoucJkYpIycgqKzupqxjp6BgrGZggAtM520ZHRdjZjNjFe7oEhCGERUbHxicmpGVkgOUL5FFS0DCwc3Kh8W3kitVKynUoeLZpIIO36ht2IvV62Hl7elmE2lh83xmoXCkRicQSSRS5gSmWylW2IkK+xKR3KZ2qogkVwaShs9zauheXUePV6gPo3jSUyi-xBczBi0hKxh5mc8M2iPOBVgYHY+EY3IIfNYqGkAAtBWLWDwNESOq8yaCbM56A4bB5fGllHYvD4fAz4h56CNfG5LKqHMpLdFOZidvRJWBpABrCRQZBUHhYWB6BSwcjyx7PG5vPrs5TqjWqyyjTXRDwMjwxei68J2ZQ2nyWXN2jYOkT0dCwGjMbDiKAASXEL1YzEIqGY5AgCjA9BxNFd7cLZGLcDLFertYM9cbzEu9RuGmD2mJYeVfRGdipyh86Yc0XiE3MDK3JssIwcrmtPjGSXzCMEPNI-dL5Y9NbrDabKOKhzKJwq16xd8Hj5HLAxybSdrkMGdWhDeclVAclN3odlzBsKwBjSSxjwcZM7DVeJ1w8P4xmidk7HtYVHRLf9KwAQWYZgaFwZAOHYKhxEDVtxHbTtu2-KpyIHB9qNo+jGPYZjUFY0C8Qgh450VUlYPedkHHoHwnDSZDVOiGwfGiBlUhXXwwjsQYtKSYzSJ-Pj7yHGi6IYpiWMDPZ31KY5TjIosKIEqBbOEhzxNgSTpzUWcnmg+TTHePV6Hw3MYgzaItJ0hlYRNTNkLiHxBl1GILN4zz+KHccADFaB4TEAGUwDFSVGNQWUWzbDs6m43tby8oqm1KmhyuFKqaolOrZSC8CQsg2SSSMRdel8ZSNUTdlcw8M07AZQZrDXdaDRtUZnHWK98r7DqPRKsrKuq8VBplHg3wOVyMQ8o7CpOrqzr6i7auukbGjGmSwrkqaFL6MJlLiWFlC1EGty0hknAiXVVPMRx12UJwOQLR72ueytMQAWRoCAwEajjmqkVrMb-by8YJsBvqUX6FUm8Nem2+hbWPUZErGTcjS8NUJg8AE9T1ZwHHwvKkSe6yPWpwnic4lqewp46ceFfHCbpmdmkZhcgZmyxzFsDmTPcXUUiNRKDy3ZQJlVLSkYlm9KaHWWifYhWyaVyyCul1Wf3V2nOzAn71DuHWYMivovGsBxPCy74beWaJDWCUJzBSFTrUcQYdMzIFHd-FXPTVmn5dJrsvcOrHfeL-2ac1kKCXDiLyWcNKJiiHM-BtONwgtnMEM1DVNwhhI7B8AurMo2uqgD260U-dzval6fXYbwkoIB5moijLLkm5tvYRBo1nGQtND11ZaIdzEiMeX6vV5LuW+QFIVLNFS7pXquVxv+pnF1FtYP4OY7AG3QohJMqcEDeGUq4NwYQBhLEnkWWAABXaQ0g4CBhfoKMiH9JRf1lKFUMEceiizVPA0+7gtQQy8LzXU6obaJTFtEJwHhXDIL7G-WepccHcO2PgqUjBrrEPCoDSOFI3C2AGHtQ8sIiJJGTILZS7JRaeGSKw7CnDbz8LwAHJ06AOBgHOtIdA7Ay5cUrpLHRT92ymOqsxExZj16iK3gAqI6oaQ6QtE4YylhkynzmkCBGNgNR7VvgdaxTBbEGIccY969jzHOTuuiL8bVol10JrEoxTj+QuN-iQlu7xwjKX1P8bSTC0hGhcKaBIOZAQGkBKE7RGSeFZMMRACqEoxRgCohgrBFjFY8Sibo3A+iOldJ6X0zBfp8l-UKeIshjgqTGTiPYPaGotS7igd8QWtgsp6iQnFOEd8q6tKEOM6qnTunoGmQM5JC83LDKdqMy5rBrlTP6bMoOUkGab3-kDU+ERVEpnsEjDRVSdljBXKeQY3h5gOBaa8mmzt4k-nHIMz2zzfzIvaYVNFVRxxzObosxAfg1Q2jSOERIh5kIBNGKaNZ2lvjhFhEimJHUCVCAxQ8j8Tz0m4vbJyzERKfnBQ3hNXWkdyWeJsCMVhqNsK6mTO4Q2Q9DysLCEhDw7LMntjQV8wMJhYDsCMfQVgnAxIAAowAmEYFgdAnSXRmIAJTkAFTEg1MzYCuIBZHKYKlUiqWwrCMJkDZgDAYceRMfwUisPYZYTIGxxA03gI8NqJLmZ6msKqENcjErqIZL0cethvDGXLew9hiYWnOjdDLb0vp-SsUzdNcwEMEJ7WTohDMfgU4RpTCpUJnhYrHghuEFpRcnyjhfMwFtet2Q2FNOwsWZarBan8TsuMkRvhIzPJGDwmkWnJLnf6g0aZl0mQTURDdsxYiGwwsRIEgwEwTuxj5IS9lRKORPeSJCOF4XgrUZqbZsxwZszcJtbC4RUg2FfTXU6PVzoDSGjwH9ik-gxRGG4NtxkkZblhgyxIhFQG5lSPEODj89VoYjKqGKURkij0zImXSUCwiozZuDLUCQQY6tOVEr1WDqMsxNCkP4RFPBZj+I4I0qoRMODjIlceBzkK6raWAIT7DDZlNPhUuVkKI0pEXbHBISF1yAiIqpi5KL7E5ISWYoTna2b6Qg+DcFN7EAphLdpdOWVoPJ0RXxl5HKrmTNuYahzaQviaQPVERa8mlGeBUnnQyDStSwcCzi4L1kuV4HHNR4DCFdRaVVFSzcZ4VVIVsDEVhZ5QnWlYZZvRKLj3-KlT0FIKjVRZghkCXwqkjQGzVFxvOMisoWYy46QV9ABN+mo3mFZZ427lp032jzVa2bJGtCUtciak1AA */
    readonly id: 'Preview URL'
    readonly context: ({
      input,
    }: {
      spawn: {
        <
          TSrc extends
            | 'resolve url from preview search param'
            | 'check permission'
            | 'resolve initial url'
            | 'resolve allow patterns'
            | 'resolve preview mode'
            | 'create preview secret'
            | 'read shared preview secret'
            | 'resolve preview mode url',
        >(
          logic: TSrc,
          ...[options]:
            | ({
                src: 'resolve url from preview search param'
                logic: PromiseActorLogic<
                  URL,
                  {
                    initialUrl: URL
                    previewSearchParam: string | null | undefined
                    allowOrigins: URLPattern[]
                  },
                  EventObject
                >
                id: string | undefined
              } extends infer T
                ? T extends {
                    src: 'resolve url from preview search param'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        initialUrl: URL
                        previewSearchParam: string | null | undefined
                        allowOrigins: URLPattern[]
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  ? T extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K in RequiredActorOptions<T>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'check permission'
                logic: ObservableActorLogic<
                  PermissionCheckResult,
                  CheckPermissionInput,
                  EventObject
                >
                id: string | undefined
              } extends infer T_1
                ? T_1 extends {
                    src: 'check permission'
                    logic: ObservableActorLogic<
                      PermissionCheckResult,
                      CheckPermissionInput,
                      EventObject
                    >
                    id: string | undefined
                  }
                  ? T_1 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_1['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_1['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_1 in RequiredActorOptions<T_1>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_1>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'resolve initial url'
                logic: PromiseActorLogic<
                  URL,
                  {
                    previewSearchParam: string | null
                  },
                  EventObject
                >
                id: string | undefined
              } extends infer T_2
                ? T_2 extends {
                    src: 'resolve initial url'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        previewSearchParam: string | null
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  ? T_2 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_2['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_2['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_2 in RequiredActorOptions<T_2>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_2>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'resolve allow patterns'
                logic: PromiseActorLogic<
                  URLPattern[],
                  {
                    initialUrl: URL
                  },
                  EventObject
                >
                id: string | undefined
              } extends infer T_3
                ? T_3 extends {
                    src: 'resolve allow patterns'
                    logic: PromiseActorLogic<
                      URLPattern[],
                      {
                        initialUrl: URL
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  ? T_3 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_3['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_3['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_3 in RequiredActorOptions<T_3>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_3>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'resolve preview mode'
                logic: PromiseActorLogic<
                  false | PreviewUrlPreviewMode,
                  {
                    targetOrigin: string
                  },
                  EventObject
                >
                id: string | undefined
              } extends infer T_4
                ? T_4 extends {
                    src: 'resolve preview mode'
                    logic: PromiseActorLogic<
                      false | PreviewUrlPreviewMode,
                      {
                        targetOrigin: string
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  ? T_4 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_4['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_4['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_4 in RequiredActorOptions<T_4>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_4>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'create preview secret'
                logic: PromiseActorLogic<
                  {
                    secret: string
                    expiresAt: Date
                  },
                  NonReducibleUnknown,
                  EventObject
                >
                id: string | undefined
              } extends infer T_5
                ? T_5 extends {
                    src: 'create preview secret'
                    logic: PromiseActorLogic<
                      {
                        secret: string
                        expiresAt: Date
                      },
                      NonReducibleUnknown,
                      EventObject
                    >
                    id: string | undefined
                  }
                  ? T_5 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_5['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_5['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_5 in RequiredActorOptions<T_5>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_5>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'read shared preview secret'
                logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                id: string | undefined
              } extends infer T_6
                ? T_6 extends {
                    src: 'read shared preview secret'
                    logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                    id: string | undefined
                  }
                  ? T_6 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_6['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_6['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_6 in RequiredActorOptions<T_6>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_6>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'resolve preview mode url'
                logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                id: string | undefined
              } extends infer T_7
                ? T_7 extends {
                    src: 'resolve preview mode url'
                    logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                    id: string | undefined
                  }
                  ? T_7 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_7['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_7['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_7 in RequiredActorOptions<T_7>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_7>>
                      >
                    : never
                  : never
                : never)
        ): ActorRefFromLogic<
          GetConcreteByKey<
            Values<{
              'resolve url from preview search param': {
                src: 'resolve url from preview search param'
                logic: PromiseActorLogic<
                  URL,
                  {
                    initialUrl: URL
                    previewSearchParam: string | null | undefined
                    allowOrigins: URLPattern[]
                  },
                  EventObject
                >
                id: string | undefined
              }
              'check permission': {
                src: 'check permission'
                logic: ObservableActorLogic<
                  PermissionCheckResult,
                  CheckPermissionInput,
                  EventObject
                >
                id: string | undefined
              }
              'resolve initial url': {
                src: 'resolve initial url'
                logic: PromiseActorLogic<
                  URL,
                  {
                    previewSearchParam: string | null
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve allow patterns': {
                src: 'resolve allow patterns'
                logic: PromiseActorLogic<
                  URLPattern[],
                  {
                    initialUrl: URL
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve preview mode': {
                src: 'resolve preview mode'
                logic: PromiseActorLogic<
                  false | PreviewUrlPreviewMode,
                  {
                    targetOrigin: string
                  },
                  EventObject
                >
                id: string | undefined
              }
              'create preview secret': {
                src: 'create preview secret'
                logic: PromiseActorLogic<
                  {
                    secret: string
                    expiresAt: Date
                  },
                  NonReducibleUnknown,
                  EventObject
                >
                id: string | undefined
              }
              'read shared preview secret': {
                src: 'read shared preview secret'
                logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                id: string | undefined
              }
              'resolve preview mode url': {
                src: 'resolve preview mode url'
                logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                id: string | undefined
              }
            }>,
            'src',
            TSrc
          >['logic']
        >
        <TLogic extends AnyActorLogic>(
          src: TLogic,
          ...[options]: ConditionalRequired<
            [
              options?:
                | ({
                    id?: never
                    systemId?: string
                    input?: InputFrom<TLogic> | undefined
                    syncSnapshot?: boolean
                  } & {[K in RequiredLogicInput<TLogic>]: unknown})
                | undefined,
            ],
            IsNotNever<RequiredLogicInput<TLogic>>
          >
        ): ActorRefFromLogic<TLogic>
      }
      input: Input
      self: ActorRef<
        MachineSnapshot<
          Context_2,
          SetPreviewSearchParamEvent,
          Record<string, AnyActorRef | undefined>,
          StateValue,
          string,
          unknown,
          any,
          any
        >,
        SetPreviewSearchParamEvent,
        AnyEventObject
      >
    }) => {
      initialUrl: null
      previewUrl: null
      error: null
      allowOrigins: null
      previewSearchParam: string | null
      previewUrlSecret: null
      previewAccessSharingCreatePermission: null
      previewAccessSharingReadPermission: null
      previewAccessSharingUpdatePermission: null
      previewUrlSecretPermission: null
      previewMode: null
    }
    readonly invoke: readonly [
      {
        readonly src: 'check permission'
        readonly input: () => {
          checkPermissionName: 'read'
          document: {
            _id: 'sanity-preview-url-secret.share-access'
            _type: string
          }
        }
        readonly onError: {
          readonly target: '.error'
          readonly actions: {
            readonly type: 'assign error'
            readonly params: ({
              event,
            }: {
              context: Context_2
              event: ErrorActorEvent<unknown, string>
            }) => {
              message: string
              error: unknown
            }
          }
        }
        readonly onSnapshot: {
          readonly actions: ActionFunction<
            Context_2,
            SnapshotEvent<ObservableSnapshot<PermissionCheckResult, CheckPermissionInput>>,
            SetPreviewSearchParamEvent,
            undefined,
            Values<{
              'resolve url from preview search param': {
                src: 'resolve url from preview search param'
                logic: PromiseActorLogic<
                  URL,
                  {
                    initialUrl: URL
                    previewSearchParam: string | null | undefined
                    allowOrigins: URLPattern[]
                  },
                  EventObject
                >
                id: string | undefined
              }
              'check permission': {
                src: 'check permission'
                logic: ObservableActorLogic<
                  PermissionCheckResult,
                  CheckPermissionInput,
                  EventObject
                >
                id: string | undefined
              }
              'resolve initial url': {
                src: 'resolve initial url'
                logic: PromiseActorLogic<
                  URL,
                  {
                    previewSearchParam: string | null
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve allow patterns': {
                src: 'resolve allow patterns'
                logic: PromiseActorLogic<
                  URLPattern[],
                  {
                    initialUrl: URL
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve preview mode': {
                src: 'resolve preview mode'
                logic: PromiseActorLogic<
                  false | PreviewUrlPreviewMode,
                  {
                    targetOrigin: string
                  },
                  EventObject
                >
                id: string | undefined
              }
              'create preview secret': {
                src: 'create preview secret'
                logic: PromiseActorLogic<
                  {
                    secret: string
                    expiresAt: Date
                  },
                  NonReducibleUnknown,
                  EventObject
                >
                id: string | undefined
              }
              'read shared preview secret': {
                src: 'read shared preview secret'
                logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                id: string | undefined
              }
              'resolve preview mode url': {
                src: 'resolve preview mode url'
                logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                id: string | undefined
              }
            }>,
            never,
            never,
            never,
            never
          >
        }
      },
      {
        readonly src: 'check permission'
        readonly input: () => {
          checkPermissionName: 'create'
          document: {
            _id: 'sanity-preview-url-secret.share-access'
            _type: string
          }
        }
        readonly onError: {
          readonly target: '.error'
          readonly actions: {
            readonly type: 'assign error'
            readonly params: ({
              event,
            }: {
              context: Context_2
              event: ErrorActorEvent<unknown, string>
            }) => {
              message: string
              error: unknown
            }
          }
        }
        readonly onSnapshot: {
          readonly actions: ActionFunction<
            Context_2,
            SnapshotEvent<ObservableSnapshot<PermissionCheckResult, CheckPermissionInput>>,
            SetPreviewSearchParamEvent,
            undefined,
            Values<{
              'resolve url from preview search param': {
                src: 'resolve url from preview search param'
                logic: PromiseActorLogic<
                  URL,
                  {
                    initialUrl: URL
                    previewSearchParam: string | null | undefined
                    allowOrigins: URLPattern[]
                  },
                  EventObject
                >
                id: string | undefined
              }
              'check permission': {
                src: 'check permission'
                logic: ObservableActorLogic<
                  PermissionCheckResult,
                  CheckPermissionInput,
                  EventObject
                >
                id: string | undefined
              }
              'resolve initial url': {
                src: 'resolve initial url'
                logic: PromiseActorLogic<
                  URL,
                  {
                    previewSearchParam: string | null
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve allow patterns': {
                src: 'resolve allow patterns'
                logic: PromiseActorLogic<
                  URLPattern[],
                  {
                    initialUrl: URL
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve preview mode': {
                src: 'resolve preview mode'
                logic: PromiseActorLogic<
                  false | PreviewUrlPreviewMode,
                  {
                    targetOrigin: string
                  },
                  EventObject
                >
                id: string | undefined
              }
              'create preview secret': {
                src: 'create preview secret'
                logic: PromiseActorLogic<
                  {
                    secret: string
                    expiresAt: Date
                  },
                  NonReducibleUnknown,
                  EventObject
                >
                id: string | undefined
              }
              'read shared preview secret': {
                src: 'read shared preview secret'
                logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                id: string | undefined
              }
              'resolve preview mode url': {
                src: 'resolve preview mode url'
                logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                id: string | undefined
              }
            }>,
            never,
            never,
            never,
            never
          >
        }
      },
      {
        readonly src: 'check permission'
        readonly input: () => {
          checkPermissionName: 'update'
          document: {
            _id: 'sanity-preview-url-secret.share-access'
            _type: string
          }
        }
        readonly onError: {
          readonly target: '.error'
          readonly actions: {
            readonly type: 'assign error'
            readonly params: ({
              event,
            }: {
              context: Context_2
              event: ErrorActorEvent<unknown, string>
            }) => {
              message: string
              error: unknown
            }
          }
        }
        readonly onSnapshot: {
          readonly actions: ActionFunction<
            Context_2,
            SnapshotEvent<ObservableSnapshot<PermissionCheckResult, CheckPermissionInput>>,
            SetPreviewSearchParamEvent,
            undefined,
            Values<{
              'resolve url from preview search param': {
                src: 'resolve url from preview search param'
                logic: PromiseActorLogic<
                  URL,
                  {
                    initialUrl: URL
                    previewSearchParam: string | null | undefined
                    allowOrigins: URLPattern[]
                  },
                  EventObject
                >
                id: string | undefined
              }
              'check permission': {
                src: 'check permission'
                logic: ObservableActorLogic<
                  PermissionCheckResult,
                  CheckPermissionInput,
                  EventObject
                >
                id: string | undefined
              }
              'resolve initial url': {
                src: 'resolve initial url'
                logic: PromiseActorLogic<
                  URL,
                  {
                    previewSearchParam: string | null
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve allow patterns': {
                src: 'resolve allow patterns'
                logic: PromiseActorLogic<
                  URLPattern[],
                  {
                    initialUrl: URL
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve preview mode': {
                src: 'resolve preview mode'
                logic: PromiseActorLogic<
                  false | PreviewUrlPreviewMode,
                  {
                    targetOrigin: string
                  },
                  EventObject
                >
                id: string | undefined
              }
              'create preview secret': {
                src: 'create preview secret'
                logic: PromiseActorLogic<
                  {
                    secret: string
                    expiresAt: Date
                  },
                  NonReducibleUnknown,
                  EventObject
                >
                id: string | undefined
              }
              'read shared preview secret': {
                src: 'read shared preview secret'
                logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                id: string | undefined
              }
              'resolve preview mode url': {
                src: 'resolve preview mode url'
                logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                id: string | undefined
              }
            }>,
            never,
            never,
            never,
            never
          >
        }
      },
      {
        readonly src: 'check permission'
        readonly input: () => {
          checkPermissionName: 'create'
          document: {
            _id: string
            _type: string
          }
        }
        readonly onError: {
          readonly target: '.error'
          readonly actions: {
            readonly type: 'assign error'
            readonly params: ({
              event,
            }: {
              context: Context_2
              event: ErrorActorEvent<unknown, string>
            }) => {
              message: string
              error: unknown
            }
          }
        }
        readonly onSnapshot: {
          readonly actions: ActionFunction<
            Context_2,
            SnapshotEvent<ObservableSnapshot<PermissionCheckResult, CheckPermissionInput>>,
            SetPreviewSearchParamEvent,
            undefined,
            Values<{
              'resolve url from preview search param': {
                src: 'resolve url from preview search param'
                logic: PromiseActorLogic<
                  URL,
                  {
                    initialUrl: URL
                    previewSearchParam: string | null | undefined
                    allowOrigins: URLPattern[]
                  },
                  EventObject
                >
                id: string | undefined
              }
              'check permission': {
                src: 'check permission'
                logic: ObservableActorLogic<
                  PermissionCheckResult,
                  CheckPermissionInput,
                  EventObject
                >
                id: string | undefined
              }
              'resolve initial url': {
                src: 'resolve initial url'
                logic: PromiseActorLogic<
                  URL,
                  {
                    previewSearchParam: string | null
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve allow patterns': {
                src: 'resolve allow patterns'
                logic: PromiseActorLogic<
                  URLPattern[],
                  {
                    initialUrl: URL
                  },
                  EventObject
                >
                id: string | undefined
              }
              'resolve preview mode': {
                src: 'resolve preview mode'
                logic: PromiseActorLogic<
                  false | PreviewUrlPreviewMode,
                  {
                    targetOrigin: string
                  },
                  EventObject
                >
                id: string | undefined
              }
              'create preview secret': {
                src: 'create preview secret'
                logic: PromiseActorLogic<
                  {
                    secret: string
                    expiresAt: Date
                  },
                  NonReducibleUnknown,
                  EventObject
                >
                id: string | undefined
              }
              'read shared preview secret': {
                src: 'read shared preview secret'
                logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                id: string | undefined
              }
              'resolve preview mode url': {
                src: 'resolve preview mode url'
                logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                id: string | undefined
              }
            }>,
            never,
            never,
            never,
            never
          >
        }
      },
    ]
    readonly on: {
      readonly 'set preview search param': {
        readonly actions: {
          readonly type: 'assign preview search param'
          readonly params: ({event}: {context: Context_2; event: SetPreviewSearchParamEvent}) => {
            previewSearchParam: string | null
          }
        }
      }
    }
    readonly states: {
      readonly checkingPermissions: {
        readonly always: {
          readonly guard: 'has checked permissions'
          readonly target: 'resolvingInitialUrl'
        }
        readonly tags: 'busy'
      }
      readonly resolvingInitialUrl: {
        readonly invoke: {
          readonly src: 'resolve initial url'
          readonly input: ({
            context,
          }: {
            context: Context_2
            event: SetPreviewSearchParamEvent
            self: ActorRef<
              MachineSnapshot<
                Context_2,
                SetPreviewSearchParamEvent,
                Record<string, AnyActorRef>,
                StateValue,
                string,
                unknown,
                any,
                any
              >,
              SetPreviewSearchParamEvent,
              AnyEventObject
            >
          }) => {
            previewSearchParam: string | null
          }
          readonly onError: {
            readonly target: 'error'
            readonly actions: {
              readonly type: 'assign error'
              readonly params: ({
                event,
              }: {
                context: Context_2
                event: ErrorActorEvent<unknown, string>
              }) => {
                message: string
                error: unknown
              }
            }
          }
          readonly onDone: {
            readonly target: 'resolvingAllowPatterns'
            readonly actions: ActionFunction<
              Context_2,
              DoneActorEvent<URL, string>,
              SetPreviewSearchParamEvent,
              undefined,
              Values<{
                'resolve url from preview search param': {
                  src: 'resolve url from preview search param'
                  logic: PromiseActorLogic<
                    URL,
                    {
                      initialUrl: URL
                      previewSearchParam: string | null | undefined
                      allowOrigins: URLPattern[]
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'check permission': {
                  src: 'check permission'
                  logic: ObservableActorLogic<
                    PermissionCheckResult,
                    CheckPermissionInput,
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve initial url': {
                  src: 'resolve initial url'
                  logic: PromiseActorLogic<
                    URL,
                    {
                      previewSearchParam: string | null
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve allow patterns': {
                  src: 'resolve allow patterns'
                  logic: PromiseActorLogic<
                    URLPattern[],
                    {
                      initialUrl: URL
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve preview mode': {
                  src: 'resolve preview mode'
                  logic: PromiseActorLogic<
                    false | PreviewUrlPreviewMode,
                    {
                      targetOrigin: string
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'create preview secret': {
                  src: 'create preview secret'
                  logic: PromiseActorLogic<
                    {
                      secret: string
                      expiresAt: Date
                    },
                    NonReducibleUnknown,
                    EventObject
                  >
                  id: string | undefined
                }
                'read shared preview secret': {
                  src: 'read shared preview secret'
                  logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                  id: string | undefined
                }
                'resolve preview mode url': {
                  src: 'resolve preview mode url'
                  logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                  id: string | undefined
                }
              }>,
              never,
              never,
              never,
              never
            >
          }
        }
        readonly tags: 'busy'
      }
      readonly error: {
        readonly type: 'final'
        readonly tags: 'error'
      }
      readonly resolvingAllowPatterns: {
        readonly invoke: {
          readonly src: 'resolve allow patterns'
          readonly input: ({
            context,
          }: {
            context: Context_2
            event: SetPreviewSearchParamEvent
            self: ActorRef<
              MachineSnapshot<
                Context_2,
                SetPreviewSearchParamEvent,
                Record<string, AnyActorRef>,
                StateValue,
                string,
                unknown,
                any,
                any
              >,
              SetPreviewSearchParamEvent,
              AnyEventObject
            >
          }) => {
            initialUrl: URL
          }
          readonly onError: {
            readonly target: 'error'
            readonly actions: {
              readonly type: 'assign error'
              readonly params: ({
                event,
              }: {
                context: Context_2
                event: ErrorActorEvent<unknown, string>
              }) => {
                message: string
                error: unknown
              }
            }
          }
          readonly onDone: {
            readonly target: 'resolvingUrlFromPreviewSearchParam'
            readonly actions: ActionFunction<
              Context_2,
              DoneActorEvent<URLPattern[], string>,
              SetPreviewSearchParamEvent,
              undefined,
              Values<{
                'resolve url from preview search param': {
                  src: 'resolve url from preview search param'
                  logic: PromiseActorLogic<
                    URL,
                    {
                      initialUrl: URL
                      previewSearchParam: string | null | undefined
                      allowOrigins: URLPattern[]
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'check permission': {
                  src: 'check permission'
                  logic: ObservableActorLogic<
                    PermissionCheckResult,
                    CheckPermissionInput,
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve initial url': {
                  src: 'resolve initial url'
                  logic: PromiseActorLogic<
                    URL,
                    {
                      previewSearchParam: string | null
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve allow patterns': {
                  src: 'resolve allow patterns'
                  logic: PromiseActorLogic<
                    URLPattern[],
                    {
                      initialUrl: URL
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve preview mode': {
                  src: 'resolve preview mode'
                  logic: PromiseActorLogic<
                    false | PreviewUrlPreviewMode,
                    {
                      targetOrigin: string
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'create preview secret': {
                  src: 'create preview secret'
                  logic: PromiseActorLogic<
                    {
                      secret: string
                      expiresAt: Date
                    },
                    NonReducibleUnknown,
                    EventObject
                  >
                  id: string | undefined
                }
                'read shared preview secret': {
                  src: 'read shared preview secret'
                  logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                  id: string | undefined
                }
                'resolve preview mode url': {
                  src: 'resolve preview mode url'
                  logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                  id: string | undefined
                }
              }>,
              never,
              never,
              never,
              never
            >
          }
        }
        readonly tags: readonly ['busy']
      }
      readonly resolvingUrlFromPreviewSearchParam: {
        readonly id: 'loop'
        readonly invoke: {
          readonly src: 'resolve url from preview search param'
          readonly input: ({
            context,
          }: {
            context: Context_2
            event: SetPreviewSearchParamEvent
            self: ActorRef<
              MachineSnapshot<
                Context_2,
                SetPreviewSearchParamEvent,
                Record<string, AnyActorRef>,
                StateValue,
                string,
                unknown,
                any,
                any
              >,
              SetPreviewSearchParamEvent,
              AnyEventObject
            >
          }) => {
            initialUrl: URL
            allowOrigins: URLPattern[]
            previewSearchParam: string | null
          }
          readonly onError: {
            readonly target: 'error'
            readonly actions: {
              readonly type: 'assign error'
              readonly params: ({
                event,
              }: {
                context: Context_2
                event: ErrorActorEvent<unknown, string>
              }) => {
                message: string
                error: unknown
              }
            }
          }
          readonly onDone: {
            readonly target: 'resolvingPreviewMode'
            readonly actions: ActionFunction<
              Context_2,
              DoneActorEvent<URL, string>,
              SetPreviewSearchParamEvent,
              undefined,
              Values<{
                'resolve url from preview search param': {
                  src: 'resolve url from preview search param'
                  logic: PromiseActorLogic<
                    URL,
                    {
                      initialUrl: URL
                      previewSearchParam: string | null | undefined
                      allowOrigins: URLPattern[]
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'check permission': {
                  src: 'check permission'
                  logic: ObservableActorLogic<
                    PermissionCheckResult,
                    CheckPermissionInput,
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve initial url': {
                  src: 'resolve initial url'
                  logic: PromiseActorLogic<
                    URL,
                    {
                      previewSearchParam: string | null
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve allow patterns': {
                  src: 'resolve allow patterns'
                  logic: PromiseActorLogic<
                    URLPattern[],
                    {
                      initialUrl: URL
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'resolve preview mode': {
                  src: 'resolve preview mode'
                  logic: PromiseActorLogic<
                    false | PreviewUrlPreviewMode,
                    {
                      targetOrigin: string
                    },
                    EventObject
                  >
                  id: string | undefined
                }
                'create preview secret': {
                  src: 'create preview secret'
                  logic: PromiseActorLogic<
                    {
                      secret: string
                      expiresAt: Date
                    },
                    NonReducibleUnknown,
                    EventObject
                  >
                  id: string | undefined
                }
                'read shared preview secret': {
                  src: 'read shared preview secret'
                  logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                  id: string | undefined
                }
                'resolve preview mode url': {
                  src: 'resolve preview mode url'
                  logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                  id: string | undefined
                }
              }>,
              never,
              never,
              never,
              never
            >
          }
        }
        readonly tags: readonly ['busy']
      }
      readonly resolvingPreviewMode: {
        readonly on: {
          readonly 'set preview search param': {
            readonly guard: 'search param has new origin'
            readonly actions: {
              readonly type: 'assign preview search param'
              readonly params: ({
                event,
              }: {
                context: Context_2
                event: SetPreviewSearchParamEvent
              }) => {
                previewSearchParam: string | null
              }
            }
            readonly target: '#loop'
            readonly reenter: true
          }
        }
        readonly invoke: {
          readonly src: 'resolve preview mode'
          readonly input: ({
            context,
          }: {
            context: Context_2
            event: SetPreviewSearchParamEvent
            self: ActorRef<
              MachineSnapshot<
                Context_2,
                SetPreviewSearchParamEvent,
                Record<string, AnyActorRef>,
                StateValue,
                string,
                unknown,
                any,
                any
              >,
              SetPreviewSearchParamEvent,
              AnyEventObject
            >
          }) => {
            targetOrigin: string
          }
          readonly onError: {
            readonly target: 'error'
            readonly actions: {
              readonly type: 'assign error'
              readonly params: ({
                event,
              }: {
                context: Context_2
                event: ErrorActorEvent<unknown, string>
              }) => {
                message: string
                error: unknown
              }
            }
          }
          readonly onDone: readonly [
            {
              readonly guard: {
                readonly type: 'has preview mode with created secret'
                readonly params: ({
                  event,
                }: {
                  context: Context_2
                  event: DoneActorEvent<false | PreviewUrlPreviewMode, string>
                }) => false | PreviewUrlPreviewMode
              }
              readonly actions: ActionFunction<
                Context_2,
                DoneActorEvent<false | PreviewUrlPreviewMode, string>,
                SetPreviewSearchParamEvent,
                undefined,
                Values<{
                  'resolve url from preview search param': {
                    src: 'resolve url from preview search param'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        initialUrl: URL
                        previewSearchParam: string | null | undefined
                        allowOrigins: URLPattern[]
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'check permission': {
                    src: 'check permission'
                    logic: ObservableActorLogic<
                      PermissionCheckResult,
                      CheckPermissionInput,
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve initial url': {
                    src: 'resolve initial url'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        previewSearchParam: string | null
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve allow patterns': {
                    src: 'resolve allow patterns'
                    logic: PromiseActorLogic<
                      URLPattern[],
                      {
                        initialUrl: URL
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve preview mode': {
                    src: 'resolve preview mode'
                    logic: PromiseActorLogic<
                      false | PreviewUrlPreviewMode,
                      {
                        targetOrigin: string
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'create preview secret': {
                    src: 'create preview secret'
                    logic: PromiseActorLogic<
                      {
                        secret: string
                        expiresAt: Date
                      },
                      NonReducibleUnknown,
                      EventObject
                    >
                    id: string | undefined
                  }
                  'read shared preview secret': {
                    src: 'read shared preview secret'
                    logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                    id: string | undefined
                  }
                  'resolve preview mode url': {
                    src: 'resolve preview mode url'
                    logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                    id: string | undefined
                  }
                }>,
                never,
                never,
                never,
                never
              >
              readonly target: 'previewMode.createPreviewSecret'
            },
            {
              readonly guard: {
                readonly type: 'has preview mode with share access'
                readonly params: ({
                  event,
                }: {
                  context: Context_2
                  event: DoneActorEvent<false | PreviewUrlPreviewMode, string>
                }) => false | PreviewUrlPreviewMode
              }
              readonly actions: ActionFunction<
                Context_2,
                DoneActorEvent<false | PreviewUrlPreviewMode, string>,
                SetPreviewSearchParamEvent,
                undefined,
                Values<{
                  'resolve url from preview search param': {
                    src: 'resolve url from preview search param'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        initialUrl: URL
                        previewSearchParam: string | null | undefined
                        allowOrigins: URLPattern[]
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'check permission': {
                    src: 'check permission'
                    logic: ObservableActorLogic<
                      PermissionCheckResult,
                      CheckPermissionInput,
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve initial url': {
                    src: 'resolve initial url'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        previewSearchParam: string | null
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve allow patterns': {
                    src: 'resolve allow patterns'
                    logic: PromiseActorLogic<
                      URLPattern[],
                      {
                        initialUrl: URL
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve preview mode': {
                    src: 'resolve preview mode'
                    logic: PromiseActorLogic<
                      false | PreviewUrlPreviewMode,
                      {
                        targetOrigin: string
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'create preview secret': {
                    src: 'create preview secret'
                    logic: PromiseActorLogic<
                      {
                        secret: string
                        expiresAt: Date
                      },
                      NonReducibleUnknown,
                      EventObject
                    >
                    id: string | undefined
                  }
                  'read shared preview secret': {
                    src: 'read shared preview secret'
                    logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                    id: string | undefined
                  }
                  'resolve preview mode url': {
                    src: 'resolve preview mode url'
                    logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                    id: string | undefined
                  }
                }>,
                never,
                never,
                never,
                never
              >
              readonly target: 'previewMode.readShareAccess'
            },
            {
              readonly guard: {
                readonly type: 'has preview mode without permissions'
                readonly params: ({
                  event,
                }: {
                  context: Context_2
                  event: DoneActorEvent<false | PreviewUrlPreviewMode, string>
                }) => false | PreviewUrlPreviewMode
              }
              readonly actions: readonly [
                ActionFunction<
                  Context_2,
                  DoneActorEvent<false | PreviewUrlPreviewMode, string>,
                  SetPreviewSearchParamEvent,
                  undefined,
                  Values<{
                    'resolve url from preview search param': {
                      src: 'resolve url from preview search param'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          initialUrl: URL
                          previewSearchParam: string | null | undefined
                          allowOrigins: URLPattern[]
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'check permission': {
                      src: 'check permission'
                      logic: ObservableActorLogic<
                        PermissionCheckResult,
                        CheckPermissionInput,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve initial url': {
                      src: 'resolve initial url'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          previewSearchParam: string | null
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve allow patterns': {
                      src: 'resolve allow patterns'
                      logic: PromiseActorLogic<
                        URLPattern[],
                        {
                          initialUrl: URL
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve preview mode': {
                      src: 'resolve preview mode'
                      logic: PromiseActorLogic<
                        false | PreviewUrlPreviewMode,
                        {
                          targetOrigin: string
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'create preview secret': {
                      src: 'create preview secret'
                      logic: PromiseActorLogic<
                        {
                          secret: string
                          expiresAt: Date
                        },
                        NonReducibleUnknown,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'read shared preview secret': {
                      src: 'read shared preview secret'
                      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                      id: string | undefined
                    }
                    'resolve preview mode url': {
                      src: 'resolve preview mode url'
                      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                      id: string | undefined
                    }
                  }>,
                  never,
                  never,
                  never,
                  never
                >,
                'notify preview will likely fail',
              ]
              readonly target: 'success'
            },
            {
              readonly actions: ActionFunction<
                Context_2,
                DoneActorEvent<false | PreviewUrlPreviewMode, string>,
                SetPreviewSearchParamEvent,
                undefined,
                Values<{
                  'resolve url from preview search param': {
                    src: 'resolve url from preview search param'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        initialUrl: URL
                        previewSearchParam: string | null | undefined
                        allowOrigins: URLPattern[]
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'check permission': {
                    src: 'check permission'
                    logic: ObservableActorLogic<
                      PermissionCheckResult,
                      CheckPermissionInput,
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve initial url': {
                    src: 'resolve initial url'
                    logic: PromiseActorLogic<
                      URL,
                      {
                        previewSearchParam: string | null
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve allow patterns': {
                    src: 'resolve allow patterns'
                    logic: PromiseActorLogic<
                      URLPattern[],
                      {
                        initialUrl: URL
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'resolve preview mode': {
                    src: 'resolve preview mode'
                    logic: PromiseActorLogic<
                      false | PreviewUrlPreviewMode,
                      {
                        targetOrigin: string
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  'create preview secret': {
                    src: 'create preview secret'
                    logic: PromiseActorLogic<
                      {
                        secret: string
                        expiresAt: Date
                      },
                      NonReducibleUnknown,
                      EventObject
                    >
                    id: string | undefined
                  }
                  'read shared preview secret': {
                    src: 'read shared preview secret'
                    logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                    id: string | undefined
                  }
                  'resolve preview mode url': {
                    src: 'resolve preview mode url'
                    logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                    id: string | undefined
                  }
                }>,
                never,
                never,
                never,
                never
              >
              readonly target: 'success'
            },
          ]
        }
        readonly tags: readonly ['busy']
      }
      readonly success: {
        readonly on: {
          readonly 'set preview search param': {
            readonly guard: 'search param has new origin'
            readonly actions: {
              readonly type: 'assign preview search param'
              readonly params: ({
                event,
              }: {
                context: Context_2
                event: SetPreviewSearchParamEvent
              }) => {
                previewSearchParam: string | null
              }
            }
            readonly target: '#loop'
            readonly reenter: true
          }
        }
      }
      readonly previewMode: {
        readonly on: {
          readonly 'set preview search param': {
            readonly guard: 'search param has new origin'
            readonly actions: {
              readonly type: 'assign preview search param'
              readonly params: ({
                event,
              }: {
                context: Context_2
                event: SetPreviewSearchParamEvent
              }) => {
                previewSearchParam: string | null
              }
            }
            readonly target: '#loop'
            readonly reenter: true
          }
        }
        readonly states: {
          readonly createPreviewSecret: {
            readonly invoke: {
              readonly src: 'create preview secret'
              readonly onError: {
                readonly target: 'error'
                readonly actions: {
                  readonly type: 'assign error'
                  readonly params: ({
                    event,
                  }: {
                    context: Context_2
                    event: ErrorActorEvent<unknown, string>
                  }) => {
                    message: string
                    error: unknown
                  }
                }
              }
              readonly onDone: {
                readonly target: 'resolvePreviewUrl'
                readonly actions: ActionFunction<
                  Context_2,
                  DoneActorEvent<
                    {
                      secret: string
                      expiresAt: Date
                    },
                    string
                  >,
                  SetPreviewSearchParamEvent,
                  undefined,
                  Values<{
                    'resolve url from preview search param': {
                      src: 'resolve url from preview search param'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          initialUrl: URL
                          previewSearchParam: string | null | undefined
                          allowOrigins: URLPattern[]
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'check permission': {
                      src: 'check permission'
                      logic: ObservableActorLogic<
                        PermissionCheckResult,
                        CheckPermissionInput,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve initial url': {
                      src: 'resolve initial url'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          previewSearchParam: string | null
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve allow patterns': {
                      src: 'resolve allow patterns'
                      logic: PromiseActorLogic<
                        URLPattern[],
                        {
                          initialUrl: URL
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve preview mode': {
                      src: 'resolve preview mode'
                      logic: PromiseActorLogic<
                        false | PreviewUrlPreviewMode,
                        {
                          targetOrigin: string
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'create preview secret': {
                      src: 'create preview secret'
                      logic: PromiseActorLogic<
                        {
                          secret: string
                          expiresAt: Date
                        },
                        NonReducibleUnknown,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'read shared preview secret': {
                      src: 'read shared preview secret'
                      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                      id: string | undefined
                    }
                    'resolve preview mode url': {
                      src: 'resolve preview mode url'
                      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                      id: string | undefined
                    }
                  }>,
                  never,
                  never,
                  never,
                  never
                >
              }
            }
            readonly tags: readonly ['busy']
          }
          readonly readShareAccess: {
            readonly invoke: {
              readonly src: 'read shared preview secret'
              readonly onError: {
                readonly target: 'error'
                readonly actions: {
                  readonly type: 'assign error'
                  readonly params: ({
                    event,
                  }: {
                    context: Context_2
                    event: ErrorActorEvent<unknown, string>
                  }) => {
                    message: string
                    error: unknown
                  }
                }
              }
              readonly onDone: {
                readonly target: 'resolvePreviewUrl'
                readonly actions: ActionFunction<
                  Context_2,
                  DoneActorEvent<string | null, string>,
                  SetPreviewSearchParamEvent,
                  undefined,
                  Values<{
                    'resolve url from preview search param': {
                      src: 'resolve url from preview search param'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          initialUrl: URL
                          previewSearchParam: string | null | undefined
                          allowOrigins: URLPattern[]
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'check permission': {
                      src: 'check permission'
                      logic: ObservableActorLogic<
                        PermissionCheckResult,
                        CheckPermissionInput,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve initial url': {
                      src: 'resolve initial url'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          previewSearchParam: string | null
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve allow patterns': {
                      src: 'resolve allow patterns'
                      logic: PromiseActorLogic<
                        URLPattern[],
                        {
                          initialUrl: URL
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve preview mode': {
                      src: 'resolve preview mode'
                      logic: PromiseActorLogic<
                        false | PreviewUrlPreviewMode,
                        {
                          targetOrigin: string
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'create preview secret': {
                      src: 'create preview secret'
                      logic: PromiseActorLogic<
                        {
                          secret: string
                          expiresAt: Date
                        },
                        NonReducibleUnknown,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'read shared preview secret': {
                      src: 'read shared preview secret'
                      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                      id: string | undefined
                    }
                    'resolve preview mode url': {
                      src: 'resolve preview mode url'
                      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                      id: string | undefined
                    }
                  }>,
                  never,
                  never,
                  never,
                  never
                >
              }
            }
            readonly tags: readonly ['busy']
          }
          readonly resolvePreviewUrl: {
            readonly invoke: {
              readonly src: 'resolve preview mode url'
              readonly input: ({
                context,
              }: {
                context: Context_2
                event: SetPreviewSearchParamEvent
                self: ActorRef<
                  MachineSnapshot<
                    Context_2,
                    SetPreviewSearchParamEvent,
                    Record<string, AnyActorRef>,
                    StateValue,
                    string,
                    unknown,
                    any,
                    any
                  >,
                  SetPreviewSearchParamEvent,
                  AnyEventObject
                >
              }) => {
                initialUrl: URL
                resolvedPreviewMode: PreviewUrlPreviewMode
                previewUrlSecret: string
              }
              readonly onError: {
                readonly target: 'error'
                readonly actions: {
                  readonly type: 'assign error'
                  readonly params: ({
                    event,
                  }: {
                    context: Context_2
                    event: ErrorActorEvent<unknown, string>
                  }) => {
                    message: string
                    error: unknown
                  }
                }
              }
              readonly onDone: {
                readonly target: 'success'
                readonly actions: ActionFunction<
                  Context_2,
                  DoneActorEvent<URL, string>,
                  SetPreviewSearchParamEvent,
                  undefined,
                  Values<{
                    'resolve url from preview search param': {
                      src: 'resolve url from preview search param'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          initialUrl: URL
                          previewSearchParam: string | null | undefined
                          allowOrigins: URLPattern[]
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'check permission': {
                      src: 'check permission'
                      logic: ObservableActorLogic<
                        PermissionCheckResult,
                        CheckPermissionInput,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve initial url': {
                      src: 'resolve initial url'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          previewSearchParam: string | null
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve allow patterns': {
                      src: 'resolve allow patterns'
                      logic: PromiseActorLogic<
                        URLPattern[],
                        {
                          initialUrl: URL
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve preview mode': {
                      src: 'resolve preview mode'
                      logic: PromiseActorLogic<
                        false | PreviewUrlPreviewMode,
                        {
                          targetOrigin: string
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'create preview secret': {
                      src: 'create preview secret'
                      logic: PromiseActorLogic<
                        {
                          secret: string
                          expiresAt: Date
                        },
                        NonReducibleUnknown,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'read shared preview secret': {
                      src: 'read shared preview secret'
                      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                      id: string | undefined
                    }
                    'resolve preview mode url': {
                      src: 'resolve preview mode url'
                      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                      id: string | undefined
                    }
                  }>,
                  never,
                  never,
                  never,
                  never
                >
              }
            }
            readonly tags: readonly ['busy']
          }
          readonly error: {
            readonly type: 'final'
            readonly tags: readonly ['error']
          }
          readonly success: {
            readonly after: {
              readonly expiredSecret: {
                readonly guard: 'can create preview secret'
                readonly actions: ActionFunction<
                  Context_2,
                  SetPreviewSearchParamEvent,
                  SetPreviewSearchParamEvent,
                  undefined,
                  Values<{
                    'resolve url from preview search param': {
                      src: 'resolve url from preview search param'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          initialUrl: URL
                          previewSearchParam: string | null | undefined
                          allowOrigins: URLPattern[]
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'check permission': {
                      src: 'check permission'
                      logic: ObservableActorLogic<
                        PermissionCheckResult,
                        CheckPermissionInput,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve initial url': {
                      src: 'resolve initial url'
                      logic: PromiseActorLogic<
                        URL,
                        {
                          previewSearchParam: string | null
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve allow patterns': {
                      src: 'resolve allow patterns'
                      logic: PromiseActorLogic<
                        URLPattern[],
                        {
                          initialUrl: URL
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'resolve preview mode': {
                      src: 'resolve preview mode'
                      logic: PromiseActorLogic<
                        false | PreviewUrlPreviewMode,
                        {
                          targetOrigin: string
                        },
                        EventObject
                      >
                      id: string | undefined
                    }
                    'create preview secret': {
                      src: 'create preview secret'
                      logic: PromiseActorLogic<
                        {
                          secret: string
                          expiresAt: Date
                        },
                        NonReducibleUnknown,
                        EventObject
                      >
                      id: string | undefined
                    }
                    'read shared preview secret': {
                      src: 'read shared preview secret'
                      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
                      id: string | undefined
                    }
                    'resolve preview mode url': {
                      src: 'resolve preview mode url'
                      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
                      id: string | undefined
                    }
                  }>,
                  never,
                  never,
                  never,
                  never
                >
                readonly target: 'createPreviewSecret'
                readonly reenter: true
              }
            }
          }
        }
        readonly initial: 'readShareAccess'
      }
    }
    readonly initial: 'checkingPermissions'
  }
>

/** @public */
export declare type PreviewUrlOption =
  | string
  | DeprecatedPreviewUrlResolver
  | PreviewUrlResolverOptions

/** @public */
declare interface PreviewUrlPreviewMode {
  /**
   * The route that enables Preview Mode
   * @example '/api/preview'
   * @example '/api/draft-mode/enable'
   */
  enable: string
  /**
   * Allow sharing access to a preview with others.
   * This is enabled/disabled in the Presentation Tool. It's initially disabled, and can be enabled by someone who has access to creating draft documents in the Studio.
   * Custom roles can limit access to `_id in path("drafts.**") && _type == "sanity.previewUrlSecret"`.
   * This will create a secret that is valid until sharing is disabled. Turning sharing off and on again will create a new secret and can be used to remove access for folks that got the link in an email but should no longer have access.
   * Share URLs to previews will append this secret and give access to anyone who is given the URL, they don't need to be logged into the Studio or to Vercel.
   */
  shareAccess?: boolean
  /**
   * The route that reports if Preview Mode is enabled or not, useful for debugging
   * @example '/api/check-preview'
   * @deprecated - this API is not yet implemented
   */
  check?: string
  /**
   * The route that disables Preview Mode, useful for debugging
   * @example '/api/disable-preview'
   * @deprecated - this API is not yet implemented
   */
  disable?: string
}

/** @public */
declare type PreviewUrlPreviewModeOption =
  | PreviewUrlPreviewMode
  | ((
      context: PreviewUrlPreviewModeOptionContext,
    ) => false | PreviewUrlPreviewMode | Promise<false | PreviewUrlPreviewMode>)

/** @public */
declare interface PreviewUrlPreviewModeOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
  /**
   * The origin on the URL that will be used in the preview iframe
   */
  targetOrigin: string
}

declare type PreviewUrlRef = ActorRefFrom<typeof previewUrlMachine>

export {PreviewUrlResolver}

/**
 * @public
 */
export declare interface PreviewUrlResolverOptions {
  /**
   * The default preview URL, used when the URL to use is not yet known, or there's no `&preview=...` search param in the studio URL.
   * @example '/en/preview?q=shoes'
   * @example 'https://example.com'
   * @defaultValue `location.origin`
   */
  initial?: PreviewUrlInitialOption
  previewMode?: PreviewUrlPreviewModeOption
  /**
   * @defaultValue `location.origin`
   * @deprecated - use `initial` instead
   */
  origin?: string
  /**
   * @defaultValue '/'
   * @deprecated - use `initial` instead
   */
  preview?: string
  /**
   * @deprecated - use `previewMode` instead
   */
  draftMode?: {
    /**
     * @deprecated - use `previewMode.enable` instead
     */
    enable: string
    /**
     * @deprecated - use `previewMode.shareAccess` instead
     */
    shareAccess?: boolean
    /**
     * @deprecated - use `previewMode.check` instead
     */
    check?: string
    /**
     * @deprecated - use `previewMode.disable` instead
     */
    disable?: string
  }
}

/**
 * @hidden
 * @beta */
declare type PrimitiveFormNode = BooleanFormNode | NumberFormNode | StringFormNode

/**
 * @hidden
 * @public */
declare interface PrimitiveInputElementProps {
  'value'?: string
  'id': string
  'readOnly': boolean
  'placeholder'?: string
  'onChange': FormEventHandler
  'onFocus': FocusEventHandler
  'onBlur': FocusEventHandler
  'ref': MutableRefObject<any>
  'aria-describedby': string | undefined
}

/** @public */
declare interface PrimitiveItemProps extends BaseItemProps<string | number | boolean> {
  /**
   * The value of the primitive item.
   */
  value: string | number | boolean
  /**
   * The schema type of the primitive item.
   */
  schemaType: NumberSchemaType | BooleanSchemaType | StringSchemaType
  /**
   * The schema type of the parent array containing the item.
   */
  parentSchemaType: ArraySchemaType
}

/**
 * When comparing documents, diff provenance reflects details about the bundle in which a change
 * was introduced.
 *
 * @public
 */
declare interface ProvenanceDiffAnnotation {
  provenance: {
    bundle?: TargetPerspective
  }
}

/**
 * @hidden
 * @beta */
declare type QueryParams = Record<string, string | number | boolean | string[]>

/**
 * Symbol for enabling releases outside of quota restrictions for single docs
 * @internal
 */
declare const QUOTA_EXCLUDED_RELEASES_ENABLED: unique symbol

/**
 * @hidden
 * @beta */
declare interface ReconnectEvent {
  type: 'reconnect'
}

/**
 * @hidden
 * @public
 */
declare interface ReleaseActionComponent {
  (props: ReleaseActionProps): ReleaseActionDescription
  displayName?: string
}

/**
 * @hidden
 * @public
 */
declare interface ReleaseActionDescription {
  disabled?: boolean
  icon?: ReactNode | ComponentType
  label: string
  onHandle?: () => void
  title?: ReactNode
}

/**
 * @public
 */
declare interface ReleaseActionProps {
  release: ReleaseDocument
  documents: DocumentInRelease[]
}

/**
 * @hidden
 * @public
 */
declare type ReleaseActionsContext = ConfigContext & ReleaseActionProps

/**
 * @hidden
 * @public
 */
declare type ReleaseActionsResolver = ComposableOption<
  ReleaseActionComponent[],
  ReleaseActionsContext
>

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotEvent = DocumentRemoteMutationEvent | SnapshotEvent_2

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotVersionEvent = WithVersion<RemoteSnapshotEvent>

/**
 * @hidden
 * @public */
declare type RenderAnnotationCallback<T extends BlockAnnotationProps = BlockAnnotationProps> = (
  annotationProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public  */
declare type RenderArrayOfObjectsItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @beta */
declare type RenderArrayOfPrimitivesItemCallback = (
  itemProps: Omit<PrimitiveItemProps, 'renderDefault'>,
) => ReactNode

/**
 * Function for rendering custom block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type RenderBlockActionsCallback = (props: RenderBlockActionsProps) => ReactNode

/**
 * Props for rendering block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare interface RenderBlockActionsProps {
  block: PortableTextBlock
  value: PortableTextBlock[] | undefined
  set: (block: PortableTextBlock) => void
  unset: () => void
  insert: (block: PortableTextBlock | PortableTextBlock[]) => void
}

/**
 * @hidden
 * @public */
declare type RenderBlockCallback<T extends BlockProps = BlockProps> = (
  blockProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * Function for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type RenderCustomMarkers = (markers: PortableTextMarker[]) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderFieldCallback<T extends FieldProps = FieldProps> = (
  fieldProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderInputCallback<T extends InputProps = InputProps> = (
  inputProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderPreviewCallback = (props: RenderPreviewCallbackProps) => ReactNode

/**
 *
 * @hidden
 * @public
 */
declare interface RenderPreviewCallbackProps<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  error?: Error | null
  fallbackTitle?: ReactNode
  isPlaceholder?: boolean
  layout?: TLayoutKey
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  value: unknown
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType: SchemaType
  skipVisibilityCheck?: boolean
  style?: CSSProperties
}

/** @internal */
declare interface ResolvePreviewModeUrlInput {
  previewUrlSecret: string
  resolvedPreviewMode: PreviewUrlPreviewMode
  initialUrl: URL
}

/**
 * @hidden
 * @beta
 */
declare interface ResolveProductionUrlContext extends ConfigContext {
  document: SanityDocumentLike
}

declare type SanityDefinedAction =
  | 'delete'
  | 'discardChanges'
  | 'discardVersion'
  | 'duplicate'
  | 'restore'
  | 'publish'
  | 'unpublish'
  | 'unpublishVersion'
  | 'linkToCanvas'
  | 'editInCanvas'
  | 'unlinkFromCanvas'
  | 'schedule'

/**
 * @public
 */
declare interface SanityFormConfig {
  /**
   * these have not been migrated over
   *
   *
   * @hidden
   * @beta
   */
  unstable?: {
    CustomMarkers?: FormBuilderCustomMarkersComponent
    Markers?: FormBuilderMarkersComponent
  }
  /**
   * Components for the form.
   * @hidden
   * @beta
   */
  components?: FormComponents
  file?: {
    /**
     * @hidden
     * @beta
     */
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
  /**
   * @hidden
   * @beta
   */
  image?: {
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
}

/**
 * Config for the Scheduled Publishing plugin.
 * @public
 */
declare interface ScheduledPublishingPluginOptions {
  /**
   * Whether scheduled publishing is enabled for this workspace.
   */
  enabled: boolean
  /**
   * Date format to use for input fields. This must be a valid `date-fns` {@link https://date-fns.org/docs/format | formatted string}.
   * @defaultValue 'dd/MM/yyyy HH:mm' make sure to specify minutes and hours if you are specifying a custom format
   */
  inputDateTimeFormat?: string
  /**
   * @hidden
   * Whether scheduled publishing is enabled by the workspace.
   * Sanity is enabling it by default in the config, {@link "../scheduledPublishing/constants.ts"}
   */
  __internal__workspaceEnabled?: boolean
  /**
   * Whether to show the use releases warning banner in the tool.
   * @defaultValue true
   */
  showReleasesBanner?: boolean
}

/**
 * @hidden
 * @beta
 */
declare interface SchemaPluginOptions {
  name?: string
  types?:
    | SchemaTypeDefinition[]
    | ComposableOption<
        SchemaTypeDefinition[],
        Omit<ConfigContext, 'schema' | 'currentUser' | 'getClient' | 'client' | 'i18n'>
      >
  templates?: Template[] | TemplateResolver
}

export {Serializable}

export {SerializableArray}

export {SerializableObject}

export {SerializablePrimitive}

declare type SetPreviewSearchParamEvent = {
  type: 'set preview search param'
  previewSearchParam: string | null
}

/**
 * @hidden
 * @beta */
declare interface SnapshotEvent_2 {
  type: 'snapshot'
  document: SanityDocument
}

/** @public */
declare interface SourceClientOptions {
  /**
   * API version to use. See {@link https://www.sanity.io/docs/api-versioning | api-versioning}
   */
  apiVersion: string
}

/**
 * @hidden
 * @beta
 */
declare interface SourceOptions extends PluginOptions {
  title?: string
  /**
   * Project ID for this source
   */
  projectId: string
  /**
   * Dataset name for this source
   */
  dataset: string
  /**
   * API hostname used for requests. Generally used for custom CNAMEs, allowing businesses to use
   * their own domain for API requests. Must include protocol:
   * eg `https://sanityapi.mycompany.com`
   *
   * Note that (currently) the project ID will be prepended to the passed URL, so the above
   * example would end up as: `https://<projectId>.sanityapi.mycompany.com`
   */
  apiHost?: string
  /**
   * Authentication options for this source.
   */
  auth?: AuthConfig | AuthStore
  /**
   * @hidden
   * @beta
   */
  unstable_clientFactory?: (options: ClientConfig) => SanityClient
}

/**
 * @hidden
 * @public */
declare interface StringFieldProps extends BaseFieldProps {
  schemaType: StringSchemaType
  value: string | undefined
  inputProps: StringInputProps
}

/** @public */
declare type StringFormNode<S extends StringSchemaType = StringSchemaType> = BaseFormNode<string, S>

/**
 * @hidden
 * @public */
declare interface StringInputProps<S extends StringSchemaType = StringSchemaType>
  extends BaseInputProps,
    StringFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * Document Pane specific URL search parameters, they should not persist when
 * navigating between the document pane and document list pane
 * @public
 */
export declare interface StructureDocumentPaneParams extends InspectorTab {
  inspect?: string
  parentRefPath?: string
  path?: string
  rev?: string
  since?: string
  template?: string
  templateParams?: string
  version?: string
  view?: string
  pathKey?: string
  instruction?: string
  comment?: string
}

/**
 * @hidden
 * @beta */
declare interface StudioComponentsPluginOptions {
  activeToolLayout?: ComponentType<ActiveToolLayoutProps>
  layout?: ComponentType<LayoutProps>
  /**
   * @deprecated Add custom icons on a per-workspace basis by customizing workspace `icon` instead.
   * @see {@link https://www.sanity.io/docs/workspaces}
   */
  logo?: ComponentType<LogoProps>
  navbar?: ComponentType<NavbarProps>
  toolMenu?: ComponentType<ToolMenuProps>
}

/** @public */
declare interface StudioTheme
  extends Omit<
    RootTheme,
    | 'avatar'
    | 'button'
    | 'container'
    | 'focusRing'
    | 'input'
    | 'layer'
    | 'media'
    | 'radius'
    | 'shadows'
    | 'space'
    | 'styles'
    | 'color'
    | 'fonts'
  > {
  /** @internal */
  __dark?: boolean
  /** @internal */
  __legacy?: boolean
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  avatar?: RootTheme['avatar']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  button?: RootTheme['button']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  container?: RootTheme['container']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  focusRing?: RootTheme['focusRing']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  input?: RootTheme['input']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  layer?: RootTheme['layer']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  media?: RootTheme['media']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  radius?: RootTheme['radius']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  shadows?: RootTheme['shadows']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  space?: RootTheme['space']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  styles?: RootTheme['styles']
  color?: RootTheme['color']
  fonts?: RootTheme['fonts']
}

/**
 * System bundles are sets of documents owned by the system.
 *
 * - Draft documents contain data that has not yet been published. These documents all exist in the "drafts" path.
 * - Published documents contain data that has been published. These documents all exist in the root path.
 *
 * These differ to user bundles, which are created when a user establishes a custom set of documents
 * (e.g. by creating a release).
 *
 * @public
 */
declare type SystemBundle = 'drafts' | 'published'

/**
 * A value representing a perspective, including the data describing it. This is either the name of a
 * system bundle, or a document describing a release.
 *
 * @public
 */
declare type TargetPerspective = ReleaseDocument | SystemBundle

/**
 * An initial value template is a template that can be used to create a new documents.
 *
 * This allows a document type to have multiple different starting values while having the same
 * shared schema definition. Using parameters allows for dynamic template values.
 *
 * As the name implies, these are _initial_ values, not _default_ values. The distinction is that
 * the initial value is only set when the document is created - it is not "merged" into existing
 * documents that may lack values for fields.
 *
 * All document types will by default (automatically, behind the scenes) have an initial value
 * template generated for them, which will have the same ID as the schema type name. The value of
 * this template will be the value of the `initialValue` property on the schema type definition,
 * or an empty object if none is set.
 *
 * @public
 */
declare interface Template<Params = any, Value = any> {
  /**
   * Template ID. Automatically generated templates will have the same ID as the schema type name.
   */
  id: string
  /**
   * Template title.
   */
  title: string
  i18n?: I18nTextRecord<'title'>
  /**
   * Schema type name the template belongs to. For the automatically generated templates,
   * this will be equal to the `id` property.
   */
  schemaType: string
  /**
   * Template icon. Rendered in places such as the "new document" dialog. Optional.
   * Inferred from the schema type icon if not set.
   */
  icon?: SchemaType['icon']
  /**
   * Value to use as initial value. Can either be a static object value, or a function that
   * resolves _to_ an object value. If using a function, it can be given a set of parameters,
   * which can then determine the value that is returned.
   */
  value: InitialValueProperty<Params, Value>
  /**
   * Array of parameters the template accepts. Currently not used (any parameters are accepted),
   * but by defining parameters, the templates that require parameters can be identified and
   * excluded from UIs that do not provide them.
   */
  parameters?: TemplateParameter[]
  /**
   * Template description. Rendered in places such as the "new document" dialog. Optional.
   *
   * @deprecated No longer used
   */
  description?: string
}

/** @public */
declare type TemplateArrayFieldDefinition = TemplateFieldDefinition & {
  type: 'array'
  /** Defines items that are definition of. See {@link TemplateReferenceTarget} and {@link TypeTarget} */
  of: (TemplateReferenceTarget | TypeTarget)[]
}

/**
 * Field definition for a template parameter.
 * Closely resembles API used to define fields for object schema types.
 *
 * @public
 */
declare interface TemplateFieldDefinition {
  /**
   * Parameter name. Must be unique within the template.
   */
  name: string
  /**
   * Parameter type, eg `string`, `number`, `boolean` etc.
   */
  type: string
  /**
   * Parameter type. Will be attempted to be automatically set if not given,
   * by title-casing the `name` property.
   */
  title?: string
  /**
   * Description for the parameter. Optional.
   * May be used in the future to explain the parameter in UIs.
   */
  description?: string
  /**
   * Optional bag of options for the parameter. Currently unused.
   */
  options?: {
    [key: string]: any
  }
}

/**
 * Represents the items that can appear in different parts of the Sanity studio when creating
 * new documents - examples being the "New document" button in the navigation bar,
 * the corresponding button in panes, as well as the "Create new" button on references.
 *
 * Differs from an actual _template_ in that a single template can be pointed at by multiple
 * different items. This is useful when the template can create different values based on
 * passed parameters.
 *
 * @public
 */
declare interface TemplateItem {
  /**
   * ID for the template. Must be unique within the set of templates.
   */
  templateId: string
  /**
   * Title for the item.
   * Defaults to the title of the associated template.
   */
  title?: string
  i18n?: I18nTextRecord<'title'>
  /**
   * Parameters for the template - an object of any JSON-serializable values
   */
  parameters?: {
    [key: string]: any
  }
  /**
   * React icon for the item, if any.
   * Defaults to the icon for the associated template.
   */
  icon?: React.ElementType | React.JSX.Element
  /**
   * Experimental: not fully supported yet
   * Hints at what the document ID for the new document should be.
   * Leave undefined to let the system decide.
   *
   * @experimental
   * @beta
   * @hidden
   */
  initialDocumentId?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  subtitle?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  description?: string
}

/**
 * Parameter for a template. Closely resembles API used to define fields for object schema types.
 * See {@link TemplateFieldDefinition} and {@link TemplateArrayFieldDefinition}
 * @public
 */
declare type TemplateParameter = TemplateFieldDefinition | TemplateArrayFieldDefinition

/** @public */
declare interface TemplateReferenceTarget {
  type: 'reference'
  /** Type to reference. See {@link TypeTarget} */
  to: TypeTarget | TypeTarget[]
}

/** @public */
declare type TemplateResolver = ComposableOption<Template[], ConfigContext>

/**
 * A tool can be thought of as a top-level "view" or "app".
 * They are available through the global menu bar, and has a URL route associated with them.
 *
 * In essence, a tool is a React component that is rendered when the tool is active,
 * along with a title, name (URL segment) and icon.
 *
 * Tools can handle {@link structure.Intent | intents} such as "edit" or "create" by defining a
 * function for the `canHandleIntent` property, as well as the `getIntentState` property,
 * which defines what an intent will be mapped to in terms of the tool's URL state.
 *
 * @public
 */
declare interface Tool<Options = any> {
  /**
   * The React component that renders the tool.
   */
  component: ComponentType<{
    tool: Tool<Options>
  }>
  /**
   * React component for the icon representing the tool.
   */
  icon?: ComponentType
  /**
   * The name of the tool, used as part of the URL.
   */
  name: string
  /**
   * Options are passed through from the configuration to the component defined by the `component`
   */
  options?: Options
  /**
   * The router for the tool. See {@link router.Router}
   */
  router?: Router
  /**
   * Title of the tool - used for the navigation menu item, along with the icon.
   */
  title: string
  /**
   * Determines whether the tool will control the `document.title`.
   */
  controlsDocumentTitle?: boolean
  /**
   * Gets the state for the given intent.
   *
   * @param intent - The intent to get the state for.
   * @param params - The parameters for the intent.
   * @param routerState - The current router state. See {@link router.RouterState}
   * @param payload - The payload for the intent.
   * @returns The state for the intent.
   */
  getIntentState?: (
    intent: string,
    params: Record<string, string>,
    routerState: RouterState | undefined,
    payload: unknown,
  ) => unknown
  /**
   * Determines whether the tool can handle the given intent.
   *
   * Can either return a boolean, or an object where the keys represent the parameters that
   * can/can not be handled. This will be used to determine whether or not a tool is the best
   * suited to handle an intent. Note that an object of only `false` values (or an empty object)
   * is treated as `true`, so you want to explicitly return `false` if you know the intent cannot
   * fulfill the intent request.
   *
   * @param intent - The intent to check.
   * @param params - The parameters for the intent.
   * @param payload - The payload for the intent.
   * @returns Boolean: whether it can handle the intent. Object: Values representing what specific parameters can be handled.
   */
  canHandleIntent?: (
    intent: string,
    params: Record<string, unknown>,
    payload: unknown,
  ) =>
    | boolean
    | {
        [key: string]: boolean
      }
}

/**
 * @hidden
 * @beta */
declare interface ToolMenuProps {
  activeToolName?: string
  closeSidebar: () => void
  context: 'sidebar' | 'topbar'
  isSidebarOpen: boolean
  tools: Tool[]
  renderDefault: (props: ToolMenuProps) => React.JSX.Element
}

declare interface TransactionSyncLockState {
  enabled: boolean
}

/**
 * This error may happen if the _type of the value is different from the declared schema type
 * It represents a case where we encounter field value that is structurally compatible with the field's defined schema type
 * (e.g. they are both json objects), but the _type name is different from what the schema type expects
 *
 * Note on compatibility: The schema of a field may be defined as an object with fields (a, b, c), but the value is an object with (d, e, f)
 * These are still structurally compatible because (d, e, f) will be considered undeclared members
 *
 * @public
 */
declare type TypeAnnotationMismatchError = {
  type: 'TYPE_ANNOTATION_MISMATCH'
  expectedSchemaType: SchemaType
  resolvedValueType: string
}

/**
 * @public
 */
declare interface TypeTarget {
  type: string
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type UndeclaredMembersError = {
  type: 'UNDECLARED_MEMBERS'
  schemaType: ArraySchemaType
}

/**
 *
 * @hidden
 * @beta
 */
declare type Uploader<S extends SchemaType = SchemaType> = {
  type: string
  accepts: string
  upload: (
    client: SanityClient,
    file: File,
    type: S,
    options?: UploadOptions,
  ) => Observable<UploadProgressEvent>
  priority: number
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploaderResolver<S extends SchemaType = SchemaType> = (
  type: S,
  file: FileLike,
) => Uploader<S> | null

/**
 * @hidden
 * @beta */
declare interface UploadEvent {
  file: File
  schemaType: SchemaType
  uploader: Uploader
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadOptions = {
  metadata?: AssetMetadataType[]
  storeOriginalFilename?: boolean
  label?: string
  title?: string
  description?: string
  creditLine?: string
  source?: AssetSourceSpec
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadProgressEvent = {
  type: 'uploadProgress'
  patches: FormPatch[] | null
}

/** @public */
export declare function usePresentationNavigate(): PresentationNavigateContextValue

/** @public */
export declare function usePresentationParams(throwOnMissingContext?: true): PresentationParams

/** @public */
export declare function usePresentationParams(
  throwOnMissingContext: false,
): PresentationParams | null

/** @public */
export declare const useSharedState: (key: string, value: Serializable) => undefined

/**
 * @hidden
 * @beta */
declare interface ValidationStatus {
  isValidating: boolean
  validation: ValidationMarker[]
  revision?: string
}

/** @beta */
declare interface WelcomeEvent {
  type: 'welcome'
  listenerName: string
}

/**
 * @hidden
 * @beta */
declare type WithVersion<T> = T & {
  version: DocumentVariantType
}

/**
 * @hidden
 * @beta
 */
declare interface WorkspaceOptions extends SourceOptions {
  basePath: string
  subtitle?: string
  /**
   * The workspace logo
   *
   * @deprecated Custom logo components are no longer supported.
   * Users are encouraged to provide custom components for individual workspace icons instead.
   */
  logo?: ComponentType
  icon?: ComponentType
  /**
   * @hidden
   * @beta
   */
  theme?: StudioTheme
  /**
   * @hidden
   * @beta
   */
  unstable_sources?: SourceOptions[]
  /**
   * @deprecated Use `tasks` instead
   */
  unstable_tasks?: DefaultPluginsWorkspaceOptions['tasks']
  /**
   * @internal
   */
  tasks?: DefaultPluginsWorkspaceOptions['tasks']
  /**
   * @internal
   */
  releases?: DefaultPluginsWorkspaceOptions['releases']
  /**
   * @internal
   */
  mediaLibrary?: DefaultPluginsWorkspaceOptions['mediaLibrary']
  apps?: AppsOptions
  /**
   * @hidden
   * @internal
   */
  __internal_serverDocumentActions?: {
    /**
     * @deprecated The Mutations API integration will be removed in a future release.
     */
    enabled?: boolean
  }
  /**
   * @hidden
   * @internal
   */
  [QUOTA_EXCLUDED_RELEASES_ENABLED]?: boolean
  /**
   * @beta
   */
  [DECISION_PARAMETERS_SCHEMA]?: DecisionParametersConfig
  scheduledPublishing?: DefaultPluginsWorkspaceOptions['scheduledPublishing']
}

export {}
