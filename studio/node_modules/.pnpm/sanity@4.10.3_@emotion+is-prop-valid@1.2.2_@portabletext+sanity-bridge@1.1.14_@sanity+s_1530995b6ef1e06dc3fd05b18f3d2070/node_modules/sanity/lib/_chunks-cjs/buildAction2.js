"use strict";
var path = require("node:path"), chalk = require("chalk"), logSymbols = require("log-symbols"), semver = require("semver"), telemetry = require("@sanity/telemetry"), rimraf = require("rimraf"), previewServer = require("./previewServer.js");
require("./runtime.js");
var upgradePackages = require("./upgradePackages.js"), timing = require("./timing.js"), moduleFormatUtils = require("./moduleFormatUtils.js"), warnAboutMissingAppId = require("./warnAboutMissingAppId.js"), _internal = require("./_internal.js"), getAppId = require("./getAppId.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var path__default = /* @__PURE__ */ _interopDefaultCompat(path), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), semver__default = /* @__PURE__ */ _interopDefaultCompat(semver);
const BuildTrace = telemetry.defineTrace({
  name: "Studio Build Completed",
  version: 0,
  description: "A Studio build completed"
});
async function buildSanityStudio(args, context, overrides) {
  const timer = timing.getTimer(), {
    output,
    prompt,
    workDir,
    cliConfig,
    telemetry: telemetry$1 = telemetry.noopLogger,
    cliConfigPath
  } = context, flags = {
    minify: !0,
    stats: !1,
    "source-maps": !1,
    ...args.extOptions
  }, unattendedMode = !!(flags.yes || flags.y), defaultOutputDir = path__default.default.resolve(path__default.default.join(workDir, "dist")), outputDir = path__default.default.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
  await upgradePackages.checkStudioDependencyVersions(workDir);
  const {
    didInstall,
    installedSanityVersion
  } = await upgradePackages.checkRequiredDependencies(context);
  if (didInstall)
    return {
      didCompile: !1
    };
  const autoUpdatesEnabled = warnAboutMissingAppId.shouldAutoUpdate({
    flags,
    cliConfig,
    output
  });
  let autoUpdatesImports = {};
  if (autoUpdatesEnabled) {
    const cleanSanityVersion = semver__default.default.parse(installedSanityVersion)?.version;
    if (!cleanSanityVersion)
      throw new Error(`Failed to parse installed Sanity version: ${installedSanityVersion}`);
    const sanityDependencies = [{
      name: "sanity",
      version: cleanSanityVersion
    }, {
      name: "@sanity/vision",
      version: cleanSanityVersion
    }], appId = getAppId.getAppId({
      cliConfig,
      output
    });
    autoUpdatesImports = warnAboutMissingAppId.getAutoUpdatesImportMap(sanityDependencies, {
      appId
    }), output.print(`${logSymbols.info} Building with auto-updates enabled`), args.groupOrCommand !== "deploy" && !appId && warnAboutMissingAppId.warnAboutMissingAppId({
      appType: "studio",
      cliConfigPath,
      output,
      projectId: cliConfig?.api?.projectId
    });
    const result = await warnAboutMissingAppId.compareDependencyVersions(sanityDependencies, workDir);
    if (result?.length) {
      const warning = `The following local package versions are different from the versions currently served at runtime.
When using auto updates, we recommend that you test locally with the same versions before deploying. 

${result.map((mod) => ` - ${mod.pkg} (local version: ${mod.installed}, runtime version: ${mod.remote})`).join(`
`)} 

`;
      if (_internal.isInteractive && !unattendedMode) {
        const choice = await prompt.single({
          type: "list",
          message: chalk__default.default.yellow(`${warning}

Do you want to upgrade local versions before deploying?`),
          choices: [{
            type: "choice",
            value: "upgrade",
            name: `Upgrade local versions (recommended). You will need to run the ${args.groupOrCommand} command again`
          }, {
            type: "choice",
            value: "upgrade-and-proceed",
            name: `Upgrade and proceed with ${args.groupOrCommand}`
          }, {
            type: "choice",
            value: "continue",
            name: "Continue anyway"
          }, {
            type: "choice",
            name: "Cancel",
            value: "cancel"
          }],
          default: "upgrade-and-proceed"
        });
        if (choice === "cancel")
          return {
            didCompile: !1
          };
        if ((choice === "upgrade" || choice === "upgrade-and-proceed") && (await upgradePackages.upgradePackages({
          packageManager: (await upgradePackages.getPackageManagerChoice(workDir, {
            interactive: !1
          })).chosen,
          packages: result.map((res) => [res.pkg, res.remote])
        }, context), choice !== "upgrade-and-proceed"))
          return {
            didCompile: !1
          };
      } else
        console.warn(`WARNING: ${warning}`);
    }
  }
  const envVarKeys = getSanityEnvVars();
  envVarKeys.length > 0 && (output.print(`
Including the following environment variables as part of the JavaScript bundle:`), envVarKeys.forEach((key) => output.print(`- ${key}`)), output.print(""));
  let shouldClean = !0;
  outputDir !== defaultOutputDir && !unattendedMode && (shouldClean = await prompt.single({
    type: "confirm",
    message: `Do you want to delete the existing directory (${outputDir}) first?`,
    default: !0
  }));
  let basePath = "/";
  const envBasePath = process.env.SANITY_STUDIO_BASEPATH, configBasePath = cliConfig?.project?.basePath;
  overrides?.basePath ? basePath = overrides.basePath : envBasePath ? basePath = envBasePath : configBasePath && (basePath = configBasePath), envBasePath && configBasePath && output.warn(`Overriding configured base path (${configBasePath}) with value from environment variable (${envBasePath})`);
  let spin;
  if (shouldClean) {
    timer.start("cleanOutputFolder"), spin = output.spinner("Clean output folder").start(), await rimraf.rimraf(outputDir);
    const cleanDuration = timer.end("cleanOutputFolder");
    spin.text = `Clean output folder (${cleanDuration.toFixed()}ms)`, spin.succeed();
  }
  spin = output.spinner("Build Sanity Studio").start();
  const trace = telemetry$1.trace(BuildTrace);
  trace.start();
  let importMap;
  autoUpdatesEnabled && (importMap = {
    imports: {
      ...await moduleFormatUtils.buildVendorDependencies({
        cwd: workDir,
        outputDir,
        basePath
      }),
      ...autoUpdatesImports
    }
  });
  try {
    timer.start("bundleStudio");
    const bundle = await previewServer.buildStaticFiles({
      cwd: workDir,
      outputDir,
      basePath,
      sourceMap: !!flags["source-maps"],
      minify: !!flags.minify,
      vite: cliConfig && "vite" in cliConfig ? cliConfig.vite : void 0,
      importMap,
      reactCompiler: cliConfig && "reactCompiler" in cliConfig ? cliConfig.reactCompiler : void 0,
      entry: cliConfig && "app" in cliConfig ? cliConfig.app?.entry : void 0
    });
    trace.log({
      outputSize: bundle.chunks.flatMap((chunk) => chunk.modules.flatMap((mod) => mod.renderedLength)).reduce((sum, n) => sum + n, 0)
    });
    const buildDuration = timer.end("bundleStudio");
    spin.text = `Build Sanity Studio (${buildDuration.toFixed()}ms)`, spin.succeed(), trace.complete(), flags.stats && (output.print(`
Largest module files:`), output.print(moduleFormatUtils.formatModuleSizes(moduleFormatUtils.sortModulesBySize(bundle.chunks).slice(0, 15))));
  } catch (err) {
    throw spin.fail(), trace.error(err), err;
  }
  return {
    didCompile: !0
  };
}
function getSanityEnvVars(env = process.env) {
  return Object.keys(env).filter((key) => key.toUpperCase().startsWith("SANITY_STUDIO_"));
}
exports.default = buildSanityStudio;
//# sourceMappingURL=buildAction2.js.map
