{"version":3,"file":"helpers.js","sources":["../../src/_internal/cli/actions/deploy/helpers.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport {PassThrough} from 'node:stream'\nimport {type Gzip} from 'node:zlib'\n\nimport {type CliCommandContext, type CliOutputter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport FormData from 'form-data'\nimport {customAlphabet} from 'nanoid'\nimport readPkgUp from 'read-pkg-up'\n\nimport {debug as debugIt} from '../../debug'\nimport {determineIsApp} from '../../util/determineIsApp'\n\nexport const debug = debugIt.extend('deploy')\n\n// TODO: replace with `Promise.withResolvers()` once it lands in node\nfunction promiseWithResolvers<T>() {\n  let resolve!: (t: T) => void\n  let reject!: (err: unknown) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {promise, resolve, reject}\n}\n\nexport interface ActiveDeployment {\n  deployedAt: string\n  deployedBy: string\n  isActiveDeployment: boolean\n  isAutoUpdating: boolean | null\n  size: string | null\n  createdAt: string\n  updatedAt: string\n  version: string\n}\n\nexport interface UserApplication {\n  id: string\n  projectId: string | null\n  organizationId: string | null\n  title: string | null\n  appHost: string\n  urlType: 'internal' | 'external'\n  createdAt: string\n  updatedAt: string\n  type: 'studio' | 'coreApp'\n  activeDeployment?: ActiveDeployment | null\n}\n\nexport interface GetUserApplicationsOptions {\n  client: SanityClient\n  organizationId?: string\n}\n\nexport interface GetUserApplicationOptions {\n  client: SanityClient\n  appHost?: string\n  appId?: string\n  isSdkApp?: boolean\n}\nexport async function getUserApplication({\n  client,\n  appHost,\n  appId,\n  isSdkApp,\n}: GetUserApplicationOptions): Promise<UserApplication | null> {\n  let query: undefined | Record<string, string>\n\n  const uri = appId ? `/user-applications/${appId}` : '/user-applications'\n\n  if (isSdkApp) {\n    query = {appType: 'coreApp'}\n  } else if (!appId) {\n    // either request the app by host or get the default app\n    query = appHost ? {appHost} : {default: 'true'}\n  }\n  try {\n    return await client.request({\n      uri,\n      query,\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\nexport async function getUserApplications({\n  client,\n  organizationId,\n}: GetUserApplicationsOptions): Promise<UserApplication[] | null> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  try {\n    return await client.request({\n      uri: '/user-applications',\n      query,\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user applications', e)\n    throw e\n  }\n}\n\nfunction createUserApplication(\n  client: SanityClient,\n  body: Pick<UserApplication, 'appHost' | 'urlType' | 'type'> & {\n    title?: string\n  },\n  organizationId?: string,\n): Promise<UserApplication> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  return client.request({uri: '/user-applications', method: 'POST', body, query})\n}\n\ninterface SelectApplicationOptions {\n  client: SanityClient\n  prompt: GetOrCreateUserApplicationOptions['context']['prompt']\n  message: string\n  createNewLabel: string\n  organizationId?: string\n}\n\n/**\n * Shared utility for selecting an existing application or opting to create a new one\n * @internal\n */\nasync function selectExistingApplication({\n  client,\n  prompt,\n  message,\n  createNewLabel,\n  organizationId,\n}: SelectApplicationOptions): Promise<UserApplication | null> {\n  const userApplications = await getUserApplications({client, organizationId})\n\n  if (!userApplications?.length) {\n    return null\n  }\n\n  const choices = userApplications.map((app) => ({\n    value: app.appHost,\n    name: app.title ?? app.appHost,\n  }))\n\n  const selected = await prompt.single({\n    message,\n    type: 'list',\n    choices: [...choices, new prompt.Separator(), {value: 'new', name: createNewLabel}],\n  })\n\n  if (selected === 'new') {\n    return null\n  }\n\n  return userApplications.find((app) => app.appHost === selected)!\n}\n\nexport interface GetOrCreateUserApplicationOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\n/**\n * These functions handle the logic for managing user applications when\n * studioHost is not provided in the CLI config.\n *\n * @internal\n *\n *    +-------------------------------+\n *    |   Fetch Existing user-app?   |\n *    +---------+--------------------+\n *              |\n *        +-----+-----+\n *        |           |\n *        v           v\n *   +---------+  +-------------------------+\n *   | Return  |  | Fetch all user apps     |\n *   | user-app|  +-------------------------+\n *   +---------+            |\n *                          v\n *           +---------------------------+\n *           |  User apps found?         |\n *           +-----------+---------------+\n *                       |\n *                +------v------+\n *                |             |\n *                v             v\n *   +--------------------+  +------------------------+\n *   | Show list and      |  | Prompt for hostname    |\n *   | prompt selection   |  | and create new app     |\n *   +--------------------+  +------------------------+\n */\nexport async function getOrCreateStudio({\n  client,\n  spinner,\n  context,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {output, prompt} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select existing studio hostname',\n    createNewLabel: 'Create new studio hostname',\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // otherwise, prompt the user for a hostname\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print('To deploy your Sanity Studio to our hosted sanity.studio service,')\n  output.print('you will need one. Please enter the part you want to use.')\n\n  const {promise, resolve} = promiseWithResolvers<UserApplication>()\n\n  await prompt.single({\n    type: 'input',\n    filter: (inp: string) => inp.replace(/\\.sanity\\.studio$/i, ''),\n    message: 'Studio hostname (<value>.sanity.studio):',\n    // if a string is returned here, it is relayed to the user and prompt allows\n    // the user to try again until this function returns true\n    validate: async (appHost: string) => {\n      try {\n        const response = await createUserApplication(client, {\n          appHost,\n          urlType: 'internal',\n          type: 'studio',\n        })\n        resolve(response)\n        return true\n      } catch (e) {\n        // if the name is taken, it should return a 409 so we relay to the user\n        if ([402, 409].includes(e?.statusCode)) {\n          return e?.response?.body?.message || 'Bad request' // just in case\n        }\n\n        debug('Error creating user application', e)\n        // otherwise, it's a fatal error\n        throw e\n      }\n    },\n  })\n\n  return await promise\n}\n\n/**\n * Creates a core application with an auto-generated hostname\n *\n * @internal\n */\nexport async function getOrCreateApplication({\n  client,\n  context,\n  spinner,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {prompt, cliConfig} = context\n  const organizationId = cliConfig && 'app' in cliConfig && cliConfig.app?.organizationId\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select an existing deployed application',\n    createNewLabel: 'Create new deployed application',\n    organizationId: organizationId || undefined,\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // First get the title from the user\n  const title = await prompt.single({\n    type: 'input',\n    message: 'Enter a title for your application:',\n    validate: (input: string) => input.length > 0 || 'Title is required',\n  })\n\n  const {promise, resolve, reject} = promiseWithResolvers<UserApplication>()\n\n  // Try to create the application, retrying with new hostnames if needed\n  const tryCreateApp = async () => {\n    // appHosts have some restrictions (no uppercase, must start with a letter)\n    const generateId = () => {\n      const letters = 'abcdefghijklmnopqrstuvwxyz'\n      const firstChar = customAlphabet(letters, 1)()\n      const rest = customAlphabet('abcdefghijklmnopqrstuvwxyz0123456789', 11)()\n      return `${firstChar}${rest}`\n    }\n\n    // we will likely prepend this with an org ID or other parameter in the future\n    const appHost = generateId()\n\n    try {\n      const response = await createUserApplication(\n        client,\n        {\n          appHost,\n          urlType: 'internal',\n          title,\n          type: 'coreApp',\n        },\n        organizationId || undefined,\n      )\n      resolve(response)\n      return true\n    } catch (e) {\n      // if the name is taken, generate a new one and try again\n      if ([402, 409].includes(e?.statusCode)) {\n        debug('App host taken, retrying with new host')\n        return tryCreateApp()\n      }\n\n      debug('Error creating core application', e)\n      reject(e)\n      // otherwise, it's a fatal error\n      throw e\n    }\n  }\n\n  spinner.start('Creating application')\n\n  await tryCreateApp()\n  const response = await promise\n\n  spinner.succeed()\n  return response\n}\n\nexport interface BaseConfigOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\ntype UserApplicationConfigOptions = BaseConfigOptions &\n  (\n    | {\n        /**\n         * @deprecated – appHost is replaced by appId, but kept for backwards compat\n         */\n        appHost: string | undefined\n        appId: undefined\n      }\n    | {\n        appId: string | undefined\n        /**\n         * @deprecated – appHost is replaced by appId, but kept for backwards compat\n         */\n        appHost: undefined\n      }\n  )\n\nasync function getOrCreateStudioFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n  appId,\n}: UserApplicationConfigOptions): Promise<UserApplication> {\n  const {output} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client, appId, appHost})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  if (!appHost) {\n    throw new Error(`Application not found. Application with id ${appId} does not exist`)\n  }\n\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print(`Creating https://${appHost}.sanity.studio`)\n  output.print('')\n  spinner.start('Creating studio hostname')\n\n  try {\n    const response = await createUserApplication(client, {\n      appHost,\n      urlType: 'internal',\n      type: 'studio',\n    })\n    spinner.succeed()\n    return response\n  } catch (e) {\n    spinner.fail()\n    // if the name is taken, it should return a 409 so we relay to the user\n    if ([402, 409].includes(e?.statusCode)) {\n      throw new Error(e?.response?.body?.message || 'Bad request', {cause: e}) // just in case\n    }\n    debug('Error creating user application from config', e)\n    // otherwise, it's a fatal error\n    throw e\n  }\n}\n\nasync function getOrCreateAppFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n  appId,\n}: UserApplicationConfigOptions): Promise<UserApplication> {\n  const {output, cliConfig} = context\n  if (appId) {\n    const existingUserApplication = await getUserApplication({\n      client,\n      appId,\n      appHost,\n      isSdkApp: determineIsApp(cliConfig),\n    })\n    spinner.succeed()\n\n    if (existingUserApplication) {\n      return existingUserApplication\n    }\n  }\n\n  // custom apps cannot arbitrarily create ids or hosts, so send them to create option\n  output.print('The id provided in your configuration is not recognized.')\n  output.print('Checking existing applications...')\n  return getOrCreateApplication({client, context, spinner})\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost or appId is provided in the CLI config.\n *\n * @internal\n */\nexport async function getOrCreateUserApplicationFromConfig(\n  options: UserApplicationConfigOptions,\n): Promise<UserApplication> {\n  const {context, appId, appHost} = options\n  const isSdkApp = determineIsApp(context.cliConfig)\n\n  if (isSdkApp) {\n    return getOrCreateAppFromConfig(options)\n  }\n\n  if (!appId && !appHost) {\n    throw new Error(\n      'Studio was detected, but neither appId or appHost (deprecated) found in CLI config',\n    )\n  }\n\n  return getOrCreateStudioFromConfig(options)\n}\n\nexport interface CreateDeploymentOptions {\n  client: SanityClient\n  applicationId: string\n  version: string\n  isAutoUpdating: boolean\n  tarball: Gzip\n  isSdkApp?: boolean\n}\n\nexport async function createDeployment({\n  client,\n  tarball,\n  applicationId,\n  isAutoUpdating,\n  version,\n  isSdkApp,\n}: CreateDeploymentOptions): Promise<{location: string}> {\n  const formData = new FormData()\n  formData.append('isAutoUpdating', isAutoUpdating.toString())\n  formData.append('version', version)\n  formData.append('tarball', tarball, {contentType: 'application/gzip', filename: 'app.tar.gz'})\n\n  return client.request({\n    uri: `/user-applications/${applicationId}/deployments`,\n    method: 'POST',\n    headers: formData.getHeaders(),\n    body: formData.pipe(new PassThrough()),\n    query: isSdkApp ? {appType: 'coreApp'} : {appType: 'studio'},\n  })\n}\n\nexport interface DeleteUserApplicationOptions {\n  client: SanityClient\n  applicationId: string\n  appType: 'coreApp' | 'studio'\n}\n\nexport async function deleteUserApplication({\n  applicationId,\n  client,\n  appType,\n}: DeleteUserApplicationOptions): Promise<void> {\n  await client.request({\n    uri: `/user-applications/${applicationId}`,\n    query: {\n      appType,\n    },\n    method: 'DELETE',\n  })\n}\n\nexport async function getInstalledSanityVersion(): Promise<string> {\n  const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path\n  if (!sanityPkgPath) {\n    throw new Error('Unable to resolve `sanity` module root')\n  }\n\n  const pkg = JSON.parse(await fs.readFile(sanityPkgPath, 'utf-8'))\n  if (typeof pkg?.version !== 'string') {\n    throw new Error('Unable to find version of `sanity` module')\n  }\n  return pkg.version\n}\n\nexport async function dirIsEmptyOrNonExistent(sourceDir: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return true\n    }\n\n    throw err\n  }\n\n  const content = await fs.readdir(sourceDir)\n  return content.length === 0\n}\n\nexport async function checkDir(sourceDir: string): Promise<void> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    const error = err.code === 'ENOENT' ? new Error(`Directory \"${sourceDir}\" does not exist`) : err\n\n    throw error\n  }\n\n  try {\n    await fs.stat(path.join(sourceDir, 'index.html'))\n  } catch (err) {\n    const error =\n      err.code === 'ENOENT'\n        ? new Error(\n            [\n              `\"${sourceDir}/index.html\" does not exist -`,\n              '[SOURCE_DIR] must be a directory containing',\n              'a Sanity studio built using \"sanity build\"',\n            ].join(' '),\n          )\n        : err\n\n    throw error\n  }\n}\n"],"names":["debug","debugIt","extend","promiseWithResolvers","resolve","reject","promise","Promise","res","rej","getUserApplication","client","appHost","appId","isSdkApp","query","uri","appType","default","request","e","statusCode","getUserApplications","organizationId","createUserApplication","body","method","selectExistingApplication","prompt","message","createNewLabel","userApplications","length","choices","map","app","value","name","title","selected","single","type","Separator","find","getOrCreateStudio","spinner","context","output","existingUserApplication","succeed","selectedApp","print","filter","inp","replace","validate","response","urlType","includes","getOrCreateApplication","cliConfig","undefined","input","tryCreateApp","generateId","firstChar","customAlphabet","rest","start","getOrCreateStudioFromConfig","Error","fail","cause","getOrCreateAppFromConfig","determineIsApp","getOrCreateUserApplicationFromConfig","options","createDeployment","tarball","applicationId","isAutoUpdating","version","formData","FormData","append","toString","contentType","filename","headers","getHeaders","pipe","PassThrough","deleteUserApplication","getInstalledSanityVersion","sanityPkgPath","readPkgUp","cwd","__dirname","path","pkg","JSON","parse","fs","readFile","dirIsEmptyOrNonExistent","sourceDir","stat","isDirectory","err","code","readdir","checkDir","join"],"mappings":";;;;;;AAcO,MAAMA,QAAQC,UAAAA,MAAQC,OAAO,QAAQ;AAG5C,SAASC,uBAA0B;AACjC,MAAIC,SACAC;AAKJ,SAAO;AAAA,IAACC,SAJQ,IAAIC,QAAW,CAACC,KAAKC,QAAQ;AAC3CL,gBAAUI,KACVH,SAASI;AAAAA,IACX,CAAC;AAAA,IACgBL;AAAAA,IAASC;AAAAA,EAAAA;AAC5B;AAqCA,eAAsBK,mBAAmB;AAAA,EACvCC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AACyB,GAAoC;AAC7D,MAAIC;AAEJ,QAAMC,MAAMH,QAAQ,sBAAsBA,KAAK,KAAK;AAEhDC,aACFC,QAAQ;AAAA,IAACE,SAAS;AAAA,EAAA,IACRJ,UAEVE,QAAQH,UAAU;AAAA,IAACA;AAAAA,EAAAA,IAAW;AAAA,IAACM,SAAS;AAAA,EAAA;AAE1C,MAAI;AACF,WAAO,MAAMP,OAAOQ,QAAQ;AAAA,MAC1BH;AAAAA,MACAD;AAAAA,IAAAA,CACD;AAAA,EACH,SAASK,GAAG;AACV,QAAIA,GAAGC,eAAe;AACpB,aAAO;AAGTrB,UAAAA,MAAM,kCAAkCoB,CAAC,GACnCA;AAAAA,EACR;AACF;AACA,eAAsBE,oBAAoB;AAAA,EACxCX;AAAAA,EACAY;AAC0B,GAAsC;AAChE,QAAMR,QAAgCQ,iBAClC;AAAA,IAACA;AAAAA,IAAgCN,SAAS;AAAA,EAAA,IAC1C;AAAA,IAACA,SAAS;AAAA,EAAA;AACd,MAAI;AACF,WAAO,MAAMN,OAAOQ,QAAQ;AAAA,MAC1BH,KAAK;AAAA,MACLD;AAAAA,IAAAA,CACD;AAAA,EACH,SAASK,GAAG;AACV,QAAIA,GAAGC,eAAe;AACpB,aAAO;AAGTrB,UAAAA,MAAM,mCAAmCoB,CAAC,GACpCA;AAAAA,EACR;AACF;AAEA,SAASI,sBACPb,QACAc,MAGAF,gBAC0B;AAC1B,QAAMR,QAAgCQ,iBAClC;AAAA,IAACA;AAAAA,IAAgCN,SAAS;AAAA,EAAA,IAC1C;AAAA,IAACA,SAAS;AAAA,EAAA;AACd,SAAON,OAAOQ,QAAQ;AAAA,IAACH,KAAK;AAAA,IAAsBU,QAAQ;AAAA,IAAQD;AAAAA,IAAMV;AAAAA,EAAAA,CAAM;AAChF;AAcA,eAAeY,0BAA0B;AAAA,EACvChB;AAAAA,EACAiB;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAP;AACwB,GAAoC;AAC5D,QAAMQ,mBAAmB,MAAMT,oBAAoB;AAAA,IAACX;AAAAA,IAAQY;AAAAA,EAAAA,CAAe;AAE3E,MAAI,CAACQ,kBAAkBC;AACrB,WAAO;AAGT,QAAMC,UAAUF,iBAAiBG,IAAKC,CAAAA,SAAS;AAAA,IAC7CC,OAAOD,IAAIvB;AAAAA,IACXyB,MAAMF,IAAIG,SAASH,IAAIvB;AAAAA,EAAAA,EACvB,GAEI2B,WAAW,MAAMX,OAAOY,OAAO;AAAA,IACnCX;AAAAA,IACAY,MAAM;AAAA,IACNR,SAAS,CAAC,GAAGA,SAAS,IAAIL,OAAOc,aAAa;AAAA,MAACN,OAAO;AAAA,MAAOC,MAAMP;AAAAA,IAAAA,CAAe;AAAA,EAAA,CACnF;AAED,SAAIS,aAAa,QACR,OAGFR,iBAAiBY,KAAMR,CAAAA,QAAQA,IAAIvB,YAAY2B,QAAQ;AAChE;AAsCA,eAAsBK,kBAAkB;AAAA,EACtCjC;AAAAA,EACAkC;AAAAA,EACAC;AACiC,GAA6B;AAC9D,QAAM;AAAA,IAACC;AAAAA,IAAQnB;AAAAA,EAAAA,IAAUkB,SAEnBE,0BAA0B,MAAMtC,mBAAmB;AAAA,IAACC;AAAAA,EAAAA,CAAO;AAKjE,MAFAkC,QAAQI,WAEJD;AACF,WAAOA;AAGT,QAAME,cAAc,MAAMvB,0BAA0B;AAAA,IAClDhB;AAAAA,IACAiB;AAAAA,IACAC,SAAS;AAAA,IACTC,gBAAgB;AAAA,EAAA,CACjB;AAED,MAAIoB;AACF,WAAOA;AAITH,SAAOI,MAAM,uDAAuD,GACpEJ,OAAOI,MAAM,mEAAmE,GAChFJ,OAAOI,MAAM,2DAA2D;AAExE,QAAM;AAAA,IAAC7C;AAAAA,IAASF;AAAAA,EAAAA,IAAWD,qBAAAA;AAE3B,SAAA,MAAMyB,OAAOY,OAAO;AAAA,IAClBC,MAAM;AAAA,IACNW,QAASC,CAAAA,QAAgBA,IAAIC,QAAQ,sBAAsB,EAAE;AAAA,IAC7DzB,SAAS;AAAA;AAAA;AAAA,IAGT0B,UAAU,OAAO3C,YAAoB;AACnC,UAAI;AACF,cAAM4C,WAAW,MAAMhC,sBAAsBb,QAAQ;AAAA,UACnDC;AAAAA,UACA6C,SAAS;AAAA,UACThB,MAAM;AAAA,QAAA,CACP;AACDrC,eAAAA,QAAQoD,QAAQ,GACT;AAAA,MACT,SAASpC,GAAG;AAEV,YAAI,CAAC,KAAK,GAAG,EAAEsC,SAAStC,GAAGC,UAAU;AACnC,iBAAOD,GAAGoC,UAAU/B,MAAMI,WAAW;AAGvC7B,cAAAA,MAAM,mCAAmCoB,CAAC,GAEpCA;AAAAA,MACR;AAAA,IACF;AAAA,EAAA,CACD,GAEM,MAAMd;AACf;AAOA,eAAsBqD,uBAAuB;AAAA,EAC3ChD;AAAAA,EACAmC;AAAAA,EACAD;AACiC,GAA6B;AAC9D,QAAM;AAAA,IAACjB;AAAAA,IAAQgC;AAAAA,EAAAA,IAAad,SACtBvB,iBAAiBqC,aAAa,SAASA,aAAaA,UAAUzB,KAAKZ;AAGzEsB,UAAQI,QAAAA;AAER,QAAMC,cAAc,MAAMvB,0BAA0B;AAAA,IAClDhB;AAAAA,IACAiB;AAAAA,IACAC,SAAS;AAAA,IACTC,gBAAgB;AAAA,IAChBP,gBAAgBA,kBAAkBsC;AAAAA,EAAAA,CACnC;AAED,MAAIX;AACF,WAAOA;AAIT,QAAMZ,QAAQ,MAAMV,OAAOY,OAAO;AAAA,IAChCC,MAAM;AAAA,IACNZ,SAAS;AAAA,IACT0B,UAAWO,CAAAA,UAAkBA,MAAM9B,SAAS,KAAK;AAAA,EAAA,CAClD,GAEK;AAAA,IAAC1B;AAAAA,IAASF;AAAAA,IAASC;AAAAA,EAAAA,IAAUF,qBAAAA,GAG7B4D,eAAe,YAAY;AAU/B,UAAMnD,WARaoD,MAAM;AAEvB,YAAMC,YAAYC,sBADF,8BAC0B,CAAC,KACrCC,OAAOD,OAAAA,eAAe,wCAAwC,EAAE,EAAA;AACtE,aAAO,GAAGD,SAAS,GAAGE,IAAI;AAAA,IAC5B,GAAA;AAKA,QAAI;AACF,YAAMX,YAAW,MAAMhC,sBACrBb,QACA;AAAA,QACEC;AAAAA,QACA6C,SAAS;AAAA,QACTnB;AAAAA,QACAG,MAAM;AAAA,MAAA,GAERlB,kBAAkBsC,MACpB;AACAzD,aAAAA,QAAQoD,SAAQ,GACT;AAAA,IACT,SAASpC,GAAG;AAEV,UAAI,CAAC,KAAK,GAAG,EAAEsC,SAAStC,GAAGC,UAAU;AACnCrB,eAAAA,MAAM,wCAAwC,GACvC+D,aAAAA;AAGT/D,YAAAA,MAAM,mCAAmCoB,CAAC,GAC1Cf,OAAOe,CAAC,GAEFA;AAAAA,IACR;AAAA,EACF;AAEAyB,UAAQuB,MAAM,sBAAsB,GAEpC,MAAML,aAAAA;AACN,QAAMP,WAAW,MAAMlD;AAEvBuC,SAAAA,QAAQI,WACDO;AACT;AA0BA,eAAea,4BAA4B;AAAA,EACzC1D;AAAAA,EACAmC;AAAAA,EACAD;AAAAA,EACAjC;AAAAA,EACAC;AAC4B,GAA6B;AACzD,QAAM;AAAA,IAACkC;AAAAA,EAAAA,IAAUD,SAEXE,0BAA0B,MAAMtC,mBAAmB;AAAA,IAACC;AAAAA,IAAQE;AAAAA,IAAOD;AAAAA,EAAAA,CAAQ;AAKjF,MAFAiC,QAAQI,WAEJD;AACF,WAAOA;AAGT,MAAI,CAACpC;AACH,UAAM,IAAI0D,MAAM,8CAA8CzD,KAAK,iBAAiB;AAGtFkC,SAAOI,MAAM,uDAAuD,GACpEJ,OAAOI,MAAM,oBAAoBvC,OAAO,gBAAgB,GACxDmC,OAAOI,MAAM,EAAE,GACfN,QAAQuB,MAAM,0BAA0B;AAExC,MAAI;AACF,UAAMZ,WAAW,MAAMhC,sBAAsBb,QAAQ;AAAA,MACnDC;AAAAA,MACA6C,SAAS;AAAA,MACThB,MAAM;AAAA,IAAA,CACP;AACDI,WAAAA,QAAQI,WACDO;AAAAA,EACT,SAASpC,GAAG;AAGV,UAFAyB,QAAQ0B,KAAAA,GAEJ,CAAC,KAAK,GAAG,EAAEb,SAAStC,GAAGC,UAAU,IAC7B,IAAIiD,MAAMlD,GAAGoC,UAAU/B,MAAMI,WAAW,eAAe;AAAA,MAAC2C,OAAOpD;AAAAA,IAAAA,CAAE,KAEzEpB,MAAM,+CAA+CoB,CAAC,GAEhDA;AAAAA,EACR;AACF;AAEA,eAAeqD,yBAAyB;AAAA,EACtC9D;AAAAA,EACAmC;AAAAA,EACAD;AAAAA,EACAjC;AAAAA,EACAC;AAC4B,GAA6B;AACzD,QAAM;AAAA,IAACkC;AAAAA,IAAQa;AAAAA,EAAAA,IAAad;AAC5B,MAAIjC,OAAO;AACT,UAAMmC,0BAA0B,MAAMtC,mBAAmB;AAAA,MACvDC;AAAAA,MACAE;AAAAA,MACAD;AAAAA,MACAE,UAAU4D,UAAAA,eAAed,SAAS;AAAA,IAAA,CACnC;AAGD,QAFAf,QAAQI,WAEJD;AACF,aAAOA;AAAAA,EAEX;AAGAD,SAAAA,OAAOI,MAAM,0DAA0D,GACvEJ,OAAOI,MAAM,mCAAmC,GACzCQ,uBAAuB;AAAA,IAAChD;AAAAA,IAAQmC;AAAAA,IAASD;AAAAA,EAAAA,CAAQ;AAC1D;AAQA,eAAsB8B,qCACpBC,SAC0B;AAC1B,QAAM;AAAA,IAAC9B;AAAAA,IAASjC;AAAAA,IAAOD;AAAAA,EAAAA,IAAWgE;AAGlC,MAFiBF,UAAAA,eAAe5B,QAAQc,SAAS;AAG/C,WAAOa,yBAAyBG,OAAO;AAGzC,MAAI,CAAC/D,SAAS,CAACD;AACb,UAAM,IAAI0D,MACR,oFACF;AAGF,SAAOD,4BAA4BO,OAAO;AAC5C;AAWA,eAAsBC,iBAAiB;AAAA,EACrClE;AAAAA,EACAmE;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAnE;AACuB,GAAgC;AACvD,QAAMoE,WAAW,IAAIC,0BAAAA;AACrBD,SAAAA,SAASE,OAAO,kBAAkBJ,eAAeK,SAAAA,CAAU,GAC3DH,SAASE,OAAO,WAAWH,OAAO,GAClCC,SAASE,OAAO,WAAWN,SAAS;AAAA,IAACQ,aAAa;AAAA,IAAoBC,UAAU;AAAA,EAAA,CAAa,GAEtF5E,OAAOQ,QAAQ;AAAA,IACpBH,KAAK,sBAAsB+D,aAAa;AAAA,IACxCrD,QAAQ;AAAA,IACR8D,SAASN,SAASO,WAAAA;AAAAA,IAClBhE,MAAMyD,SAASQ,KAAK,IAAIC,YAAAA,aAAa;AAAA,IACrC5E,OAAOD,WAAW;AAAA,MAACG,SAAS;AAAA,IAAA,IAAa;AAAA,MAACA,SAAS;AAAA,IAAA;AAAA,EAAQ,CAC5D;AACH;AAQA,eAAsB2E,sBAAsB;AAAA,EAC1Cb;AAAAA,EACApE;AAAAA,EACAM;AAC4B,GAAkB;AAC9C,QAAMN,OAAOQ,QAAQ;AAAA,IACnBH,KAAK,sBAAsB+D,aAAa;AAAA,IACxChE,OAAO;AAAA,MACLE;AAAAA,IAAAA;AAAAA,IAEFS,QAAQ;AAAA,EAAA,CACT;AACH;AAEA,eAAsBmE,4BAA6C;AACjE,QAAMC,iBAAiB,MAAMC,2BAAU;AAAA,IAACC,KAAKC;AAAAA,EAAAA,CAAU,IAAIC;AAC3D,MAAI,CAACJ;AACH,UAAM,IAAIxB,MAAM,wCAAwC;AAG1D,QAAM6B,MAAMC,KAAKC,MAAM,MAAMC,YAAAA,QAAGC,SAAST,eAAe,OAAO,CAAC;AAChE,MAAI,OAAOK,KAAKlB,WAAY;AAC1B,UAAM,IAAIX,MAAM,2CAA2C;AAE7D,SAAO6B,IAAIlB;AACb;AAEA,eAAsBuB,wBAAwBC,WAAqC;AACjF,MAAI;AAEF,QAAI,EADU,MAAMH,YAAAA,QAAGI,KAAKD,SAAS,GAC1BE,YAAAA;AACT,YAAM,IAAIrC,MAAM,aAAamC,SAAS,qBAAqB;AAAA,EAE/D,SAASG,KAAK;AACZ,QAAIA,IAAIC,SAAS;AACf,aAAO;AAGT,UAAMD;AAAAA,EACR;AAGA,UADgB,MAAMN,YAAAA,QAAGQ,QAAQL,SAAS,GAC3BzE,WAAW;AAC5B;AAEA,eAAsB+E,SAASN,WAAkC;AAC/D,MAAI;AAEF,QAAI,EADU,MAAMH,YAAAA,QAAGI,KAAKD,SAAS,GAC1BE,YAAAA;AACT,YAAM,IAAIrC,MAAM,aAAamC,SAAS,qBAAqB;AAAA,EAE/D,SAASG,KAAK;AAGZ,UAFcA,IAAIC,SAAS,WAAW,IAAIvC,MAAM,cAAcmC,SAAS,kBAAkB,IAAIG;AAAAA,EAG/F;AAEA,MAAI;AACF,UAAMN,YAAAA,QAAGI,KAAKR,cAAAA,QAAKc,KAAKP,WAAW,YAAY,CAAC;AAAA,EAClD,SAASG,KAAK;AAYZ,UAVEA,IAAIC,SAAS,WACT,IAAIvC,MACF,CACE,IAAImC,SAAS,iCACb,+CACA,4CAA4C,EAC5CO,KAAK,GAAG,CACZ,IACAJ;AAAAA,EAGR;AACF;;;;;;;;;;;"}