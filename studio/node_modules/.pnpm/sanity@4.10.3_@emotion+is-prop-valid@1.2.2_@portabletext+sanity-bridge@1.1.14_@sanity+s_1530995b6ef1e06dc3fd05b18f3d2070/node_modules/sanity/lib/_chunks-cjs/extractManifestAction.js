"use strict";
var node_crypto = require("node:crypto"), fs = require("node:fs/promises"), path = require("node:path"), node_worker_threads = require("node:worker_threads"), dateFns = require("date-fns"), readPkgUp = require("read-pkg-up"), timing = require("./timing.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var readPkgUp__default = /* @__PURE__ */ _interopDefaultCompat(readPkgUp);
const MANIFEST_FILENAME = "create-manifest.json", SCHEMA_FILENAME_SUFFIX = ".create-schema.json", TOOLS_FILENAME_SUFFIX = ".create-tools.json", FEATURE_ENABLED_ENV_NAME = "SANITY_CLI_EXTRACT_MANIFEST_ENABLED", EXTRACT_MANIFEST_ENABLED = process.env[FEATURE_ENABLED_ENV_NAME] !== "false", EXTRACT_MANIFEST_LOG_ERRORS = process.env.SANITY_CLI_EXTRACT_MANIFEST_LOG_ERRORS === "true", CREATE_TIMER = "create-manifest", EXTRACT_TASK_TIMEOUT_MS = dateFns.minutesToMilliseconds(2);
async function extractManifestSafe(args, context) {
  if (EXTRACT_MANIFEST_ENABLED)
    try {
      await extractManifest(args, context);
      return;
    } catch (err) {
      return EXTRACT_MANIFEST_LOG_ERRORS && context.output.error(err), err;
    }
}
async function extractManifest(args, context) {
  const {
    output,
    workDir
  } = context, flags = args.extOptions, defaultOutputDir = path.resolve(path.join(workDir, "dist")), outputDir = path.resolve(defaultOutputDir), defaultStaticPath = path.join(outputDir, "static"), staticPath = flags.path ?? defaultStaticPath, path$1 = path.join(staticPath, MANIFEST_FILENAME), rootPkgPath = readPkgUp__default.default.sync({
    cwd: __dirname
  })?.path;
  if (!rootPkgPath)
    throw new Error("Could not find root directory for `sanity` package");
  const timer = timing.getTimer();
  timer.start(CREATE_TIMER);
  const spinner = output.spinner({}).start("Extracting manifest");
  try {
    const workspaceManifests = await getWorkspaceManifests({
      rootPkgPath,
      workDir
    });
    await fs.mkdir(staticPath, {
      recursive: !0
    });
    const workspaceFiles = await writeWorkspaceFiles(workspaceManifests, staticPath), manifest = {
      /**
       * Version history:
       * 1: Initial release.
       * 2: Added tools file.
       */
      version: 2,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      workspaces: workspaceFiles
    };
    await fs.writeFile(path$1, JSON.stringify(manifest, null, 2));
    const manifestDuration = timer.end(CREATE_TIMER);
    spinner.succeed(`Extracted manifest (${manifestDuration.toFixed()}ms)`);
  } catch (err) {
    throw spinner.fail(err.message), err;
  }
}
async function getWorkspaceManifests({
  rootPkgPath,
  workDir
}) {
  const workerPath = path.join(path.dirname(rootPkgPath), "lib", "_internal", "cli", "threads", "extractManifest.js"), worker = new node_worker_threads.Worker(workerPath, {
    workerData: {
      workDir
    },
    env: process.env
  });
  let timeout = !1;
  const timeoutId = setTimeout(() => {
    timeout = !0, worker.terminate();
  }, EXTRACT_TASK_TIMEOUT_MS);
  try {
    return await new Promise((resolveWorkspaces, reject) => {
      const buffer = [];
      worker.addListener("message", (message) => buffer.push(message)), worker.addListener("exit", (exitCode) => {
        exitCode === 0 ? resolveWorkspaces(buffer) : timeout && reject(new Error(`Extract manifest was aborted after ${EXTRACT_TASK_TIMEOUT_MS}ms`));
      }), worker.addListener("error", reject);
    });
  } finally {
    clearTimeout(timeoutId);
  }
}
function writeWorkspaceFiles(manifestWorkspaces, staticPath) {
  const output = manifestWorkspaces.reduce((workspaces, workspace) => [...workspaces, writeWorkspaceFile(workspace, staticPath)], []);
  return Promise.all(output);
}
async function writeWorkspaceFile(workspace, staticPath) {
  const [schemaFilename, toolsFilename] = await Promise.all([createFile(staticPath, workspace.schema, SCHEMA_FILENAME_SUFFIX), createFile(staticPath, workspace.tools, TOOLS_FILENAME_SUFFIX)]);
  return {
    ...workspace,
    schema: schemaFilename,
    tools: toolsFilename
  };
}
const createFile = async (path$1, content, filenameSuffix) => {
  const stringifiedContent = JSON.stringify(content, null, 2), filename = `${node_crypto.createHash("sha1").update(stringifiedContent).digest("hex").slice(0, 8)}${filenameSuffix}`;
  return await fs.writeFile(path.join(path$1, filename), stringifiedContent), filename;
};
exports.MANIFEST_FILENAME = MANIFEST_FILENAME;
exports.extractManifestSafe = extractManifestSafe;
//# sourceMappingURL=extractManifestAction.js.map
