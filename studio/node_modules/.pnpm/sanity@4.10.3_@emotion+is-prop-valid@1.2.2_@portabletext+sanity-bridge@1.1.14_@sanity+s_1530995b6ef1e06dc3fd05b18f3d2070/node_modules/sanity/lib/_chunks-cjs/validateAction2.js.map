{"version":3,"file":"validateAction2.js","sources":["../../src/_internal/cli/actions/validation/reporters/jsonReporter.ts","../../src/_internal/cli/actions/validation/reporters/ndjsonReporter.ts","../../src/_internal/cli/actions/validation/reporters/prettyReporter/util.ts","../../src/_internal/cli/actions/validation/reporters/prettyReporter/formatDocumentValidation.ts","../../src/_internal/cli/actions/validation/reporters/prettyReporter/prettyReporter.ts","../../src/_internal/cli/actions/validation/reporters/index.ts","../../src/_internal/cli/util/workerChannels.ts","../../src/_internal/cli/actions/validation/validateDocuments.ts","../../src/_internal/cli/actions/validation/validateAction.ts"],"sourcesContent":["import {type BuiltInValidationReporter} from '../validateAction'\n\n// TODO: replace with Array.fromAsync when it's out of stage3\nasync function arrayFromAsync<T>(iterable: AsyncIterable<T>) {\n  const results: T[] = []\n  for await (const item of iterable) results.push(item)\n  return results\n}\n\nexport const json: BuiltInValidationReporter = async ({output, worker}) => {\n  const results = await arrayFromAsync(worker.stream.validation())\n  const formatted = results\n    // report out only documents with some markers\n    .filter(({markers}) => markers.length)\n    // remove validatedCount from the results\n    .map(({validatedCount, ...result}) => result)\n\n  await worker.dispose()\n\n  output.print(JSON.stringify(formatted))\n\n  let overallLevel: 'error' | 'warning' | 'info' = 'info'\n\n  for (const {level} of formatted) {\n    if (level === 'error') overallLevel = 'error'\n    if (level === 'warning' && overallLevel !== 'error') overallLevel = 'warning'\n  }\n\n  return overallLevel\n}\n","import {type BuiltInValidationReporter} from '../validateAction'\n\nexport const ndjson: BuiltInValidationReporter = async ({output, worker}) => {\n  let overallLevel: 'error' | 'warning' | 'info' = 'info'\n\n  for await (const {validatedCount, ...result} of worker.stream.validation()) {\n    if (result.level === 'error') overallLevel = 'error'\n    if (result.level === 'warning' && overallLevel !== 'error') overallLevel = 'warning'\n\n    if (result.markers.length) {\n      output.print(JSON.stringify(result))\n    }\n  }\n\n  await worker.dispose()\n\n  return overallLevel\n}\n","import {isatty} from 'node:tty'\n\nimport {type ValidationMarker} from '@sanity/types'\nimport logSymbols from 'log-symbols'\n\nexport type Level = ValidationMarker['level']\n\nexport interface DocumentValidationResult {\n  revision: string\n  documentId: string\n  documentType: string\n  intentUrl?: string\n  level: ValidationMarker['level']\n  markers: ValidationMarker[]\n}\n\nexport const isTty = isatty(1)\nexport const levelValues = {error: 0, warning: 1, info: 2} as const\n\n/**\n * Generates a formatted string that includes a numerical amount and a subject\n * in plural or singular form. Note: the subject must end in `s`\n */\nexport const count = (amount: number, subject: string): string =>\n  `${amount.toLocaleString('en-US')} ${\n    amount === 1 ? subject.slice(0, Math.max(0, subject.length - 1)) : subject\n  }`\n\nconst percentageFormatter = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 1,\n  maximumFractionDigits: 1,\n})\n\n/**\n * Given a decimal, this will return that number formatted as a percentage\n */\nexport const percent = (value: number): string => percentageFormatter.format(Math.min(value, 1))\n\nconst secondFormatter = new Intl.NumberFormat('en-US', {\n  minimumFractionDigits: 1,\n  maximumFractionDigits: 1,\n})\n\n/**\n * Given a start time in milliseconds, this will output the time elapsed\n * formatted in seconds\n */\nexport const seconds = (startTime: number): string => {\n  const endTime = Date.now()\n  return `(${secondFormatter.format((endTime - startTime) / 1000)}s)`\n}\n\ninterface ValidationTotals {\n  valid: {documents: number}\n  errors: {documents: number; markers: number}\n  warnings: {documents: number; markers: number}\n  infos: {documents: number; markers: number}\n}\n\n/**\n * Outputs summary text given an object of totals. Omits totals depending on the\n * desired validation `level`\n */\nexport const summary = (\n  {errors, infos, valid, warnings}: ValidationTotals,\n  level: Level = 'warning',\n): string => {\n  const levelValue = levelValues[level]\n\n  return [\n    `${logSymbols.success} Valid:    ${count(valid.documents, 'documents')}`,\n    `${logSymbols.error} Errors:   ${count(errors.documents, 'documents')}, ${count(\n      errors.markers,\n      'errors',\n    )}`,\n    levelValue >= levelValues.warning &&\n      `${logSymbols.warning} Warnings: ${count(warnings.documents, 'documents')}, ${count(\n        warnings.markers,\n        'warnings',\n      )}`,\n    levelValue >= levelValues.info &&\n      `${logSymbols.info} Info:     ${count(infos.documents, 'documents')}, ${count(\n        infos.documents,\n        'markers',\n      )}`,\n  ]\n    .filter(Boolean)\n    .join('\\n')\n}\n","import {type Path, type ValidationMarker} from '@sanity/types'\nimport chalk from 'chalk'\nimport logSymbols from 'log-symbols'\n\nimport {convertToTree, formatTree, maxKeyLength, type Tree} from '../../../../util/tree'\nimport {type DocumentValidationResult, isTty, type Level, levelValues} from './util'\n\nexport interface FormatDocumentValidationOptions extends DocumentValidationResult {\n  studioHost?: string\n  basePath?: string\n}\n\ninterface Marker extends Pick<ValidationMarker, 'level' | 'message'> {\n  path: Path\n}\n\ntype ValidationTree = Tree<Marker>\n\nconst levelHeaders = {\n  error: isTty ? chalk.bold(chalk.bgRed(chalk.black(' ERROR '))) : chalk.red('[ERROR]'),\n  warning: isTty ? chalk.bold(chalk.bgYellow(chalk.black(' WARN '))) : chalk.yellow('[WARN]'),\n  info: isTty ? chalk.bold(chalk.cyan(chalk.black(' INFO '))) : chalk.cyan('[INFO]'),\n}\n/**\n * Creates a terminal hyperlink. Only outputs a hyperlink if the output is\n * determined to be a TTY\n */\nconst link = (text: string, url: string) =>\n  isTty ? `\\u001b]8;;${url}\\u0007${text}\\u001b]8;;\\u0007` : chalk.underline(text)\n\n/**\n * For sorting markers\n */\nconst compareLevels = <T extends {level: Level; message: string}>(a: T, b: T) =>\n  levelValues[a.level] - levelValues[b.level]\n\n/**\n * Formats the markers at the root of the validation tree\n */\nconst formatRootErrors = (root: ValidationTree, hasChildren: boolean, paddingLength: number) => {\n  if (!root.nodes) return ''\n\n  const [first, ...rest] = root.nodes.slice().sort(compareLevels)\n  if (!first) return ''\n\n  const firstElbow = hasChildren ? '│ ' : '└─'\n  const firstPadding = '.'.repeat(paddingLength - 6)\n  const firstLine = `${firstElbow} (root) ${firstPadding} ${logSymbols[first.level]} ${\n    first.message\n  }`\n  const subsequentPadding = ' '.repeat(paddingLength + 2)\n  const subsequentElbow = hasChildren ? '│ ' : '  '\n\n  const restOfLines = rest\n    .map(\n      (marker) =>\n        `${subsequentElbow}${subsequentPadding} ${logSymbols[marker.level]} ${marker.message}`,\n    )\n    .join('\\n')\n  return [firstLine, restOfLines].filter(Boolean).join('\\n')\n}\n\n/**\n * Formats document validation results into a user-friendly tree structure\n */\nexport function formatDocumentValidation({\n  documentId,\n  documentType,\n  level,\n  markers,\n  intentUrl,\n}: FormatDocumentValidationOptions): string {\n  const tree = convertToTree<Marker>(markers)\n\n  const documentTypeHeader = isTty\n    ? chalk.bgWhite(chalk.black(` ${documentType} `))\n    : `[${documentType}]`\n\n  const header = `${levelHeaders[level]} ${documentTypeHeader} ${\n    intentUrl ? link(documentId, intentUrl) : chalk.underline(documentId)\n  }`\n\n  const paddingLength = Math.max(maxKeyLength(tree.children) + 2, 30)\n\n  const childErrors = formatTree<Marker>({\n    node: tree.children,\n    paddingLength,\n    getNodes: ({nodes}) => (nodes ?? []).slice().sort(compareLevels),\n    getMessage: (marker) => [logSymbols[marker.level], marker.message].join(' '),\n  })\n\n  const rootErrors = formatRootErrors(tree, childErrors.length > 0, paddingLength)\n\n  return [header, rootErrors, childErrors].filter(Boolean).join('\\n')\n}\n","import {type BuiltInValidationReporter} from '../../validateAction'\nimport {formatDocumentValidation} from './formatDocumentValidation'\nimport {\n  count,\n  type DocumentValidationResult,\n  type Level,\n  levelValues,\n  percent,\n  seconds,\n  summary,\n} from './util'\n\n/**\n * Represents the default stylish/pretty reporter\n */\n// eslint-disable-next-line max-statements\nexport const pretty: BuiltInValidationReporter = async ({output, worker, flags}) => {\n  const workspaceLoadStart = Date.now()\n  // Report workspace loaded\n  const spinner = output\n    .spinner(flags.workspace ? `Loading workspace '${flags.workspace}'…` : 'Loading workspace…')\n    .start()\n\n  const workspace = await worker.event.loadedWorkspace()\n  spinner.succeed(\n    `Loaded workspace '${workspace.name}' using project '${workspace.projectId}' and dataset '${\n      flags.dataset || workspace.dataset\n    }' ${seconds(workspaceLoadStart)}`,\n  )\n\n  if (!flags.file) {\n    // Report document count\n    spinner.start('Calculating documents to be validated…')\n    const {documentCount} = await worker.event.loadedDocumentCount()\n\n    // Report export progress\n    const downloadStart = Date.now()\n    spinner.text = `Downloading ${count(documentCount, 'documents')}…`\n    for await (const {downloadedCount} of worker.stream.exportProgress()) {\n      const percentage = percent(downloadedCount / documentCount)\n      spinner.text = `Downloading ${count(documentCount, 'documents')}… ${percentage}`\n    }\n    spinner.succeed(`Downloaded ${count(documentCount, 'documents')} ${seconds(downloadStart)}`)\n  }\n\n  const {totalDocumentsToValidate} = await worker.event.exportFinished()\n\n  const referenceIntegrityStart = Date.now()\n  spinner.start(`Checking reference existence…`)\n  await worker.event.loadedReferenceIntegrity()\n  spinner.succeed(`Checked all references ${seconds(referenceIntegrityStart)}`)\n\n  // Report validation progress\n  const validationStart = Date.now()\n  spinner.start(`Validating ${count(totalDocumentsToValidate, 'documents')}…`)\n\n  const results: DocumentValidationResult[] = []\n\n  const totals = {\n    valid: {documents: 0},\n    errors: {documents: 0, markers: 0},\n    warnings: {documents: 0, markers: 0},\n    infos: {documents: 0, markers: 0},\n  }\n\n  for await (const {validatedCount, ...result} of worker.stream.validation()) {\n    const {markers} = result\n\n    if (markers.length) {\n      results.push(result)\n    }\n\n    const errors = markers.filter((marker) => marker.level === 'error')\n    const warnings = markers.filter((marker) => marker.level === 'warning')\n    const infos = markers.filter((marker) => marker.level === 'info')\n\n    if (!markers.length) {\n      totals.valid.documents += 1\n    }\n\n    if (errors.length) {\n      totals.errors.documents += 1\n      totals.errors.markers += errors.length\n    }\n\n    if (warnings.length) {\n      totals.warnings.documents += 1\n      totals.warnings.markers += warnings.length\n    }\n\n    if (infos.length) {\n      totals.infos.documents += 1\n      totals.infos.markers += infos.length\n    }\n\n    spinner.text =\n      `Validating ${count(totalDocumentsToValidate, 'documents')}…\\n\\n` +\n      `Processed ${count(validatedCount, 'documents')} (${percent(\n        validatedCount / totalDocumentsToValidate,\n      )}):\\n${summary(totals, flags.level)}`\n  }\n\n  spinner.succeed(\n    `Validated ${count(totalDocumentsToValidate, 'documents')} ${seconds(validationStart)}`,\n  )\n  output.print(`\\nValidation results:\\n${summary(totals, flags.level)}`)\n\n  results.sort((a, b) => {\n    if (a.level === b.level) return a.documentType.localeCompare(b.documentType)\n    return levelValues[a.level] - levelValues[b.level]\n  })\n\n  let overallLevel: Level = 'info'\n\n  for (const result of results) {\n    if (result.level === 'error') overallLevel = 'error'\n    if (result.level === 'warning' && overallLevel !== 'error') overallLevel = 'warning'\n\n    output.print(`${formatDocumentValidation(result)}\\n`)\n  }\n\n  await worker.dispose()\n\n  return overallLevel\n}\n","import {json} from './jsonReporter'\nimport {ndjson} from './ndjsonReporter'\nimport {pretty} from './prettyReporter'\n\nexport const reporters = {pretty, ndjson, json}\n","import {type MessagePort, type Worker} from 'node:worker_threads'\n\ntype StreamReporter<TPayload = unknown> = {emit: (payload: TPayload) => void; end: () => void}\ntype EventReporter<TPayload = unknown> = (payload: TPayload) => void\ntype EventReceiver<TPayload = unknown> = () => Promise<TPayload>\ntype StreamReceiver<TPayload = unknown> = () => AsyncIterable<TPayload>\n\ntype EventKeys<TWorkerChannel extends WorkerChannel> = {\n  [K in keyof TWorkerChannel]: TWorkerChannel[K] extends WorkerChannelEvent<any> ? K : never\n}[keyof TWorkerChannel]\ntype StreamKeys<TWorkerChannel extends WorkerChannel> = {\n  [K in keyof TWorkerChannel]: TWorkerChannel[K] extends WorkerChannelStream<any> ? K : never\n}[keyof TWorkerChannel]\n\ntype EventMessage<TPayload = unknown> = {type: 'event'; name: string; payload: TPayload}\ntype StreamEmissionMessage<TPayload = unknown> = {type: 'emission'; name: string; payload: TPayload}\ntype StreamEndMessage = {type: 'end'; name: string}\ntype WorkerChannelMessage = EventMessage | StreamEmissionMessage | StreamEndMessage\n\n/**\n * Represents the definition of a \"worker channel\" to report progress from the\n * worker to the parent. Worker channels can define named events or streams and\n * the worker will report events and streams while the parent will await them.\n * This allows the control flow of the parent to follow the control flow of the\n * worker 1-to-1.\n */\nexport type WorkerChannel<\n  TWorkerChannel extends Record<\n    string,\n    WorkerChannelEvent<unknown> | WorkerChannelStream<unknown>\n  > = Record<string, WorkerChannelEvent<unknown> | WorkerChannelStream<unknown>>,\n> = TWorkerChannel\n\nexport type WorkerChannelEvent<TPayload = void> = {type: 'event'; payload: TPayload}\nexport type WorkerChannelStream<TPayload = void> = {type: 'stream'; payload: TPayload}\n\nexport interface WorkerChannelReporter<TWorkerChannel extends WorkerChannel> {\n  event: {\n    [K in EventKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelEvent<infer TPayload>\n      ? EventReporter<TPayload>\n      : void\n  }\n  stream: {\n    [K in StreamKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelStream<infer TPayload>\n      ? StreamReporter<TPayload>\n      : void\n  }\n}\n\nexport interface WorkerChannelReceiver<TWorkerChannel extends WorkerChannel> {\n  event: {\n    [K in EventKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelEvent<infer TPayload>\n      ? EventReceiver<TPayload>\n      : void\n  }\n  stream: {\n    [K in StreamKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelStream<infer TPayload>\n      ? StreamReceiver<TPayload>\n      : void\n  }\n  // TODO: good candidate for [Symbol.asyncDispose] when our tooling better supports it\n  dispose: () => Promise<number>\n}\n\n/**\n * A simple queue that has two primary methods: `push(message)` and\n * `await next()`. This message queue is used by the \"receiver\" of the worker\n * channel and this class handles buffering incoming messages if the worker is\n * producing faster than the parent as well as returning a promise if there is\n * no message yet in the queue when the parent awaits `next()`.\n */\nclass MessageQueue<T> {\n  resolver: ((result: IteratorResult<T>) => void) | null = null\n  queue: T[] = []\n\n  push(message: T) {\n    if (this.resolver) {\n      this.resolver({value: message, done: false})\n      this.resolver = null\n    } else {\n      this.queue.push(message)\n    }\n  }\n\n  next(): Promise<IteratorResult<T>> {\n    if (this.queue.length) {\n      return Promise.resolve({value: this.queue.shift()!, done: false})\n    }\n\n    return new Promise((resolve) => (this.resolver = resolve))\n  }\n\n  end() {\n    if (this.resolver) {\n      this.resolver({value: undefined, done: true})\n    }\n  }\n}\n\nfunction isWorkerChannelMessage(message: unknown): message is WorkerChannelMessage {\n  if (typeof message !== 'object') return false\n  if (!message) return false\n  if (!('type' in message)) return false\n  if (typeof message.type !== 'string') return false\n  const types: string[] = ['event', 'emission', 'end'] satisfies WorkerChannelMessage['type'][]\n  return types.includes(message.type)\n}\n\n/**\n * Creates a \"worker channel receiver\" that subscribes to incoming messages\n * from the given worker and returns promises for worker channel events and\n * async iterators for worker channel streams.\n */\nexport function createReceiver<TWorkerChannel extends WorkerChannel>(\n  worker: Worker,\n): WorkerChannelReceiver<TWorkerChannel> {\n  const _events = new Map<string, MessageQueue<EventMessage>>()\n  const _streams = new Map<string, MessageQueue<StreamEmissionMessage>>()\n  const errors = new MessageQueue<{type: 'error'; error: unknown}>()\n\n  const eventQueue = (name: string) => {\n    const queue = _events.get(name) ?? new MessageQueue()\n    if (!_events.has(name)) _events.set(name, queue)\n    return queue\n  }\n\n  const streamQueue = (name: string) => {\n    const queue = _streams.get(name) ?? new MessageQueue()\n    if (!_streams.has(name)) _streams.set(name, queue)\n    return queue\n  }\n\n  const handleMessage = (message: unknown) => {\n    if (!isWorkerChannelMessage(message)) return\n    if (message.type === 'event') eventQueue(message.name).push(message)\n    if (message.type === 'emission') streamQueue(message.name).push(message)\n    if (message.type === 'end') streamQueue(message.name).end()\n  }\n\n  const handleError = (error: unknown) => {\n    errors.push({type: 'error', error})\n  }\n\n  worker.addListener('message', handleMessage)\n  worker.addListener('error', handleError)\n\n  return {\n    event: new Proxy({} as WorkerChannelReceiver<TWorkerChannel>['event'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const eventReceiver: EventReceiver = async () => {\n          const {value} = await Promise.race([eventQueue(name).next(), errors.next()])\n          if (value.type === 'error') throw value.error\n          return value.payload\n        }\n\n        return eventReceiver\n      },\n    }),\n    stream: new Proxy({} as WorkerChannelReceiver<TWorkerChannel>['stream'], {\n      get: (target, prop) => {\n        if (typeof prop !== 'string') return target[prop as keyof typeof target]\n        const name = prop // alias for better typescript narrowing\n\n        async function* streamReceiver() {\n          while (true) {\n            const {value, done} = await Promise.race([streamQueue(name).next(), errors.next()])\n            if (done) return\n            if (value.type === 'error') throw value.error\n            yield value.payload\n          }\n        }\n\n        return streamReceiver satisfies StreamReceiver\n      },\n    }),\n    dispose: () => {\n      worker.removeListener('message', handleMessage)\n      worker.removeListener('error', handleError)\n      return worker.terminate()\n    },\n  }\n}\n\n/**\n * Creates a \"worker channel reporter\" that sends messages to the given\n * `parentPort` to be received by a worker channel receiver.\n */\nexport function createReporter<TWorkerChannel extends WorkerChannel>(\n  parentPort: MessagePort | null,\n): WorkerChannelReporter<TWorkerChannel> {\n  if (!parentPort) {\n    throw new Error('parentPart was falsy')\n  }\n\n  return {\n    event: new Proxy({} as WorkerChannelReporter<TWorkerChannel>['event'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const eventReporter: EventReporter = (payload) => {\n          const message: EventMessage = {type: 'event', name, payload}\n          parentPort.postMessage(message)\n        }\n\n        return eventReporter\n      },\n    }),\n    stream: new Proxy({} as WorkerChannelReporter<TWorkerChannel>['stream'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const streamReporter: StreamReporter = {\n          emit: (payload) => {\n            const message: StreamEmissionMessage = {type: 'emission', name, payload}\n            parentPort.postMessage(message)\n          },\n          end: () => {\n            const message: StreamEndMessage = {type: 'end', name}\n            parentPort.postMessage(message)\n          },\n        }\n\n        return streamReporter\n      },\n    }),\n  }\n}\n","import path from 'node:path'\nimport {Worker} from 'node:worker_threads'\n\nimport {type ClientConfig} from '@sanity/client'\nimport {type ValidationMarker} from '@sanity/types'\nimport readPkgUp from 'read-pkg-up'\n\nimport {\n  type ValidateDocumentsWorkerData,\n  type ValidationWorkerChannel,\n} from '../../threads/validateDocuments'\nimport {createReceiver, type WorkerChannelReceiver} from '../../util/workerChannels'\n\nexport interface ValidateDocumentsOptions<TReturn = unknown> {\n  level?: 'error' | 'warning' | 'info'\n  workspace?: string\n  workDir?: string\n  configPath?: string\n  clientConfig?: Partial<ClientConfig>\n  projectId?: string // override\n  dataset?: string // override\n  ndjsonFilePath?: string\n  maxCustomValidationConcurrency?: number\n  maxFetchConcurrency?: number\n  reporter?: (worker: WorkerChannelReceiver<ValidationWorkerChannel>) => TReturn\n  studioHost?: string\n}\n\nexport interface DocumentValidationResult {\n  documentId: string\n  documentType: string\n  revision: string\n  level: ValidationMarker['level']\n  markers: ValidationMarker[]\n}\n\nconst defaultReporter = ({stream, dispose}: WorkerChannelReceiver<ValidationWorkerChannel>) => {\n  async function* createValidationGenerator() {\n    for await (const {documentId, documentType, markers, revision, level} of stream.validation()) {\n      const result: DocumentValidationResult = {\n        documentId,\n        documentType,\n        revision,\n        level,\n        markers,\n      }\n\n      yield result\n    }\n\n    await dispose()\n  }\n\n  return createValidationGenerator()\n}\n\nexport function validateDocuments<TReturn>(\n  options: ValidateDocumentsOptions<TReturn> &\n    Required<Pick<ValidateDocumentsOptions<TReturn>, 'reporter'>>,\n): TReturn\nexport function validateDocuments(\n  options: ValidateDocumentsOptions,\n): AsyncIterable<DocumentValidationResult>\nexport function validateDocuments(options: ValidateDocumentsOptions): unknown {\n  const {\n    workspace,\n    clientConfig,\n    configPath,\n    dataset,\n    projectId,\n    workDir = process.cwd(),\n    reporter = defaultReporter,\n    level,\n    maxCustomValidationConcurrency,\n    maxFetchConcurrency,\n    ndjsonFilePath,\n  } = options\n\n  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path\n  if (!rootPkgPath) {\n    throw new Error('Could not find root directory for `sanity` package')\n  }\n\n  const workerPath = path.join(\n    path.dirname(rootPkgPath),\n    'lib',\n    '_internal',\n    'cli',\n    'threads',\n    'validateDocuments.js',\n  )\n\n  const worker = new Worker(workerPath, {\n    workerData: {\n      workDir,\n      // removes props in the config that make this object fail to serialize\n      clientConfig: JSON.parse(JSON.stringify(clientConfig)),\n      configPath,\n      workspace,\n      dataset,\n      projectId,\n      level,\n      ndjsonFilePath,\n      maxCustomValidationConcurrency,\n      maxFetchConcurrency,\n      studioHost: options.studioHost,\n    } satisfies ValidateDocumentsWorkerData,\n    env: process.env,\n  })\n\n  return reporter(createReceiver<ValidationWorkerChannel>(worker))\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliConfig,\n  type CliOutputter,\n} from '@sanity/cli'\nimport {type ClientConfig} from '@sanity/client'\nimport chalk from 'chalk'\nimport logSymbols from 'log-symbols'\n\nimport {type ValidationWorkerChannel} from '../../threads/validateDocuments'\nimport {type WorkerChannelReceiver} from '../../util/workerChannels'\nimport {reporters} from './reporters'\nimport {validateDocuments} from './validateDocuments'\n\ninterface ValidateFlags {\n  'workspace'?: string\n  'format'?: string\n  'dataset'?: string\n  'file'?: string\n  'level'?: 'error' | 'warning' | 'info'\n  'max-custom-validation-concurrency'?: number\n  'max-fetch-concurrency'?: number\n  'yes'?: boolean\n  'y'?: boolean\n}\n\nexport type BuiltInValidationReporter = (options: {\n  output: CliOutputter\n  worker: WorkerChannelReceiver<ValidationWorkerChannel>\n  flags: ValidateFlags\n}) => Promise<'error' | 'warning' | 'info'>\n\nexport default async function validateAction(\n  args: CliCommandArguments<ValidateFlags>,\n  {apiClient, workDir, output, cliConfig, prompt}: CliCommandContext,\n): Promise<void> {\n  const flags = args.extOptions\n  const unattendedMode = Boolean(flags.yes || flags.y)\n\n  if (!unattendedMode) {\n    output.print(\n      `${chalk.yellow(`${logSymbols.warning} Warning:`)} This command ${\n        flags.file\n          ? 'reads all documents from your input file'\n          : 'downloads all documents from your dataset'\n      } and processes them through your local schema within a ` +\n        `simulated browser environment.\\n`,\n    )\n    output.print(`Potential pitfalls:\\n`)\n    output.print(\n      `- Processes all documents locally (excluding assets). Large datasets may require more resources.`,\n    )\n    output.print(\n      `- Executes all custom validation functions. Some functions may need to be refactored for compatibility.`,\n    )\n    output.print(\n      `- Not all standard browser features are available and may cause issues while loading your Studio.`,\n    )\n    output.print(\n      `- Adheres to document permissions. Ensure this account can see all desired documents.`,\n    )\n    if (flags.file) {\n      output.print(\n        `- Checks for missing document references against the live dataset if not found in your file.`,\n      )\n    }\n\n    const confirmed = await prompt.single<boolean>({\n      type: 'confirm',\n      message: `Are you sure you want to continue?`,\n      default: true,\n    })\n\n    if (!confirmed) {\n      output.print('User aborted')\n      process.exitCode = 1\n      return\n    }\n  }\n\n  if (flags.format && !(flags.format in reporters)) {\n    const formatter = new Intl.ListFormat('en-US', {\n      style: 'long',\n      type: 'conjunction',\n    })\n    throw new Error(\n      `Did not recognize format '${flags.format}'. Available formats are ${formatter.format(\n        Object.keys(reporters).map((key) => `'${key}'`),\n      )}`,\n    )\n  }\n\n  const level = flags.level || 'warning'\n\n  if (level !== 'error' && level !== 'warning' && level !== 'info') {\n    throw new Error(`Invalid level. Available levels are 'error', 'warning', and 'info'.`)\n  }\n\n  const maxCustomValidationConcurrency = flags['max-custom-validation-concurrency']\n  if (\n    maxCustomValidationConcurrency &&\n    typeof maxCustomValidationConcurrency !== 'number' &&\n    !Number.isInteger(maxCustomValidationConcurrency)\n  ) {\n    throw new Error(`'--max-custom-validation-concurrency' must be an integer.`)\n  }\n\n  const maxFetchConcurrency = flags['max-fetch-concurrency']\n  if (\n    maxFetchConcurrency &&\n    typeof maxFetchConcurrency !== 'number' &&\n    !Number.isInteger(maxFetchConcurrency)\n  ) {\n    throw new Error(`'--max-fetch-concurrency' must be an integer.`)\n  }\n\n  const clientConfig: Partial<ClientConfig> = {\n    ...apiClient({\n      requireUser: true,\n      requireProject: false, // we'll get this from the workspace\n    }).config(),\n    // we set this explictly to true because the default client configuration\n    // from the CLI comes configured with `useProjectHostname: false` when\n    // `requireProject` is set to false\n    useProjectHostname: true,\n    // we set this explictly to true because we pass in a token via the\n    // `clientConfiguration` object and also mock a browser environment in\n    // this worker which triggers the browser warning\n    ignoreBrowserTokenWarning: true,\n  }\n\n  let ndjsonFilePath\n  if (flags.file) {\n    if (typeof flags.file !== 'string') {\n      throw new Error(`'--file' must be a string`)\n    }\n    const filePath = path.resolve(workDir, flags.file)\n\n    const stat = await fs.promises.stat(filePath)\n    if (!stat.isFile()) {\n      throw new Error(`'--file' must point to a valid ndjson file or tarball`)\n    }\n\n    ndjsonFilePath = filePath\n  }\n\n  const overallLevel = await validateDocuments({\n    workspace: flags.workspace,\n    dataset: flags.dataset,\n    clientConfig,\n    workDir,\n    level,\n    maxCustomValidationConcurrency,\n    maxFetchConcurrency,\n    ndjsonFilePath,\n    reporter: (worker) => {\n      const reporter =\n        flags.format && flags.format in reporters\n          ? reporters[flags.format as keyof typeof reporters]\n          : reporters.pretty\n\n      return reporter({output, worker, flags})\n    },\n    studioHost: (cliConfig as CliConfig)?.studioHost,\n  })\n\n  process.exitCode = overallLevel === 'error' ? 1 : 0\n}\n"],"names":["arrayFromAsync","iterable","results","item","push","json","output","worker","formatted","stream","validation","filter","markers","length","map","validatedCount","result","dispose","print","JSON","stringify","overallLevel","level","ndjson","isTty","isatty","levelValues","error","warning","info","count","amount","subject","toLocaleString","slice","Math","max","percentageFormatter","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","percent","value","format","min","secondFormatter","seconds","startTime","endTime","Date","now","summary","errors","infos","valid","warnings","levelValue","logSymbols","success","documents","Boolean","join","levelHeaders","chalk","bold","bgRed","black","red","bgYellow","yellow","cyan","link","text","url","underline","compareLevels","a","b","formatRootErrors","root","hasChildren","paddingLength","nodes","first","rest","sort","firstElbow","firstPadding","repeat","firstLine","message","subsequentPadding","subsequentElbow","restOfLines","marker","formatDocumentValidation","documentId","documentType","intentUrl","tree","convertToTree","documentTypeHeader","bgWhite","header","maxKeyLength","children","childErrors","formatTree","node","getNodes","getMessage","rootErrors","pretty","flags","workspaceLoadStart","spinner","workspace","start","event","loadedWorkspace","succeed","name","projectId","dataset","file","documentCount","loadedDocumentCount","downloadStart","downloadedCount","exportProgress","percentage","totalDocumentsToValidate","exportFinished","referenceIntegrityStart","loadedReferenceIntegrity","validationStart","totals","localeCompare","reporters","MessageQueue","resolver","queue","done","next","Promise","resolve","shift","end","undefined","isWorkerChannelMessage","type","includes","createReceiver","_events","Map","_streams","eventQueue","get","has","set","streamQueue","handleMessage","handleError","addListener","Proxy","target","race","payload","prop","streamReceiver","removeListener","terminate","defaultReporter","createValidationGenerator","revision","validateDocuments","options","clientConfig","configPath","workDir","process","cwd","reporter","maxCustomValidationConcurrency","maxFetchConcurrency","ndjsonFilePath","rootPkgPath","readPkgUp","sync","__dirname","path","Error","workerPath","dirname","Worker","workerData","parse","studioHost","env","validateAction","args","apiClient","cliConfig","prompt","extOptions","yes","y","single","default","exitCode","formatter","ListFormat","Object","keys","key","Number","isInteger","requireUser","requireProject","config","useProjectHostname","ignoreBrowserTokenWarning","filePath","fs","promises","stat","isFile"],"mappings":"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"}