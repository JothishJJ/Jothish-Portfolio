import { spawn } from 'node:child_process';
import { performance } from 'node:perf_hooks';
import { cwd } from 'node:process';
import { setTimeout } from 'node:timers';
import { fileURLToPath } from 'node:url';
import * as groq from 'groq-js';
import config from '../config.js';
import { findFunctionEntryPoint } from './functions/find-entry-point.js';
import { cleanupTempPackageJson, createTempPackageJson, doesPackageJsonExists, } from './functions/packageJsonUtils.js';
import { resolveResourceDependencies } from './functions/resolve-dependencies.js';
import { shouldAutoResolveDependencies } from './functions/should-auto-resolve-deps.js';
import { shouldTranspileFunction } from './functions/should-transpile.js';
import { transpileFunction } from './transpile/transpile-function.js';
function getChildProcessWrapperPath() {
    return fileURLToPath(new URL('./child-process-wrapper.js', import.meta.url));
}
export function sanitizeLogs(logs) {
    return logs.replace(/([a-zA-Z0-9]{10})[a-zA-Z0-9]{65,}/g, '$1**********');
}
export const DEFAULT_GROQ_RULE = { on: ['publish'], filter: '', projection: '' };
export function isDefaultGROQRule(rule) {
    if (!rule)
        return true;
    return (Array.isArray(rule.on) &&
        rule.on.length === DEFAULT_GROQ_RULE.on.length &&
        rule.on.every((v) => DEFAULT_GROQ_RULE.on.includes(v)) &&
        rule.filter === DEFAULT_GROQ_RULE.filter &&
        rule.projection === DEFAULT_GROQ_RULE.projection);
}
function getEvent(rule) {
    return {
        on: rule.on || DEFAULT_GROQ_RULE.on,
        filter: rule.filter || DEFAULT_GROQ_RULE.filter,
        projection: rule.projection || DEFAULT_GROQ_RULE.projection,
    };
}
export async function applyGroqRule(resource, data, before, after, projectId, dataset) {
    // If there is no rule set return everything
    if (!resource.event)
        return data;
    // default groq rule is: gimme full doc content. otherwise, parse + eval custom rule
    // applying the GROQ filter may result in a slimmer set of documents
    const event = getEvent(resource.event);
    if (!isDefaultGROQRule(event)) {
        const hasProjection = event.projection?.length;
        const projection = hasProjection ? `${event?.projection}` : '';
        const query = `*[${event?.filter}]${projection}`;
        const rule = groq.parse(query, { mode: 'delta' });
        const sanity = projectId && dataset ? { projectId, dataset } : undefined;
        const queryResults = await groq.evaluate(rule, { dataset: [data], before, after, sanity });
        const currentFunctionDocumentSet = await queryResults.get();
        return currentFunctionDocumentSet[0];
    }
    // default groq rule so just return the data
    return data;
}
export default async function invoke(resource, payload, context, options) {
    if (!resource.src) {
        throw new Error(`Function resource "${resource.name}" is missing the 'src' property.`);
    }
    const { before, after, payload: data = null } = payload;
    const { forceColor = true, timeout = 10 } = options;
    const { projectId, dataset } = context.clientOptions;
    const filteredData = await applyGroqRule(resource, data, before, after, projectId, dataset);
    if (typeof filteredData === 'undefined') {
        return {
            logs: `⚠️ Filter "${resource.event?.filter}" returned an empty result. Skipping invoke.`,
            error: undefined,
            json: undefined,
        };
    }
    let cleanupBundle = async () => { };
    let functionPath = '';
    let bundleTimings;
    // If no package.json exists we will create a temporary one to avoid the
    // Module Type warning from node
    const existingPackageJson = doesPackageJsonExists(resource);
    const shouldTranspile = await shouldTranspileFunction(resource);
    if (shouldTranspile) {
        const transpileResult = await transpileFunction(resource);
        functionPath = await findFunctionEntryPoint(transpileResult.outputDir);
        bundleTimings = transpileResult.timings;
        cleanupBundle = transpileResult.cleanup;
    }
    else {
        functionPath = await findFunctionEntryPoint(resource.src, resource.displayName ?? resource.name);
    }
    const shouldResolveDependencies = await shouldAutoResolveDependencies(resource);
    if (shouldResolveDependencies && existingPackageJson) {
        await resolveResourceDependencies(resource, shouldTranspile);
    }
    if (!existingPackageJson) {
        createTempPackageJson(functionPath);
    }
    return new Promise((resolve, reject) => {
        let child;
        let timer;
        let executionStart;
        function start() {
            executionStart = performance.now();
            child = spawn('node', ['--enable-source-maps', getChildProcessWrapperPath()], {
                cwd: cwd(),
                stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
                env: { ...process.env, ...resource.env, FORCE_COLOR: forceColor ? '1' : '0' },
            });
            child.on('message', (data) => {
                const executionTimeMs = performance.now() - executionStart;
                const { json, logs } = JSON.parse(data.toString());
                shutdown();
                resolve({
                    json,
                    logs: sanitizeLogs(logs),
                    error: undefined,
                    timings: {
                        ...bundleTimings,
                        execute: executionTimeMs,
                    },
                });
            });
            child.on('error', (error) => {
                shutdown();
                reject(new Error(`encountered error ${error.message}`));
            });
            child.on('exit', (code) => {
                const executionTimeMs = performance.now() - executionStart;
                shutdown();
                if (code !== 0) {
                    reject(new Error(`exited with code ${code}`));
                }
                else {
                    resolve({
                        json: undefined,
                        logs: '',
                        error: undefined,
                        timings: {
                            ...bundleTimings,
                            execute: executionTimeMs,
                        },
                    });
                }
            });
            timer = setTimeout(() => {
                shutdown();
                reject(new Error(`Timeout: The process exceeded your current timeout limit of ${timeout} seconds. Learn to adjust your Blueprint's timeout settings here: https://www.sanity.io/docs/help/functions-timeout`));
            }, timeout * 1000);
            const payload = {
                data: { ...filteredData },
                context: {
                    ...context,
                    local: true,
                    clientOptions: {
                        ...context.clientOptions,
                        apiHost: config.apiUrl,
                    },
                },
            };
            child.send(JSON.stringify({ srcPath: functionPath, payload }, null, 2));
        }
        function shutdown() {
            clearTimeout(timer);
            if (child && !child.killed) {
                child.kill();
            }
            // If we previously created a temporary package.json, let's clean it up
            if (!existingPackageJson) {
                cleanupTempPackageJson(functionPath);
            }
            cleanupBundle().catch((err) => console.warn('Bundle cleanup failed:', err));
        }
        start();
    });
}
