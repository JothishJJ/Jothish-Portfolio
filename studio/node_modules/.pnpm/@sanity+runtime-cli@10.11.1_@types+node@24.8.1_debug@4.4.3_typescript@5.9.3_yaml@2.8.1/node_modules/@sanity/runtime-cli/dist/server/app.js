import { existsSync, readFileSync, watchFile } from 'node:fs';
import * as http from 'node:http';
import { default as mime } from 'mime-types';
import { WebSocketServer } from 'ws';
import { readLocalBlueprint } from '../actions/blueprints/blueprint.js';
import config from '../config.js';
import { isRecord } from '../utils/is-record.js';
import { isEventType, } from '../utils/types.js';
import { handleInvokeRequest } from './handlers/invoke.js';
const host = 'localhost';
const app = (port, executionOptions) => {
    const requestListener = async (req, res) => {
        res.setHeader('Content-Type', 'application/json');
        switch (true) {
            case req.url === '/blueprint': {
                try {
                    const { parsedBlueprint, projectId } = await readLocalBlueprint();
                    res.setHeader('Content-Type', 'application/json');
                    res.writeHead(200);
                    res.end(JSON.stringify({ parsedBlueprint, projectId })); // Use blueprint directly
                }
                catch (error) {
                    res.writeHead(404);
                    res.end(JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' }));
                }
                break;
            }
            case req.url === '/invoke': {
                if (req.method === 'POST') {
                    const body = [];
                    req.on('data', (data) => body.push(data));
                    req.on('end', async () => {
                        res.setHeader('Content-Type', 'application/json');
                        try {
                            const { data, func: functionName, metadata } = parseInvokeRequest(Buffer.concat(body));
                            const { context, event } = data;
                            // replace user token if required
                            if (context.clientOptions.token) {
                                context.clientOptions.token = config.token || undefined;
                            }
                            else {
                                delete context.clientOptions.token;
                            }
                            const result = await handleInvokeRequest(functionName, event, metadata, context, executionOptions);
                            // Add Server-Timing header
                            const timingHeaders = [];
                            for (const [key, value] of Object.entries(result.timings)) {
                                timingHeaders.push(`${key.replace(/:/g, '-')};dur=${Math.abs(value).toFixed(1)}`);
                            }
                            if (timingHeaders.length > 0) {
                                res.setHeader('Server-Timing', timingHeaders.join(', '));
                            }
                            res.end(JSON.stringify(result));
                        }
                        catch (error) {
                            console.error(error);
                            const response = { logs: '', error: '' };
                            if (error instanceof Error) {
                                response.logs = error.message;
                            }
                            res.writeHead(200);
                            res.end(JSON.stringify(response));
                        }
                    });
                }
                break;
            }
            case req.url === '/projects': {
                res.setHeader('Content-Type', 'application/json');
                try {
                    const response = await fetch(`${config.apiUrl}/v2021-06-07/projects?includeOrganizationProjects=true`, {
                        headers: {
                            Authorization: `Bearer ${config.token}`,
                        },
                    });
                    const json = await response.json();
                    res.writeHead(200);
                    res.end(JSON.stringify(json));
                }
                catch {
                    res.writeHead(200);
                    res.end(JSON.stringify([]));
                }
                break;
            }
            case req.url?.startsWith('/datasets'): {
                const url = req.url || '';
                const matches = url.match(/[?&]project=([^&]+)/) || [];
                const projectId = matches ? matches[1] : null;
                res.setHeader('Content-Type', 'application/json');
                try {
                    let json = [];
                    if (projectId) {
                        const response = await fetch(`${config.apiUrl}/v2024-08-25/projects/${projectId}/datasets?includeStats=true`, {
                            headers: {
                                Authorization: `Bearer ${config.token}`,
                            },
                        });
                        json = await response.json();
                    }
                    res.writeHead(200);
                    res.end(JSON.stringify(json));
                }
                catch {
                    res.writeHead(200);
                    res.end(JSON.stringify([]));
                }
                break;
            }
            case req.url?.startsWith('/document'): {
                const url = req.url || '';
                const parsed = parseDocumentUrl(url);
                if (parsed) {
                    const { projectId, dataset, docId } = parsed;
                    res.setHeader('Content-Type', 'application/json');
                    try {
                        let json = {};
                        const url = buildApiUrl(projectId, dataset, docId, config.apiUrl);
                        if (docId) {
                            const response = await fetch(url, {
                                headers: {
                                    Authorization: `Bearer ${config.token}`,
                                },
                            });
                            const queryResponse = await response.json();
                            if (queryResponse?.result[0]) {
                                json = queryResponse?.result[0];
                            }
                        }
                        res.writeHead(200);
                        res.end(JSON.stringify(json));
                    }
                    catch {
                        res.writeHead(200);
                        res.end(JSON.stringify([]));
                    }
                }
                break;
            }
            default: {
                const requestPath = req.url?.endsWith('/') ? `${req.url}index.html` : req.url;
                const filePath = new URL(`./static${requestPath}`, import.meta.url).pathname;
                if (existsSync(filePath)) {
                    const mimeType = mime.lookup(filePath) || 'text/plain';
                    res.setHeader('Content-Type', mimeType);
                    const content = readFileSync(filePath).toString();
                    res.writeHead(200);
                    res.end(content);
                }
                else {
                    res.writeHead(404);
                    res.end();
                }
                break;
            }
        }
    };
    const server = http.createServer(requestListener);
    server.listen(port, host, () => { });
    const wss = new WebSocketServer({ port: 8974 });
    wss.on('connection', async function connection(ws) {
        ws.on('error', console.error);
        const { fileInfo } = await readLocalBlueprint();
        watchFile(fileInfo.blueprintFilePath, { interval: 2007 }, async () => {
            ws.send('reload-blueprint');
        });
    });
};
// Helper function to test URL parsing and document fetching logic
function parseDocumentUrl(url) {
    const matches = url.match(/[?&]project=([^&]+).*?[&]dataset=([^&]+).*?[&]doc=([^&]+)/) || [];
    if (matches && matches.length === 4) {
        const [, projectId, dataset, docId] = matches;
        // Ensure all parameters are present and non-empty
        if (projectId && dataset && docId) {
            return { projectId, dataset, docId };
        }
    }
    return null;
}
// Helper function to build expected API URL
function buildApiUrl(projectId, dataset, docId, apiUrl) {
    const encodedQuery = encodeURIComponent(`*[_id == "${docId}"]`);
    const baseUrl = apiUrl === 'https://api.sanity.io/'
        ? `https://${projectId}.api.sanity.io/`
        : `https://${projectId}.api.sanity.work/`;
    return `${baseUrl}v1/data/query/${dataset}?query=${encodedQuery}`;
}
function parseInvokeRequest(body) {
    let json;
    try {
        json = JSON.parse(body.toString('utf8'));
    }
    catch (error) {
        throw new Error('Request body is not valid JSON', { cause: error });
    }
    if (!isRecord(json)) {
        throw new Error('Request body is not valid, must be an object');
    }
    if (!('func' in json)) {
        throw new Error('Request body is not valid, missing `func` field');
    }
    if (!('data' in json)) {
        throw new Error('Request body is not valid, missing `data` field');
    }
    const { data, func, metadata } = json;
    if (typeof func !== 'string') {
        throw new Error('Request body is not valid, `func` field is not a string');
    }
    if (!isRecord(data)) {
        throw new Error('Request body is not valid, `data` field is not an object');
    }
    const { context, event } = data;
    if (!isRecord(context)) {
        throw new Error('Request body is not valid, `context` field is not an object');
    }
    if (!isRecord(event)) {
        throw new Error('Request body is not valid, `event` field is not an object');
    }
    if (!('clientOptions' in context)) {
        throw new Error('Request body is not valid, `context.clientOptions` field is missing');
    }
    if (!isRecord(context.clientOptions)) {
        throw new Error('Request body is not valid, `context.clientOptions` field is not an object');
    }
    const { projectId, dataset, apiVersion } = context.clientOptions;
    if (typeof projectId !== 'string' && typeof projectId !== 'undefined') {
        throw new Error('Request body is not valid, `context.clientOptions.projectId` field is not a string');
    }
    if (typeof dataset !== 'string' && typeof dataset !== 'undefined') {
        throw new Error('Request body is not valid, `context.clientOptions.dataset` field is not a string');
    }
    if (typeof apiVersion !== 'string' && typeof apiVersion !== 'undefined') {
        throw new Error('Request body is not valid, `context.clientOptions.apiVersion` field is not a string');
    }
    if (!isRecord(metadata)) {
        throw new Error('Request body is not valid, `metadata` field is not an object');
    }
    if (!('event' in metadata)) {
        throw new Error('Request body is not valid, `metadata.event` field is missing');
    }
    const metadataEvent = metadata.event;
    if (typeof metadataEvent !== 'string' || !isEventType(metadataEvent)) {
        throw new Error('Request body is not valid, `metadata.event` field is not one of `create`, `update`, or `delete`');
    }
    if (!('before' in metadata)) {
        throw new Error('Request body is not valid, `metadata.before` field is missing');
    }
    if (!('after' in metadata)) {
        throw new Error('Request body is not valid, `metadata.after` field is missing');
    }
    const { before, after } = metadata;
    if (!isRecord(before) && before !== null) {
        throw new Error('Request body is not valid, `metadata.before` field is not an object');
    }
    if (!isRecord(after) && after !== null) {
        throw new Error('Request body is not valid, `metadata.after` field is not an object');
    }
    const clientOptions = {
        ...context.clientOptions,
        projectId,
        dataset,
        // Prefer `undefined` over empty string, triggering the right warnings in the client
        apiVersion: apiVersion || undefined,
    };
    return {
        func,
        data: { context: { ...context, clientOptions }, event },
        metadata: { event: metadataEvent, before, after },
    };
}
export { app, buildApiUrl, parseDocumentUrl };
