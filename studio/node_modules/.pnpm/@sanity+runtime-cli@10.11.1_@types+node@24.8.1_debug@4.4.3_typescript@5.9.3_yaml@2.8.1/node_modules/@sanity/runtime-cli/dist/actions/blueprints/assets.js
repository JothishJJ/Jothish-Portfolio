import crypto from 'node:crypto';
import fs from 'node:fs';
import path from 'node:path';
import { cwd } from 'node:process';
import AdmZip from 'adm-zip';
import getFolderSize from 'get-folder-size';
import config from '../../config.js';
import { resolveResourceDependencies } from '../../utils/functions/resolve-dependencies.js';
import { shouldAutoResolveDependencies } from '../../utils/functions/should-auto-resolve-deps.js';
import { shouldTranspileFunction } from '../../utils/functions/should-transpile.js';
import getHeaders from '../../utils/get-headers.js';
import { transpileFunction } from '../../utils/transpile/transpile-function.js';
const { apiUrl } = config;
const ASSETS_URL = `${apiUrl}vX/blueprints/assets`;
export const ASSET_CHECK_URL = `${ASSETS_URL}/check`;
export const ASSET_STASH_URL = `${ASSETS_URL}/stash`;
const MAX_ASSET_SIZE = 209_715_200; // 200 MB in bytes
export async function stashAsset({ resource, auth, }) {
    if (!resource.src)
        throw new Error('Resource src is required');
    let functionPath = path.join(cwd(), resource.src);
    let cleanup = async () => { };
    const shouldTranspile = await shouldTranspileFunction(resource);
    if (shouldTranspile) {
        try {
            const result = await transpileFunction(resource);
            functionPath = result.outputDir;
            cleanup = result.cleanup;
        }
        catch (err) {
            return { success: false, error: err instanceof Error ? err.message : `${err}` };
        }
    }
    const shouldResolveDependencies = await shouldAutoResolveDependencies(resource);
    if (shouldResolveDependencies) {
        await resolveResourceDependencies(resource, shouldTranspile);
    }
    try {
        // This works for files and folders
        const size = await getFolderSize.loose(functionPath);
        if (size > MAX_ASSET_SIZE) {
            throw new Error('Resource is larger than max asset size of 200 MB.');
        }
        const { b64, hash } = await pathToB64ZipHash(functionPath);
        try {
            const checkResponse = await fetch(`${ASSET_CHECK_URL}/${hash}`, {
                method: 'GET',
                headers: getHeaders(auth),
            });
            const checkJson = await checkResponse.json();
            if (checkResponse.ok && checkJson.exists && checkJson.id) {
                return { success: true, assetId: checkJson.id, exists: true, hash };
            }
        }
        catch { } // Continue to stash the Asset
        // Asset doesn't exist, so stash it
        const assetResponse = await fetch(ASSET_STASH_URL, {
            method: 'POST',
            headers: getHeaders(auth),
            body: JSON.stringify({
                file: b64,
                filename: `${resource.name}.zip`,
            }),
        });
        const assetJson = await assetResponse.json();
        if (assetResponse.ok) {
            return { success: true, assetId: assetJson.id, exists: false, hash };
        }
        return { success: false, error: assetJson.message || 'Unknown error' };
    }
    catch (err) {
        let error = '';
        if (err instanceof Error)
            error = err.message;
        return { success: false, error };
    }
    finally {
        await cleanup();
    }
}
export function hashBuffer(buffer) {
    const hash = crypto.createHash('sha256');
    hash.update(buffer);
    return hash.digest('hex');
}
export async function pathToZip(path) {
    const stats = await fs.promises.stat(path);
    const zip = new AdmZip();
    if (stats.isDirectory())
        zip.addLocalFolder(path);
    else
        zip.addLocalFile(path, '', 'index.js');
    return zip;
}
export async function pathToB64ZipHash(path) {
    const zip = await pathToZip(path);
    const buffer = zip.toBuffer();
    const b64 = buffer.toString('base64');
    const hash = hashBuffer(buffer);
    return { b64, buffer, hash, zip };
}
