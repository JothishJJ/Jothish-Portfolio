import { existsSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { cwd } from 'node:process';
import { highlight } from 'cardinal';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { createFunctionResource } from '../../actions/blueprints/resources.js';
import { verifyExampleExists, writeExample } from '../../actions/sanity/examples.js';
import { check, indent, warn } from '../../utils/display/presenters.js';
import { validateFunctionName } from '../../utils/validate/resource.js';
const generateFunctionBlueprintResourceTemplate = (fnName, eventNames) => `
  export default defineBlueprint({
    resources: [
      // ...
      defineDocumentFunction({name: '${fnName}', event: {on: [${eventNames.map((e) => `'${e.replace('document-', '')}'`).join(', ')}]}}), // ← add this line
    ],
  })
`;
export async function blueprintAddCore(options) {
    const root = cwd();
    const { log, blueprint, args, flags } = options;
    const { blueprintFilePath } = blueprint.fileInfo;
    const { type: resourceType } = args;
    const { example: flagExample, name: flagResourceName, 'fn-type': flagFnType, javascript: flagJs, 'fn-helpers': flagFnHelpers, install: flagI, 'fn-installer': flagFnInstaller, // can be 'skip'!
     } = flags;
    let { language: flagFnLang } = flags;
    flagFnLang = flagJs ? 'js' : flagFnLang;
    if (resourceType !== 'function') {
        return {
            success: false,
            error: `Unsupported Resource type: ${resourceType}`,
        };
    }
    if (flagExample) {
        // ! short circuit for examples
        log(warn(`Example feature is experimental. Setting up "${flagExample}"...`)); // we need to...
        // * 1. verify example exists in the recipes repo
        const exampleExists = await verifyExampleExists({ type: 'function', name: flagExample });
        if (!exampleExists) {
            return { success: false, error: `Function example "${flagExample}" does not exist.` };
        }
        // * 2. download and write example to disk
        // TODO: revisit path string handling; differs for fs operations vs. display
        const exampleDir = join(dirname(blueprintFilePath), 'functions', flagExample);
        if (existsSync(exampleDir)) {
            return {
                success: false,
                error: `Directory "${exampleDir.replace(root, '')}" already exists.`,
            };
        }
        const addedExample = await writeExample({
            exampleType: 'function',
            exampleName: flagExample,
            dir: exampleDir,
        });
        if (!addedExample) {
            return { success: false, error: `Unable to download example "${flagExample}"` };
        }
        const { files, dir, instructions, functionConfig } = addedExample;
        const newDir = dir.replace(root, '').replace(/^[/\\]+/, '');
        for (const filePath of Object.keys(files)) {
            log(check(`${chalk.bold('Created:')}  ${newDir}/${filePath}`));
        }
        // * 3. print instructions
        if (functionConfig) {
            log('');
            log(chalk.bold(`Add the following to ${blueprint.fileInfo.fileName}:`));
            const configString = JSON.stringify(functionConfig, null, 2);
            if (blueprint.fileInfo.extension === '.json') {
                log(indent(highlight(configString)));
            }
            else {
                // modify configString so it doesn't have quoted keys
                const objectLiteral = configString.replace(/^(\s*)"([a-zA-Z_$][a-zA-Z0-9_$]*)":/gm, '$1$2:');
                log(indent(highlight(`defineDocumentFunction(${objectLiteral})`)));
            }
        }
        else {
            log(warn('No Function config found in example.'));
        }
        if (instructions) {
            log('');
            log(instructions);
        }
        return { success: true };
    }
    if (flagI) {
        if (flagFnInstaller) {
            return {
                success: false,
                error: 'Cannot use --fn-installer flag with the --install flag',
            };
        }
        if (!flagFnHelpers) {
            return {
                success: false,
                error: 'Cannot use --no-fn-helpers flag with the --install flag',
            };
        }
    }
    if (flagResourceName && !validateFunctionName(flagResourceName)) {
        // if provided && invalid, return error ASAP
        return {
            success: false,
            error: `Invalid function name: ${flagResourceName}`,
        };
    }
    try {
        const fnName = flagResourceName || (await promptForFunctionName());
        // look for existing function with same name
        if (blueprint.parsedBlueprint.resources?.some((r) => r.name === fnName)) {
            return {
                success: false,
                error: `Function "${chalk.bold(fnName)}" already exists.`,
            };
        }
        let fnTypes;
        if (flagFnType) {
            if (Array.isArray(flagFnType)) {
                fnTypes = flagFnType;
            }
            else {
                fnTypes = [flagFnType];
            }
        }
        else {
            fnTypes = await promptForFunctionType();
        }
        const fnLang = flagFnLang || (await promptForFunctionLang());
        if (fnTypes.length === 0) {
            throw new Error('At least one function type must be provided.');
        }
        if (!fnTypes.every((evt) => ['document-publish', 'document-create', 'document-delete', 'document-update'].includes(evt))) {
            throw new Error('Invalid function type. Must be one of: document-publish, document-create, document-delete, document-update');
        }
        let addHelpers;
        let installCommand;
        if (!['ts', 'js'].includes(fnLang)) {
            // language is not supported
            addHelpers = false;
            installCommand = null;
        }
        else if (flagFnHelpers === false) {
            // explicit "false" means user does not want helpers: "--no-fn-helpers"
            addHelpers = false;
            installCommand = null;
        }
        else if (flagI) {
            // user wants to install helpers with npm
            addHelpers = true;
            installCommand = 'npm';
        }
        else if (flagFnInstaller) {
            addHelpers = true; //  if installer is passed, assume addHelpers
            installCommand = flagFnInstaller === 'skip' ? null : flagFnInstaller;
        }
        else {
            // unsure; ask...
            addHelpers = flagFnHelpers || (await promptForAddHelpers());
            installCommand = addHelpers ? await promptForInstallCommand() : null;
        }
        if (installCommand)
            log(`${chalk.magenta('Installing')} with ${installCommand}...`);
        const { filePath, resourceAdded, resource } = await createFunctionResource({
            blueprintFilePath,
            name: fnName,
            type: fnTypes,
            lang: fnLang,
            addHelpers,
            installCommand,
        });
        log(`\nCreated function: ${filePath.replace(root, '')}`);
        if (!resourceAdded) {
            // print the resource definition for manual addition
            log(`\n${chalk.bold('Add the Resource to your Blueprint:')}`);
            switch (blueprint.fileInfo.extension) {
                case '.ts':
                case '.js':
                case '.mjs': {
                    log(highlight(generateFunctionBlueprintResourceTemplate(fnName, fnTypes)));
                    break;
                }
                default:
                    log(highlight(JSON.stringify(resource, null, 2)));
                    break;
            }
        }
        else {
            // added to blueprint.json
            log(`Function "${chalk.bold(fnName)}" added to Blueprint file.`);
        }
        return { success: true };
    }
    catch (err) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        return {
            success: false,
            error: errorMessage,
        };
    }
}
async function promptForFunctionName() {
    const { functionName } = await inquirer.prompt([
        {
            type: 'input',
            name: 'functionName',
            message: 'Enter function name:',
            validate: (input) => validateFunctionName(input) ||
                'Invalid function name. Must be 6+ characters, no special characters, no spaces',
        },
    ]);
    return functionName;
}
async function promptForFunctionType() {
    const { functionType } = await inquirer.prompt([
        {
            type: 'checkbox',
            name: 'functionType',
            message: 'Choose document change events to trigger your function:',
            choices: [
                { name: 'Document Create', value: 'document-create' },
                { name: 'Document Update', value: 'document-update' },
                { name: 'Document Delete', value: 'document-delete' },
                {
                    name: 'Document Publish (Deprecated - use Create + Update instead)',
                    value: 'document-publish',
                },
            ],
            default: ['document-create', 'document-update'],
            validate(choices) {
                if (choices.length === 0) {
                    return 'You must choose at least one function type / document change event';
                }
                return true;
            },
        },
    ]);
    return functionType;
}
async function promptForFunctionLang() {
    const { functionLang } = await inquirer.prompt([
        {
            type: 'list',
            name: 'functionLang',
            message: 'Choose function language:',
            choices: [
                { name: 'TypeScript', value: 'ts' },
                { name: 'JavaScript', value: 'js' },
            ],
            default: 'ts',
        },
    ]);
    return functionLang;
}
async function promptForAddHelpers() {
    const { addHelpers } = await inquirer.prompt([
        {
            type: 'confirm',
            name: 'addHelpers',
            message: 'Add @sanity/functions helpers to the new Function?',
            default: true,
        },
    ]);
    return addHelpers;
}
async function promptForInstallCommand() {
    const { command } = await inquirer.prompt([
        {
            type: 'list',
            name: 'command',
            message: 'How to install the @sanity/functions helpers:',
            choices: [
                { name: 'npm', value: 'npm' },
                { name: 'pnpm', value: 'pnpm' },
                { name: 'yarn', value: 'yarn' },
                { name: 'Skip install', value: null },
            ],
            default: 'npm',
        },
    ]);
    return command;
}
