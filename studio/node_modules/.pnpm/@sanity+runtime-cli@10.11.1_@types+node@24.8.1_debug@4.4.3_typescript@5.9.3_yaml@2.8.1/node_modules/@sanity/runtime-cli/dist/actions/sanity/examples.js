import { createReadStream, createWriteStream, existsSync, mkdirSync, statSync, writeFileSync, } from 'node:fs';
import { tmpdir } from 'node:os';
import { dirname, join } from 'node:path';
import { pipeline } from 'node:stream/promises';
import { createGunzip } from 'node:zlib';
import { extract } from 'tar-stream';
import { gitHubRequest } from '../../utils/other/github.js';
export const EXAMPLES_CACHE_DIR = join(tmpdir(), 'sanity-examples');
const EXAMPLES_REPO = 'sanity-io/sanity';
const EXAMPLES_DIR = 'examples';
const BLUEPRINTS_DIR = `${EXAMPLES_DIR}/blueprints`;
const FUNCTIONS_DIR = `${EXAMPLES_DIR}/functions`;
const EXAMPLE_TYPES = {
    blueprint: BLUEPRINTS_DIR,
    function: FUNCTIONS_DIR,
};
export async function verifyExampleExists({ type, name, }) {
    const examplePath = `${EXAMPLE_TYPES[type]}/${name}`;
    const path = `/repos/${EXAMPLES_REPO}/contents/${examplePath}`;
    const response = await gitHubRequest(path);
    return response.ok;
}
async function downloadRepoArchive(ownerRepo, ref = 'main') {
    // cache the archive in a temp directory
    const cacheKey = `${ownerRepo.replace('/', '-')}-${ref}.tar.gz`;
    const cacheDir = EXAMPLES_CACHE_DIR;
    const cachePath = join(cacheDir, cacheKey);
    if (existsSync(cachePath)) {
        const stats = statSync(cachePath);
        const ageMinutes = (Date.now() - stats.mtime.getTime()) / (1000 * 60);
        if (ageMinutes < 5)
            return createReadStream(cachePath);
    }
    const path = `/repos/${ownerRepo}/tarball/${ref}`;
    try {
        const response = await gitHubRequest(path);
        if (!response.ok)
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        if (!response.body)
            throw new Error('No response body received');
        mkdirSync(cacheDir, { recursive: true });
        const cacheWriteStream = createWriteStream(cachePath);
        try {
            // converting web streams to node streams is awkward
            await pipeline(response.body, cacheWriteStream);
        }
        catch (error) {
            console.debug(error);
            return response.body;
        }
        return createReadStream(cachePath);
    }
    catch (error) {
        console.error('❌ Error:', error instanceof Error ? error.message : 'Unknown error');
        return null;
    }
}
async function extractExampleFromArchive({ archiveStream, exampleType, exampleName, }) {
    const fullPath = `${EXAMPLE_TYPES[exampleType]}/${exampleName}`;
    const files = {};
    let repoPrefix = null;
    const extractStream = extract();
    extractStream.on('entry', (header, stream, next) => {
        const { name, type } = header;
        // GitHub tarballs have a top-level directory like "repo-name-commit-hash/"
        // detect it and strip it
        if (!repoPrefix && name.includes('/'))
            repoPrefix = name.split('/')[0];
        // remove the repo prefix to get the actual file path
        const cleanPath = repoPrefix ? name.replace(`${repoPrefix}/`, '') : name;
        // check if this file is in our target example directory
        if (cleanPath.startsWith(`${fullPath}/`) || cleanPath === fullPath) {
            if (type === 'file') {
                const chunks = [];
                stream.on('data', (chunk) => chunks.push(chunk));
                stream.on('end', () => {
                    const content = Buffer.concat(chunks).toString('utf8');
                    files[cleanPath.replace(`${fullPath}/`, '')] = content;
                    next();
                });
            }
            else {
                stream.resume(); // skip directories
                next();
            }
        }
        else {
            stream.resume();
            next();
        }
    });
    // pipes!
    await pipeline(archiveStream, createGunzip(), extractStream);
    if (Object.keys(files).length === 0)
        return null;
    return files;
}
function writeExampleToDisk(files, targetDir, exampleName) {
    for (const [filePath, content] of Object.entries(files)) {
        // Remove the example prefix from the file path for local storage
        const localPath = filePath.startsWith(`${exampleName}/`)
            ? filePath.replace(`${exampleName}/`, '')
            : filePath;
        const fullPath = join(targetDir, localPath);
        const dir = dirname(fullPath);
        // Create directory if it doesn't exist
        mkdirSync(dir, { recursive: true });
        // Write file
        writeFileSync(fullPath, content);
    }
}
/**
 * @sideEffect Modifies the example files to remove the function config from the package.json.
 * @returns The function config if it exists.
 */
function extractFunctionConfig(exampleFiles) {
    const packageJson = exampleFiles['package.json'];
    if (!packageJson)
        return null;
    let functionConfig = null;
    try {
        const packageJsonContent = JSON.parse(packageJson);
        functionConfig = packageJsonContent.blueprintResourceItem;
        packageJsonContent.blueprintResourceItem = undefined;
        exampleFiles['package.json'] = JSON.stringify(packageJsonContent, null, 2);
    }
    catch {
        return null;
    }
    return functionConfig;
}
/**
 * @sideEffect Modifies the example files to remove the instructions from the package.json.
 * @returns The instructions if they exist.
 */
function extractInstructions(exampleFiles) {
    const packageJson = exampleFiles['package.json'];
    if (!packageJson)
        return null;
    let instructions = null;
    try {
        const packageJsonContent = JSON.parse(packageJson);
        instructions = packageJsonContent.exampleInstructions;
        packageJsonContent.exampleInstructions = undefined;
        exampleFiles['package.json'] = JSON.stringify(packageJsonContent, null, 2);
    }
    catch {
        return null;
    }
    return instructions;
}
/**
 * Downloads an example from the examples repo and writes it to disk.
 * @sideEffect Creates the example directory and writes the example to disk.
 * @returns The example files and directory and the function config if it exists.
 */
export async function writeExample({ ownerRepo = EXAMPLES_REPO, exampleType, exampleName, dir = './tmp', }) {
    const archiveStream = await downloadRepoArchive(ownerRepo);
    if (!archiveStream)
        return false;
    const exampleFiles = await extractExampleFromArchive({
        archiveStream,
        exampleType,
        exampleName,
    });
    if (!exampleFiles)
        return false;
    let instructions = null;
    instructions = extractInstructions(exampleFiles);
    let functionConfig = null;
    if (exampleType === 'function')
        functionConfig = extractFunctionConfig(exampleFiles);
    mkdirSync(dir, { recursive: true });
    writeExampleToDisk(exampleFiles, dir, exampleName);
    return { files: exampleFiles, dir, instructions, functionConfig };
}
