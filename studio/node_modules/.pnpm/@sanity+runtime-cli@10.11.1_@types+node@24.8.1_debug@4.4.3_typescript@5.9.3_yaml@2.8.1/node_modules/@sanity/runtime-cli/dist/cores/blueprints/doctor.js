import { cwd } from 'node:process';
import chalk from 'chalk';
import ora from 'ora';
import { findBlueprintFile, readLocalBlueprint, } from '../../actions/blueprints/blueprint.js';
import { getStack } from '../../actions/blueprints/stacks.js';
import config from '../../config.js';
import { check, indent, niceId, severe, warn } from '../../utils/display/presenters.js';
import { validTokenOrErrorMessage } from '../../utils/validated-token.js';
const diagLookup = {
    online: 'Online',
    tokenPresent: 'Auth token present',
    tokenValid: 'Auth token valid',
    configFilePresent: 'Blueprints config file present',
    configFileValid: 'Blueprints config file valid',
    blueprintPresent: 'Blueprint file present',
    blueprintValid: 'Blueprint file valid',
    stackReady: 'Deployment "Stack" ready',
    userHasAccess: 'User has access to "Stack"',
};
export async function blueprintDoctorCore(options) {
    const { log, token, flags: { verbose: v, path: p }, } = options;
    const yikes = (s) => {
        log(chalk.bgRedBright.whiteBright.bold(` ${s} `));
    };
    const here = cwd();
    const path = p || here;
    if (v)
        log(`Checking ${path}`);
    // 3 states: null == unknown, true == good, false == bad
    const diagnostics = {};
    for (const key in diagLookup) {
        diagnostics[key] = null;
    }
    let spinner;
    if (!v)
        spinner = ora('Checking environment').start();
    // ONLINE
    try {
        const res = await fetch(config.apiUrl);
        if (res.ok) {
            if (v)
                log(`Successfully pinged ${config.apiUrl}`);
            diagnostics.online = res.ok;
        }
        else {
            if (v)
                yikes(`Failed to ping ${config.apiUrl}: ${res.status} ${res.statusText}`);
            diagnostics.online = false;
        }
    }
    catch {
        if (v)
            yikes(`Failed to ping ${config.apiUrl}`);
    }
    // TOKEN
    if (token) {
        diagnostics.tokenPresent = true;
        const tokenOrError = await validTokenOrErrorMessage(token);
        if (tokenOrError.ok) {
            diagnostics.tokenValid = true;
        }
        else {
            if (v)
                yikes(`Token error: ${tokenOrError.error}`);
            diagnostics.tokenValid = false;
        }
    }
    else {
        diagnostics.tokenPresent = false;
    }
    // BLUEPRINT file
    const blueprintFile = findBlueprintFile(path);
    if (blueprintFile?.blueprintFilePath) {
        if (v)
            log(`Found blueprint file at ${blueprintFile.blueprintFilePath.replace(here, '.')}`);
        diagnostics.blueprintPresent = true;
    }
    else {
        diagnostics.blueprintPresent = false;
    }
    let blueprint;
    try {
        blueprint = await readLocalBlueprint(path);
        if (blueprint.errors.length === 0) {
            if (v)
                log(`Blueprint has no errors`);
            diagnostics.blueprintValid = true;
        }
        else {
            if (v)
                log(`Blueprint errors: \n${blueprint.errors.join('\n  ')}`);
            diagnostics.blueprintValid = false;
        }
    }
    catch {
        if (v)
            yikes(`Unable to read blueprint`);
        diagnostics.blueprintValid = false;
    }
    if (blueprint) {
        const { configPath, scopeType, scopeId, stackId, projectId } = blueprint;
        // CONFIG file
        if (configPath) {
            if (v)
                log(`Found config file at ${configPath.replace(here, '.')}`);
            diagnostics.configFilePresent = true;
            if (scopeType && scopeId && stackId) {
                diagnostics.configFileValid = true;
                if (v) {
                    const capitalizedScopeType = scopeType.charAt(0).toUpperCase() + scopeType.slice(1);
                    const configOutput = [
                        `${capitalizedScopeType}: ${niceId(scopeId)}`,
                        `Deployment: ${niceId(stackId)}`,
                    ].join('\n');
                    log(indent(configOutput));
                }
            }
            else {
                diagnostics.configFileValid = false;
            }
        }
        else {
            diagnostics.configFilePresent = false;
        }
        // STACK + ACCESS
        if (diagnostics.online && diagnostics.tokenValid && token && stackId && projectId) {
            const stackResponse = await getStack({
                auth: { token, scopeType: 'project', scopeId: projectId },
                stackId,
            });
            if (stackResponse.ok) {
                if (v)
                    log(`Deployment "Stack" ${niceId(stackId)} ready`);
                diagnostics.stackReady = true;
                diagnostics.userHasAccess = true;
            }
            else if (stackResponse.response?.status === 404) {
                if (v)
                    yikes(`Deployment "Stack" <${stackId}> not found`);
                diagnostics.stackReady = false;
            }
            else if (stackResponse.response?.status === 403 || stackResponse.response?.status === 401) {
                if (v)
                    yikes(`User does not have access to "Stack" <${stackId}>`);
                diagnostics.userHasAccess = false;
            }
            else {
                if (v)
                    yikes(`Unknown error with "Stack" <${stackId}>: ${stackResponse.error}`);
            }
        }
        else {
            if (v)
                yikes('Unable to check deployment "Stack" status.');
        }
    }
    if (spinner)
        spinner.stop();
    if (v)
        log('');
    let allGood = true;
    for (const [key, value] of Object.entries(diagnostics)) {
        switch (value) {
            case true:
                if (v)
                    log(check(diagLookup[key]));
                break;
            case false:
                allGood = false;
                log(severe(diagLookup[key]));
                break;
            case null:
                allGood = false;
                log(warn(diagLookup[key]));
                break;
            default:
                allGood = false;
                log(severe(`${key} is ${value}`));
        }
    }
    if (allGood) {
        log(chalk.bold.green('All checks passed'));
        return { success: true, data: { diagnostics } };
    }
    else {
        return { success: false, error: 'One or more checks failed', data: { diagnostics } };
    }
}
