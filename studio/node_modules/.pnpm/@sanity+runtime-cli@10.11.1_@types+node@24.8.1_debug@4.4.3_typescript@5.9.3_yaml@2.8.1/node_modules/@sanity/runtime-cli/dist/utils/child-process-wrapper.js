import {table as renderTable} from 'node:console'
import {existsSync, statSync} from 'node:fs'
import {isAbsolute, join} from 'node:path'
import process from 'node:process'
import {inspect} from 'node:util'

export function getFunctionSource(src) {
  const pathToCheck = isAbsolute(src) ? src : join(process.cwd(), src)

  if (statSync(pathToCheck).isDirectory()) {
    const indexPath = join(pathToCheck, 'index.js')
    if (!existsSync(indexPath)) {
      throw Error(`Function directory ${pathToCheck} has no index.js`)
    }
    return `file://${indexPath}`
  }
  return `file://${pathToCheck}`
}

// Monkey patch console menthods to have logs match server log format
function logPrefix(level, ...args) {
  const date = new Date()
  const shouldUseColors = process.env.FORCE_COLOR === '1'
  const message = args
    .map((arg) =>
      typeof arg === 'string' ? arg : inspect(arg, {depth: null, colors: shouldUseColors}),
    )
    .join(' ')
  return `${date.toLocaleDateString()} ${date.toLocaleTimeString()} ${level.toUpperCase()} ${message}`
}

console.log = (...args) => {
  process.stdout.write(`${logPrefix('info', ...args)}\n`)
}

console.info = (...args) => {
  process.stdout.write(`${logPrefix('info', ...args)}\n`)
}

console.dir = (obj, options) => {
  const shouldUseColors = process.env.FORCE_COLOR === '1'
  const inspectOptions = {...options, colors: shouldUseColors}
  process.stdout.write(`${logPrefix('info', inspect(obj, inspectOptions))}\n`)
}

console.table = (data, columns) => {
  const prefix = logPrefix('info')

  // Capture table output
  const originalWrite = process.stdout.write.bind(process.stdout)
  let buffer = ''

  process.stdout.write = (chunk, _encoding, callback) => {
    buffer += chunk
    if (typeof callback === 'function') callback()
  }

  renderTable(data, columns)

  // Restore and print
  process.stdout.write = originalWrite
  for (const line of buffer.split('\n')) {
    if (line.trim()) {
      const message = `${!line.startsWith(prefix) ? `${prefix} ${line}` : line}`.trim()
      process.stdout.write(`${message}\n`)
    }
  }
}

console.warn = (...args) => {
  process.stdout.write(`${logPrefix('warn', ...args)}\n`)
}

console.error = (...args) => {
  process.stdout.write(`${logPrefix('error', ...args)}\n`)
}

// Start when payload data arrives from parent process
process.on('message', async (data) => {
  let jsonData = null
  try {
    jsonData = JSON.parse(data)
  } catch {
    // invalid payload so return early
    return
  }
  const {srcPath, payload} = jsonData
  const {context, ...event} = payload
  let logs = ''
  let json = null

  // Import the function code
  const entry = await import(getFunctionSource(srcPath))

  let eventHandler = null

  if (typeof entry.handler === 'function') {
    eventHandler = entry.handler
  } else if (typeof entry.default === 'function') {
    eventHandler = entry.default
  }

  if (!eventHandler) {
    throw new Error(
      'No valid handler found. Please provide a default export or a named export, "handler"',
    )
  }

  // backup stdout
  const originalStdoutWrite = process.stdout.write.bind(process.stdout)

  // redirect stdout to a buffer
  process.stdout.write = (chunk) => {
    if (typeof chunk === 'string') {
      logs += chunk
    }
    return true
  }

  json = await eventHandler({context, event})

  // revert changes to stdout
  process.stdout.write = originalStdoutWrite

  // Send result of handler code to parent process.
  process.send(JSON.stringify({json, logs}))
})
