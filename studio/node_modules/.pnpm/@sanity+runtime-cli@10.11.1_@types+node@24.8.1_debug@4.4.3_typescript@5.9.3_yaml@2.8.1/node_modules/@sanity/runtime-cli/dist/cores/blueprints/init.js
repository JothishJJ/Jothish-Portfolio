import { existsSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { findBlueprintFile, writeBlueprintToDisk } from '../../actions/blueprints/blueprint.js';
import { writeConfigFile } from '../../actions/blueprints/config.js';
import { createEmptyStack, getStack } from '../../actions/blueprints/stacks.js';
import { writeGitignoreFile } from '../../actions/git.js';
import { writeOrUpdateNodeDependency } from '../../actions/node.js';
import { verifyExampleExists, writeExample } from '../../actions/sanity/examples.js';
import { getProject } from '../../actions/sanity/projects.js';
import { BLUEPRINT_CONFIG_FILE, BLUEPRINT_DIR } from '../../config.js';
import { check, warn } from '../../utils/display/presenters.js';
import { promptForProject, promptForStackId } from '../../utils/display/prompt.js';
const LAUNCH_LIMIT_STACK_PER_PROJECT = true;
export async function blueprintInitCore(options) {
    const { bin = 'sanity', log, token, args, flags } = options;
    try {
        const { dir: flagDir, example: flagExample, 'blueprint-type': flagBlueprintType, 'project-id': flagProjectId, 'stack-id': flagStackId, 'stack-name': flagStackName, } = flags;
        const { dir: argDir } = args;
        const providedDir = argDir || flagDir;
        const blueprintDir = providedDir || '.';
        const existingBlueprint = findBlueprintFile(blueprintDir);
        if (existingBlueprint) {
            return { success: false, error: 'Existing Blueprint found.' };
        }
        if (flagExample) {
            // ! short circuit for examples
            log(warn(`Example feature is experimental. Setting up "${flagExample}"...`));
            // we need to...
            // * 1. verify example exists in the recipes repo
            const exampleExists = await verifyExampleExists({ type: 'blueprint', name: flagExample });
            if (!exampleExists) {
                return { success: false, error: `Blueprint example "${flagExample}" does not exist.` };
            }
            // * 2. get a projectId from the user
            const projectId = flagProjectId || (await promptForProject({ token })).projectId;
            // * 3. create empty stack with name from example name
            const stack = await createEmptyStack({
                token,
                scopeType: 'project',
                scopeId: projectId,
                name: `example-${flagExample}`,
                projectBased: false,
            });
            // * 4. download and write example to disk
            // take into account optional providedDir
            const exampleDir = join(blueprintDir, providedDir ? '' : flagExample);
            if (existsSync(exampleDir)) {
                return { success: false, error: `Example directory "${exampleDir}" already exists.` };
            }
            const addedExample = await writeExample({
                exampleType: 'blueprint',
                exampleName: flagExample,
                dir: exampleDir,
            });
            if (!addedExample) {
                return { success: false, error: `Unable to download example "${flagExample}"` };
            }
            const { files, dir: newDir, instructions } = addedExample;
            for (const filePath of Object.keys(files)) {
                log(check(`${chalk.bold('Created:')}    ${newDir}/${filePath}`));
            }
            const discoveredBlueprint = findBlueprintFile(exampleDir);
            if (!discoveredBlueprint) {
                return { success: false, error: 'Failed to find blueprint file.' };
            }
            const { blueprintFilePath } = discoveredBlueprint;
            // * 5. write config file
            writeConfigFile({ blueprintFilePath, projectId, stackId: stack.id });
            log(check(`${chalk.bold('Configured:')} ${exampleDir}/${BLUEPRINT_DIR}/${BLUEPRINT_CONFIG_FILE}`));
            // * 6. print next step
            log(`\n  Run "${chalk.bold.magenta(`cd ${exampleDir} && npm i`)}" and check out the README`);
            if (instructions) {
                log('');
                log(instructions);
            }
            return { success: true };
        }
        let blueprintExtension = flagBlueprintType || (await promptForBlueprintType());
        if (!blueprintExtension) {
            return { success: false, error: 'Blueprint type is required.' };
        }
        if (blueprintExtension === 'js') {
            const packageJsonPath = join(blueprintDir, 'package.json');
            const packageExists = existsSync(packageJsonPath);
            if (packageExists) {
                // if package.json#type is not module, set blueprintExtension to mjs
                try {
                    const packageJson = readFileSync(packageJsonPath, 'utf8');
                    const packageJsonObject = JSON.parse(packageJson);
                    if (packageJsonObject.type !== 'module') {
                        blueprintExtension = 'mjs';
                    }
                }
                catch { } // not our concern
            }
        }
        let projectId = flagProjectId;
        let stackId = flagStackId;
        if (!projectId) {
            const pickedProject = await promptForProject({ token });
            projectId = pickedProject.projectId;
        }
        log('');
        if (flagStackName) {
            // using --stack-name gets around "LAUNCH LIMIT: 1 Stack per Project"
            const stack = await createEmptyStack({
                token,
                scopeType: 'project',
                scopeId: projectId,
                name: flagStackName,
                projectBased: false,
            });
            stackId = stack.id;
        }
        if (!stackId) {
            // LAUNCH LIMIT: 1 Stack per Project - do not prompt for Stack, just create one
            if (LAUNCH_LIMIT_STACK_PER_PROJECT) {
                await createProjectBasedStack({ token, scopeType: 'project', scopeId: projectId }, log);
                // do not set stackId, to avoid saving it to the config file
            }
            else {
                stackId = await promptForStackId({ projectId, token });
            }
        }
        const blueprintFileName = `sanity.blueprint.${blueprintExtension}`;
        const blueprintFilePath = join(blueprintDir, blueprintFileName);
        writeBlueprintToDisk({ blueprintFilePath });
        if (providedDir)
            log(check(`${chalk.bold('New folder created:')}  ${providedDir}/`));
        log(check(`${chalk.bold('Created Blueprint:')}   ${providedDir ?? '.'}/${blueprintFileName}`));
        writeConfigFile({ blueprintFilePath, projectId, stackId });
        log(check(`${chalk.bold('Added configuration:')} ${providedDir ?? '.'}/${BLUEPRINT_DIR}/${BLUEPRINT_CONFIG_FILE}`));
        writeGitignoreFile(blueprintFilePath);
        log(check(`${chalk.bold('Added .gitignore:')}    ${providedDir ?? '.'}/.gitignore`));
        if (blueprintExtension !== 'json') {
            try {
                // check for || create package.json and add @sanity/blueprints to dependencies
                await writeOrUpdateNodeDependency(blueprintFilePath, '@sanity/blueprints');
                log(check(`${chalk.bold('Added dependency:')}    @sanity/blueprints`));
            }
            catch {
                log(warn('Unable to add @sanity/blueprints to your project.'));
            }
        }
        const nextStepParts = [];
        if (providedDir)
            nextStepParts.push(`cd ${providedDir}`);
        if (blueprintExtension !== 'json')
            nextStepParts.push('npm install');
        nextStepParts.push(`${bin} blueprints --help`);
        log(`\n  Run "${chalk.bold.magenta(nextStepParts.join(' && '))}" to get started`);
        return { success: true };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log(`Error: ${errorMessage}`);
        return { success: false, error: errorMessage };
    }
}
async function promptForBlueprintType() {
    const { pickedBlueprintsType } = await inquirer.prompt([
        {
            type: 'list',
            name: 'pickedBlueprintsType',
            message: 'Choose a Blueprint file type:',
            choices: [
                { name: 'TypeScript', value: 'ts' },
                { name: 'JavaScript', value: 'js' },
                { name: 'JSON', value: 'json' },
            ],
            default: 'ts',
        },
    ]);
    return pickedBlueprintsType;
}
// LAUNCH LIMIT: 1 Stack per Project - create exclusive stack for project
async function createProjectBasedStack(auth, log) {
    if (auth.scopeType !== 'project') {
        throw new Error('Auth must be for a project');
    }
    const { scopeId: projectId, token } = auth;
    // get project
    const { ok: projectOk, project } = await getProject({
        token: auth.token,
        scopeType: 'project',
        scopeId: projectId,
    });
    if (!projectOk) {
        throw new Error('Failed to find Project while creating Stack');
    }
    const projectDisplayName = project.displayName;
    // check if project has a stack
    const inferredStackId = `ST-${projectId}`;
    const { stack: existingStack, ok: stackOk } = await getStack({ stackId: inferredStackId, auth });
    // if existing stack, return stack
    if (stackOk && existingStack) {
        log(warn(`"${projectDisplayName}" has an existing deployment.`));
        log(warn(`Deploying an empty Blueprint ${chalk.bold.red('will override the existing deployment!')}`));
        log('');
        return existingStack;
    }
    // if not, create a stack
    const stack = await createEmptyStack({
        token,
        scopeType: 'project',
        scopeId: projectId,
        name: projectDisplayName,
    });
    return stack;
}
