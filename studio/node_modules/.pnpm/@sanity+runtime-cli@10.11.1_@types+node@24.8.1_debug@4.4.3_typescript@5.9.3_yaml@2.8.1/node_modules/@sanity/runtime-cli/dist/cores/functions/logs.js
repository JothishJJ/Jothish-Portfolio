import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';
import { deleteLogs as deleteLogsAction, logs as getLogsAction, streamLogs as streamLogsAction, } from '../../actions/functions/logs.js';
import { formatTitle } from '../../utils/display/blueprints-formatting.js';
import { niceId } from '../../utils/display/presenters.js';
import { findFunctionByName } from '../../utils/find-function.js';
export async function functionLogsCore(options) {
    const { args, flags, log, auth, deployedStack } = options;
    const { name } = args;
    const { delete: shouldDelete, watch: shouldWatch, force, limit, json, utc } = flags;
    const { externalId } = findFunctionByName(deployedStack, name); // throws if not found
    if (shouldDelete)
        return deleteLogs({ name, externalId, auth, force, log });
    if (shouldWatch)
        return streamLogs({ name, externalId, auth, json, utc, log });
    return getLogs({ name, externalId, auth, limit, json, utc, log });
}
async function deleteLogs({ name, externalId, auth, force, }) {
    if (!force) {
        const { certain } = await inquirer.prompt({
            type: 'confirm',
            name: 'certain',
            message: `Are you sure you want to delete ${chalk.bold('all')} logs for function ${chalk.yellow(name)}?`,
            default: false,
        });
        if (!certain)
            return { success: true };
    }
    const spinner = ora(`Deleting logs for function ${chalk.yellow(name)}`).start();
    const { ok, error } = await deleteLogsAction(externalId, auth);
    if (!ok) {
        spinner.fail(`${chalk.red('Failed')} to delete logs`);
        return { success: false, error: error || 'Unknown error' };
    }
    spinner.succeed('Logs deleted');
    return { success: true };
}
async function streamLogs({ name, externalId, auth, log, }) {
    const spinner = ora(`Setting up streaming logs session for function ${niceId(name)}`).start();
    try {
        spinner.stop();
        log(`Streaming log session for function ${niceId(name)}`);
        log(`Watching for new logs... ${chalk.bold('ctrl+c')} to stop`);
        let alreadyOpened = false;
        const onOpen = () => {
            if (alreadyOpened)
                log(`${chalk.green('Reconnected')}`);
            alreadyOpened = true;
        };
        const renderLog = (logEntry) => {
            const { time, level, message } = logEntry;
            log(formatLog(time, level, message, true));
        };
        streamLogsAction(externalId, auth, renderLog, onOpen, (error) => log(`${chalk.red('Error:')} ${error}`));
        // Return a special key for streaming mode
        return {
            success: true,
            streaming: new Promise(() => { }),
        };
    }
    catch (err) {
        spinner.fail('Failed to retrieve logs');
        const errorMessage = err instanceof Error ? err.message : String(err);
        log(`Error: ${errorMessage}`);
        return { success: false, error: errorMessage };
    }
}
async function getLogs({ name, externalId, auth, limit, json, utc, log, }) {
    const spinner = ora(`Finding logs for function "${name}"`).start();
    const { ok, error, logs, total } = await getLogsAction(externalId, { limit }, auth);
    if (!ok) {
        spinner.fail(`${chalk.red('Failed')} to retrieve logs`);
        return { success: false, error: error || 'Unknown error' };
    }
    const filteredLogs = logs.filter((entry) => entry.level && entry.message);
    if (filteredLogs.length === 0) {
        spinner.info(`No logs found for function ${name}`);
        return { success: true };
    }
    spinner.succeed(`${formatTitle('Function', name)} Logs`);
    if (!json) {
        log(`Found ${chalk.bold(total)} log entries for function ${chalk.yellow(name)}`);
        if (logs.length < total) {
            log(`Here are the last ${chalk.bold(filteredLogs.length.toString())} entries`);
        }
        log('\n');
        for (const { time, level, message } of filteredLogs) {
            log(formatLog(time, level, message, utc));
        }
    }
    else {
        log(JSON.stringify(filteredLogs, null, 2));
    }
    return { success: true };
}
function formatLog(time, level, message, utc) {
    const date = new Date(time);
    const [dateString, timeString] = utc
        ? date.toISOString().slice(0, 19).split('T')
        : [date.toLocaleDateString(), date.toLocaleTimeString()];
    return [chalk.bold(dateString), chalk.bold.blue(timeString), logLevel(level), message].join(' ');
}
function logLevel(level) {
    if (level === 'ERROR')
        return chalk.red(level);
    if (level === 'WARN')
        return chalk.yellow(level);
    return chalk.green(level);
}
