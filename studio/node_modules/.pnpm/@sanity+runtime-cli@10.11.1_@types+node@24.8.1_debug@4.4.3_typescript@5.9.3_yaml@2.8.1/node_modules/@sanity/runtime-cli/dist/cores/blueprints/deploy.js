import { setTimeout } from 'node:timers/promises';
import chalk from 'chalk';
import ora from 'ora';
import { stashAsset } from '../../actions/blueprints/assets.js';
import { setupLogStreaming } from '../../actions/blueprints/logs-streaming.js';
import { getStack, updateStack } from '../../actions/blueprints/stacks.js';
import { niceId } from '../../utils/display/presenters.js';
import { isLocalFunctionResource } from '../../utils/types.js';
export async function blueprintDeployCore(options) {
    const { bin = 'sanity', log, auth, stackId, projectId, deployedStack, blueprint, flags } = options;
    const { verbose } = flags;
    const noWait = flags['no-wait'] || false;
    log(`Deploying "${deployedStack.name}" ${niceId(deployedStack.id)}...`);
    try {
        const { resources } = blueprint.parsedBlueprint;
        const validResources = resources?.filter((r) => r.type);
        const functionResources = validResources?.filter(isLocalFunctionResource);
        // First stash all function assets
        if (functionResources?.length) {
            log('Processing function assets...');
            for (const resource of functionResources) {
                const fnSpinner = ora({ text: `Processing ${resource.name}...`, prefixText: ' ' }).start();
                const result = await stashAsset({ resource, auth });
                if (result.success && result.assetId) {
                    const src = resource.src;
                    resource.src = result.assetId;
                    fnSpinner.succeed(`${resource.name} ${niceId(result.assetId)}`);
                    log(`   Source: ${src}`);
                    if (verbose) {
                        if (result.hash) {
                            if (result.hash.length > 24) {
                                log(`   Hash: ${result.hash.slice(0, 8)}...${result.hash.slice(-12)}`);
                            }
                            else {
                                log(`   Hash: ${result.hash}`);
                            }
                        }
                        if (result.exists)
                            log('   Asset unchanged');
                    }
                }
                else {
                    fnSpinner.fail(`Failed uploading ${resource.name} asset, deploy has stopped`);
                    log(`   Error: ${result.error}`);
                    return { success: false, error: result.error || 'Failed to process function resource' };
                }
            }
        }
        const spinner = ora('Deploying...').start();
        const isoNow = new Date().toISOString();
        const { ok: deployOk, stack, error: deployError, } = await updateStack({
            stackId,
            stackMutation: {
                scopeType: 'project',
                scopeId: projectId,
                name: deployedStack.name,
                document: { resources: validResources },
            },
            auth,
        });
        if (!deployOk) {
            spinner.fail(`${chalk.red('Failed')} to update deployment`);
            return { success: false, error: deployError || 'Failed to update deployment' };
        }
        spinner.stop().clear();
        if (noWait) {
            log(chalk.bold.green('Deployment started!'));
            log(`Use \`${bin} blueprints info\` to check status`);
            return { success: true };
        }
        log(chalk.dim('Deployment progress:'));
        let logStreamCleanup = null;
        try {
            logStreamCleanup = await setupLogStreaming({
                stackId: stack.id,
                after: isoNow,
                auth,
                log,
            });
            while (true) {
                const { ok, stack: currentStack } = await getStack({ stackId: stack.id, auth });
                if (!ok) {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'Failed to check deployment status' };
                }
                const operation = currentStack.recentOperation;
                if (!operation) {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'No deployment operation found' };
                }
                if (operation.status === 'FAILED') {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'Deployment failed' };
                }
                if (operation.status === 'COMPLETED') {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    log(chalk.bold.green('Deployment completed!'));
                    return { success: true };
                }
                await setTimeout(1500);
            }
        }
        catch (error) {
            if (logStreamCleanup)
                logStreamCleanup();
            throw error;
        }
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}
