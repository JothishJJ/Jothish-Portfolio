import { spawn } from 'node:child_process';
import { existsSync, mkdirSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { cwd } from 'node:process';
import chalk from 'chalk';
import { writeOrUpdateNodeDependency } from '../node.js';
import { addResourceToBlueprint } from './blueprint.js';
const DEFAULT_FUNCTION_TEMPLATE = /*js*/ `export async function handler({context, event}) {
  const time = new Date().toLocaleTimeString()
  console.log(\`ðŸ‘‹ Your Sanity Function was called at \${time}\`)
}`;
const DEFAULT_HELPER_FUNCTION_TEMPLATE = /*ts*/ `import { documentEventHandler } from '@sanity/functions'

export const handler = documentEventHandler(async ({ context, event }) => {
  const time = new Date().toLocaleTimeString()
  console.log(\`ðŸ‘‹ Your Sanity Function was called at \${time}\`)
})`;
/**
 * Creates a new function resource file and adds it to the blueprint
 */
export async function createFunctionResource(options) {
    const { name, type, lang, blueprintFilePath, addHelpers = false, installCommand } = options;
    let workingDir = cwd();
    if (blueprintFilePath) {
        if (!existsSync(blueprintFilePath)) {
            throw Error(`Blueprint file not found: ${blueprintFilePath}`);
        }
        workingDir = dirname(blueprintFilePath);
    }
    // Ensure functions directory exists
    const functionsDir = join(workingDir, 'functions');
    if (!existsSync(functionsDir)) {
        mkdirSync(functionsDir, { recursive: true });
    }
    // Create function directory
    const functionDir = join(functionsDir, name);
    if (existsSync(functionDir))
        throw Error(`${functionDir} already exists`);
    mkdirSync(functionDir, { recursive: true });
    if (!['ts', 'js'].includes(lang))
        throw Error(`Unsupported language: ${lang}`);
    // Create index.<lang> with default template
    const indexPath = join(functionDir, `index.${lang}`);
    writeFileSync(indexPath, addHelpers ? DEFAULT_HELPER_FUNCTION_TEMPLATE : DEFAULT_FUNCTION_TEMPLATE);
    if (addHelpers && blueprintFilePath) {
        try {
            await writeOrUpdateNodeDependency(blueprintFilePath, '@sanity/functions');
        }
        catch (err) {
            throw new Error('Unable to add @sanity/functions to your project.', { cause: err });
        }
    }
    if (installCommand) {
        const success = await runPackageInstall(workingDir, installCommand);
        if (!success) {
            throw new Error(`Failed to install dependencies using \`${installCommand}\``);
        }
    }
    // type looks like 'document-publish'
    const typeParts = type[0].split('-');
    const typeName = typeParts[0];
    const eventsOn = type.map((t) => t.split('-')[1]);
    // Create resource definition
    const resourceJson = {
        name,
        src: `functions/${name}`,
        type: `sanity.function.${typeName}`,
        event: {
            on: eventsOn,
        },
    };
    // Add to blueprint or return for manual addition
    const resource = addResourceToBlueprint({ blueprintFilePath, resource: resourceJson });
    return {
        filePath: indexPath,
        resourceAdded: !resource, // If resource is null, it was added to blueprint
        resource: resource || resourceJson,
    };
}
async function runPackageInstall(cwd, command) {
    return new Promise((resolve) => {
        const install = spawn(command, ['install'], { cwd });
        const formatOutput = (data) => {
            const lines = data.toString().split('\n');
            return lines
                .filter(Boolean)
                .map((line) => `  ${chalk.magenta('â”‚')} ${chalk.dim(line)}`)
                .join('\n');
        };
        install.stdout?.on('data', (data) => {
            console.log(formatOutput(data));
        });
        install.stderr?.on('data', (data) => {
            console.error(formatOutput(data));
        });
        install.on('close', (code) => {
            resolve(code === 0);
        });
    });
}
