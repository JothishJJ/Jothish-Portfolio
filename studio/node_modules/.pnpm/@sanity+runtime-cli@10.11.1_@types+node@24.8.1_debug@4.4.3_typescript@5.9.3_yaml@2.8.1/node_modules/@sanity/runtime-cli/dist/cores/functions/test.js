import { readFileSync } from 'node:fs';
import { join } from 'node:path';
import { cwd } from 'node:process';
import ora from 'ora';
import { testAction } from '../../actions/functions/test.js';
import config from '../../config.js';
import buildPayload from '../../utils/build-payload.js';
import { findFunctionByName } from '../../utils/find-function.js';
import { fetchDocument } from '../../utils/functions/fetch-document.js';
import { parseJsonObject } from '../../utils/parse-json-object.js';
import { isEventType, } from '../../utils/types.js';
export async function functionTestCore(options) {
    const { blueprint, log, args, flags } = options;
    const { name: fnName } = args;
    const { data, event, file, timeout, api, dataset, 'document-id': documentId, 'with-user-token': withUserToken, 'data-before': dataBefore, 'data-after': dataAfter, 'file-before': fileBefore, 'file-after': fileAfter, 'document-id-before': documentIdBefore, 'document-id-after': documentIdAfter, } = flags;
    let { 'project-id': projectId } = flags;
    const { parsedBlueprint } = blueprint;
    if (!projectId && blueprint?.projectId) {
        projectId = blueprint.projectId;
    }
    let eventType;
    if (!event) {
        eventType = 'create';
    }
    else if (isEventType(event)) {
        eventType = event;
    }
    else {
        return {
            success: false,
            error: 'The event must be one of `create`, `update` or `delete`.',
        };
    }
    try {
        const resource = findFunctionByName(parsedBlueprint, fnName); // throws if not found
        const contextOptions = {
            clientOptions: {
                apiVersion: api,
                dataset,
                projectId,
            },
        };
        // If the user sets the flag to use the real token set it in our options
        if (withUserToken) {
            contextOptions.clientOptions.token = config.token || undefined;
        }
        let before = null;
        let after = null;
        if (dataBefore && dataAfter) {
            before = parseJsonObject(dataBefore);
            after = parseJsonObject(dataAfter);
        }
        else if (fileBefore && fileAfter) {
            let fileContents = readFileSync(join(cwd(), fileBefore), 'utf8');
            before = parseJsonObject(fileContents);
            fileContents = readFileSync(join(cwd(), fileAfter), 'utf8');
            after = parseJsonObject(fileContents);
        }
        else if (documentIdBefore && documentIdAfter) {
            before = await fetchDocument(documentIdBefore, {
                projectId,
                dataset,
                apiVersion: api,
                apiHost: config.apiUrl,
                token: config.token || undefined,
            });
            after = await fetchDocument(documentIdAfter, {
                projectId,
                dataset,
                apiVersion: api,
                apiHost: config.apiUrl,
                token: config.token || undefined,
            });
        }
        let payload;
        if (after) {
            payload = after;
        }
        else {
            payload = documentId
                ? await fetchDocument(documentId, {
                    projectId,
                    dataset,
                    apiVersion: api,
                    apiHost: config.apiUrl,
                    token: config.token || undefined,
                })
                : buildPayload({ data, file });
        }
        const invokeOptions = {
            event: eventType,
            payload,
            before,
            after,
        };
        const spinner = ora('Executing function...').start();
        const { json, logs, error } = await testAction(resource, invokeOptions, contextOptions, {
            timeout: timeout ? timeout : resource.timeout,
        });
        if (error) {
            spinner.fail('Function execution failed.');
            return {
                success: false,
                error: error.toString(),
            };
        }
        spinner.succeed('Function execution succeeded.');
        log('Logs:');
        log(logs || '');
        if (json) {
            log('Response:');
            log(JSON.stringify(json, null, 2));
        }
        return { success: true };
    }
    catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error),
        };
    }
}
