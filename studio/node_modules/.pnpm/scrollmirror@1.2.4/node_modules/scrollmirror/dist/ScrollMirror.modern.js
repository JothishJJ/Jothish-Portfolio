const e=()=>new Promise(e=>{requestAnimationFrame(()=>e())}),t=({clientWidth:e,clientHeight:t,scrollWidth:o,scrollHeight:r})=>r>t||o>e,o=e=>{const t=window.getComputedStyle(e).overflow;return t.includes("auto")||t.includes("scroll")},r=e=>{if(null==e)return{x:0,y:0};const{scrollTop:t,scrollHeight:o,clientHeight:r,scrollLeft:n,scrollWidth:l,clientWidth:s}=e,i=o-r;return{x:n?n/Math.max(1e-5,l-s):0,y:t?t/Math.max(1e-5,i):0}};function n(){return n=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var r in o)({}).hasOwnProperty.call(o,r)&&(e[r]=o[r])}return e},n.apply(null,arguments)}function l(e){return e.matches("body *")?e:window}class s{constructor(l,s={}){var i,c=this;this.elements=void 0,this.defaults={vertical:!0,horizontal:!0,debug:!0},this.options=void 0,this.paused=!1,this.logger=void 0,this.handleScroll=async function(t){if(c.paused)return;if(!t.currentTarget)return;const o=c.getScrollContainer(t.currentTarget);await e(),c.mirrorScrollPositions(r(o),o)},this.elements=[...l].filter(Boolean).map(e=>this.getScrollContainer(e)),this.elements=[...new Set(this.elements)],this.options=n({},this.defaults,s),this.options.debug&&(this.logger=(i="[scroll-mirror]",{log:(...e)=>console.log(i,...e),warn:(...e)=>console.warn(i,...e),error:(...e)=>console.error(i,...e)}),function(e,r){if(e.length<1)null==r||r.warn("No elements provided.");else{e.length<2&&(null==r||r.warn("Only one element provided.",e)),e.some(e=>!e)&&(null==r||r.error("Some elements are not defined.",e));for(const n of e)n instanceof HTMLElement&&!t(n)&&(null==r||r.warn("Element doesn't have overflow:",n)),n instanceof HTMLElement&&n.matches("body *")&&!o(n)&&(null==r||r.warn('No "overflow: auto;" or "overflow: scroll;" set on element:',n))}}(this.elements,this.logger)),this.elements.forEach(e=>this.addScrollHandler(e)),this.elements.includes(document.documentElement)&&this.mirrorScrollPositions(r(document.documentElement),document.documentElement)}pause(){this.paused=!0}resume(){this.paused=!1}destroy(){this.elements.forEach(e=>this.removeScrollHandler(e))}addScrollHandler(e){this.removeScrollHandler(e),l(e).addEventListener("scroll",this.handleScroll,{passive:!0})}removeScrollHandler(e){l(e).removeEventListener("scroll",this.handleScroll)}getScrollContainer(e){return e instanceof HTMLElement&&e.matches("body *")?e:document.documentElement}mirrorScrollPositions(e,t=void 0){this.elements.forEach(o=>{t!==o&&(this.removeScrollHandler(o),this.setScrollPosition(e,o),window.requestAnimationFrame(()=>{this.addScrollHandler(o)}))})}setScrollPosition(e,t){const{vertical:o,horizontal:r}=this.options,n=t.scrollWidth-t.clientWidth,l=t.scrollHeight-t.clientHeight;o&&l&&t.scrollTo({top:l*e.y,behavior:"instant"}),r&&n&&t.scrollTo({left:n*e.x,behavior:"instant"})}get progress(){const e=this.elements.find(e=>t(e));return r(e)}set progress(e){"number"==typeof e&&(e={x:e,y:e});const t=n({},this.progress,e);(function(e,t){let o=!0;for(const[r,n]of Object.entries(e))("number"!=typeof n||n<0||n>1)&&(null==t||t.error(`progress.${r} must be a number between 0-1`),o=!1);return o})(t,this.logger)&&this.mirrorScrollPositions(t)}}export{s as default,r as getScrollProgress,o as hasCSSOverflow,t as hasOverflow,e as nextTick};
//# sourceMappingURL=ScrollMirror.modern.js.map
