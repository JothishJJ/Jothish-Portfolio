!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e||self).ScrollMirror=t()}(this,function(){const e=e=>{let{clientWidth:t,clientHeight:o,scrollWidth:r,scrollHeight:n}=e;return n>o||r>t},t=e=>{const t=window.getComputedStyle(e).overflow;return t.includes("auto")||t.includes("scroll")},o=e=>{if(null==e)return{x:0,y:0};const{scrollTop:t,scrollHeight:o,clientHeight:r,scrollLeft:n,scrollWidth:l,clientWidth:s}=e,i=o-r;return{x:n?n/Math.max(1e-5,l-s):0,y:t?t/Math.max(1e-5,i):0}};function r(e){return e.matches("body *")?e:window}return class{constructor(r,n){const l=this;var s;void 0===n&&(n={}),this.elements=void 0,this.defaults={vertical:!0,horizontal:!0,debug:!0},this.options=void 0,this.paused=!1,this.logger=void 0,this.handleScroll=function(e){try{if(l.paused)return Promise.resolve();if(!e.currentTarget)return Promise.resolve();const t=l.getScrollContainer(e.currentTarget);return Promise.resolve(new Promise(e=>{requestAnimationFrame(()=>e())})).then(function(){l.mirrorScrollPositions(o(t),t)})}catch(e){return Promise.reject(e)}},this.elements=[...r].filter(Boolean).map(e=>this.getScrollContainer(e)),this.elements=[...new Set(this.elements)],this.options={...this.defaults,...n},this.options.debug&&(this.logger=(s="[scroll-mirror]",{log:function(){return console.log(s,...[].slice.call(arguments))},warn:function(){return console.warn(s,...[].slice.call(arguments))},error:function(){return console.error(s,...[].slice.call(arguments))}}),function(o,r){if(o.length<1)r?.warn("No elements provided.");else{o.length<2&&r?.warn("Only one element provided.",o),o.some(e=>!e)&&r?.error("Some elements are not defined.",o);for(const n of o)n instanceof HTMLElement&&!e(n)&&r?.warn("Element doesn't have overflow:",n),n instanceof HTMLElement&&n.matches("body *")&&!t(n)&&r?.warn('No "overflow: auto;" or "overflow: scroll;" set on element:',n)}}(this.elements,this.logger)),this.elements.forEach(e=>this.addScrollHandler(e)),this.elements.includes(document.documentElement)&&this.mirrorScrollPositions(o(document.documentElement),document.documentElement)}pause(){this.paused=!0}resume(){this.paused=!1}destroy(){this.elements.forEach(e=>this.removeScrollHandler(e))}addScrollHandler(e){this.removeScrollHandler(e),r(e).addEventListener("scroll",this.handleScroll,{passive:!0})}removeScrollHandler(e){r(e).removeEventListener("scroll",this.handleScroll)}getScrollContainer(e){return e instanceof HTMLElement&&e.matches("body *")?e:document.documentElement}mirrorScrollPositions(e,t){void 0===t&&(t=void 0),this.elements.forEach(o=>{t!==o&&(this.removeScrollHandler(o),this.setScrollPosition(e,o),window.requestAnimationFrame(()=>{this.addScrollHandler(o)}))})}setScrollPosition(e,t){const{vertical:o,horizontal:r}=this.options,n=t.scrollWidth-t.clientWidth,l=t.scrollHeight-t.clientHeight;o&&l&&t.scrollTo({top:l*e.y,behavior:"instant"}),r&&n&&t.scrollTo({left:n*e.x,behavior:"instant"})}get progress(){const t=this.elements.find(t=>e(t));return o(t)}set progress(e){"number"==typeof e&&(e={x:e,y:e});const t={...this.progress,...e};(function(e,t){let o=!0;for(const[r,n]of Object.entries(e))("number"!=typeof n||n<0||n>1)&&(t?.error(`progress.${r} must be a number between 0-1`),o=!1);return o})(t,this.logger)&&this.mirrorScrollPositions(t)}}});
//# sourceMappingURL=ScrollMirror.umd.js.map
