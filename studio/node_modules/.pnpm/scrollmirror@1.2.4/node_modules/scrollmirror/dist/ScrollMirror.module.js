const e=()=>new Promise(e=>{requestAnimationFrame(()=>e())}),t=({clientWidth:e,clientHeight:t,scrollWidth:o,scrollHeight:r})=>r>t||o>e,o=e=>{const t=window.getComputedStyle(e).overflow;return t.includes("auto")||t.includes("scroll")},r=e=>{if(null==e)return{x:0,y:0};const{scrollTop:t,scrollHeight:o,clientHeight:r,scrollLeft:n,scrollWidth:l,clientWidth:s}=e,i=o-r;return{x:n?n/Math.max(1e-5,l-s):0,y:t?t/Math.max(1e-5,i):0}};function n(e){return e.matches("body *")?e:window}class l{constructor(n,l={}){const s=this;var i;this.elements=void 0,this.defaults={vertical:!0,horizontal:!0,debug:!0},this.options=void 0,this.paused=!1,this.logger=void 0,this.handleScroll=function(t){try{if(s.paused)return Promise.resolve();if(!t.currentTarget)return Promise.resolve();const o=s.getScrollContainer(t.currentTarget);return Promise.resolve(e()).then(function(){s.mirrorScrollPositions(r(o),o)})}catch(e){return Promise.reject(e)}},this.elements=[...n].filter(Boolean).map(e=>this.getScrollContainer(e)),this.elements=[...new Set(this.elements)],this.options={...this.defaults,...l},this.options.debug&&(this.logger=(i="[scroll-mirror]",{log:function(){return console.log(i,...[].slice.call(arguments))},warn:function(){return console.warn(i,...[].slice.call(arguments))},error:function(){return console.error(i,...[].slice.call(arguments))}}),function(e,r){if(e.length<1)r?.warn("No elements provided.");else{e.length<2&&r?.warn("Only one element provided.",e),e.some(e=>!e)&&r?.error("Some elements are not defined.",e);for(const n of e)n instanceof HTMLElement&&!t(n)&&r?.warn("Element doesn't have overflow:",n),n instanceof HTMLElement&&n.matches("body *")&&!o(n)&&r?.warn('No "overflow: auto;" or "overflow: scroll;" set on element:',n)}}(this.elements,this.logger)),this.elements.forEach(e=>this.addScrollHandler(e)),this.elements.includes(document.documentElement)&&this.mirrorScrollPositions(r(document.documentElement),document.documentElement)}pause(){this.paused=!0}resume(){this.paused=!1}destroy(){this.elements.forEach(e=>this.removeScrollHandler(e))}addScrollHandler(e){this.removeScrollHandler(e),n(e).addEventListener("scroll",this.handleScroll,{passive:!0})}removeScrollHandler(e){n(e).removeEventListener("scroll",this.handleScroll)}getScrollContainer(e){return e instanceof HTMLElement&&e.matches("body *")?e:document.documentElement}mirrorScrollPositions(e,t=void 0){this.elements.forEach(o=>{t!==o&&(this.removeScrollHandler(o),this.setScrollPosition(e,o),window.requestAnimationFrame(()=>{this.addScrollHandler(o)}))})}setScrollPosition(e,t){const{vertical:o,horizontal:r}=this.options,n=t.scrollWidth-t.clientWidth,l=t.scrollHeight-t.clientHeight;o&&l&&t.scrollTo({top:l*e.y,behavior:"instant"}),r&&n&&t.scrollTo({left:n*e.x,behavior:"instant"})}get progress(){const e=this.elements.find(e=>t(e));return r(e)}set progress(e){"number"==typeof e&&(e={x:e,y:e});const t={...this.progress,...e};(function(e,t){let o=!0;for(const[r,n]of Object.entries(e))("number"!=typeof n||n<0||n>1)&&(t?.error(`progress.${r} must be a number between 0-1`),o=!1);return o})(t,this.logger)&&this.mirrorScrollPositions(t)}}export{l as default,r as getScrollProgress,o as hasCSSOverflow,t as hasOverflow,e as nextTick};
//# sourceMappingURL=ScrollMirror.module.js.map
