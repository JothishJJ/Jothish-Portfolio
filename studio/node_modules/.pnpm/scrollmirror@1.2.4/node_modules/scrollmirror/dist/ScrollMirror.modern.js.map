{"version":3,"file":"ScrollMirror.modern.js","sources":["../src/support/helpers.ts","../src/support/functions.ts","../src/ScrollMirror.ts"],"sourcesContent":["import type { Progress } from \"./defs.js\";\n\n/** Return a Promise that resolves after the next event loop. */\nexport const nextTick = (): Promise<void> => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(() => resolve());\n  });\n};\n\n/** Check if an element has overflow */\nexport const hasOverflow = ({\n  clientWidth,\n  clientHeight,\n  scrollWidth,\n  scrollHeight,\n}: HTMLElement) => {\n  return scrollHeight > clientHeight || scrollWidth > clientWidth;\n};\n\n/** Check if an element is set to overflow: auto in at least one direction */\nexport const hasCSSOverflow = (element: HTMLElement) => {\n  const overflow = window.getComputedStyle(element)[\"overflow\"];\n  return overflow.includes(\"auto\") || overflow.includes(\"scroll\");\n};\n\n/** Get the scroll progress of an element, between 0-1 */\nexport const getScrollProgress = (el: HTMLElement | undefined): Progress => {\n  if (el == null) {\n    return {\n      x: 0,\n      y: 0,\n    };\n  }\n\n  const {\n    scrollTop,\n    scrollHeight,\n    clientHeight,\n    scrollLeft,\n    scrollWidth,\n    clientWidth,\n  } = el;\n\n  const availableWidth = scrollWidth - clientWidth;\n  const availableHeight = scrollHeight - clientHeight;\n\n  return {\n    x: !!scrollLeft ? scrollLeft / Math.max(0.00001, availableWidth) : 0,\n    y: !!scrollTop ? scrollTop / Math.max(0.00001, availableHeight) : 0,\n  };\n};\n","import type { Logger, Progress } from \"./defs.js\";\nimport { hasCSSOverflow, hasOverflow } from \"./helpers.js\";\n\n/**\n * Get the event target for receiving scroll events\n * - return the window if the element is either the html or body element\n * - otherwise, return the element\n */\nexport function getScrollEventTarget(element: HTMLElement): Window | HTMLElement {\n  return element.matches(\"body *\") ? element : window;\n}\n\n/**\n * Get a minimal logger with a prefix\n */\nexport function getLogger(prefix: string) {\n  return {\n    log: (...args: any[]) => console.log(prefix, ...args),\n    warn: (...args: any[]) => console.warn(prefix, ...args),\n    error: (...args: any[]) => console.error(prefix, ...args),\n  };\n}\n\n/**\n * Make sure the provided elements are valid\n */\nexport function validateElements(\n  elements: HTMLElement[],\n  logger?: Logger\n): void {\n  if (elements.length < 1) {\n    logger?.warn(\"No elements provided.\");\n    return;\n  }\n\n  if (elements.length < 2) {\n    logger?.warn(\"Only one element provided.\", elements);\n  }\n\n  if (elements.some((el) => !el)) {\n    logger?.error(\"Some elements are not defined.\", elements);\n  }\n\n  for (const element of elements) {\n    if (element instanceof HTMLElement && !hasOverflow(element)) {\n      logger?.warn(\"Element doesn't have overflow:\", element);\n    }\n    if (\n      element instanceof HTMLElement &&\n      element.matches(\"body *\") &&\n      !hasCSSOverflow(element)\n    ) {\n      logger?.warn('No \"overflow: auto;\" or \"overflow: scroll;\" set on element:', element); // prettier-ignore\n    }\n  }\n}\n\n/**\n * Validate the progress, log errors for invalid values\n */\nexport function validateProgress(\n  progress: Partial<Progress>,\n  logger?: Logger\n) {\n  let valid = true;\n  for (const [key, value] of Object.entries(progress)) {\n    if (typeof value !== \"number\" || value < 0 || value > 1) {\n      logger?.error(`progress.${key} must be a number between 0-1`);\n      valid = false;\n    }\n  }\n  return valid;\n}","import type { Progress, Options, Logger } from \"./support/defs.js\";\nimport { getScrollProgress, hasOverflow, nextTick } from \"./support/helpers.js\";\n\nimport {\n  getScrollEventTarget,\n  getLogger,\n  validateElements,\n  validateProgress,\n} from \"./support/functions.js\";\n\n/**\n * Mirrors the scroll position of multiple elements on a page\n */\nexport default class ScrollMirror {\n  /** Mirror the scroll positions of these elements */\n  readonly elements: HTMLElement[];\n  /** The default options */\n  readonly defaults: Options = {\n    vertical: true,\n    horizontal: true,\n    debug: true,\n  };\n  /** The parsed options */\n  options: Options;\n  /** Is mirroring paused? */\n  paused: boolean = false;\n  /** a simple logger @internal */\n  logger: Logger | undefined = undefined;\n\n  constructor(\n    elements: NodeListOf<Element> | Element[],\n    options: Partial<Options> = {}\n  ) {\n    this.elements = [...elements]\n      .filter(Boolean)\n      .map((el) => this.getScrollContainer(el));\n\n    /** remove duplicates */\n    this.elements = [...new Set(this.elements)];\n\n    this.options = { ...this.defaults, ...options };\n\n    if (this.options.debug) {\n      this.logger = getLogger(\"[scroll-mirror]\");\n      validateElements(this.elements, this.logger);\n    }\n\n    this.elements.forEach((element) => this.addScrollHandler(element));\n\n    /**\n     * Initially, make sure that elements are mirrored to the\n     * documentElement's scroll position (if provided)\n     */\n    if (this.elements.includes(document.documentElement)) {\n      this.mirrorScrollPositions(\n        getScrollProgress(document.documentElement),\n        document.documentElement\n      );\n    }\n  }\n\n  /** Pause mirroring */\n  pause() {\n    this.paused = true;\n  }\n\n  /** Resume mirroring */\n  resume() {\n    this.paused = false;\n  }\n\n  /** Destroy. Removes all event handlers */\n  destroy() {\n    this.elements.forEach((element) => this.removeScrollHandler(element));\n  }\n\n  /** Add the scroll handler to the element @internal */\n  addScrollHandler(element: HTMLElement) {\n    /** Safeguard to prevent duplicate handlers on elements */\n    this.removeScrollHandler(element);\n\n    const target = getScrollEventTarget(element);\n    target.addEventListener(\"scroll\", this.handleScroll, { passive: true });\n  }\n\n  /** Remove the scroll handler from an element @internal */\n  removeScrollHandler(element: HTMLElement) {\n    const target = getScrollEventTarget(element);\n    target.removeEventListener(\"scroll\", this.handleScroll);\n  }\n\n  /**\n   * Get the scroll container, based on element provided:\n   * - return the element if it's a child of <body>\n   * - otherwise, return the documentElement\n   */\n  getScrollContainer(el: unknown): HTMLElement {\n    if (el instanceof HTMLElement && el.matches(\"body *\")) return el;\n    return document.documentElement;\n  }\n\n  /** Handle a scroll event on an element @internal */\n  handleScroll = async (event: Event) => {\n    if (this.paused) return;\n\n    if (!event.currentTarget) return;\n\n    const scrolledElement = this.getScrollContainer(event.currentTarget);\n\n    await nextTick();\n\n    this.mirrorScrollPositions(\n      getScrollProgress(scrolledElement),\n      scrolledElement\n    );\n  };\n\n  /** Mirror the scroll positions of all elements to a target @internal */\n  mirrorScrollPositions(\n    progress: Progress,\n    ignore: HTMLElement | undefined = undefined\n  ) {\n    this.elements.forEach((element) => {\n      /* Ignore the currently scrolled element  */\n      if (ignore === element) return;\n\n      /* Remove the scroll event listener */\n      this.removeScrollHandler(element);\n\n      this.setScrollPosition(progress, element);\n\n      /* Re-attach the scroll event listener */\n      window.requestAnimationFrame(() => {\n        this.addScrollHandler(element);\n      });\n    });\n  }\n\n  /** Mirror the scroll position from one element to another @internal */\n  setScrollPosition(progress: Progress, target: HTMLElement) {\n    const { vertical, horizontal } = this.options;\n\n    /* Calculate the actual element scroll lengths */\n    const availableScroll = {\n      x: target.scrollWidth - target.clientWidth,\n      y: target.scrollHeight - target.clientHeight,\n    };\n\n    /* Adjust the scroll position accordingly */\n    if (vertical && !!availableScroll.y) {\n      target.scrollTo({\n        top: availableScroll.y * progress.y,\n        behavior: \"instant\",\n      });\n    }\n    if (horizontal && !!availableScroll.x) {\n      target.scrollTo({\n        left: availableScroll.x * progress.x,\n        behavior: \"instant\",\n      });\n    }\n  }\n\n  /**\n   * Get the scroll position from the first container that has overflow\n   */\n  get progress(): Progress {\n    const firstWithOverflow = this.elements.find((el) => hasOverflow(el));\n\n    return getScrollProgress(firstWithOverflow);\n  }\n\n  /**\n   * Set the scroll progress of all mirrored elements\n   *\n   * The progress is an object of { x:number , y: number }, where both x and y are a number\n   * between 0-1\n   *\n   * Examples:\n   *  - `const progress = mirror.progress` — returns something like { x: 0.2, y:0.5 }\n   *  - `mirror.progress = 0.5` — set the scroll position to 50% on both axes\n   *  - `mirror.progress = { y: 0.5 }` — set the scroll position to 50% on the y axis\n   *  - `mirror.progress = { x: 0.2, y: 0.5 }` — set the scroll position on both axes\n   */\n  set progress(value: Partial<Progress> | number) {\n    /** if the value is a number, set both axes to that value */\n    if (typeof value === \"number\") {\n      value = { x: value, y: value };\n    }\n    const progress = { ...this.progress, ...value };\n\n    if (!validateProgress(progress, this.logger)) {\n      return;\n    }\n\n    this.mirrorScrollPositions(progress);\n  }\n}\n"],"names":["nextTick","Promise","resolve","requestAnimationFrame","hasOverflow","clientWidth","clientHeight","scrollWidth","scrollHeight","hasCSSOverflow","element","overflow","window","getComputedStyle","includes","getScrollProgress","el","x","y","scrollTop","scrollLeft","availableHeight","Math","max","getScrollEventTarget","matches","ScrollMirror","constructor","elements","options","prefix","_this","defaults","vertical","horizontal","debug","this","paused","logger","undefined","handleScroll","async","event","currentTarget","scrolledElement","getScrollContainer","mirrorScrollPositions","filter","Boolean","map","Set","_extends","log","args","console","warn","error","length","some","HTMLElement","validateElements","forEach","addScrollHandler","document","documentElement","pause","resume","destroy","removeScrollHandler","addEventListener","passive","removeEventListener","progress","ignore","setScrollPosition","target","availableScroll","scrollTo","top","behavior","left","firstWithOverflow","find","value","valid","key","Object","entries","validateProgress"],"mappings":"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"}