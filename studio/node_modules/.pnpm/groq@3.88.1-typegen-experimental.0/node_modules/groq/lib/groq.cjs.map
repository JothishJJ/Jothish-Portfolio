{"version":3,"file":"groq.cjs","sources":["../src/define.ts","../src/groq.ts","../src/_exports.cts.ts"],"sourcesContent":["/**\n * Defines a GROQ query string literal type. This no-op function helps TypeScript\n * preserve the exact query structure for type inference when working with\n * {@link SanityQueryResult} and query type generation. While similar to the `groq`\n * template tag, this function enables better type inference until TypeScript\n * resolves microsoft/TypeScript#33304.\n *\n * @param query - The GROQ query to capture as a literal type\n * @returns The same query string unchanged\n *\n * @example\n * ```ts\n * const authorQuery = defineQuery('*[_type == \"author\"]')\n * type AuthorResult = SanityQueryResult<typeof authorQuery>\n * ```\n * @public\n */\nexport function defineQuery<const TQuery extends string>(query: TQuery): TQuery {\n  return query\n}\n\n/**\n * Defines a GROQ projection string literal type. This no-op function helps TypeScript\n * preserve the exact projection string structure for type inference when working with\n * {@link SanityProjectionResult} and projection type generation.\n *\n * @param projection - The GROQ projection string to capture as a literal type\n * @returns The same projection string unchanged\n *\n * @example\n * ```ts\n * const authorProjection = defineProjection('{ name, \"books\": favoriteBooks[]->title }')\n * type AuthorResult = SanityProjectionResult<typeof authorProjection, 'author'>\n * ```\n * @public\n */\nexport function defineProjection<const TProjection extends string>(\n  projection: TProjection,\n): TProjection {\n  return projection\n}\n\n/**\n * This interface is augmented by [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to\n * provide type definitions for registered GROQ queries. This allows library authors to capture the\n * query string as a literal and look up type of the query result via importing this augmented\n * interface.\n *\n * See {@link SanityQueryResult}.\n *\n * @example\n * ```ts\n * export type AuthorsQueryResult = {\n *   // ...\n * }[]\n *\n * declare module 'groq' {\n *  interface SanityQueries {\n *   '*[_type==\"author\"]': AuthorsQueryResult\n *  }\n * }\n * ```\n *\n * @public\n */\nexport interface SanityQueries {}\n\n/**\n * This interface is augmented by [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to\n * provide type definitions for registered GROQ projections. Projections are computed against all\n * possible document types registered per schema and then unioned with {@link ProjectionBase}\n * using document type name as the second type parameter.\n *\n * Use the {@link PickProjectionResult} and {@link SanityProjectionResult} helpers to extract a\n * specific projection result.\n *\n * @example\n * ```ts\n * type PreviewProjectionResult =\n *  | ProjectionBase<{title: string | null, description: string | null}, 'product'>\n *  | ProjectionBase<{title: null, description: string | null}, 'author'>\n *\n * declare module 'groq' {\n *   interface SanityProjections {\n *     '{title, description}': PreviewProjectionResult\n *   }\n * }\n * ```\n *\n * @public\n */\nexport interface SanityProjections {}\n\n/**\n * This interface is augmented by the [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to\n * provide type definitions for all schema types registered by the user. This allows extracting\n * specific schema types using helpers like {@link SanitySchema}, {@link SanityDocument}, or\n * {@link SanitySchemaType}.\n *\n * @example\n * ```ts\n * type Author =\n *   SchemaOrigin<{_id: string, _type: 'author', foo: string}, 'yourProjectId:test'> |\n *   SchemaOrigin<{_id: string, _type: 'author', foo: number}, 'yourProjectId:production'>;\n *\n * type Book =\n *   SchemaOrigin<{_id: string, _type: 'book', foo: string}, 'yourProjectId:test'> |\n *   SchemaOrigin<{_id: string, _type: 'book', foo: number}, 'yourProjectId:production'>;\n *\n * type YourProjectIdTestSchema =\n *   PickSchema<Author, 'yourProjectId:test'> |\n *   PickSchema<Book, 'yourProjectId:test'>;\n *\n * type YourProjectIdProductionSchema =\n *   PickSchema<Author, 'yourProjectId:production'> |\n *   PickSchema<Book, 'yourProjectId:production'>;\n *\n * declare module 'groq' {\n *   interface SanitySchemas {\n *     \"yourProjectId:test\": YourProjectIdTestSchema;\n *     \"yourProjectId:production\": YourProjectIdProductionSchema;\n *   }\n * }\n * ```\n * @public\n */\nexport interface SanitySchemas {}\n\n/**\n * Represents the result type for a specific GROQ projection when used with\n * `PickProjectionResult`. Extracts the projection result for a specific type name.\n *\n * @typeParam T - Union type of possible projection results\n * @typeParam TProjectionBaseTypeName - The document type name to filter by\n *\n * @example\n * ```ts\n * type AuthorProjection = PickProjectionResult<AuthorProjectionProjectionResult, 'author'>\n * // Returns: ProjectionBase<{name: string | null, favoriteBookTitles: ...}, 'author'>\n * ```\n * @public\n */\nexport type PickProjectionResult<T, TProjectionBaseTypeName extends string = string> = Extract<\n  T,\n  ProjectionBase<T, TProjectionBaseTypeName>\n>\n\n/**\n * Represents the result type of a GROQ projection query. Combines schema picking\n * with projection type filtering.\n *\n * @typeParam TProjection - The projection string literal type\n * @typeParam TProjectionBaseTypeName - The document type name to filter by\n * @typeParam TSchemaId - The schema ID to pick from\n *\n * @example\n * ```ts\n * const authorProjection = defineProjection('{name, \"favoriteBooks\": favoriteBooks[]->title}')\n * type Result = SanityProjectionResult<typeof authorProjection, 'author', 'yourProjectId:production'>\n * // Returns: SchemaOrigin<ProjectionBase<{name: string, favoriteBooks: string[]}, 'author'>, 'yourProjectId:production'>\n * ```\n * @public\n */\nexport type SanityProjectionResult<\n  TProjection extends string = string,\n  TProjectionBaseTypeName extends string = string,\n  TSchemaId extends string = string,\n> = PickSchema<\n  PickProjectionResult<SafeAccess<SanityProjections, TProjection>, TProjectionBaseTypeName>,\n  TSchemaId\n>\n\n/**\n * Extracts a schema type by its ID. Used to get the type definition for a specific\n * schema version when working with multiple schemas.\n *\n * @typeParam TSchemaId - The schema ID to extract\n *\n * @example\n * ```ts\n * type TestSchema = SanitySchema<'yourProjectId:test'>\n * // Returns union of all types in the test schema\n * ```\n * @public\n */\nexport type SanitySchema<TSchemaId extends string = string> = PickSchema<\n  SafeAccess<SanitySchemas, TSchemaId>,\n  TSchemaId\n>\n\ninterface _SanityDocument {\n  _id: string\n  _type: string\n  _createdAt: string\n  _updatedAt: string\n  _rev: string\n  [key: string]: unknown\n}\n\n/**\n * Represents a Sanity document with base document fields. Used as the foundation\n * for document type definitions.\n *\n * @typeParam TDocumentType - The _type field value of the document\n * @typeParam TSchemaId - The schema ID to pick from\n *\n * @example\n * ```ts\n * type AuthorDoc = SanityDocument<'author', 'yourProjectId:production'>\n * // Returns: Author type with __schemaId metadata\n * ```\n * @public\n */\nexport type SanityDocument<\n  TDocumentType extends string = string,\n  TSchemaId extends string = string,\n> = Extract<\n  Extract<SanitySchema<TSchemaId>, _SanityDocument> | _SanityDocument,\n  {_type: TDocumentType}\n>\n\n/**\n * Extracts a specific schema type by both schema ID and type name. Combines\n * schema selection with type filtering.\n *\n * @typeParam TSchemaTypeName - The _type field value to match\n * @typeParam TSchemaId - The schema ID to pick from\n *\n * @example\n * ```ts\n * type TestAuthor = SanitySchemaType<'author', 'yourProjectId:test'>\n * // Returns: Author type from test schema\n * ```\n * @public\n */\nexport type SanitySchemaType<\n  TSchemaTypeName extends string = string,\n  TSchemaId extends string = string,\n> = Extract<SanitySchema<TSchemaId>, {_type: TSchemaTypeName}>\n\ntype SafeAccess<T, K extends string> = K extends keyof T ? T[K] : T[keyof T]\n\n/**\n * @public\n */\nexport type SanityQueryResult<\n  TQuery extends string = string,\n  TSchemaId extends string = string,\n> = Extract<\n  SafeAccess<SanityQueries, TQuery>,\n  SchemaOrigin<SafeAccess<SanityQueries, TQuery>, TSchemaId>\n>\n\n/**\n * Represents the result type of a GROQ query. Combines schema picking with\n * query result type resolution.\n *\n * @typeParam TQuery - The GROQ query string literal type\n * @typeParam TSchemaId - The schema ID to pick from\n *\n * @example\n * ```ts\n * type Result = SanityQueryResult<'*[_type==\"author\"]', 'yourProjectId:production'>\n * // Returns: Author[] from production schema\n * ```\n * @public\n */\nexport type SchemaOrigin<TBase, TSchemaId extends string> = TBase & {\n  /**\n   * @internal\n   * @deprecated typescript helper only\n   */\n  __schemaId?: TSchemaId\n}\n\n/**\n * Base type for projection results that includes metadata about the document type\n * being projected. Designed to be used in union types representing multiple possible\n * document type projections, which can then be narrowed using type helpers like\n * {@link PickProjectionResult}.\n *\n * @typeParam TBase - The actual projection result type\n * @typeParam TProjectionBaseTypeName - The document type name this projection applies to\n *\n * @example\n * ```ts\n * // Typically appears as a union of possible document type projections:\n * type BookProjections =\n *   ProjectionBase<{name: string}, 'book'> |\n *   ProjectionBase<{name: string[]}, 'author'>\n *\n * // Narrow the union to a specific document type:\n * type BookProjection = PickProjectionResult<BookProjections, 'book'>\n * ```\n * @public\n */\nexport type ProjectionBase<TBase, TProjectionBaseTypeName extends string> = TBase & {\n  /**\n   * @internal\n   * @deprecated typescript helper only\n   */\n  __schemaTypeName?: TProjectionBaseTypeName // projection base type name\n}\n\n/**\n * Extracts types from a schema-aware union that match a specific schema ID.\n * Useful when working with multi-schema environments.\n *\n * @typeParam T - Union type containing SchemaOrigin types\n * @typeParam TSchemaId - The schema ID to filter by\n *\n * @example\n * ```ts\n * // As generated in explain.sanity.types.ts:\n * type Author =\n *   SchemaOrigin<{_type: 'author'; foo: string}, 'yourProjectId:test'> |\n *   SchemaOrigin<{_type: 'author'; foo: number}, 'yourProjectId:production'>\n *\n * // Extract production version:\n * type ProductionAuthor = PickSchema<Author, 'yourProjectId:production'>\n * // Returns: {_type: 'author'; foo: number}\n * ```\n * @public\n */\nexport type PickSchema<T, TSchemaId extends string = string> = Extract<\n  T,\n  SchemaOrigin<T, TSchemaId>\n>\n","/**\n * Pass-through groq template tag. This is a no-op, but it helps editor integrations\n * understand that a string represents a GROQ query in order to provide syntax highlighting\n * and other features.\n *\n * @param strings - Template string parts\n * @param keys - Template string keys\n * @returns The same string as the input\n * @public\n */\nexport function groq(\n  strings: TemplateStringsArray,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...keys: any[]\n): string {\n  const lastIndex = strings.length - 1\n  return (\n    strings.slice(0, lastIndex).reduce((acc, str, i) => {\n      return acc + str + keys[i]\n    }, '') + strings[lastIndex]\n  )\n}\n","import {\n  defineProjection,\n  defineQuery,\n  type PickProjectionResult,\n  type PickSchema,\n  type ProjectionBase,\n  type SanityDocument,\n  type SanityProjectionResult,\n  type SanityProjections,\n  type SanityQueries,\n  type SanityQueryResult,\n  type SanitySchema,\n  type SanitySchemas,\n  type SanitySchemaType,\n  type SchemaOrigin,\n} from './define'\nimport {groq} from './groq'\n\nmodule.exports = groq\n\nObject.assign(module.exports, {defineQuery, defineProjection})\n\n/**\n * This is just to fix the typegen for the CJS export, as TS won't pick up on `module.exports` syntax when the package.json has `type: \"module\"`\n */\nexport type {\n  groq as default,\n  defineProjection,\n  defineQuery,\n  PickProjectionResult,\n  PickSchema,\n  ProjectionBase,\n  SanityDocument,\n  SanityProjectionResult,\n  SanityProjections,\n  SanityQueries,\n  SanityQueryResult,\n  SanitySchema,\n  SanitySchemas,\n  SanitySchemaType,\n  SchemaOrigin,\n}\n"],"names":[],"mappings":";AAiBO,SAAS,YAAyC,OAAuB;AACvE,SAAA;AACT;AAiBO,SAAS,iBACd,YACa;AACN,SAAA;AACT;AC9BgB,SAAA,KACd,YAEG,MACK;AACF,QAAA,YAAY,QAAQ,SAAS;AACnC,SACE,QAAQ,MAAM,GAAG,SAAS,EAAE,OAAO,CAAC,KAAK,KAAK,MACrC,MAAM,MAAM,KAAK,CAAC,GACxB,EAAE,IAAI,QAAQ,SAAS;AAE9B;ACHA,OAAO,UAAU;AAEjB,OAAO,OAAO,OAAO,SAAS,EAAC,aAAa,kBAAiB;"}