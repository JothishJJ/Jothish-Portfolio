{"version":3,"file":"index.js","sources":["../src/interfaces/path-ref.ts","../src/interfaces/point-ref.ts","../src/interfaces/range-ref.ts","../src/utils/weak-maps.ts","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/iterableToArray.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/toConsumableArray.js","../src/interfaces/path.ts","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/typeof.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/toPrimitive.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/toPropertyKey.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/defineProperty.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/arrayWithHoles.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/nonIterableRest.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/slicedToArray.js","../src/interfaces/transforms/general.ts","../src/interfaces/transforms/node.ts","../src/interfaces/transforms/selection.ts","../src/utils/is-object.ts","../src/utils/deep-equal.ts","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../../../../.yarn/berry/cache/@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip/node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../src/interfaces/range.ts","../src/interfaces/element.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/editor/is-editor.ts","../src/interfaces/editor.ts","../src/interfaces/location.ts","../src/interfaces/point.ts","../src/interfaces/scrubber.ts","../src/interfaces/text.ts","../src/utils/get-default-insert-location.ts","../src/utils/match-path.ts","../src/utils/string.ts","../src/interfaces/transforms/text.ts","../src/interfaces/transforms/index.ts","../src/core/batch-dirty-paths.ts","../src/core/update-dirty-paths.ts","../src/core/apply.ts","../src/core/get-dirty-paths.ts","../src/core/get-fragment.ts","../src/core/normalize-node.ts","../src/core/should-normalize.ts","../src/editor/above.ts","../src/editor/add-mark.ts","../src/editor/after.ts","../src/editor/before.ts","../src/editor/delete-backward.ts","../src/editor/delete-forward.ts","../src/editor/delete-fragment.ts","../src/editor/edges.ts","../src/editor/element-read-only.ts","../src/editor/end.ts","../src/editor/first.ts","../src/editor/fragment.ts","../src/editor/get-void.ts","../src/editor/has-blocks.ts","../src/editor/has-inlines.ts","../src/editor/has-path.ts","../src/editor/has-texts.ts","../src/editor/insert-break.ts","../src/editor/insert-node.ts","../src/editor/insert-soft-break.ts","../src/editor/insert-text.ts","../src/editor/is-block.ts","../src/editor/is-edge.ts","../src/editor/is-empty.ts","../src/editor/is-end.ts","../src/editor/is-normalizing.ts","../src/editor/is-start.ts","../src/editor/last.ts","../src/editor/leaf.ts","../src/editor/levels.ts","../src/editor/marks.ts","../src/editor/next.ts","../src/editor/node.ts","../src/editor/nodes.ts","../src/editor/normalize.ts","../src/editor/parent.ts","../src/editor/path-ref.ts","../src/editor/path-refs.ts","../src/editor/path.ts","../src/editor/point-ref.ts","../src/editor/point-refs.ts","../src/editor/point.ts","../src/editor/positions.ts","../src/editor/previous.ts","../src/editor/range-ref.ts","../src/editor/range-refs.ts","../src/editor/range.ts","../src/editor/remove-mark.ts","../src/editor/set-normalizing.ts","../src/editor/start.ts","../src/editor/string.ts","../src/editor/unhang-range.ts","../src/editor/without-normalizing.ts","../src/editor/should-merge-nodes-remove-prev-node.ts","../src/transforms-text/delete-text.ts","../src/transforms-text/insert-fragment.ts","../src/transforms-selection/collapse.ts","../src/transforms-selection/deselect.ts","../src/transforms-selection/move.ts","../src/transforms-selection/select.ts","../src/transforms-selection/set-point.ts","../src/transforms-selection/set-selection.ts","../src/transforms-node/insert-nodes.ts","../src/transforms-node/lift-nodes.ts","../src/transforms-node/merge-nodes.ts","../src/transforms-node/move-nodes.ts","../src/transforms-node/remove-nodes.ts","../src/transforms-node/set-nodes.ts","../src/transforms-node/split-nodes.ts","../src/transforms-node/unset-nodes.ts","../src/transforms-node/unwrap-nodes.ts","../src/transforms-node/wrap-nodes.ts","../src/create-editor.ts"],"sourcesContent":["import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport interface PathRefInterface {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n  transform: (ref: PathRef, op: Operation) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const PathRef: PathRefInterface = {\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import { Operation, Point } from '..'\nimport { TextDirection } from '../types/types'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: TextDirection | null\n  unref(): Point | null\n}\n\nexport interface PointRefInterface {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n  transform: (ref: PointRef, op: Operation) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const PointRef: PointRefInterface = {\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport interface RangeRefInterface {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n  transform: (ref: RangeRef, op: Operation) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const RangeRef: RangeRefInterface = {\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const DIRTY_PATH_KEYS: WeakMap<Editor, Set<string>> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithoutHoles = require(\"./arrayWithoutHoles.js\");\nvar iterableToArray = require(\"./iterableToArray.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableSpread = require(\"./nonIterableSpread.js\");\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import {\n  InsertNodeOperation,\n  MergeNodeOperation,\n  MoveNodeOperation,\n  Operation,\n  RemoveNodeOperation,\n  SplitNodeOperation,\n} from '..'\nimport { TextDirection } from '../types/types'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport interface PathAncestorsOptions {\n  reverse?: boolean\n}\n\nexport interface PathLevelsOptions {\n  reverse?: boolean\n}\n\nexport interface PathTransformOptions {\n  affinity?: TextDirection | null\n}\n\nexport interface PathInterface {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n  ancestors: (path: Path, options?: PathAncestorsOptions) => Path[]\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n  common: (path: Path, another: Path) => Path\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n  compare: (path: Path, another: Path) => -1 | 0 | 1\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n  endsAfter: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n  endsAt: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n  endsBefore: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n  equals: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if the path of previous sibling node exists\n   */\n  hasPrevious: (path: Path) => boolean\n\n  /**\n   * Check if a path is after another.\n   */\n  isAfter: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n  isAncestor: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path is before another.\n   */\n  isBefore: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path is a child of another.\n   */\n  isChild: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n  isCommon: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n  isDescendant: (path: Path, another: Path) => boolean\n\n  /**\n   * Check if a path is the parent of another.\n   */\n  isParent: (path: Path, another: Path) => boolean\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n  isPath: (value: any) => value is Path\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n  isSibling: (path: Path, another: Path) => boolean\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n  levels: (path: Path, options?: PathLevelsOptions) => Path[]\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n  next: (path: Path) => Path\n\n  /**\n   * Returns whether this operation can affect paths or not. Used as an\n   * optimization when updating dirty paths during normalization\n   *\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\n   * below\n   */\n  operationCanTransformPath: (\n    operation: Operation\n  ) => operation is\n    | InsertNodeOperation\n    | RemoveNodeOperation\n    | MergeNodeOperation\n    | SplitNodeOperation\n    | MoveNodeOperation\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n  parent: (path: Path) => Path\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n  previous: (path: Path) => Path\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n  relative: (path: Path, ancestor: Path) => Path\n\n  /**\n   * Transform a path by an operation.\n   */\n  transform: (\n    path: Path,\n    operation: Operation,\n    options?: PathTransformOptions\n  ) => Path | null\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Path: PathInterface = {\n  ancestors(path: Path, options: PathAncestorsOptions = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  hasPrevious(path: Path): boolean {\n    return path[path.length - 1] > 0\n  },\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  levels(path: Path, options: PathLevelsOptions = {}): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  operationCanTransformPath(\n    operation: Operation\n  ): operation is\n    | InsertNodeOperation\n    | RemoveNodeOperation\n    | MergeNodeOperation\n    | SplitNodeOperation\n    | MoveNodeOperation {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true\n      default:\n        return false\n    }\n  },\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  transform(\n    path: Path | null,\n    operation: Operation,\n    options: PathTransformOptions = {}\n  ): Path | null {\n    if (!path) return null\n\n    // PERF: use destructing instead of immer\n    const p = [...path]\n    const { affinity = 'forward' } = options\n\n    // PERF: Exit early if the operation is guaranteed not to have an effect.\n    if (path.length === 0) {\n      return p\n    }\n\n    switch (operation.type) {\n      case 'insert_node': {\n        const { path: op } = operation\n\n        if (\n          Path.equals(op, p) ||\n          Path.endsBefore(op, p) ||\n          Path.isAncestor(op, p)\n        ) {\n          p[op.length - 1] += 1\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path: op } = operation\n\n        if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n          return null\n        } else if (Path.endsBefore(op, p)) {\n          p[op.length - 1] -= 1\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path: op, position } = operation\n\n        if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n          p[op.length - 1] -= 1\n        } else if (Path.isAncestor(op, p)) {\n          p[op.length - 1] -= 1\n          p[op.length] += position\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path: op, position } = operation\n\n        if (Path.equals(op, p)) {\n          if (affinity === 'forward') {\n            p[p.length - 1] += 1\n          } else if (affinity === 'backward') {\n            // Nothing, because it still refers to the right path.\n          } else {\n            return null\n          }\n        } else if (Path.endsBefore(op, p)) {\n          p[op.length - 1] += 1\n        } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n          p[op.length - 1] += 1\n          p[op.length] -= position\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path: op, newPath: onp } = operation\n\n        // If the old and new path are the same, it's a no-op.\n        if (Path.equals(op, onp)) {\n          return p\n        }\n\n        if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n          const copy = onp.slice()\n\n          if (Path.endsBefore(op, onp) && op.length < onp.length) {\n            copy[op.length - 1] -= 1\n          }\n\n          return copy.concat(p.slice(op.length))\n        } else if (\n          Path.isSibling(op, onp) &&\n          (Path.isAncestor(onp, p) || Path.equals(onp, p))\n        ) {\n          if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else {\n            p[op.length - 1] += 1\n          }\n        } else if (\n          Path.endsBefore(onp, p) ||\n          Path.equals(onp, p) ||\n          Path.isAncestor(onp, p)\n        ) {\n          if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          p[onp.length - 1] += 1\n        } else if (Path.endsBefore(op, p)) {\n          if (Path.equals(onp, p)) {\n            p[onp.length - 1] += 1\n          }\n\n          p[op.length - 1] -= 1\n        }\n\n        break\n      }\n    }\n\n    return p\n  },\n}\n","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableRest = require(\"./nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import {\n  Ancestor,\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  Point,\n  Range,\n  Scrubber,\n  Selection,\n  Text,\n} from '../../index'\n\nexport interface GeneralTransforms {\n  /**\n   * Transform the editor by an operation.\n   */\n  transform: (editor: Editor, op: Operation) => void\n}\n\nconst insertChildren = <T>(xs: T[], index: number, ...newValues: T[]) => [\n  ...xs.slice(0, index),\n  ...newValues,\n  ...xs.slice(index),\n]\n\nconst replaceChildren = <T>(\n  xs: T[],\n  index: number,\n  removeCount: number,\n  ...newValues: T[]\n) => [...xs.slice(0, index), ...newValues, ...xs.slice(index + removeCount)]\n\nconst removeChildren = replaceChildren\n\n/**\n * Replace a descendant with a new node, replacing all ancestors\n */\nconst modifyDescendant = <N extends Descendant>(\n  editor: Editor,\n  path: Path,\n  f: (node: N) => N\n) => {\n  if (path.length === 0) {\n    throw new Error('Cannot modify the editor')\n  }\n\n  const node = Node.get(editor, path) as N\n  const slicedPath = path.slice()\n  let modifiedNode: Node = f(node)\n\n  while (slicedPath.length > 1) {\n    const index = slicedPath.pop()!\n    const ancestorNode = Node.get(editor, slicedPath) as Ancestor\n\n    modifiedNode = {\n      ...ancestorNode,\n      children: replaceChildren(ancestorNode.children, index, 1, modifiedNode),\n    }\n  }\n\n  const index = slicedPath.pop()!\n  editor.children = replaceChildren(editor.children, index, 1, modifiedNode)\n}\n\n/**\n * Replace the children of a node, replacing all ancestors\n */\nconst modifyChildren = (\n  editor: Editor,\n  path: Path,\n  f: (children: Descendant[]) => Descendant[]\n) => {\n  if (path.length === 0) {\n    editor.children = f(editor.children)\n  } else {\n    modifyDescendant<Element>(editor, path, node => {\n      if (Text.isText(node)) {\n        throw new Error(\n          `Cannot get the element at path [${path}] because it refers to a leaf node: ${Scrubber.stringify(\n            node\n          )}`\n        )\n      }\n\n      return { ...node, children: f(node.children) }\n    })\n  }\n}\n\n/**\n * Replace a leaf, replacing all ancestors\n */\nconst modifyLeaf = (editor: Editor, path: Path, f: (leaf: Text) => Text) =>\n  modifyDescendant(editor, path, node => {\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${Scrubber.stringify(\n          node\n        )}`\n      )\n    }\n\n    return f(node)\n  })\n\n// eslint-disable-next-line no-redeclare\nexport const GeneralTransforms: GeneralTransforms = {\n  transform(editor: Editor, op: Operation): void {\n    let transformSelection = false\n\n    switch (op.type) {\n      case 'insert_node': {\n        const { path, node } = op\n\n        modifyChildren(editor, Path.parent(path), children => {\n          const index = path[path.length - 1]\n\n          if (index > children.length) {\n            throw new Error(\n              `Cannot apply an \"insert_node\" operation at path [${path}] because the destination is past the end of the node.`\n            )\n          }\n\n          return insertChildren(children, index, node)\n        })\n\n        transformSelection = true\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        if (text.length === 0) break\n\n        modifyLeaf(editor, path, node => {\n          const before = node.text.slice(0, offset)\n          const after = node.text.slice(offset)\n\n          return {\n            ...node,\n            text: before + text + after,\n          }\n        })\n\n        transformSelection = true\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const prevPath = Path.previous(path)\n        const prevIndex = prevPath[prevPath.length - 1]\n\n        modifyChildren(editor, Path.parent(path), children => {\n          const node = children[index]\n          const prev = children[prevIndex]\n          let newNode: Descendant\n\n          if (Text.isText(node) && Text.isText(prev)) {\n            newNode = { ...prev, text: prev.text + node.text }\n          } else if (!Text.isText(node) && !Text.isText(prev)) {\n            newNode = { ...prev, children: prev.children.concat(node.children) }\n          } else {\n            throw new Error(\n              `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interfaces: ${Scrubber.stringify(\n                node\n              )} ${Scrubber.stringify(prev)}`\n            )\n          }\n\n          return replaceChildren(children, prevIndex, 2, newNode)\n        })\n\n        transformSelection = true\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n        const index = path[path.length - 1]\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n\n        modifyChildren(editor, Path.parent(path), children =>\n          removeChildren(children, index, 1)\n        )\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        const truePath = Path.transform(path, op)!\n        const newIndex = truePath[truePath.length - 1]\n\n        modifyChildren(editor, Path.parent(truePath), children =>\n          insertChildren(children, newIndex, node)\n        )\n\n        transformSelection = true\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n\n        modifyChildren(editor, Path.parent(path), children =>\n          removeChildren(children, index, 1)\n        )\n\n        // Transform all the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (editor.selection) {\n          let selection: Selection = { ...editor.selection }\n\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else {\n              let prev: NodeEntry<Text> | undefined\n              let next: NodeEntry<Text> | undefined\n\n              for (const [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, path) === -1) {\n                  prev = [n, p]\n                } else {\n                  next = [n, p]\n                  break\n                }\n              }\n\n              let preferNext = false\n              if (prev && next) {\n                if (Path.isSibling(prev[1], path)) {\n                  preferNext = false\n                } else if (Path.equals(next[1], path)) {\n                  preferNext = true\n                } else {\n                  preferNext =\n                    Path.common(prev[1], path).length <\n                    Path.common(next[1], path).length\n                }\n              }\n\n              if (prev && !preferNext) {\n                selection![key] = { path: prev[1], offset: prev[0].text.length }\n              } else if (next) {\n                selection![key] = { path: next[1], offset: 0 }\n              } else {\n                selection = null\n              }\n            }\n          }\n\n          if (!selection || !Range.equals(selection, editor.selection)) {\n            editor.selection = selection\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        if (text.length === 0) break\n\n        modifyLeaf(editor, path, node => {\n          const before = node.text.slice(0, offset)\n          const after = node.text.slice(offset + text.length)\n\n          return {\n            ...node,\n            text: before + after,\n          }\n        })\n\n        transformSelection = true\n        break\n      }\n\n      case 'set_node': {\n        const { path, properties, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        modifyDescendant(editor, path, node => {\n          const newNode = { ...node }\n\n          for (const key in newProperties) {\n            if (key === 'children' || key === 'text') {\n              throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n            }\n\n            const value = newProperties[<keyof Node>key]\n\n            if (value == null) {\n              delete newNode[<keyof Node>key]\n            } else {\n              newNode[<keyof Node>key] = value\n            }\n          }\n\n          // properties that were previously defined, but are now missing, must be deleted\n          for (const key in properties) {\n            if (!newProperties.hasOwnProperty(key)) {\n              delete newNode[<keyof Node>key]\n            }\n          }\n\n          return newNode\n        })\n\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          editor.selection = null\n          break\n        }\n\n        if (editor.selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${Scrubber.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          editor.selection = { ...newProperties }\n          break\n        }\n\n        const selection = { ...editor.selection }\n\n        for (const key in newProperties) {\n          const value = newProperties[<keyof Range>key]\n\n          if (value == null) {\n            if (key === 'anchor' || key === 'focus') {\n              throw new Error(`Cannot remove the \"${key}\" selection property`)\n            }\n\n            delete selection[<keyof Range>key]\n          } else {\n            selection[<keyof Range>key] = value\n          }\n        }\n\n        editor.selection = selection\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n        const index = path[path.length - 1]\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        modifyChildren(editor, Path.parent(path), children => {\n          const node = children[index]\n          let newNode: Descendant\n          let nextNode: Descendant\n\n          if (Text.isText(node)) {\n            const before = node.text.slice(0, position)\n            const after = node.text.slice(position)\n            newNode = {\n              ...node,\n              text: before,\n            }\n            nextNode = {\n              ...(properties as Partial<Text>),\n              text: after,\n            }\n          } else {\n            const before = node.children.slice(0, position)\n            const after = node.children.slice(position)\n            newNode = {\n              ...node,\n              children: before,\n            }\n            nextNode = {\n              ...(properties as Partial<Element>),\n              children: after,\n            }\n          }\n\n          return replaceChildren(children, index, 1, newNode, nextNode)\n        })\n\n        transformSelection = true\n        break\n      }\n    }\n\n    if (transformSelection && editor.selection) {\n      const selection = { ...editor.selection }\n\n      for (const [point, key] of Range.points(selection)) {\n        selection[key] = Point.transform(point, op)!\n      }\n\n      if (!Range.equals(selection, editor.selection)) {\n        editor.selection = selection\n      }\n    }\n  },\n}\n","import { Editor, Element, Location, Node, Path } from '../../index'\nimport { NodeMatch, PropsCompare, PropsMerge } from '../editor'\nimport { MaximizeMode, RangeMode } from '../../types/types'\n\nexport interface NodeInsertNodesOptions<T extends Node> {\n  at?: Location\n  match?: NodeMatch<T>\n  mode?: RangeMode\n  hanging?: boolean\n  select?: boolean\n  voids?: boolean\n  batchDirty?: boolean\n}\n\nexport interface NodeTransforms {\n  /**\n   * Insert nodes in the editor\n   * at the specified location or (if not defined) the current selection or (if not defined) the end of the document.\n   */\n  insertNodes: <T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options?: NodeInsertNodesOptions<T>\n  ) => void\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n  liftNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: MaximizeMode\n      voids?: boolean\n    }\n  ) => void\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n  mergeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: RangeMode\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n  moveNodes: <T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: MaximizeMode\n      to: Path\n      voids?: boolean\n    }\n  ) => void\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n  removeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: RangeMode\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n  setNodes: <T extends Node>(\n    editor: Editor,\n    props: Partial<T>,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: MaximizeMode\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n      compare?: PropsCompare\n      merge?: PropsMerge\n    }\n  ) => void\n\n  /**\n   * Split the nodes at a specific location.\n   */\n  splitNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: RangeMode\n      always?: boolean\n      height?: number\n      voids?: boolean\n    }\n  ) => void\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n  unsetNodes: <T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: MaximizeMode\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n  unwrapNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: MaximizeMode\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n  wrapNodes: <T extends Node>(\n    editor: Editor,\n    element: Element,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: MaximizeMode\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const NodeTransforms: NodeTransforms = {\n  insertNodes(editor, nodes, options) {\n    editor.insertNodes(nodes, options)\n  },\n  liftNodes(editor, options) {\n    editor.liftNodes(options)\n  },\n  mergeNodes(editor, options) {\n    editor.mergeNodes(options)\n  },\n  moveNodes(editor, options) {\n    editor.moveNodes(options)\n  },\n  removeNodes(editor, options) {\n    editor.removeNodes(options)\n  },\n  setNodes(editor, props, options) {\n    editor.setNodes(props, options)\n  },\n  splitNodes(editor, options) {\n    editor.splitNodes(options)\n  },\n  unsetNodes(editor, props, options) {\n    editor.unsetNodes(props, options)\n  },\n  unwrapNodes(editor, options) {\n    editor.unwrapNodes(options)\n  },\n  wrapNodes(editor, element, options) {\n    editor.wrapNodes(element, options)\n  },\n}\n","import { Editor, Location, Point, Range } from '../../index'\nimport { MoveUnit, SelectionEdge } from '../../types/types'\n\nexport interface SelectionCollapseOptions {\n  edge?: SelectionEdge\n}\n\nexport interface SelectionMoveOptions {\n  distance?: number\n  unit?: MoveUnit\n  reverse?: boolean\n  edge?: SelectionEdge\n}\n\nexport interface SelectionSetPointOptions {\n  edge?: SelectionEdge\n}\n\nexport interface SelectionTransforms {\n  /**\n   * Collapse the selection.\n   */\n  collapse: (editor: Editor, options?: SelectionCollapseOptions) => void\n\n  /**\n   * Unset the selection.\n   */\n  deselect: (editor: Editor) => void\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n  move: (editor: Editor, options?: SelectionMoveOptions) => void\n\n  /**\n   * Set the selection to a new value.\n   */\n  select: (editor: Editor, target: Location) => void\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n  setPoint: (\n    editor: Editor,\n    props: Partial<Point>,\n    options?: SelectionSetPointOptions\n  ) => void\n\n  /**\n   * Set new properties on the selection.\n   */\n  setSelection: (editor: Editor, props: Partial<Range>) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const SelectionTransforms: SelectionTransforms = {\n  collapse(editor, options) {\n    editor.collapse(options)\n  },\n  deselect(editor) {\n    editor.deselect()\n  },\n  move(editor, options) {\n    editor.move(options)\n  },\n  select(editor, target) {\n    editor.select(target)\n  },\n  setPoint(editor, props, options) {\n    editor.setPoint(props, options)\n  },\n  setSelection(editor, props) {\n    editor.setSelection(props)\n  },\n}\n","export const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\n","import { isObject } from './is-object'\n\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */\nexport const isDeepEqual = (\n  node: Record<string, any>,\n  another: Record<string, any>\n): boolean => {\n  for (const key in node) {\n    const a = node[key]\n    const b = another[key]\n    if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false\n      }\n    } else if (isObject(a) && isObject(b)) {\n      if (!isDeepEqual(a, b)) return false\n    } else if (a !== b) {\n      return false\n    }\n  }\n\n  /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */\n\n  for (const key in another) {\n    if (node[key] === undefined && another[key] !== undefined) {\n      return false\n    }\n  }\n\n  return true\n}\n","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { ExtendedType, Operation, Path, Point, PointEntry, isObject } from '..'\nimport { RangeDirection } from '../types/types'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface BaseRange {\n  anchor: Point\n  focus: Point\n}\n\nexport type Range = ExtendedType<'Range', BaseRange>\n\nexport interface RangeEdgesOptions {\n  reverse?: boolean\n}\n\nexport interface RangeTransformOptions {\n  affinity?: RangeDirection | null\n}\n\nexport interface RangeInterface {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n  edges: (range: Range, options?: RangeEdgesOptions) => [Point, Point]\n\n  /**\n   * Get the end point of a range.\n   */\n  end: (range: Range) => Point\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n  equals: (range: Range, another: Range) => boolean\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n  includes: (range: Range, target: Path | Point | Range) => boolean\n\n  /**\n   * Check if a range includes another range.\n   */\n  surrounds: (range: Range, target: Range) => boolean\n\n  /**\n   * Get the intersection of a range with another.\n   */\n  intersection: (range: Range, another: Range) => Range | null\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n  isBackward: (range: Range) => boolean\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n  isCollapsed: (range: Range) => boolean\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n  isExpanded: (range: Range) => boolean\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n  isForward: (range: Range) => boolean\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n  isRange: (value: any) => value is Range\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n  points: (range: Range) => Generator<PointEntry, void, undefined>\n\n  /**\n   * Get the start point of a range.\n   */\n  start: (range: Range) => Point\n\n  /**\n   * Transform a range by an operation.\n   */\n  transform: (\n    range: Range,\n    op: Operation,\n    options?: RangeTransformOptions\n  ) => Range | null\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Range: RangeInterface = {\n  edges(range: Range, options: RangeEdgesOptions = {}): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  surrounds(range: Range, target: Range): boolean {\n    const intersectionRange = Range.intersection(range, target)\n    if (!intersectionRange) {\n      return false\n    }\n    return Range.equals(intersectionRange, target)\n  },\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  isRange(value: any): value is Range {\n    return (\n      isObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  *points(range: Range): Generator<PointEntry, void, undefined> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  transform(\n    range: Range | null,\n    op: Operation,\n    options: RangeTransformOptions = {}\n  ): Range | null {\n    if (range === null) {\n      return null\n    }\n\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      // If the range is collapsed, make sure to use the same affinity to\n      // avoid the two points passing each other and expanding in the opposite\n      // direction\n      const isCollapsed = Range.isCollapsed(range)\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = isCollapsed ? affinityAnchor : 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = isCollapsed ? affinityAnchor : 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n    const anchor = Point.transform(range.anchor, op, {\n      affinity: affinityAnchor,\n    })\n    const focus = Point.transform(range.focus, op, { affinity: affinityFocus })\n\n    if (!anchor || !focus) {\n      return null\n    }\n\n    return { anchor, focus }\n  },\n}\n","import {\n  Ancestor,\n  Descendant,\n  Editor,\n  ExtendedType,\n  Node,\n  Path,\n  isObject,\n} from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface BaseElement {\n  children: Descendant[]\n}\n\nexport type Element = ExtendedType<'Element', BaseElement>\n\nexport interface ElementIsElementOptions {\n  deep?: boolean\n}\n\nexport interface ElementInterface {\n  /**\n   * Check if a value implements the 'Ancestor' interface.\n   */\n  isAncestor: (\n    value: any,\n    options?: ElementIsElementOptions\n  ) => value is Ancestor\n\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n  isElement: (value: any, options?: ElementIsElementOptions) => value is Element\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n  isElementList: (\n    value: any,\n    options?: ElementIsElementOptions\n  ) => value is Element[]\n\n  /**\n   * Check if a set of props is a partial of Element.\n   */\n  isElementProps: (props: any) => props is Partial<Element>\n\n  /**\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\n   * Default it check to `type` key value\n   */\n  isElementType: <T extends Element>(\n    value: any,\n    elementVal: string,\n    elementKey?: string\n  ) => value is T\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n  matches: (element: Element, props: Partial<Element>) => boolean\n}\n\n/**\n * Shared the function with isElementType utility\n */\nconst isElement = (\n  value: any,\n  { deep = false }: ElementIsElementOptions = {}\n): value is Element => {\n  if (!isObject(value)) return false\n\n  // PERF: No need to use the full Editor.isEditor here\n  const isEditor = typeof value.apply === 'function'\n  if (isEditor) return false\n\n  const isChildrenValid = deep\n    ? Node.isNodeList(value.children)\n    : Array.isArray(value.children)\n\n  return isChildrenValid\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Element: ElementInterface = {\n  isAncestor(\n    value: any,\n    { deep = false }: ElementIsElementOptions = {}\n  ): value is Ancestor {\n    return isObject(value) && Node.isNodeList(value.children, { deep })\n  },\n\n  isElement,\n\n  isElementList(\n    value: any,\n    { deep = false }: ElementIsElementOptions = {}\n  ): value is Element[] {\n    return (\n      Array.isArray(value) &&\n      value.every(val => Element.isElement(val, { deep }))\n    )\n  },\n\n  isElementProps(props: any): props is Partial<Element> {\n    return (props as Partial<Element>).children !== undefined\n  },\n\n  isElementType: <T extends Element>(\n    value: any,\n    elementVal: string,\n    elementKey: string = 'type'\n  ): value is T => {\n    return (\n      isElement(value) && value[<keyof Descendant>elementKey] === elementVal\n    )\n  },\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[<keyof Descendant>key] !== props[<keyof Descendant>key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\nexport type ElementEntry = [Element, Path]\n","import { produce } from 'immer'\nimport { Editor, Path, Range, Scrubber, Text } from '..'\nimport { Element, ElementEntry } from './element'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type BaseNode = Editor | Element | Text\nexport type Node = Editor | Element | Text\n\nexport interface NodeAncestorsOptions {\n  reverse?: boolean\n}\n\nexport interface NodeChildrenOptions {\n  reverse?: boolean\n}\n\nexport interface NodeDescendantsOptions {\n  from?: Path\n  to?: Path\n  reverse?: boolean\n  pass?: (node: NodeEntry) => boolean\n}\n\nexport interface NodeElementsOptions {\n  from?: Path\n  to?: Path\n  reverse?: boolean\n  pass?: (node: NodeEntry) => boolean\n}\n\nexport interface NodeIsNodeOptions {\n  deep?: boolean\n}\n\nexport interface NodeLevelsOptions {\n  reverse?: boolean\n}\n\nexport interface NodeNodesOptions {\n  from?: Path\n  to?: Path\n  reverse?: boolean\n  pass?: (entry: NodeEntry) => boolean\n}\n\nexport interface NodeTextsOptions {\n  from?: Path\n  to?: Path\n  reverse?: boolean\n  pass?: (node: NodeEntry) => boolean\n}\n\nexport interface NodeInterface {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n  ancestor: (root: Node, path: Path) => Ancestor\n\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is top-down, from highest to lowest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\n   */\n  ancestors: (\n    root: Node,\n    path: Path,\n    options?: NodeAncestorsOptions\n  ) => Generator<NodeEntry<Ancestor>, void, undefined>\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n  child: (root: Node, index: number) => Descendant\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n  children: (\n    root: Node,\n    path: Path,\n    options?: NodeChildrenOptions\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n  common: (root: Node, path: Path, another: Path) => NodeEntry\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n  descendant: (root: Node, path: Path) => Descendant\n\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n  descendants: (\n    root: Node,\n    options?: NodeDescendantsOptions\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n  elements: (\n    root: Node,\n    options?: NodeElementsOptions\n  ) => Generator<ElementEntry, void, undefined>\n\n  /**\n   * Extract props from a Node.\n   */\n  extractProps: (node: Node) => NodeProps\n\n  /**\n   * Get the first leaf node entry in a root node from a path.\n   */\n  first: (root: Node, path: Path) => NodeEntry\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n  fragment: <T extends Ancestor = Editor>(\n    root: T,\n    range: Range\n  ) => T['children']\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n  get: (root: Node, path: Path) => Node\n\n  /**\n   * Similar to get, but returns undefined if the node does not exist.\n   */\n  getIf: (root: Node, path: Path) => Node | undefined\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n  has: (root: Node, path: Path) => boolean\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n  isNode: (value: any, options?: NodeIsNodeOptions) => value is Node\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n  isNodeList: (value: any, options?: NodeIsNodeOptions) => value is Node[]\n\n  /**\n   * Get the last leaf node entry in a root node from a path.\n   */\n  last: (root: Node, path: Path) => NodeEntry\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n  leaf: (root: Node, path: Path) => Text\n\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from highest to lowest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n  levels: (\n    root: Node,\n    path: Path,\n    options?: NodeLevelsOptions\n  ) => Generator<NodeEntry, void, undefined>\n\n  /**\n   * Check if a node matches a set of props.\n   */\n  matches: (node: Node, props: Partial<Node>) => boolean\n\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n  nodes: (\n    root: Node,\n    options?: NodeNodesOptions\n  ) => Generator<NodeEntry, void, undefined>\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n  parent: (root: Node, path: Path) => Ancestor\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n  string: (node: Node) => string\n\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n  texts: (\n    root: Node,\n    options?: NodeTextsOptions\n  ) => Generator<NodeEntry<Text>, void, undefined>\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Node: NodeInterface = {\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${Scrubber.stringify(\n          node\n        )}`\n      )\n    }\n\n    return node\n  },\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: NodeAncestorsOptions = {}\n  ): Generator<NodeEntry<Ancestor>, void, undefined> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${Scrubber.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${Scrubber.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  *children(\n    root: Node,\n    path: Path,\n    options: NodeChildrenOptions = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${Scrubber.stringify(\n          node\n        )}`\n      )\n    }\n\n    return node\n  },\n\n  *descendants(\n    root: Node,\n    options: NodeDescendantsOptions = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  *elements(\n    root: Node,\n    options: NodeElementsOptions = {}\n  ): Generator<ElementEntry, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  extractProps(node: Node): NodeProps {\n    if (Element.isAncestor(node)) {\n      const { children, ...properties } = node\n\n      return properties\n    } else {\n      const { text, ...properties } = node\n\n      return properties\n    }\n  },\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  fragment<T extends Ancestor = Editor>(root: T, range: Range): T['children'] {\n    const newRoot = produce({ children: root.children }, r => {\n      const [start, end] = Range.edges(range)\n      const nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null\n      }\n    })\n\n    return newRoot.children\n  },\n\n  get(root: Node, path: Path): Node {\n    const node = Node.getIf(root, path)\n    if (node === undefined) {\n      throw new Error(\n        `Cannot find a descendant at path [${path}] in node: ${Scrubber.stringify(\n          root\n        )}`\n      )\n    }\n    return node\n  },\n\n  getIf(root: Node, path: Path): Node | undefined {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  isNode(value: any, { deep = false }: NodeIsNodeOptions = {}): value is Node {\n    return (\n      Text.isText(value) ||\n      Element.isElement(value, { deep }) ||\n      Editor.isEditor(value, { deep })\n    )\n  },\n\n  isNodeList(\n    value: any,\n    { deep = false }: NodeIsNodeOptions = {}\n  ): value is Node[] {\n    return (\n      Array.isArray(value) && value.every(val => Node.isNode(val, { deep }))\n    )\n  },\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${Scrubber.stringify(\n          node\n        )}`\n      )\n    }\n\n    return node\n  },\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: NodeLevelsOptions = {}\n  ): Generator<NodeEntry, void, undefined> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) &&\n        Element.isElementProps(props) &&\n        Element.matches(node, props)) ||\n      (Text.isText(node) &&\n        Text.isTextProps(props) &&\n        Text.matches(node, props))\n    )\n  },\n\n  *nodes(\n    root: Node,\n    options: NodeNodesOptions = {}\n  ): Generator<NodeEntry, void, undefined> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't descended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  *texts(\n    root: Node,\n    options: NodeTextsOptions = {}\n  ): Generator<NodeEntry<Text>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n\n/**\n * Convenience type for returning the props of a node.\n */\nexport type NodeProps =\n  | Omit<Editor, 'children'>\n  | Omit<Element, 'children'>\n  | Omit<Text, 'text'>\n","import { ExtendedType, Node, Path, Range, isObject } from '..'\n\nexport type BaseInsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n}\n\nexport type InsertNodeOperation = ExtendedType<\n  'InsertNodeOperation',\n  BaseInsertNodeOperation\n>\n\nexport type BaseInsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type InsertTextOperation = ExtendedType<\n  'InsertTextOperation',\n  BaseInsertTextOperation\n>\n\nexport type BaseMergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type MergeNodeOperation = ExtendedType<\n  'MergeNodeOperation',\n  BaseMergeNodeOperation\n>\n\nexport type BaseMoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n}\n\nexport type MoveNodeOperation = ExtendedType<\n  'MoveNodeOperation',\n  BaseMoveNodeOperation\n>\n\nexport type BaseRemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n}\n\nexport type RemoveNodeOperation = ExtendedType<\n  'RemoveNodeOperation',\n  BaseRemoveNodeOperation\n>\n\nexport type BaseRemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type RemoveTextOperation = ExtendedType<\n  'RemoveTextOperation',\n  BaseRemoveTextOperation\n>\n\nexport type BaseSetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n}\n\nexport type SetNodeOperation = ExtendedType<\n  'SetNodeOperation',\n  BaseSetNodeOperation\n>\n\nexport type BaseSetSelectionOperation =\n  | {\n      type: 'set_selection'\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      properties: Range\n      newProperties: null\n    }\n\nexport type SetSelectionOperation = ExtendedType<\n  'SetSelectionOperation',\n  BaseSetSelectionOperation\n>\n\nexport type BaseSplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type SplitNodeOperation = ExtendedType<\n  'SplitNodeOperation',\n  BaseSplitNodeOperation\n>\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type BaseOperation = NodeOperation | SelectionOperation | TextOperation\nexport type Operation = ExtendedType<'Operation', BaseOperation>\n\nexport interface OperationInterface {\n  /**\n   * Check if a value is a `NodeOperation` object.\n   */\n  isNodeOperation: (value: any) => value is NodeOperation\n\n  /**\n   * Check if a value is an `Operation` object.\n   */\n  isOperation: (value: any) => value is Operation\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n  isOperationList: (value: any) => value is Operation[]\n\n  /**\n   * Check if a value is a `SelectionOperation` object.\n   */\n  isSelectionOperation: (value: any) => value is SelectionOperation\n\n  /**\n   * Check if a value is a `TextOperation` object.\n   */\n  isTextOperation: (value: any) => value is TextOperation\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n  inverse: (op: Operation) => Operation\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Operation: OperationInterface = {\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  isOperation(value: any): value is Operation {\n    if (!isObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isObject(value.properties) &&\n          isObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isObject(value.properties) && isObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) && value.every(val => Operation.isOperation(val))\n    )\n  },\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Range } from '../interfaces/range'\nimport { Node } from '../interfaces/node'\nimport { Operation } from '../interfaces/operation'\nimport { isObject } from '../utils'\n\nexport const isEditor: EditorInterface['isEditor'] = (\n  value: any,\n  { deep = false } = {}\n): value is Editor => {\n  if (!isObject(value)) {\n    return false\n  }\n\n  const isEditor =\n    typeof value.addMark === 'function' &&\n    typeof value.apply === 'function' &&\n    typeof value.deleteFragment === 'function' &&\n    typeof value.insertBreak === 'function' &&\n    typeof value.insertSoftBreak === 'function' &&\n    typeof value.insertFragment === 'function' &&\n    typeof value.insertNode === 'function' &&\n    typeof value.insertText === 'function' &&\n    typeof value.isElementReadOnly === 'function' &&\n    typeof value.isInline === 'function' &&\n    typeof value.isSelectable === 'function' &&\n    typeof value.isVoid === 'function' &&\n    typeof value.normalizeNode === 'function' &&\n    typeof value.onChange === 'function' &&\n    typeof value.removeMark === 'function' &&\n    typeof value.getDirtyPaths === 'function' &&\n    (value.marks === null || isObject(value.marks)) &&\n    (value.selection === null || Range.isRange(value.selection)) &&\n    (!deep || Node.isNodeList(value.children)) &&\n    Operation.isOperationList(value.operations)\n\n  return isEditor\n}\n","import {\n  Ancestor,\n  Descendant,\n  Element,\n  ExtendedType,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n  Transforms,\n} from '..'\nimport {\n  LeafEdge,\n  MaximizeMode,\n  RangeDirection,\n  SelectionMode,\n  TextDirection,\n  TextUnit,\n  TextUnitAdjustment,\n} from '../types/types'\nimport { OmitFirstArg } from '../utils/types'\nimport { isEditor } from '../editor/is-editor'\nimport {\n  TextInsertFragmentOptions,\n  TextInsertTextOptions,\n} from './transforms/text'\nimport { NodeInsertNodesOptions } from './transforms/node'\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\nexport interface BaseEditor {\n  // Core state.\n\n  children: Descendant[]\n  selection: Selection\n  operations: Operation[]\n  marks: EditorMarks | null\n\n  // Overrideable core methods.\n\n  apply: (operation: Operation) => void\n  getDirtyPaths: (operation: Operation) => Path[]\n  getFragment: () => Descendant[]\n  isElementReadOnly: (element: Element) => boolean\n  isSelectable: (element: Element) => boolean\n  markableVoid: (element: Element) => boolean\n  normalizeNode: (\n    entry: NodeEntry,\n    options?: {\n      operation?: Operation\n      fallbackElement?: () => Element\n    }\n  ) => void\n  onChange: (options?: { operation?: Operation }) => void\n  shouldNormalize: ({\n    iteration,\n    dirtyPaths,\n    operation,\n  }: {\n    iteration: number\n    initialDirtyPathsLength: number\n    dirtyPaths: Path[]\n    operation?: Operation\n  }) => boolean\n\n  // Overrideable core transforms.\n\n  addMark: OmitFirstArg<typeof Editor.addMark>\n  collapse: OmitFirstArg<typeof Transforms.collapse>\n  delete: OmitFirstArg<typeof Transforms.delete>\n  deleteBackward: (unit: TextUnit) => void\n  deleteForward: (unit: TextUnit) => void\n  deleteFragment: OmitFirstArg<typeof Editor.deleteFragment>\n  deselect: OmitFirstArg<typeof Transforms.deselect>\n  insertBreak: OmitFirstArg<typeof Editor.insertBreak>\n  insertFragment: OmitFirstArg<typeof Transforms.insertFragment>\n  insertNode: OmitFirstArg<typeof Editor.insertNode>\n  insertNodes: OmitFirstArg<typeof Transforms.insertNodes>\n  insertSoftBreak: OmitFirstArg<typeof Editor.insertSoftBreak>\n  insertText: OmitFirstArg<typeof Transforms.insertText>\n  liftNodes: OmitFirstArg<typeof Transforms.liftNodes>\n  mergeNodes: OmitFirstArg<typeof Transforms.mergeNodes>\n  move: OmitFirstArg<typeof Transforms.move>\n  moveNodes: OmitFirstArg<typeof Transforms.moveNodes>\n  normalize: OmitFirstArg<typeof Editor.normalize>\n  removeMark: OmitFirstArg<typeof Editor.removeMark>\n  removeNodes: OmitFirstArg<typeof Transforms.removeNodes>\n  select: OmitFirstArg<typeof Transforms.select>\n  setNodes: <T extends Node>(\n    props: Partial<T>,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: MaximizeMode\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n      compare?: PropsCompare\n      merge?: PropsMerge\n    }\n  ) => void\n  setNormalizing: OmitFirstArg<typeof Editor.setNormalizing>\n  setPoint: OmitFirstArg<typeof Transforms.setPoint>\n  setSelection: OmitFirstArg<typeof Transforms.setSelection>\n  splitNodes: OmitFirstArg<typeof Transforms.splitNodes>\n  unsetNodes: OmitFirstArg<typeof Transforms.unsetNodes>\n  unwrapNodes: OmitFirstArg<typeof Transforms.unwrapNodes>\n  withoutNormalizing: OmitFirstArg<typeof Editor.withoutNormalizing>\n  wrapNodes: OmitFirstArg<typeof Transforms.wrapNodes>\n\n  // Overrideable core queries.\n\n  above: <T extends Ancestor>(\n    options?: EditorAboveOptions<T>\n  ) => NodeEntry<T> | undefined\n  after: OmitFirstArg<typeof Editor.after>\n  before: OmitFirstArg<typeof Editor.before>\n  edges: OmitFirstArg<typeof Editor.edges>\n  elementReadOnly: OmitFirstArg<typeof Editor.elementReadOnly>\n  end: OmitFirstArg<typeof Editor.end>\n  first: OmitFirstArg<typeof Editor.first>\n  fragment: OmitFirstArg<typeof Editor.fragment>\n  getMarks: OmitFirstArg<typeof Editor.marks>\n  hasBlocks: OmitFirstArg<typeof Editor.hasBlocks>\n  hasInlines: OmitFirstArg<typeof Editor.hasInlines>\n  hasPath: OmitFirstArg<typeof Editor.hasPath>\n  hasTexts: OmitFirstArg<typeof Editor.hasTexts>\n  isBlock: OmitFirstArg<typeof Editor.isBlock>\n  isEdge: OmitFirstArg<typeof Editor.isEdge>\n  isEmpty: OmitFirstArg<typeof Editor.isEmpty>\n  isEnd: OmitFirstArg<typeof Editor.isEnd>\n  isInline: OmitFirstArg<typeof Editor.isInline>\n  isNormalizing: OmitFirstArg<typeof Editor.isNormalizing>\n  isStart: OmitFirstArg<typeof Editor.isStart>\n  isVoid: OmitFirstArg<typeof Editor.isVoid>\n  last: OmitFirstArg<typeof Editor.last>\n  leaf: OmitFirstArg<typeof Editor.leaf>\n  levels: <T extends Node>(\n    options?: EditorLevelsOptions<T>\n  ) => Generator<NodeEntry<T>, void, undefined>\n  next: <T extends Descendant>(\n    options?: EditorNextOptions<T>\n  ) => NodeEntry<T> | undefined\n  node: OmitFirstArg<typeof Editor.node>\n  nodes: <T extends Node>(\n    options?: EditorNodesOptions<T>\n  ) => Generator<NodeEntry<T>, void, undefined>\n  parent: OmitFirstArg<typeof Editor.parent>\n  path: OmitFirstArg<typeof Editor.path>\n  pathRef: OmitFirstArg<typeof Editor.pathRef>\n  pathRefs: OmitFirstArg<typeof Editor.pathRefs>\n  point: OmitFirstArg<typeof Editor.point>\n  pointRef: OmitFirstArg<typeof Editor.pointRef>\n  pointRefs: OmitFirstArg<typeof Editor.pointRefs>\n  positions: OmitFirstArg<typeof Editor.positions>\n  previous: <T extends Node>(\n    options?: EditorPreviousOptions<T>\n  ) => NodeEntry<T> | undefined\n  range: OmitFirstArg<typeof Editor.range>\n  rangeRef: OmitFirstArg<typeof Editor.rangeRef>\n  rangeRefs: OmitFirstArg<typeof Editor.rangeRefs>\n  start: OmitFirstArg<typeof Editor.start>\n  string: OmitFirstArg<typeof Editor.string>\n  unhangRange: OmitFirstArg<typeof Editor.unhangRange>\n  void: OmitFirstArg<typeof Editor.void>\n  shouldMergeNodesRemovePrevNode: OmitFirstArg<\n    typeof Editor.shouldMergeNodesRemovePrevNode\n  >\n}\n\nexport type Editor = ExtendedType<'Editor', BaseEditor>\n\nexport type BaseSelection = Range | null\n\nexport type Selection = ExtendedType<'Selection', BaseSelection>\n\nexport type EditorMarks = Omit<Text, 'text'>\n\nexport interface EditorAboveOptions<T extends Ancestor> {\n  at?: Location\n  match?: NodeMatch<T>\n  mode?: MaximizeMode\n  voids?: boolean\n}\n\nexport interface EditorAfterOptions {\n  distance?: number\n  unit?: TextUnitAdjustment\n  voids?: boolean\n}\n\nexport interface EditorBeforeOptions {\n  distance?: number\n  unit?: TextUnitAdjustment\n  voids?: boolean\n}\n\nexport interface EditorDirectedDeletionOptions {\n  unit?: TextUnit\n}\n\nexport interface EditorElementReadOnlyOptions {\n  at?: Location\n  mode?: MaximizeMode\n  voids?: boolean\n}\n\nexport interface EditorFragmentDeletionOptions {\n  direction?: TextDirection\n}\n\nexport interface EditorIsEditorOptions {\n  deep?: boolean\n}\n\nexport interface EditorLeafOptions {\n  depth?: number\n  edge?: LeafEdge\n}\n\nexport interface EditorLevelsOptions<T extends Node> {\n  at?: Location\n  match?: NodeMatch<T>\n  reverse?: boolean\n  voids?: boolean\n}\n\nexport interface EditorNextOptions<T extends Descendant> {\n  at?: Location\n  match?: NodeMatch<T>\n  mode?: SelectionMode\n  voids?: boolean\n}\n\nexport interface EditorNodeOptions {\n  depth?: number\n  edge?: LeafEdge\n}\n\nexport interface EditorNodesOptions<T extends Node> {\n  at?: Location | Span\n  match?: NodeMatch<T>\n  mode?: SelectionMode\n  universal?: boolean\n  reverse?: boolean\n  voids?: boolean\n  pass?: (entry: NodeEntry) => boolean\n}\n\nexport interface EditorNormalizeOptions {\n  force?: boolean\n  operation?: Operation\n}\n\nexport interface EditorParentOptions {\n  depth?: number\n  edge?: LeafEdge\n}\n\nexport interface EditorPathOptions {\n  depth?: number\n  edge?: LeafEdge\n}\n\nexport interface EditorPathRefOptions {\n  affinity?: TextDirection | null\n}\n\nexport interface EditorPointOptions {\n  edge?: LeafEdge\n}\n\nexport interface EditorPointRefOptions {\n  affinity?: TextDirection | null\n}\n\nexport interface EditorPositionsOptions {\n  at?: Location\n  unit?: TextUnitAdjustment\n  reverse?: boolean\n  voids?: boolean\n}\n\nexport interface EditorPreviousOptions<T extends Node> {\n  at?: Location\n  match?: NodeMatch<T>\n  mode?: SelectionMode\n  voids?: boolean\n}\n\nexport interface EditorRangeRefOptions {\n  affinity?: RangeDirection | null\n}\n\nexport interface EditorStringOptions {\n  voids?: boolean\n}\n\nexport interface EditorUnhangRangeOptions {\n  voids?: boolean\n}\n\nexport interface EditorVoidOptions {\n  at?: Location\n  mode?: MaximizeMode\n  voids?: boolean\n}\n\nexport interface EditorInterface {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n  above: <T extends Ancestor>(\n    editor: Editor,\n    options?: EditorAboveOptions<T>\n  ) => NodeEntry<T> | undefined\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n  addMark: (editor: Editor, key: string, value: any) => void\n\n  /**\n   * Get the point after a location.\n   */\n  after: (\n    editor: Editor,\n    at: Location,\n    options?: EditorAfterOptions\n  ) => Point | undefined\n\n  /**\n   * Get the point before a location.\n   */\n  before: (\n    editor: Editor,\n    at: Location,\n    options?: EditorBeforeOptions\n  ) => Point | undefined\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n  deleteBackward: (\n    editor: Editor,\n    options?: EditorDirectedDeletionOptions\n  ) => void\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n  deleteForward: (\n    editor: Editor,\n    options?: EditorDirectedDeletionOptions\n  ) => void\n\n  /**\n   * Delete the content in the current selection.\n   */\n  deleteFragment: (\n    editor: Editor,\n    options?: EditorFragmentDeletionOptions\n  ) => void\n\n  /**\n   * Get the start and end points of a location.\n   */\n  edges: (editor: Editor, at: Location) => [Point, Point]\n\n  /**\n   * Match a read-only element in the current branch of the editor.\n   */\n  elementReadOnly: (\n    editor: Editor,\n    options?: EditorElementReadOnlyOptions\n  ) => NodeEntry<Element> | undefined\n\n  /**\n   * Get the end point of a location.\n   */\n  end: (editor: Editor, at: Location) => Point\n\n  /**\n   * Get the first node at a location.\n   */\n  first: (editor: Editor, at: Location) => NodeEntry\n\n  /**\n   * Get the fragment at a location.\n   */\n  fragment: (editor: Editor, at: Location) => Descendant[]\n\n  /**\n   * Check if a node has block children.\n   */\n  hasBlocks: (editor: Editor, element: Element) => boolean\n\n  /**\n   * Check if a node has inline and text children.\n   */\n  hasInlines: (editor: Editor, element: Element) => boolean\n\n  hasPath: (editor: Editor, path: Path) => boolean\n\n  /**\n   * Check if a node has text children.\n   */\n  hasTexts: (editor: Editor, element: Element) => boolean\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n  insertBreak: (editor: Editor) => void\n\n  /**\n   * Inserts a fragment\n   * at the specified location or (if not defined) the current selection or (if not defined) the end of the document.\n   */\n  insertFragment: (\n    editor: Editor,\n    fragment: Node[],\n    options?: TextInsertFragmentOptions\n  ) => void\n\n  /**\n   * Atomically inserts `nodes`\n   * at the specified location or (if not defined) the current selection or (if not defined) the end of the document.\n   */\n  insertNode: <T extends Node>(\n    editor: Editor,\n    node: Node,\n    options?: NodeInsertNodesOptions<T>\n  ) => void\n\n  /**\n   * Insert a soft break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n  insertSoftBreak: (editor: Editor) => void\n\n  /**\n   * Insert a string of text\n   * at the specified location or (if not defined) the current selection or (if not defined) the end of the document.\n   */\n  insertText: (\n    editor: Editor,\n    text: string,\n    options?: TextInsertTextOptions\n  ) => void\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n  isBlock: (editor: Editor, value: Element) => boolean\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n  isEdge: (editor: Editor, point: Point, at: Location) => boolean\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n  isEditor: (value: any, options?: EditorIsEditorOptions) => value is Editor\n\n  /**\n   * Check if a value is a read-only `Element` object.\n   */\n  isElementReadOnly: (editor: Editor, element: Element) => boolean\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n  isEmpty: (editor: Editor, element: Element) => boolean\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n  isEnd: (editor: Editor, point: Point, at: Location) => boolean\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n  isInline: (editor: Editor, value: Element) => boolean\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n  isNormalizing: (editor: Editor) => boolean\n\n  /**\n   * Check if a value is a selectable `Element` object.\n   */\n  isSelectable: (editor: Editor, element: Element) => boolean\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n  isStart: (editor: Editor, point: Point, at: Location) => boolean\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n  isVoid: (editor: Editor, value: Element) => boolean\n\n  /**\n   * Get the last node at a location.\n   */\n  last: (editor: Editor, at: Location) => NodeEntry\n\n  /**\n   * Get the leaf text node at a location.\n   */\n  leaf: (\n    editor: Editor,\n    at: Location,\n    options?: EditorLeafOptions\n  ) => NodeEntry<Text>\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n  levels: <T extends Node>(\n    editor: Editor,\n    options?: EditorLevelsOptions<T>\n  ) => Generator<NodeEntry<T>, void, undefined>\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n  marks: (editor: Editor) => Omit<Text, 'text'> | null\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n  next: <T extends Descendant>(\n    editor: Editor,\n    options?: EditorNextOptions<T>\n  ) => NodeEntry<T> | undefined\n\n  /**\n   * Get the node at a location.\n   */\n  node: (editor: Editor, at: Location, options?: EditorNodeOptions) => NodeEntry\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n  nodes: <T extends Node>(\n    editor: Editor,\n    options?: EditorNodesOptions<T>\n  ) => Generator<NodeEntry<T>, void, undefined>\n\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n  normalize: (editor: Editor, options?: EditorNormalizeOptions) => void\n\n  /**\n   * Get the parent node of a location.\n   */\n  parent: (\n    editor: Editor,\n    at: Location,\n    options?: EditorParentOptions\n  ) => NodeEntry<Ancestor>\n\n  /**\n   * Get the path of a location.\n   */\n  path: (editor: Editor, at: Location, options?: EditorPathOptions) => Path\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n  pathRef: (\n    editor: Editor,\n    path: Path,\n    options?: EditorPathRefOptions\n  ) => PathRef\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n  pathRefs: (editor: Editor) => Set<PathRef>\n\n  /**\n   * Get the start or end point of a location.\n   */\n  point: (editor: Editor, at: Location, options?: EditorPointOptions) => Point\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n  pointRef: (\n    editor: Editor,\n    point: Point,\n    options?: EditorPointRefOptions\n  ) => PointRef\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n  pointRefs: (editor: Editor) => Set<PointRef>\n\n  /**\n   * Return all the positions in `at` range where a `Point` can be placed.\n   *\n   * By default, moves forward by individual offsets at a time, but\n   * the `unit` option can be used to to move by character, word, line, or block.\n   *\n   * The `reverse` option can be used to change iteration direction.\n   *\n   * Note: By default void nodes are treated as a single point and iteration\n   * will not happen inside their content unless you pass in true for the\n   * `voids` option, then iteration will occur.\n   */\n  positions: (\n    editor: Editor,\n    options?: EditorPositionsOptions\n  ) => Generator<Point, void, undefined>\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n  previous: <T extends Node>(\n    editor: Editor,\n    options?: EditorPreviousOptions<T>\n  ) => NodeEntry<T> | undefined\n\n  /**\n   * Get a range of a location.\n   */\n  range: (editor: Editor, at: Location, to?: Location) => Range\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n  rangeRef: (\n    editor: Editor,\n    range: Range,\n    options?: EditorRangeRefOptions\n  ) => RangeRef\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n  rangeRefs: (editor: Editor) => Set<RangeRef>\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n  removeMark: (editor: Editor, key: string) => void\n\n  /**\n   * Manually set if the editor should currently be normalizing.\n   *\n   * Note: Using this incorrectly can leave the editor in an invalid state.\n   *\n   */\n  setNormalizing: (editor: Editor, isNormalizing: boolean) => void\n\n  /**\n   * Get the start point of a location.\n   */\n  start: (editor: Editor, at: Location) => Point\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: by default the text of void nodes is considered to be an empty\n   * string, regardless of content, unless you pass in true for the voids option\n   */\n  string: (\n    editor: Editor,\n    at: Location,\n    options?: EditorStringOptions\n  ) => string\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n  unhangRange: (\n    editor: Editor,\n    range: Range,\n    options?: EditorUnhangRangeOptions\n  ) => Range\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n  void: (\n    editor: Editor,\n    options?: EditorVoidOptions\n  ) => NodeEntry<Element> | undefined\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n  withoutNormalizing: (editor: Editor, fn: () => void) => void\n\n  /**\n   *  Call a function, Determine whether or not remove the previous node when merge.\n   */\n  shouldMergeNodesRemovePrevNode: (\n    editor: Editor,\n    prevNodeEntry: NodeEntry,\n    curNodeEntry: NodeEntry\n  ) => boolean\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Editor: EditorInterface = {\n  above(editor, options) {\n    return editor.above(options)\n  },\n\n  addMark(editor, key, value) {\n    editor.addMark(key, value)\n  },\n\n  after(editor, at, options) {\n    return editor.after(at, options)\n  },\n\n  before(editor, at, options) {\n    return editor.before(at, options)\n  },\n\n  deleteBackward(editor, options = {}) {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  deleteForward(editor, options = {}) {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  deleteFragment(editor, options) {\n    editor.deleteFragment(options)\n  },\n\n  edges(editor, at) {\n    return editor.edges(at)\n  },\n\n  elementReadOnly(editor: Editor, options: EditorElementReadOnlyOptions = {}) {\n    return editor.elementReadOnly(options)\n  },\n\n  end(editor, at) {\n    return editor.end(at)\n  },\n\n  first(editor, at) {\n    return editor.first(at)\n  },\n\n  fragment(editor, at) {\n    return editor.fragment(at)\n  },\n\n  hasBlocks(editor, element) {\n    return editor.hasBlocks(element)\n  },\n\n  hasInlines(editor, element) {\n    return editor.hasInlines(element)\n  },\n\n  hasPath(editor, path) {\n    return editor.hasPath(path)\n  },\n\n  hasTexts(editor, element) {\n    return editor.hasTexts(element)\n  },\n\n  insertBreak(editor) {\n    editor.insertBreak()\n  },\n\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options)\n  },\n\n  insertNode(editor, node) {\n    editor.insertNode(node)\n  },\n\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak()\n  },\n\n  insertText(editor, text) {\n    editor.insertText(text)\n  },\n\n  isBlock(editor, value) {\n    return editor.isBlock(value)\n  },\n\n  isEdge(editor, point, at) {\n    return editor.isEdge(point, at)\n  },\n\n  isEditor(value: any): value is Editor {\n    return isEditor(value)\n  },\n\n  isElementReadOnly(editor, element) {\n    return editor.isElementReadOnly(element)\n  },\n\n  isEmpty(editor, element) {\n    return editor.isEmpty(element)\n  },\n\n  isEnd(editor, point, at) {\n    return editor.isEnd(point, at)\n  },\n\n  isInline(editor, value) {\n    return editor.isInline(value)\n  },\n\n  isNormalizing(editor) {\n    return editor.isNormalizing()\n  },\n\n  isSelectable(editor: Editor, value: Element) {\n    return editor.isSelectable(value)\n  },\n\n  isStart(editor, point, at) {\n    return editor.isStart(point, at)\n  },\n\n  isVoid(editor, value) {\n    return editor.isVoid(value)\n  },\n\n  last(editor, at) {\n    return editor.last(at)\n  },\n\n  leaf(editor, at, options) {\n    return editor.leaf(at, options)\n  },\n\n  levels(editor, options) {\n    return editor.levels(options)\n  },\n\n  marks(editor) {\n    return editor.getMarks()\n  },\n\n  next<T extends Descendant>(\n    editor: Editor,\n    options?: EditorNextOptions<T>\n  ): NodeEntry<T> | undefined {\n    return editor.next(options)\n  },\n\n  node(editor, at, options) {\n    return editor.node(at, options)\n  },\n\n  nodes(editor, options) {\n    return editor.nodes(options)\n  },\n\n  normalize(editor, options) {\n    editor.normalize(options)\n  },\n\n  parent(editor, at, options) {\n    return editor.parent(at, options)\n  },\n\n  path(editor, at, options) {\n    return editor.path(at, options)\n  },\n\n  pathRef(editor, path, options) {\n    return editor.pathRef(path, options)\n  },\n\n  pathRefs(editor) {\n    return editor.pathRefs()\n  },\n\n  point(editor, at, options) {\n    return editor.point(at, options)\n  },\n\n  pointRef(editor, point, options) {\n    return editor.pointRef(point, options)\n  },\n\n  pointRefs(editor) {\n    return editor.pointRefs()\n  },\n\n  positions(editor, options) {\n    return editor.positions(options)\n  },\n\n  previous(editor, options) {\n    return editor.previous(options)\n  },\n\n  range(editor, at, to) {\n    return editor.range(at, to)\n  },\n\n  rangeRef(editor, range, options) {\n    return editor.rangeRef(range, options)\n  },\n\n  rangeRefs(editor) {\n    return editor.rangeRefs()\n  },\n\n  removeMark(editor, key) {\n    editor.removeMark(key)\n  },\n\n  setNormalizing(editor, isNormalizing) {\n    editor.setNormalizing(isNormalizing)\n  },\n\n  start(editor, at) {\n    return editor.start(at)\n  },\n\n  string(editor, at, options) {\n    return editor.string(at, options)\n  },\n\n  unhangRange(editor, range, options) {\n    return editor.unhangRange(range, options)\n  },\n\n  void(editor, options) {\n    return editor.void(options)\n  },\n\n  withoutNormalizing(editor, fn: () => void) {\n    editor.withoutNormalizing(fn)\n  },\n  shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode) => {\n    return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\nexport type NodeMatch<T extends Node> =\n  | ((node: Node, path: Path) => node is T)\n  | ((node: Node, path: Path) => boolean)\n\nexport type PropsCompare = (prop: Partial<Node>, node: Partial<Node>) => boolean\nexport type PropsMerge = (prop: Partial<Node>, node: Partial<Node>) => object\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport interface LocationInterface {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n  isLocation: (value: any) => value is Location\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Location: LocationInterface = {\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport interface SpanInterface {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n  isSpan: (value: any) => value is Span\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Span: SpanInterface = {\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { ExtendedType, Operation, Path, isObject } from '..'\nimport { TextDirection } from '../types/types'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface BasePoint {\n  path: Path\n  offset: number\n}\n\nexport type Point = ExtendedType<'Point', BasePoint>\n\nexport interface PointTransformOptions {\n  affinity?: TextDirection | null\n}\n\nexport interface PointInterface {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n  compare: (point: Point, another: Point) => -1 | 0 | 1\n\n  /**\n   * Check if a point is after another.\n   */\n  isAfter: (point: Point, another: Point) => boolean\n\n  /**\n   * Check if a point is before another.\n   */\n  isBefore: (point: Point, another: Point) => boolean\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n  equals: (point: Point, another: Point) => boolean\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n  isPoint: (value: any) => value is Point\n\n  /**\n   * Transform a point by an operation.\n   */\n  transform: (\n    point: Point,\n    op: Operation,\n    options?: PointTransformOptions\n  ) => Point | null\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Point: PointInterface = {\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  isPoint(value: any): value is Point {\n    return (\n      isObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  transform(\n    point: Point | null,\n    op: Operation,\n    options: PointTransformOptions = {}\n  ): Point | null {\n    if (point === null) {\n      return null\n    }\n\n    const { affinity = 'forward' } = options\n    let { path, offset } = point\n\n    switch (op.type) {\n      case 'insert_node':\n      case 'move_node': {\n        path = Path.transform(path, op, options)!\n        break\n      }\n\n      case 'insert_text': {\n        if (\n          Path.equals(op.path, path) &&\n          (op.offset < offset ||\n            (op.offset === offset && affinity === 'forward'))\n        ) {\n          offset += op.text.length\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        if (Path.equals(op.path, path)) {\n          offset += op.position\n        }\n\n        path = Path.transform(path, op, options)!\n        break\n      }\n\n      case 'remove_text': {\n        if (Path.equals(op.path, path) && op.offset <= offset) {\n          offset -= Math.min(offset - op.offset, op.text.length)\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n          return null\n        }\n\n        path = Path.transform(path, op, options)!\n        break\n      }\n\n      case 'split_node': {\n        if (Path.equals(op.path, path)) {\n          if (op.position === offset && affinity == null) {\n            return null\n          } else if (\n            op.position < offset ||\n            (op.position === offset && affinity === 'forward')\n          ) {\n            offset -= op.position\n\n            path = Path.transform(path, op, {\n              ...options,\n              affinity: 'forward',\n            })!\n          }\n        } else {\n          path = Path.transform(path, op, options)!\n        }\n\n        break\n      }\n\n      default:\n        return point\n    }\n\n    return { path, offset }\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","export type Scrubber = (key: string, value: unknown) => unknown\n\nexport interface ScrubberInterface {\n  setScrubber(scrubber: Scrubber | undefined): void\n  stringify(value: any): string\n}\n\nlet _scrubber: Scrubber | undefined = undefined\n\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */\n// eslint-disable-next-line no-redeclare\nexport const Scrubber: ScrubberInterface = {\n  setScrubber(scrubber: Scrubber | undefined): void {\n    _scrubber = scrubber\n  },\n\n  stringify(value: any): string {\n    return JSON.stringify(value, _scrubber)\n  },\n}\n","import { Range, isObject } from '..'\nimport { ExtendedType } from '../types/custom-types'\nimport { isDeepEqual } from '../utils/deep-equal'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface BaseText {\n  text: string\n}\n\nexport type Text = ExtendedType<'Text', BaseText>\n\nexport interface LeafPosition {\n  start: number\n  end: number\n  isFirst?: true\n  isLast?: true\n}\n\nexport interface TextEqualsOptions {\n  loose?: boolean\n}\n\nexport type DecoratedRange = Range & {\n  /**\n   * Customize how another decoration is merged into a text node. If not specified, `Object.assign` would be used.\n   * It is useful for overlapping decorations with the same key but different values.\n   */\n  merge?: (leaf: Text, decoration: object) => void\n}\n\nexport interface TextInterface {\n  /**\n   * Check if two text nodes are equal.\n   *\n   * When loose is set, the text is not compared. This is\n   * used to check whether sibling text nodes can be merged.\n   */\n  equals: (text: Text, another: Text, options?: TextEqualsOptions) => boolean\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n  isText: (value: any) => value is Text\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n  isTextList: (value: any) => value is Text[]\n\n  /**\n   * Check if some props are a partial of Text.\n   */\n  isTextProps: (props: any) => props is Partial<Text>\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n  matches: (text: Text, props: Partial<Text>) => boolean\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n  decorations: (\n    node: Text,\n    decorations: DecoratedRange[]\n  ) => { leaf: Text; position?: LeafPosition }[]\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Text: TextInterface = {\n  equals(text: Text, another: Text, options: TextEqualsOptions = {}): boolean {\n    const { loose = false } = options\n\n    function omitText(obj: Record<any, any>) {\n      const { text, ...rest } = obj\n\n      return rest\n    }\n\n    return isDeepEqual(\n      loose ? omitText(text) : text,\n      loose ? omitText(another) : another\n    )\n  },\n\n  isText(value: any): value is Text {\n    return isObject(value) && typeof value.text === 'string'\n  },\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && value.every(val => Text.isText(val))\n  },\n\n  isTextProps(props: any): props is Partial<Text> {\n    return (props as Partial<Text>).text !== undefined\n  },\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (\n        !text.hasOwnProperty(key) ||\n        text[<keyof Text>key] !== props[<keyof Text>key]\n      ) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  decorations(\n    node: Text,\n    decorations: DecoratedRange[]\n  ): { leaf: Text; position?: LeafPosition }[] {\n    let leaves: { leaf: Text; position?: LeafPosition }[] = [\n      { leaf: { ...node } },\n    ]\n\n    for (const dec of decorations) {\n      const { anchor, focus, merge: mergeDecoration, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let leafEnd = 0\n      const decorationStart = start.offset\n      const decorationEnd = end.offset\n      const merge = mergeDecoration ?? Object.assign\n\n      for (const { leaf } of leaves) {\n        const { length } = leaf.text\n        const leafStart = leafEnd\n        leafEnd += length\n\n        // If the range encompasses the entire leaf, add the range.\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          merge(leaf, rest)\n          next.push({ leaf })\n          continue\n        }\n\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (\n          (decorationStart !== decorationEnd &&\n            (decorationStart === leafEnd || decorationEnd === leafStart)) ||\n          decorationStart > leafEnd ||\n          decorationEnd < leafStart ||\n          (decorationEnd === leafStart && leafStart !== 0)\n        ) {\n          next.push({ leaf })\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (decorationEnd < leafEnd) {\n          const off = decorationEnd - leafStart\n          after = { leaf: { ...middle, text: middle.text.slice(off) } }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (decorationStart > leafStart) {\n          const off = decorationStart - leafStart\n          before = { leaf: { ...middle, text: middle.text.slice(0, off) } }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        merge(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push({ leaf: middle })\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    if (leaves.length > 1) {\n      let currentOffset = 0\n      for (const [index, item] of leaves.entries()) {\n        const start = currentOffset\n        const end = start + item.leaf.text.length\n        const position: LeafPosition = { start, end }\n\n        if (index === 0) position.isFirst = true\n        if (index === leaves.length - 1) position.isLast = true\n\n        item.position = position\n        currentOffset = end\n      }\n    }\n\n    return leaves\n  },\n}\n","import { Editor, Location } from '../interfaces'\n\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */\nexport const getDefaultInsertLocation = (editor: Editor): Location => {\n  if (editor.selection) {\n    return editor.selection\n  } else if (editor.children.length > 0) {\n    return Editor.end(editor, [])\n  } else {\n    return [0]\n  }\n}\n","import { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { Node } from '../interfaces/node'\n\nexport const matchPath = (\n  editor: Editor,\n  path: Path\n): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (str: string, isRTL = false): number => {\n  const isLTR = !isRTL\n  const codepoints = isRTL ? codepointsIteratorRTL(str) : str\n\n  let left: CodepointType = CodepointType.None\n  let right: CodepointType = CodepointType.None\n  let distance = 0\n  // Evaluation of these conditions are deferred.\n  let gb11: boolean | null = null // Is GB11 applicable?\n  let gb12Or13: boolean | null = null // Is GB12 or GB13 applicable?\n\n  for (const char of codepoints) {\n    const code = char.codePointAt(0)\n    if (!code) break\n\n    const type = getCodepointType(char, code)\n    ;[left, right] = isLTR ? [right, type] : [type, left]\n\n    if (\n      intersects(left, CodepointType.ZWJ) &&\n      intersects(right, CodepointType.ExtPict)\n    ) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance))\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance))\n      }\n      if (!gb11) break\n    }\n\n    if (\n      intersects(left, CodepointType.RI) &&\n      intersects(right, CodepointType.RI)\n    ) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13\n      } else {\n        if (isLTR) {\n          gb12Or13 = true\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(\n            str.substring(0, str.length - distance)\n          )\n        }\n      }\n      if (!gb12Or13) break\n    }\n\n    if (\n      left !== CodepointType.None &&\n      right !== CodepointType.None &&\n      isBoundaryPair(left, right)\n    ) {\n      break\n    }\n\n    distance += char.length\n  }\n\n  return distance || 1\n}\n\nconst SPACE = /\\s/\nconst PUNCTUATION =\n  /[\\u002B\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string, isRTL = false): number => {\n  let dist = 0\n  let started = false\n\n  while (text.length > 0) {\n    const charDist = getCharacterDistance(text, isRTL)\n    const [char, remaining] = splitByCharacterDistance(text, charDist, isRTL)\n\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true\n      dist += charDist\n    } else if (!started) {\n      dist += charDist\n    } else {\n      break\n    }\n\n    text = remaining\n  }\n\n  return dist\n}\n\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */\n\nexport const splitByCharacterDistance = (\n  str: string,\n  dist: number,\n  isRTL?: boolean\n): [string, string] => {\n  if (isRTL) {\n    const at = str.length - dist\n    return [str.slice(at, str.length), str.slice(0, at)]\n  }\n\n  return [str.slice(0, dist), str.slice(dist)]\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (\n  char: string,\n  remaining: string,\n  isRTL = false\n): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    const charDist = getCharacterDistance(remaining, isRTL)\n    const [nextChar, nextRemaining] = splitByCharacterDistance(\n      remaining,\n      charDist,\n      isRTL\n    )\n\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Iterate on codepoints from right to left.\n */\n\nexport const codepointsIteratorRTL = function* (str: string) {\n  const end = str.length - 1\n\n  for (let i = 0; i < str.length; i++) {\n    const char1 = str.charAt(end - i)\n\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      const char2 = str.charAt(end - i - 1)\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1\n\n        i++\n        continue\n      }\n    }\n\n    yield char1\n  }\n}\n\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\n\nconst isHighSurrogate = (charCode: number) => {\n  return charCode >= 0xd800 && charCode <= 0xdbff\n}\n\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\n\nconst isLowSurrogate = (charCode: number) => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff\n}\n\nenum CodepointType {\n  None = 0,\n  Extend = 1 << 0,\n  ZWJ = 1 << 1,\n  RI = 1 << 2,\n  Prepend = 1 << 3,\n  SpacingMark = 1 << 4,\n  L = 1 << 5,\n  V = 1 << 6,\n  T = 1 << 7,\n  LV = 1 << 8,\n  LVT = 1 << 9,\n  ExtPict = 1 << 10,\n  Any = 1 << 11,\n}\n\nconst reExtend = /^[\\p{Gr_Ext}\\p{EMod}]$/u\nconst rePrepend =\n  /^[\\u0600-\\u0605\\u06DD\\u070F\\u0890-\\u0891\\u08E2\\u0D4E\\u{110BD}\\u{110CD}\\u{111C2}-\\u{111C3}\\u{1193F}\\u{11941}\\u{11A3A}\\u{11A84}-\\u{11A89}\\u{11D46}]$/u\nconst reSpacingMark =\n  /^[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BF-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC1\\u0CC3-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0D02-\\u0D03\\u0D3F-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82-\\u0D83\\u0DD0-\\u0DD1\\u0DD8-\\u0DDE\\u0DF2-\\u0DF3\\u0E33\\u0EB3\\u0F3E-\\u0F3F\\u0F7F\\u1031\\u103B-\\u103C\\u1056-\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43-\\u1B44\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2-\\u1BF3\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CE1\\u1CF7\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952-\\uA953\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BE-\\uA9C0\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\uABEC\\u{11000}\\u{11002}\\u{11082}\\u{110B0}-\\u{110B2}\\u{110B7}-\\u{110B8}\\u{1112C}\\u{11145}-\\u{11146}\\u{11182}\\u{111B3}-\\u{111B5}\\u{111BF}-\\u{111C0}\\u{111CE}\\u{1122C}-\\u{1122E}\\u{11232}-\\u{11233}\\u{11235}\\u{112E0}-\\u{112E2}\\u{11302}-\\u{11303}\\u{1133F}\\u{11341}-\\u{11344}\\u{11347}-\\u{11348}\\u{1134B}-\\u{1134D}\\u{11362}-\\u{11363}\\u{11435}-\\u{11437}\\u{11440}-\\u{11441}\\u{11445}\\u{114B1}-\\u{114B2}\\u{114B9}\\u{114BB}-\\u{114BC}\\u{114BE}\\u{114C1}\\u{115B0}-\\u{115B1}\\u{115B8}-\\u{115BB}\\u{115BE}\\u{11630}-\\u{11632}\\u{1163B}-\\u{1163C}\\u{1163E}\\u{116AC}\\u{116AE}-\\u{116AF}\\u{116B6}\\u{11726}\\u{1182C}-\\u{1182E}\\u{11838}\\u{11931}-\\u{11935}\\u{11937}-\\u{11938}\\u{1193D}\\u{11940}\\u{11942}\\u{119D1}-\\u{119D3}\\u{119DC}-\\u{119DF}\\u{119E4}\\u{11A39}\\u{11A57}-\\u{11A58}\\u{11A97}\\u{11C2F}\\u{11C3E}\\u{11CA9}\\u{11CB1}\\u{11CB4}\\u{11D8A}-\\u{11D8E}\\u{11D93}-\\u{11D94}\\u{11D96}\\u{11EF5}-\\u{11EF6}\\u{16F51}-\\u{16F87}\\u{16FF0}-\\u{16FF1}\\u{1D166}\\u{1D16D}]$/u\nconst reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/u\nconst reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/u\nconst reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/u\nconst reLV =\n  /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/u\nconst reLVT =\n  /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/u\nconst reExtPict = /^\\p{ExtPict}$/u\n\nconst getCodepointType = (char: string, code: number): CodepointType => {\n  let type = CodepointType.Any\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend\n  }\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ\n  }\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI\n  }\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend\n  }\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark\n  }\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L\n  }\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V\n  }\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T\n  }\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV\n  }\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT\n  }\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict\n  }\n\n  return type\n}\n\nfunction intersects(x: CodepointType, y: CodepointType) {\n  return (x & y) !== 0\n}\n\nconst NonBoundaryPairs: [CodepointType, CodepointType][] = [\n  // GB6\n  [\n    CodepointType.L,\n    CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT,\n  ],\n  // GB7\n  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],\n  // GB8\n  [CodepointType.LVT | CodepointType.T, CodepointType.T],\n  // GB9\n  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],\n  // GB9a\n  [CodepointType.Any, CodepointType.SpacingMark],\n  // GB9b\n  [CodepointType.Prepend, CodepointType.Any],\n  // GB11\n  [CodepointType.ZWJ, CodepointType.ExtPict],\n  // GB12 and GB13\n  [CodepointType.RI, CodepointType.RI],\n]\n\nfunction isBoundaryPair(left: CodepointType, right: CodepointType) {\n  return (\n    NonBoundaryPairs.findIndex(\n      r => intersects(left, r[0]) && intersects(right, r[1])\n    ) === -1\n  )\n}\n\nconst endingEmojiZWJ = /\\p{ExtPict}[\\p{Gr_Ext}\\p{EMod}]*\\u200D$/u\nconst endsWithEmojiZWJ = (str: string): boolean => {\n  return str.search(endingEmojiZWJ) !== -1\n}\n\nconst endingRIs = /\\p{RI}+$/gu\nconst endsWithOddNumberOfRIs = (str: string): boolean => {\n  const match = str.match(endingRIs)\n  if (match === null) {\n    return false\n  } else {\n    // A RI is represented by a surrogate pair.\n    const numRIs = match[0].length / 2\n    return numRIs % 2 === 1\n  }\n}\n","import { Editor, Location, Node, Path, Range, Transforms } from '../../index'\nimport { TextUnit } from '../../types/types'\nimport { getDefaultInsertLocation } from '../../utils'\n\nexport interface TextDeleteOptions {\n  at?: Location\n  distance?: number\n  unit?: TextUnit\n  reverse?: boolean\n  hanging?: boolean\n  voids?: boolean\n}\n\nexport interface TextInsertFragmentOptions {\n  at?: Location\n  hanging?: boolean\n  voids?: boolean\n  batchDirty?: boolean\n}\n\nexport interface TextInsertTextOptions {\n  at?: Location\n  voids?: boolean\n}\n\nexport interface TextTransforms {\n  /**\n   * Delete content in the editor.\n   */\n  delete: (editor: Editor, options?: TextDeleteOptions) => void\n\n  /**\n   * Insert a fragment in the editor\n   * at the specified location or (if not defined) the current selection or (if not defined) the end of the document.\n   */\n  insertFragment: (\n    editor: Editor,\n    fragment: Node[],\n    options?: TextInsertFragmentOptions\n  ) => void\n\n  /**\n   * Insert a string of text in the editor\n   * at the specified location or (if not defined) the current selection or (if not defined) the end of the document.\n   */\n  insertText: (\n    editor: Editor,\n    text: string,\n    options?: TextInsertTextOptions\n  ) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const TextTransforms: TextTransforms = {\n  delete(editor, options) {\n    editor.delete(options)\n  },\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options)\n  },\n  insertText(\n    editor: Editor,\n    text: string,\n    options: TextInsertTextOptions = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = getDefaultInsertLocation(editor) } = options\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n          const start = Range.start(at)\n          const startRef = Editor.pointRef(editor, start)\n          const endRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          const startPoint = startRef.unref()\n          const endPoint = endRef.unref()\n\n          at = startPoint || endPoint!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (\n        (!voids && Editor.void(editor, { at })) ||\n        Editor.elementReadOnly(editor, { at })\n      ) {\n        return\n      }\n\n      const { path, offset } = at\n      if (text.length > 0)\n        editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms: GeneralTransforms &\n  NodeTransforms &\n  SelectionTransforms &\n  TextTransforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n","// perf\n\nimport { Editor } from '../interfaces/editor'\n\nconst BATCHING_DIRTY_PATHS: WeakMap<Editor, boolean> = new WeakMap()\n\nexport const isBatchingDirtyPaths = (editor: Editor) => {\n  return BATCHING_DIRTY_PATHS.get(editor) || false\n}\n\nexport const batchDirtyPaths = (\n  editor: Editor,\n  fn: () => void,\n  update: () => void\n) => {\n  const value = BATCHING_DIRTY_PATHS.get(editor) || false\n  BATCHING_DIRTY_PATHS.set(editor, true)\n  try {\n    fn()\n    update()\n  } finally {\n    BATCHING_DIRTY_PATHS.set(editor, value)\n  }\n}\n","import { DIRTY_PATH_KEYS, DIRTY_PATHS } from '../utils/weak-maps'\nimport { Path } from '../interfaces/path'\nimport { Editor } from '../interfaces/editor'\n\n/**\n * update editor dirty paths\n *\n * @param newDirtyPaths: Path[]; new dirty paths\n * @param transform: (p: Path) => Path | null; how to transform existing dirty paths\n */\nexport function updateDirtyPaths(\n  editor: Editor,\n  newDirtyPaths: Path[],\n  transform?: (p: Path) => Path | null\n) {\n  const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n  const oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set()\n  let dirtyPaths: Path[]\n  let dirtyPathKeys: Set<string>\n\n  const add = (path: Path | null) => {\n    if (path) {\n      const key = path.join(',')\n\n      if (!dirtyPathKeys.has(key)) {\n        dirtyPathKeys.add(key)\n        dirtyPaths.push(path)\n      }\n    }\n  }\n\n  if (transform) {\n    dirtyPaths = []\n    dirtyPathKeys = new Set()\n    for (const path of oldDirtyPaths) {\n      const newPath = transform(path)\n      add(newPath)\n    }\n  } else {\n    dirtyPaths = oldDirtyPaths\n    dirtyPathKeys = oldDirtyPathKeys\n  }\n\n  for (const path of newDirtyPaths) {\n    add(path)\n  }\n\n  DIRTY_PATHS.set(editor, dirtyPaths)\n  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys)\n}\n","import { PathRef } from '../interfaces/path-ref'\nimport { PointRef } from '../interfaces/point-ref'\nimport { RangeRef } from '../interfaces/range-ref'\nimport { FLUSHING } from '../utils/weak-maps'\nimport { Path } from '../interfaces/path'\nimport { Transforms } from '../interfaces/transforms'\nimport { WithEditorFirstArg } from '../utils/types'\nimport { Editor } from '../interfaces/editor'\nimport { isBatchingDirtyPaths } from './batch-dirty-paths'\nimport { updateDirtyPaths } from './update-dirty-paths'\n\nexport const apply: WithEditorFirstArg<Editor['apply']> = (editor, op) => {\n  for (const ref of Editor.pathRefs(editor)) {\n    PathRef.transform(ref, op)\n  }\n\n  for (const ref of Editor.pointRefs(editor)) {\n    PointRef.transform(ref, op)\n  }\n\n  for (const ref of Editor.rangeRefs(editor)) {\n    RangeRef.transform(ref, op)\n  }\n\n  // update dirty paths\n  if (!isBatchingDirtyPaths(editor)) {\n    const transform = Path.operationCanTransformPath(op)\n      ? (p: Path) => Path.transform(p, op)\n      : undefined\n    updateDirtyPaths(editor, editor.getDirtyPaths(op), transform)\n  }\n\n  Transforms.transform(editor, op)\n  editor.operations.push(op)\n  Editor.normalize(editor, {\n    operation: op,\n  })\n\n  // Clear any formats applied to the cursor if the selection changes.\n  if (op.type === 'set_selection') {\n    editor.marks = null\n  }\n\n  if (!FLUSHING.get(editor)) {\n    FLUSHING.set(editor, true)\n\n    Promise.resolve().then(() => {\n      FLUSHING.set(editor, false)\n      editor.onChange({ operation: op })\n      editor.operations = []\n    })\n  }\n}\n","import { WithEditorFirstArg } from '../utils/types'\nimport { Path } from '../interfaces/path'\nimport { Text } from '../interfaces/text'\nimport { Node } from '../interfaces/node'\nimport { Editor } from '../interfaces/editor'\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\nexport const getDirtyPaths: WithEditorFirstArg<Editor['getDirtyPaths']> = (\n  editor,\n  op\n) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      const newParent = newAncestors[newAncestors.length - 1]\n      const newIndex = newPath[newPath.length - 1]\n      const resultPath = newParent.concat(newIndex)\n\n      return [...oldAncestors, ...newAncestors, resultPath]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","import { Editor, Node } from '../interfaces'\nimport { WithEditorFirstArg } from '../utils'\n\nexport const getFragment: WithEditorFirstArg<\n  Editor['getFragment']\n> = editor => {\n  const { selection } = editor\n\n  if (selection) {\n    return Node.fragment(editor, selection)\n  }\n  return []\n}\n","import { WithEditorFirstArg } from '../utils/types'\nimport { Text } from '../interfaces/text'\nimport { Element } from '../interfaces/element'\nimport { Transforms } from '../interfaces/transforms'\nimport { Descendant, Node } from '../interfaces/node'\nimport { Editor } from '../interfaces/editor'\n\nexport const normalizeNode: WithEditorFirstArg<Editor['normalizeNode']> = (\n  editor,\n  entry,\n  options\n) => {\n  const [node, path] = entry\n\n  // There are no core normalizations for text nodes.\n  if (Text.isText(node)) {\n    return\n  }\n\n  // Ensure that block and inline nodes have at least one text child.\n  if (Element.isElement(node) && node.children.length === 0) {\n    const child = { text: '' }\n    Transforms.insertNodes(editor, child, {\n      at: path.concat(0),\n      voids: true,\n    })\n    return\n  }\n\n  // Determine whether the node should have block or inline children.\n  const shouldHaveInlines = Editor.isEditor(node)\n    ? false\n    : Element.isElement(node) &&\n      (editor.isInline(node) ||\n        node.children.length === 0 ||\n        Text.isText(node.children[0]) ||\n        editor.isInline(node.children[0]))\n\n  // Since we'll be applying operations while iterating, keep track of an\n  // index that accounts for any added/removed nodes.\n  let n = 0\n\n  for (let i = 0; i < node.children.length; i++, n++) {\n    const currentNode = Node.get(editor, path)\n    if (Text.isText(currentNode)) continue\n    const child = currentNode.children[n] as Descendant\n    const prev = currentNode.children[n - 1] as Descendant\n    const isLast = i === node.children.length - 1\n    const isInlineOrText =\n      Text.isText(child) || (Element.isElement(child) && editor.isInline(child))\n\n    // Only allow block nodes in the top-level children and parent blocks\n    // that only contain block nodes. Similarly, only allow inline nodes in\n    // other inline nodes, or parent blocks that only contain inlines and\n    // text.\n    if (isInlineOrText !== shouldHaveInlines) {\n      if (isInlineOrText) {\n        if (options?.fallbackElement) {\n          Transforms.wrapNodes(editor, options.fallbackElement(), {\n            at: path.concat(n),\n            voids: true,\n          })\n        } else {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n        }\n      } else {\n        Transforms.unwrapNodes(editor, { at: path.concat(n), voids: true })\n      }\n      n--\n    } else if (Element.isElement(child)) {\n      // Ensure that inline nodes are surrounded by text nodes.\n      if (editor.isInline(child)) {\n        if (prev == null || !Text.isText(prev)) {\n          const newChild = { text: '' }\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n),\n            voids: true,\n          })\n          n++\n        } else if (isLast) {\n          const newChild = { text: '' }\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n + 1),\n            voids: true,\n          })\n          n++\n        }\n      }\n    } else {\n      // If the child is not a text node, and doesn't have a `children` field,\n      // then we have an invalid node that will upset slate.\n      //\n      // eg: `{ type: 'some_node' }`.\n      //\n      // To prevent slate from breaking, we can add the `children` field,\n      // and now that it is valid, we can to many more operations easily,\n      // such as extend normalizers to fix erronous structure.\n      if (!Text.isText(child) && !('children' in child)) {\n        const elementChild = child as Element\n        elementChild.children = []\n      }\n\n      // Merge adjacent text nodes that are empty or match.\n      if (prev != null && Text.isText(prev)) {\n        if (Text.equals(child, prev, { loose: true })) {\n          Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (prev.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n - 1),\n            voids: true,\n          })\n          n--\n        } else if (child.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true,\n          })\n          n--\n        }\n      }\n    }\n  }\n}\n","import { WithEditorFirstArg } from '../utils/types'\nimport { Editor } from '../interfaces/editor'\n\nexport const shouldNormalize: WithEditorFirstArg<Editor['shouldNormalize']> = (\n  editor,\n  { iteration, initialDirtyPathsLength }\n) => {\n  const maxIterations = initialDirtyPathsLength * 42 // HACK: better way?\n\n  if (iteration > maxIterations) {\n    throw new Error(\n      `Could not completely normalize the editor after ${maxIterations} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.`\n    )\n  }\n\n  return true\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Range } from '../interfaces'\nimport { Path } from '../interfaces/path'\n\nexport const above: EditorInterface['above'] = (editor, options = {}) => {\n  const {\n    voids = false,\n    mode = 'lowest',\n    at = editor.selection,\n    match,\n  } = options\n\n  if (!at) {\n    return\n  }\n\n  let path = Editor.path(editor, at)\n\n  // If `at` is a Range that spans mulitple nodes, `path` will be their common ancestor.\n  // Otherwise `path` will be a text node and/or the same as `at`, in which cases we want to start with its parent.\n  if (!Range.isRange(at) || Path.equals(at.focus.path, at.anchor.path)) {\n    if (path.length === 0) return\n    path = Path.parent(path)\n  }\n\n  const reverse = mode === 'lowest'\n\n  const [firstMatch] = Editor.levels(editor, {\n    at: path,\n    voids,\n    match,\n    reverse,\n  })\n  return firstMatch // if nothing matches this returns undefined\n}\n","import { Node } from '../interfaces/node'\nimport { Path } from '../interfaces/path'\nimport { Text } from '../interfaces/text'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\nimport { FLUSHING } from '../utils/weak-maps'\nimport { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const addMark: EditorInterface['addMark'] = (editor, key, value) => {\n  const { selection } = editor\n\n  if (selection) {\n    const match = (node: Node, path: Path) => {\n      if (!Text.isText(node)) {\n        return false // marks can only be applied to text\n      }\n      const [parentNode, parentPath] = Editor.parent(editor, path)\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode)\n    }\n    const expandedSelection = Range.isExpanded(selection)\n    let markAcceptingVoidSelected = false\n    if (!expandedSelection) {\n      const [selectedNode, selectedPath] = Editor.node(editor, selection)\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const [parentNode] = Editor.parent(editor, selectedPath)\n        markAcceptingVoidSelected =\n          parentNode && editor.markableVoid(parentNode)\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.setNodes(\n        editor,\n        { [key]: value },\n        {\n          match,\n          split: true,\n          voids: true,\n        }\n      )\n    } else {\n      const marks = {\n        ...(Editor.marks(editor) || {}),\n        [key]: value,\n      }\n\n      editor.marks = marks\n      if (!FLUSHING.get(editor)) {\n        editor.onChange()\n      }\n    }\n  }\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const after: EditorInterface['after'] = (editor, at, options = {}) => {\n  const anchor = Editor.point(editor, at, { edge: 'end' })\n  const focus = Editor.end(editor, [])\n  const range = { anchor, focus }\n  const { distance = 1 } = options\n  let d = 0\n  let target\n\n  for (const p of Editor.positions(editor, {\n    ...options,\n    at: range,\n  })) {\n    if (d > distance) {\n      break\n    }\n\n    if (d !== 0) {\n      target = p\n    }\n\n    d++\n  }\n\n  return target\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const before: EditorInterface['before'] = (editor, at, options = {}) => {\n  const anchor = Editor.start(editor, [])\n  const focus = Editor.point(editor, at, { edge: 'start' })\n  const range = { anchor, focus }\n  const { distance = 1 } = options\n  let d = 0\n  let target\n\n  for (const p of Editor.positions(editor, {\n    ...options,\n    at: range,\n    reverse: true,\n  })) {\n    if (d > distance) {\n      break\n    }\n\n    if (d !== 0) {\n      target = p\n    }\n\n    d++\n  }\n\n  return target\n}\n","import { Editor } from '../interfaces/editor'\nimport { Transforms } from '../interfaces/transforms'\nimport { Range } from '../interfaces/range'\nimport { WithEditorFirstArg } from '../utils/types'\n\nexport const deleteBackward: WithEditorFirstArg<Editor['deleteBackward']> = (\n  editor,\n  unit\n) => {\n  const { selection } = editor\n\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, { unit, reverse: true })\n  }\n}\n","import { Editor } from '../interfaces/editor'\nimport { Transforms } from '../interfaces/transforms'\nimport { Range } from '../interfaces/range'\nimport { WithEditorFirstArg } from '../utils/types'\n\nexport const deleteForward: WithEditorFirstArg<Editor['deleteForward']> = (\n  editor,\n  unit\n) => {\n  const { selection } = editor\n\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, { unit })\n  }\n}\n","import { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\nimport { EditorInterface } from '../interfaces/editor'\n\nexport const deleteFragment: EditorInterface['deleteFragment'] = (\n  editor,\n  { direction = 'forward' } = {}\n) => {\n  const { selection } = editor\n\n  if (selection && Range.isExpanded(selection)) {\n    Transforms.delete(editor, { reverse: direction === 'backward' })\n  }\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const edges: EditorInterface['edges'] = (editor, at) => {\n  return [Editor.start(editor, at), Editor.end(editor, at)]\n}\n","import { Element } from '../interfaces/element'\nimport { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const elementReadOnly: EditorInterface['elementReadOnly'] = (\n  editor,\n  options = {}\n) => {\n  return Editor.above(editor, {\n    ...options,\n    match: n => Element.isElement(n) && Editor.isElementReadOnly(editor, n),\n  })\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const end: EditorInterface['end'] = (editor, at) => {\n  return Editor.point(editor, at, { edge: 'end' })\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const first: EditorInterface['first'] = (editor, at) => {\n  const path = Editor.path(editor, at, { edge: 'start' })\n  return Editor.node(editor, path)\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Node } from '../interfaces/node'\n\nexport const fragment: EditorInterface['fragment'] = (editor, at) => {\n  const range = Editor.range(editor, at)\n  return Node.fragment(editor, range)\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Element } from '../interfaces/element'\n\nexport const getVoid: EditorInterface['void'] = (editor, options = {}) => {\n  return Editor.above(editor, {\n    ...options,\n    match: n => Element.isElement(n) && Editor.isVoid(editor, n),\n  })\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Element } from '../interfaces/element'\n\nexport const hasBlocks: EditorInterface['hasBlocks'] = (editor, element) => {\n  return element.children.some(\n    n => Element.isElement(n) && Editor.isBlock(editor, n)\n  )\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Text } from '../interfaces/text'\n\nexport const hasInlines: EditorInterface['hasInlines'] = (editor, element) => {\n  return element.children.some(\n    n => Text.isText(n) || Editor.isInline(editor, n)\n  )\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { Node } from '../interfaces/node'\n\nexport const hasPath: EditorInterface['hasPath'] = (editor, path) => {\n  return Node.has(editor, path)\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { Text } from '../interfaces/text'\n\nexport const hasTexts: EditorInterface['hasTexts'] = (editor, element) => {\n  return element.children.every(n => Text.isText(n))\n}\n","import { Transforms } from '../interfaces/transforms'\nimport { EditorInterface } from '../interfaces/editor'\n\nexport const insertBreak: EditorInterface['insertBreak'] = editor => {\n  Transforms.splitNodes(editor, { always: true })\n}\n","import { Transforms } from '../interfaces/transforms'\nimport { EditorInterface } from '../interfaces/editor'\n\nexport const insertNode: EditorInterface['insertNode'] = (\n  editor,\n  node,\n  options\n) => {\n  Transforms.insertNodes(editor, node, options)\n}\n","import { Transforms } from '../interfaces/transforms'\nimport { EditorInterface } from '../interfaces/editor'\n\nexport const insertSoftBreak: EditorInterface['insertSoftBreak'] = editor => {\n  Transforms.splitNodes(editor, { always: true })\n}\n","import { Transforms } from '../interfaces/transforms'\nimport { EditorInterface } from '../interfaces/editor'\n\nexport const insertText: EditorInterface['insertText'] = (\n  editor,\n  text,\n  options = {}\n) => {\n  const { selection, marks } = editor\n\n  if (selection) {\n    if (marks) {\n      const node = { text, ...marks }\n      Transforms.insertNodes(editor, node, {\n        at: options.at,\n        voids: options.voids,\n      })\n    } else {\n      Transforms.insertText(editor, text, options)\n    }\n\n    editor.marks = null\n  }\n}\n","import { EditorInterface } from '../interfaces/editor'\n\nexport const isBlock: EditorInterface['isBlock'] = (editor, value) => {\n  return !editor.isInline(value)\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const isEdge: EditorInterface['isEdge'] = (editor, point, at) => {\n  return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { Text } from '../interfaces/text'\n\nexport const isEmpty: EditorInterface['isEmpty'] = (editor, element) => {\n  const { children } = element\n  const [first] = children\n  return (\n    children.length === 0 ||\n    (children.length === 1 &&\n      Text.isText(first) &&\n      first.text === '' &&\n      !editor.isVoid(element))\n  )\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Point } from '../interfaces/point'\n\nexport const isEnd: EditorInterface['isEnd'] = (editor, point, at) => {\n  const end = Editor.end(editor, at)\n  return Point.equals(point, end)\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { NORMALIZING } from '../utils/weak-maps'\n\nexport const isNormalizing: EditorInterface['isNormalizing'] = editor => {\n  const isNormalizing = NORMALIZING.get(editor)\n  return isNormalizing === undefined ? true : isNormalizing\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Point } from '../interfaces/point'\n\nexport const isStart: EditorInterface['isStart'] = (editor, point, at) => {\n  // PERF: If the offset isn't `0` we know it's not the start.\n  if (point.offset !== 0) {\n    return false\n  }\n\n  const start = Editor.start(editor, at)\n  return Point.equals(point, start)\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const last: EditorInterface['last'] = (editor, at) => {\n  const path = Editor.path(editor, at, { edge: 'end' })\n  return Editor.node(editor, path)\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Node } from '../interfaces/node'\n\nexport const leaf: EditorInterface['leaf'] = (editor, at, options = {}) => {\n  const path = Editor.path(editor, at, options)\n  const node = Node.leaf(editor, path)\n  return [node, path]\n}\n","import { Node, NodeEntry } from '../interfaces/node'\nimport { Editor, EditorLevelsOptions } from '../interfaces/editor'\nimport { Element } from '../interfaces/element'\n\nexport function* levels<T extends Node>(\n  editor: Editor,\n  options: EditorLevelsOptions<T> = {}\n): Generator<NodeEntry<T>, void, undefined> {\n  const { at = editor.selection, reverse = false, voids = false } = options\n  let { match } = options\n\n  if (match == null) {\n    match = () => true\n  }\n\n  if (!at) {\n    return\n  }\n\n  const levels: NodeEntry<T>[] = []\n  const path = Editor.path(editor, at)\n\n  for (const [n, p] of Node.levels(editor, path)) {\n    if (!match(n, p)) {\n      continue\n    }\n\n    levels.push([n, p] as NodeEntry<T>)\n\n    if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n      break\n    }\n  }\n\n  if (reverse) {\n    levels.reverse()\n  }\n\n  yield* levels\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { NodeEntry } from '../interfaces/node'\nimport { Range } from '../interfaces/range'\nimport { Path } from '../interfaces/path'\nimport { Text } from '../interfaces/text'\nimport { Element } from '../interfaces/element'\nimport { Point } from '../interfaces'\n\nexport const marks: EditorInterface['marks'] = (editor, options = {}) => {\n  const { marks, selection } = editor\n\n  if (!selection) {\n    return null\n  }\n  let { anchor, focus } = selection\n\n  if (marks) {\n    return marks\n  }\n\n  if (Range.isExpanded(selection)) {\n    const isBackward = Range.isBackward(selection)\n    if (isBackward) {\n      ;[focus, anchor] = [anchor, focus]\n    }\n    /**\n     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)\n     * do not adversely affect the returned marks.\n     */\n    const isEnd = Editor.isEnd(editor, anchor, anchor.path)\n    if (isEnd) {\n      const after = Editor.after(editor, anchor as Point)\n      if (after) {\n        anchor = after\n      }\n    }\n\n    const [match] = Editor.nodes(editor, {\n      match: Text.isText,\n      at: {\n        anchor,\n        focus,\n      },\n    })\n\n    if (match) {\n      const [node] = match as NodeEntry<Text>\n      const { text, ...rest } = node\n      return rest\n    } else {\n      return {}\n    }\n  }\n\n  const { path } = anchor\n\n  let [node] = Editor.leaf(editor, path)\n\n  if (anchor.offset === 0) {\n    const prev = Editor.previous(editor, { at: path, match: Text.isText })\n    const markedVoid = Editor.above(editor, {\n      match: n =>\n        Element.isElement(n) &&\n        Editor.isVoid(editor, n) &&\n        editor.markableVoid(n),\n    })\n    if (!markedVoid) {\n      const block = Editor.above(editor, {\n        match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n  }\n\n  const { text, ...rest } = node\n  return rest\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Span } from '../interfaces/location'\nimport { Path } from '../interfaces/path'\n\nexport const next: EditorInterface['next'] = (editor, options = {}) => {\n  const { mode = 'lowest', voids = false } = options\n  let { match, at = editor.selection } = options\n\n  if (!at) {\n    return\n  }\n\n  const pointAfterLocation = Editor.after(editor, at, { voids })\n\n  if (!pointAfterLocation) return\n\n  const [, to] = Editor.last(editor, [])\n\n  const span: Span = [pointAfterLocation.path, to]\n\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(`Cannot get the next node from the root node!`)\n  }\n\n  if (match == null) {\n    if (Path.isPath(at)) {\n      const [parent] = Editor.parent(editor, at)\n      match = n => parent.children.includes(n)\n    } else {\n      match = () => true\n    }\n  }\n\n  const [next] = Editor.nodes(editor, { at: span, match, mode, voids })\n  return next\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Node } from '../interfaces/node'\n\nexport const node: EditorInterface['node'] = (editor, at, options = {}) => {\n  const path = Editor.path(editor, at, options)\n  const node = Node.get(editor, path)\n  return [node, path]\n}\n","import { Node, NodeEntry } from '../interfaces/node'\nimport { Editor, EditorNodesOptions } from '../interfaces/editor'\nimport { Span } from '../interfaces/location'\nimport { Element } from '../interfaces/element'\nimport { Path } from '../interfaces/path'\nimport { Text } from '../interfaces/text'\n\nexport function* nodes<T extends Node>(\n  editor: Editor,\n  options: EditorNodesOptions<T> = {}\n): Generator<NodeEntry<T>, void, undefined> {\n  const {\n    at = editor.selection,\n    mode = 'all',\n    universal = false,\n    reverse = false,\n    voids = false,\n    pass,\n  } = options\n  let { match } = options\n\n  if (!match) {\n    match = () => true\n  }\n\n  if (!at) {\n    return\n  }\n\n  let from\n  let to\n\n  if (Span.isSpan(at)) {\n    from = at[0]\n    to = at[1]\n  } else {\n    const first = Editor.path(editor, at, { edge: 'start' })\n    const last = Editor.path(editor, at, { edge: 'end' })\n    from = reverse ? last : first\n    to = reverse ? first : last\n  }\n\n  const nodeEntries = Node.nodes(editor, {\n    reverse,\n    from,\n    to,\n    pass: ([node, path]) => {\n      if (pass && pass([node, path])) return true\n      if (!Element.isElement(node)) return false\n      if (\n        !voids &&\n        (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))\n      )\n        return true\n\n      return false\n    },\n  })\n\n  const matches: NodeEntry<T>[] = []\n  let hit: NodeEntry<T> | undefined\n\n  for (const [node, path] of nodeEntries) {\n    const isLower = hit && Path.compare(path, hit[1]) === 0\n\n    // In highest mode any node lower than the last hit is not a match.\n    if (mode === 'highest' && isLower) {\n      continue\n    }\n\n    if (!match(node, path)) {\n      // If we've arrived at a leaf text node that is not lower than the last\n      // hit, then we've found a branch that doesn't include a match, which\n      // means the match is not universal.\n      if (universal && !isLower && Text.isText(node)) {\n        return\n      } else {\n        continue\n      }\n    }\n\n    // If there's a match and it's lower than the last, update the hit.\n    if (mode === 'lowest' && isLower) {\n      hit = [node, path] as NodeEntry<T>\n      continue\n    }\n\n    // In lowest mode we emit the last hit, once it's guaranteed lowest.\n    const emit: NodeEntry<T> | undefined =\n      mode === 'lowest' ? hit : ([node, path] as NodeEntry<T>)\n\n    if (emit) {\n      if (universal) {\n        matches.push(emit)\n      } else {\n        yield emit\n      }\n    }\n\n    hit = [node, path] as NodeEntry<T>\n  }\n\n  // Since lowest is always emitting one behind, catch up at the end.\n  if (mode === 'lowest' && hit) {\n    if (universal) {\n      matches.push(hit)\n    } else {\n      yield hit\n    }\n  }\n\n  // Universal defers to ensure that the match occurs in every branch, so we\n  // yield all of the matches after iterating.\n  if (universal) {\n    yield* matches\n  }\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { DIRTY_PATH_KEYS, DIRTY_PATHS } from '../utils/weak-maps'\nimport { Path } from '../interfaces/path'\nimport { Node } from '../interfaces/node'\nimport { Element } from '../interfaces/element'\n\nexport const normalize: EditorInterface['normalize'] = (\n  editor,\n  options = {}\n) => {\n  const { force = false, operation } = options\n  const getDirtyPaths = (editor: Editor) => {\n    return DIRTY_PATHS.get(editor) || []\n  }\n\n  const getDirtyPathKeys = (editor: Editor) => {\n    return DIRTY_PATH_KEYS.get(editor) || new Set()\n  }\n\n  const popDirtyPath = (editor: Editor): Path => {\n    const path = getDirtyPaths(editor).pop()!\n    const key = path.join(',')\n    getDirtyPathKeys(editor).delete(key)\n    return path\n  }\n\n  if (!Editor.isNormalizing(editor)) {\n    return\n  }\n\n  if (force) {\n    const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n    const allPathKeys = new Set(allPaths.map(p => p.join(',')))\n    DIRTY_PATHS.set(editor, allPaths)\n    DIRTY_PATH_KEYS.set(editor, allPathKeys)\n  }\n\n  if (getDirtyPaths(editor).length === 0) {\n    return\n  }\n\n  Editor.withoutNormalizing(editor, () => {\n    /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */\n    for (const dirtyPath of getDirtyPaths(editor)) {\n      if (Node.has(editor, dirtyPath)) {\n        const entry = Editor.node(editor, dirtyPath)\n        const [node, _] = entry\n\n        /*\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\n          So there is some risk here.\n\n          As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n          by definition adding children to an empty node can't cause other paths to change.\n        */\n        if (Element.isElement(node) && node.children.length === 0) {\n          editor.normalizeNode(entry, { operation })\n        }\n      }\n    }\n\n    let dirtyPaths = getDirtyPaths(editor)\n    const initialDirtyPathsLength = dirtyPaths.length\n    let iteration = 0\n\n    while (dirtyPaths.length !== 0) {\n      if (\n        !editor.shouldNormalize({\n          dirtyPaths,\n          iteration,\n          initialDirtyPathsLength,\n          operation,\n        })\n      ) {\n        return\n      }\n\n      const dirtyPath = popDirtyPath(editor)\n\n      // If the node doesn't exist in the tree, it does not need to be normalized.\n      if (Node.has(editor, dirtyPath)) {\n        const entry = Editor.node(editor, dirtyPath)\n        editor.normalizeNode(entry, { operation })\n      }\n      iteration++\n      dirtyPaths = getDirtyPaths(editor)\n    }\n  })\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { Ancestor, NodeEntry } from '../interfaces/node'\n\nexport const parent: EditorInterface['parent'] = (editor, at, options = {}) => {\n  const path = Editor.path(editor, at, options)\n  const parentPath = Path.parent(path)\n  const entry = Editor.node(editor, parentPath)\n  return entry as NodeEntry<Ancestor>\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { PathRef } from '../interfaces/path-ref'\n\nexport const pathRef: EditorInterface['pathRef'] = (\n  editor,\n  path,\n  options = {}\n) => {\n  const { affinity = 'forward' } = options\n  const ref: PathRef = {\n    current: path,\n    affinity,\n    unref() {\n      const { current } = ref\n      const pathRefs = Editor.pathRefs(editor)\n      pathRefs.delete(ref)\n      ref.current = null\n      return current\n    },\n  }\n\n  const refs = Editor.pathRefs(editor)\n  refs.add(ref)\n  return ref\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { PATH_REFS } from '../utils/weak-maps'\n\nexport const pathRefs: EditorInterface['pathRefs'] = editor => {\n  let refs = PATH_REFS.get(editor)\n\n  if (!refs) {\n    refs = new Set()\n    PATH_REFS.set(editor, refs)\n  }\n\n  return refs\n}\n","import { EditorInterface, Node, Path, Point, Range } from '../interfaces'\n\nexport const path: EditorInterface['path'] = (editor, at, options = {}) => {\n  const { depth, edge } = options\n\n  if (Path.isPath(at)) {\n    if (edge === 'start') {\n      const [, firstPath] = Node.first(editor, at)\n      at = firstPath\n    } else if (edge === 'end') {\n      const [, lastPath] = Node.last(editor, at)\n      at = lastPath\n    }\n  }\n\n  if (Range.isRange(at)) {\n    if (edge === 'start') {\n      at = Range.start(at)\n    } else if (edge === 'end') {\n      at = Range.end(at)\n    } else {\n      at = Path.common(at.anchor.path, at.focus.path)\n    }\n  }\n\n  if (Point.isPoint(at)) {\n    at = at.path\n  }\n\n  if (depth != null) {\n    at = at.slice(0, depth)\n  }\n\n  return at\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { PointRef } from '../interfaces/point-ref'\n\nexport const pointRef: EditorInterface['pointRef'] = (\n  editor,\n  point,\n  options = {}\n) => {\n  const { affinity = 'forward' } = options\n  const ref: PointRef = {\n    current: point,\n    affinity,\n    unref() {\n      const { current } = ref\n      const pointRefs = Editor.pointRefs(editor)\n      pointRefs.delete(ref)\n      ref.current = null\n      return current\n    },\n  }\n\n  const refs = Editor.pointRefs(editor)\n  refs.add(ref)\n  return ref\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { POINT_REFS } from '../utils/weak-maps'\n\nexport const pointRefs: EditorInterface['pointRefs'] = editor => {\n  let refs = POINT_REFS.get(editor)\n\n  if (!refs) {\n    refs = new Set()\n    POINT_REFS.set(editor, refs)\n  }\n\n  return refs\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { Node } from '../interfaces/node'\nimport { Text } from '../interfaces/text'\nimport { Range } from '../interfaces/range'\n\nexport const point: EditorInterface['point'] = (editor, at, options = {}) => {\n  const { edge = 'start' } = options\n\n  if (Path.isPath(at)) {\n    let path\n\n    if (edge === 'end') {\n      const [, lastPath] = Node.last(editor, at)\n      path = lastPath\n    } else {\n      const [, firstPath] = Node.first(editor, at)\n      path = firstPath\n    }\n\n    const node = Node.get(editor, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n      )\n    }\n\n    return { path, offset: edge === 'end' ? node.text.length : 0 }\n  }\n\n  if (Range.isRange(at)) {\n    const [start, end] = Range.edges(at)\n    return edge === 'start' ? start : end\n  }\n\n  return at\n}\n","import { Editor, EditorPositionsOptions } from '../interfaces/editor'\nimport { Point } from '../interfaces/point'\nimport { Range } from '../interfaces/range'\nimport { Element } from '../interfaces/element'\nimport { Path } from '../interfaces/path'\nimport { Text } from '../interfaces/text'\nimport {\n  getCharacterDistance,\n  getWordDistance,\n  splitByCharacterDistance,\n} from '../utils/string'\n\nexport function* positions(\n  editor: Editor,\n  options: EditorPositionsOptions = {}\n): Generator<Point, void, undefined> {\n  const {\n    at = editor.selection,\n    unit = 'offset',\n    reverse = false,\n    voids = false,\n  } = options\n\n  if (!at) {\n    return\n  }\n\n  /**\n   * Algorithm notes:\n   *\n   * Each step `distance` is dynamic depending on the underlying text\n   * and the `unit` specified.  Each step, e.g., a line or word, may\n   * span multiple text nodes, so we iterate through the text both on\n   * two levels in step-sync:\n   *\n   * `leafText` stores the text on a text leaf level, and is advanced\n   * through using the counters `leafTextOffset` and `leafTextRemaining`.\n   *\n   * `blockText` stores the text on a block level, and is shortened\n   * by `distance` every time it is advanced.\n   *\n   * We only maintain a window of one blockText and one leafText because\n   * a block node always appears before all of its leaf nodes.\n   */\n\n  const range = Editor.range(editor, at)\n  const [start, end] = Range.edges(range)\n  const first = reverse ? end : start\n  let isNewBlock = false\n  let blockText = ''\n  let distance = 0 // Distance for leafText to catch up to blockText.\n  let leafTextRemaining = 0\n  let leafTextOffset = 0\n  const skippedPaths: Path[] = []\n\n  // Iterate through all nodes in range, grabbing entire textual content\n  // of block nodes in blockText, and text nodes in leafText.\n  // Exploits the fact that nodes are sequenced in such a way that we first\n  // encounter the block node, then all of its text nodes, so when iterating\n  // through the blockText and leafText we just need to remember a window of\n  // one block node and leaf node, respectively.\n  for (const [node, path] of Editor.nodes(editor, {\n    at,\n    reverse,\n    voids,\n  })) {\n    // If the node is inside a skipped ancestor, do not return any points, but\n    // still process its content so that the iteration state remains correct.\n    const hasSkippedAncestor = skippedPaths.some(p => Path.isAncestor(p, path))\n\n    function* maybeYield(point: Point) {\n      if (!hasSkippedAncestor) {\n        yield point\n      }\n    }\n\n    /*\n     * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n     */\n    if (Element.isElement(node)) {\n      if (!editor.isSelectable(node)) {\n        /**\n         * If the node is not selectable, skip it and its descendants\n         */\n        skippedPaths.push(path)\n        if (reverse) {\n          if (Path.hasPrevious(path)) {\n            yield* maybeYield(Editor.end(editor, Path.previous(path)))\n          }\n          continue\n        } else {\n          const nextPath = Path.next(path)\n          if (Editor.hasPath(editor, nextPath)) {\n            yield* maybeYield(Editor.start(editor, nextPath))\n          }\n          continue\n        }\n      }\n\n      // Void nodes are a special case, so by default we will always\n      // yield their first point. If the `voids` option is set to true,\n      // then we will iterate over their content.\n      if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n        yield* maybeYield(Editor.start(editor, path))\n        continue\n      }\n\n      // Inline element nodes are ignored as they don't themselves\n      // contribute to `blockText` or `leafText` - their parent and\n      // children do.\n      if (editor.isInline(node)) continue\n\n      // Block element node - set `blockText` to its text content.\n      if (Editor.hasInlines(editor, node)) {\n        // We always exhaust block nodes before encountering a new one:\n        //   console.assert(blockText === '',\n        //     `blockText='${blockText}' - `+\n        //     `not exhausted before new block node`, path)\n\n        // Ensure range considered is capped to `range`, in the\n        // start/end edge cases where block extends beyond range.\n        // Equivalent to this, but presumably more performant:\n        //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n        //   blockRange = Range.intersection(range, blockRange) // intersect\n        //   blockText = Editor.string(editor, blockRange, { voids })\n        const e = Path.isAncestor(path, end.path)\n          ? end\n          : Editor.end(editor, path)\n        const s = Path.isAncestor(path, start.path)\n          ? start\n          : Editor.start(editor, path)\n\n        blockText = Editor.string(editor, { anchor: s, focus: e }, { voids })\n        isNewBlock = true\n      }\n    }\n\n    /*\n     * TEXT LEAF NODE - Iterate through text content, yielding\n     * positions every `distance` offset according to `unit`.\n     */\n    if (Text.isText(node)) {\n      const isFirst = Path.equals(path, first.path)\n\n      // Proof that we always exhaust text nodes before encountering a new one:\n      //   console.assert(leafTextRemaining <= 0,\n      //     `leafTextRemaining=${leafTextRemaining} - `+\n      //     `not exhausted before new leaf text node`, path)\n\n      // Reset `leafText` counters for new text node.\n      if (isFirst) {\n        leafTextRemaining = reverse\n          ? first.offset\n          : node.text.length - first.offset\n        leafTextOffset = first.offset // Works for reverse too.\n      } else {\n        leafTextRemaining = node.text.length\n        leafTextOffset = reverse ? leafTextRemaining : 0\n      }\n\n      // Yield position at the start of node (potentially).\n      if (isFirst || isNewBlock || unit === 'offset') {\n        yield* maybeYield({ path, offset: leafTextOffset })\n        isNewBlock = false\n      }\n\n      // Yield positions every (dynamically calculated) `distance` offset.\n      while (true) {\n        // If `leafText` has caught up with `blockText` (distance=0),\n        // and if blockText is exhausted, break to get another block node,\n        // otherwise advance blockText forward by the new `distance`.\n        if (distance === 0) {\n          if (blockText === '') break\n          distance = calcDistance(blockText, unit, reverse)\n          // Split the string at the previously found distance and use the\n          // remaining string for the next iteration.\n          blockText = splitByCharacterDistance(blockText, distance, reverse)[1]\n        }\n\n        // Advance `leafText` by the current `distance`.\n        leafTextOffset = reverse\n          ? leafTextOffset - distance\n          : leafTextOffset + distance\n        leafTextRemaining = leafTextRemaining - distance\n\n        // If `leafText` is exhausted, break to get a new leaf node\n        // and set distance to the overflow amount, so we'll (maybe)\n        // catch up to blockText in the next leaf text node.\n        if (leafTextRemaining < 0) {\n          distance = -leafTextRemaining\n          break\n        }\n\n        // Successfully walked `distance` offsets through `leafText`\n        // to catch up with `blockText`, so we can reset `distance`\n        // and yield this position in this node.\n        distance = 0\n        yield* maybeYield({ path, offset: leafTextOffset })\n      }\n    }\n  }\n  // Proof that upon completion, we've exahusted both leaf and block text:\n  //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n  //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n\n  // Helper:\n  // Return the distance in offsets for a step of size `unit` on given string.\n  function calcDistance(text: string, unit: string, reverse?: boolean) {\n    if (unit === 'character') {\n      return getCharacterDistance(text, reverse)\n    } else if (unit === 'word') {\n      return getWordDistance(text, reverse)\n    } else if (unit === 'line' || unit === 'block') {\n      return text.length\n    }\n    return 1\n  }\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Span } from '../interfaces/location'\nimport { Path } from '../interfaces/path'\n\nexport const previous: EditorInterface['previous'] = (editor, options = {}) => {\n  const { mode = 'lowest', voids = false } = options\n  let { match, at = editor.selection } = options\n\n  if (!at) {\n    return\n  }\n\n  const pointBeforeLocation = Editor.before(editor, at, { voids })\n\n  if (!pointBeforeLocation) {\n    return\n  }\n\n  const [, to] = Editor.first(editor, [])\n\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  const span: Span = [pointBeforeLocation.path, to]\n\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(`Cannot get the previous node from the root node!`)\n  }\n\n  if (match == null) {\n    if (Path.isPath(at)) {\n      const [parent] = Editor.parent(editor, at)\n      match = n => parent.children.includes(n)\n    } else {\n      match = () => true\n    }\n  }\n\n  const [previous] = Editor.nodes(editor, {\n    reverse: true,\n    at: span,\n    match,\n    mode,\n    voids,\n  })\n\n  return previous\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { RangeRef } from '../interfaces/range-ref'\n\nexport const rangeRef: EditorInterface['rangeRef'] = (\n  editor,\n  range,\n  options = {}\n) => {\n  const { affinity = 'forward' } = options\n  const ref: RangeRef = {\n    current: range,\n    affinity,\n    unref() {\n      const { current } = ref\n      const rangeRefs = Editor.rangeRefs(editor)\n      rangeRefs.delete(ref)\n      ref.current = null\n      return current\n    },\n  }\n\n  const refs = Editor.rangeRefs(editor)\n  refs.add(ref)\n  return ref\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { RANGE_REFS } from '../utils/weak-maps'\n\nexport const rangeRefs: EditorInterface['rangeRefs'] = editor => {\n  let refs = RANGE_REFS.get(editor)\n\n  if (!refs) {\n    refs = new Set()\n    RANGE_REFS.set(editor, refs)\n  }\n\n  return refs\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Range } from '../interfaces/range'\n\nexport const range: EditorInterface['range'] = (editor, at, to) => {\n  if (Range.isRange(at) && !to) {\n    return at\n  }\n\n  const start = Editor.start(editor, at)\n  const end = Editor.end(editor, to || at)\n  return { anchor: start, focus: end }\n}\n","import { Node } from '../interfaces/node'\nimport { Path } from '../interfaces/path'\nimport { Text } from '../interfaces/text'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\nimport { FLUSHING } from '../utils/weak-maps'\nimport { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const removeMark: EditorInterface['removeMark'] = (editor, key) => {\n  const { selection } = editor\n\n  if (selection) {\n    const match = (node: Node, path: Path) => {\n      if (!Text.isText(node)) {\n        return false // marks can only be applied to text\n      }\n      const [parentNode, parentPath] = Editor.parent(editor, path)\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode)\n    }\n    const expandedSelection = Range.isExpanded(selection)\n    let markAcceptingVoidSelected = false\n    if (!expandedSelection) {\n      const [selectedNode, selectedPath] = Editor.node(editor, selection)\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const [parentNode] = Editor.parent(editor, selectedPath)\n        markAcceptingVoidSelected =\n          parentNode && editor.markableVoid(parentNode)\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.unsetNodes(editor, key, {\n        match,\n        split: true,\n        voids: true,\n      })\n    } else {\n      const marks = { ...(Editor.marks(editor) || {}) }\n      delete marks[<keyof Node>key]\n      editor.marks = marks\n      if (!FLUSHING.get(editor)) {\n        editor.onChange()\n      }\n    }\n  }\n}\n","import { EditorInterface } from '../interfaces/editor'\nimport { NORMALIZING } from '../utils/weak-maps'\n\nexport const setNormalizing: EditorInterface['setNormalizing'] = (\n  editor,\n  isNormalizing\n) => {\n  NORMALIZING.set(editor, isNormalizing)\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const start: EditorInterface['start'] = (editor, at) => {\n  return Editor.point(editor, at, { edge: 'start' })\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Range } from '../interfaces/range'\nimport { Text } from '../interfaces/text'\nimport { Path } from '../interfaces/path'\n\nexport const string: EditorInterface['string'] = (editor, at, options = {}) => {\n  const { voids = false } = options\n  const range = Editor.range(editor, at)\n  const [start, end] = Range.edges(range)\n  let text = ''\n\n  for (const [node, path] of Editor.nodes(editor, {\n    at: range,\n    match: Text.isText,\n    voids,\n  })) {\n    let t = node.text\n\n    if (Path.equals(path, end.path)) {\n      t = t.slice(0, end.offset)\n    }\n\n    if (Path.equals(path, start.path)) {\n      t = t.slice(start.offset)\n    }\n\n    text += t\n  }\n\n  return text\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\nimport { Range } from '../interfaces/range'\nimport { Path } from '../interfaces/path'\nimport { Element } from '../interfaces/element'\nimport { Text } from '../interfaces/text'\n\nexport const unhangRange: EditorInterface['unhangRange'] = (\n  editor,\n  range,\n  options = {}\n) => {\n  const { voids = false } = options\n  let [start, end] = Range.edges(range)\n\n  // PERF: exit early if we can guarantee that the range isn't hanging.\n  if (\n    start.offset !== 0 ||\n    end.offset !== 0 ||\n    Range.isCollapsed(range) ||\n    Path.hasPrevious(end.path)\n  ) {\n    return range\n  }\n\n  const endBlock = Editor.above(editor, {\n    at: end,\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    voids,\n  })\n  const blockPath = endBlock ? endBlock[1] : []\n  const first = Editor.start(editor, start)\n  const before = { anchor: first, focus: end }\n  let skip = true\n\n  for (const [node, path] of Editor.nodes(editor, {\n    at: before,\n    match: Text.isText,\n    reverse: true,\n    voids,\n  })) {\n    if (skip) {\n      skip = false\n      continue\n    }\n\n    if (node.text !== '' || Path.isBefore(path, blockPath)) {\n      end = { path, offset: node.text.length }\n      break\n    }\n  }\n\n  return { anchor: start, focus: end }\n}\n","import { Editor, EditorInterface } from '../interfaces/editor'\n\nexport const withoutNormalizing: EditorInterface['withoutNormalizing'] = (\n  editor,\n  fn\n) => {\n  const value = Editor.isNormalizing(editor)\n  Editor.setNormalizing(editor, false)\n  try {\n    fn()\n  } finally {\n    Editor.setNormalizing(editor, value)\n  }\n  Editor.normalize(editor)\n}\n","import { EditorInterface, Element, Editor, Text } from '../interfaces'\n\nexport const shouldMergeNodesRemovePrevNode: EditorInterface['shouldMergeNodesRemovePrevNode'] =\n  (editor, [prevNode, prevPath], [curNode, curNodePath]) => {\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // if prevNode is first child in parent,don't remove it.\n\n    return (\n      (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n      (Text.isText(prevNode) &&\n        prevNode.text === '' &&\n        prevPath[prevPath.length - 1] !== 0)\n    )\n  }\n","import { TextTransforms } from '../interfaces/transforms/text'\nimport { Editor } from '../interfaces/editor'\nimport { Range } from '../interfaces/range'\nimport { Point } from '../interfaces/point'\nimport { Path } from '../interfaces/path'\nimport { Transforms } from '../interfaces/transforms'\nimport { Element } from '../interfaces/element'\nimport { NodeEntry } from '../interfaces/node'\n\nexport const deleteText: TextTransforms['delete'] = (editor, options = {}) => {\n  Editor.withoutNormalizing(editor, () => {\n    const {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false,\n    } = options\n    let { at = editor.selection, hanging = false } = options\n\n    if (!at) {\n      return\n    }\n\n    let isCollapsed = false\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      isCollapsed = true\n      at = at.anchor\n    }\n\n    if (Point.isPoint(at)) {\n      const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid\n        at = voidPath\n      } else {\n        const opts = { unit, distance }\n        const target = reverse\n          ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n          : Editor.after(editor, at, opts) || Editor.end(editor, [])\n        at = { anchor: at, focus: target }\n        hanging = true\n      }\n    }\n\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, { at, voids })\n      return\n    }\n\n    if (Range.isCollapsed(at)) {\n      return\n    }\n\n    if (!hanging) {\n      const [, end] = Range.edges(at)\n      const endOfDoc = Editor.end(editor, [])\n\n      if (!Point.equals(end, endOfDoc)) {\n        at = Editor.unhangRange(editor, at, { voids })\n      }\n    }\n\n    let [start, end] = Range.edges(at)\n    const startBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: start,\n      voids,\n    })\n    const endBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: end,\n      voids,\n    })\n    const isAcrossBlocks =\n      startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n    const isSingleText = Path.equals(start.path, end.path)\n    const startNonEditable = voids\n      ? null\n      : Editor.void(editor, { at: start, mode: 'highest' }) ??\n        Editor.elementReadOnly(editor, { at: start, mode: 'highest' })\n    const endNonEditable = voids\n      ? null\n      : Editor.void(editor, { at: end, mode: 'highest' }) ??\n        Editor.elementReadOnly(editor, { at: end, mode: 'highest' })\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startNonEditable) {\n      const before = Editor.before(editor, start)\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before\n      }\n    }\n\n    if (endNonEditable) {\n      const after = Editor.after(editor, end)\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: NodeEntry[] = []\n    let lastPath: Path | undefined\n\n    for (const entry of Editor.nodes(editor, { at, voids })) {\n      const [node, path] = entry\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue\n      }\n\n      if (\n        (!voids &&\n          Element.isElement(node) &&\n          (Editor.isVoid(editor, node) ||\n            Editor.isElementReadOnly(editor, node))) ||\n        (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n      ) {\n        matches.push(entry)\n        lastPath = path\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n    const startRef = Editor.pointRef(editor, start)\n    const endRef = Editor.pointRef(editor, end)\n\n    let removedText = ''\n\n    if (!isSingleText && !startNonEditable) {\n      const point = startRef.current!\n      const [node] = Editor.leaf(editor, point)\n      const { path } = point\n      const { offset } = start\n      const text = node.text.slice(offset)\n      if (text.length > 0) {\n        editor.apply({ type: 'remove_text', path, offset, text })\n        removedText = text\n      }\n    }\n\n    pathRefs\n      .reverse()\n      .map(r => r.unref())\n      .filter((r): r is Path => r !== null)\n      .forEach(p => Transforms.removeNodes(editor, { at: p, voids }))\n\n    if (!endNonEditable) {\n      const point = endRef.current!\n      const [node] = Editor.leaf(editor, point)\n      const { path } = point\n      const offset = isSingleText ? start.offset : 0\n      const text = node.text.slice(offset, end.offset)\n      if (text.length > 0) {\n        editor.apply({ type: 'remove_text', path, offset, text })\n        removedText = text\n      }\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids,\n      })\n    }\n\n    // For certain scripts, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n    // Bengali: \\u0980-\\u09FF\n    // Thai: \\u0E00-\\u0E7F\n    // Burmese (Myanmar): \\u1000-\\u109F\n    // Hindi (Devanagari): \\u0900-\\u097F\n    // Khmer: \\u1780-\\u17FF\n    // Malayalam: \\u0D00-\\u0D7F\n    // Oriya: \\u0B00-\\u0B7F\n    // Punjabi (Gurmukhi): \\u0A00-\\u0A7F\n    // Tamil: \\u0B80-\\u0BFF\n    // Telugu: \\u0C00-\\u0C7F\n    if (\n      isCollapsed &&\n      reverse &&\n      unit === 'character' &&\n      removedText.length > 1 &&\n      removedText.match(\n        /[\\u0980-\\u09FF\\u0E00-\\u0E7F\\u1000-\\u109F\\u0900-\\u097F\\u1780-\\u17FF\\u0D00-\\u0D7F\\u0B00-\\u0B7F\\u0A00-\\u0A7F\\u0B80-\\u0BFF\\u0C00-\\u0C7F]+/\n      )\n    ) {\n      Transforms.insertText(\n        editor,\n        removedText.slice(0, removedText.length - distance)\n      )\n    }\n\n    const startUnref = startRef.unref()\n    const endUnref = endRef.unref()\n    const point = reverse ? startUnref || endUnref : endUnref || startUnref\n\n    if (options.at == null && point) {\n      Transforms.select(editor, point)\n    }\n  })\n}\n","import { Transforms } from '../interfaces/transforms'\nimport { Editor } from '../interfaces/editor'\nimport { Range } from '../interfaces/range'\nimport { Path } from '../interfaces/path'\nimport { Element } from '../interfaces/element'\nimport { Descendant, Node, NodeEntry } from '../interfaces/node'\nimport { Text } from '../interfaces/text'\nimport { TextTransforms } from '../interfaces/transforms/text'\nimport { getDefaultInsertLocation } from '../utils'\n\nexport const insertFragment: TextTransforms['insertFragment'] = (\n  editor,\n  fragment,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    const { hanging = false, voids = false } = options\n    let { at = getDefaultInsertLocation(editor), batchDirty = true } = options\n\n    if (!fragment.length) {\n      return\n    }\n\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, { voids })\n      }\n\n      if (Range.isCollapsed(at)) {\n        at = at.anchor\n      } else {\n        const [, end] = Range.edges(at)\n\n        if (!voids && Editor.void(editor, { at: end })) {\n          return\n        }\n\n        const pointRef = Editor.pointRef(editor, end)\n        Transforms.delete(editor, { at })\n        at = pointRef.unref()!\n      }\n    } else if (Path.isPath(at)) {\n      at = Editor.start(editor, at)\n    }\n\n    if (!voids && Editor.void(editor, { at })) {\n      return\n    }\n\n    // If the insert point is at the edge of an inline node, move it outside\n    // instead since it will need to be split otherwise.\n    const inlineElementMatch = Editor.above(editor, {\n      at,\n      match: n => Element.isElement(n) && Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n    })\n\n    if (inlineElementMatch) {\n      const [, inlinePath] = inlineElementMatch\n\n      if (Editor.isEnd(editor, at, inlinePath)) {\n        const after = Editor.after(editor, inlinePath)!\n        at = after\n      } else if (Editor.isStart(editor, at, inlinePath)) {\n        const before = Editor.before(editor, inlinePath)!\n        at = before\n      }\n    }\n\n    const blockMatch = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at,\n      voids,\n    })!\n    const [, blockPath] = blockMatch\n    const isBlockStart = Editor.isStart(editor, at, blockPath)\n    const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n    const isBlockEmpty = isBlockStart && isBlockEnd\n    const [, firstLeafPath] = Node.first({ children: fragment }, [])\n    const [, lastLeafPath] = Node.last({ children: fragment }, [])\n\n    // For each node in the fragment, determine what level of wrapping should\n    // be kept. At minimum, all text nodes will be inserted, but if\n    // `shouldInsert` returns true for some ancestor of a particular text node,\n    // then the entire ancestor will be inserted rather than inserting the text\n    // nodes individually.\n    const shouldInsert = ([n, p]: NodeEntry) => {\n      const isRoot = p.length === 0\n      if (isRoot) {\n        return false\n      }\n\n      // If the destination block is empty, insert all top-level blocks of the\n      // fragment.\n      if (isBlockEmpty) {\n        return true\n      }\n\n      // Unless we're at the start of the destination block, unwrap any\n      // non-void blocks that contain the first leaf node in the fragment.\n      if (\n        !isBlockStart &&\n        Path.isAncestor(p, firstLeafPath) &&\n        Element.isElement(n) &&\n        !editor.isVoid(n) &&\n        !editor.isInline(n)\n      ) {\n        return false\n      }\n\n      // Unless we're at the end of the destination block, unwrap any non-void\n      // blocks that contain the last leaf node in the fragment.\n      if (\n        !isBlockEnd &&\n        Path.isAncestor(p, lastLeafPath) &&\n        Element.isElement(n) &&\n        !editor.isVoid(n) &&\n        !editor.isInline(n)\n      ) {\n        return false\n      }\n\n      // Always insert void nodes, inline elements and text nodes.\n      return true\n    }\n\n    // Whether the current node is in the first block of the fragment.\n    let starting = true\n\n    // Inline nodes in the first block of the fragment, to be merged with the\n    // destination block.\n    const starts: Descendant[] = []\n\n    // Blocks in the middle of the fragment.\n    const middles: Element[] = []\n\n    // Inline nodes in the last block of the fragment, to be merged with the\n    // destination block. If the fragment contains only one block, this will be\n    // empty.\n    const ends: Descendant[] = []\n\n    for (const entry of Node.nodes(\n      { children: fragment },\n      { pass: shouldInsert }\n    )) {\n      const [node, path] = entry\n\n      // If we encounter a block that does not contain the first leaf, we're no\n      // longer in the first block of the fragment.\n      if (\n        starting &&\n        Element.isElement(node) &&\n        !editor.isInline(node) &&\n        !Path.isAncestor(path, firstLeafPath)\n      ) {\n        starting = false\n      }\n\n      if (shouldInsert(entry)) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n    }\n\n    const [inlineMatch] = Editor.nodes(editor, {\n      at,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n    })!\n\n    const [, inlinePath] = inlineMatch\n    const isInlineStart = Editor.isStart(editor, at, inlinePath)\n    const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n    const middleRef = Editor.pathRef(\n      editor,\n      isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath\n    )\n\n    const endRef = Editor.pathRef(\n      editor,\n      isInlineEnd ? Path.next(inlinePath) : inlinePath\n    )\n\n    // If the fragment contains inlines in multiple distinct blocks, split the\n    // destination block.\n    const splitBlock = ends.length > 0\n\n    Transforms.splitNodes(editor, {\n      at,\n      match: n =>\n        splitBlock\n          ? Element.isElement(n) && Editor.isBlock(editor, n)\n          : Text.isText(n) || Editor.isInline(editor, n),\n      mode: splitBlock ? 'lowest' : 'highest',\n      always:\n        splitBlock &&\n        (!isBlockStart || starts.length > 0) &&\n        (!isBlockEnd || ends.length > 0),\n      voids,\n    })\n\n    const startRef = Editor.pathRef(\n      editor,\n      !isInlineStart || (isInlineStart && isInlineEnd)\n        ? Path.next(inlinePath)\n        : inlinePath\n    )\n\n    Transforms.insertNodes(editor, starts, {\n      at: startRef.current!,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty,\n    })\n\n    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n      Transforms.delete(editor, { at: blockPath, voids })\n    }\n\n    Transforms.insertNodes(editor, middles, {\n      at: middleRef.current!,\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      mode: 'lowest',\n      voids,\n      batchDirty,\n    })\n\n    Transforms.insertNodes(editor, ends, {\n      at: endRef.current!,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty,\n    })\n\n    if (!options.at) {\n      let path\n\n      if (ends.length > 0 && endRef.current) {\n        path = Path.previous(endRef.current)\n      } else if (middles.length > 0 && middleRef.current) {\n        path = Path.previous(middleRef.current)\n      } else if (startRef.current) {\n        path = Path.previous(startRef.current)\n      }\n\n      if (path) {\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n    }\n\n    startRef.unref()\n    middleRef.unref()\n    endRef.unref()\n  })\n}\n","import { SelectionTransforms } from '../interfaces/transforms/selection'\nimport { Transforms } from '../interfaces/transforms'\nimport { Range } from '../interfaces/range'\n\nexport const collapse: SelectionTransforms['collapse'] = (\n  editor,\n  options = {}\n) => {\n  const { edge = 'anchor' } = options\n  const { selection } = editor\n\n  if (!selection) {\n    return\n  } else if (edge === 'anchor') {\n    Transforms.select(editor, selection.anchor)\n  } else if (edge === 'focus') {\n    Transforms.select(editor, selection.focus)\n  } else if (edge === 'start') {\n    const [start] = Range.edges(selection)\n    Transforms.select(editor, start)\n  } else if (edge === 'end') {\n    const [, end] = Range.edges(selection)\n    Transforms.select(editor, end)\n  }\n}\n","import { SelectionTransforms } from '../interfaces/transforms/selection'\n\nexport const deselect: SelectionTransforms['deselect'] = editor => {\n  const { selection } = editor\n\n  if (selection) {\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: null,\n    })\n  }\n}\n","import { SelectionTransforms } from '../interfaces/transforms/selection'\nimport { Range } from '../interfaces/range'\nimport { Editor } from '../interfaces/editor'\nimport { Transforms } from '../interfaces/transforms'\n\nexport const move: SelectionTransforms['move'] = (editor, options = {}) => {\n  const { selection } = editor\n  const { distance = 1, unit = 'character', reverse = false } = options\n  let { edge = null } = options\n\n  if (!selection) {\n    return\n  }\n\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n  }\n\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n  }\n\n  const { anchor, focus } = selection\n  const opts = { distance, unit }\n  const props: Partial<Range> = {}\n\n  if (edge == null || edge === 'anchor') {\n    const point = reverse\n      ? Editor.before(editor, anchor, opts)\n      : Editor.after(editor, anchor, opts)\n\n    if (point) {\n      props.anchor = point\n    }\n  }\n\n  if (edge == null || edge === 'focus') {\n    const point = reverse\n      ? Editor.before(editor, focus, opts)\n      : Editor.after(editor, focus, opts)\n\n    if (point) {\n      props.focus = point\n    }\n  }\n\n  Transforms.setSelection(editor, props)\n}\n","import { SelectionTransforms } from '../interfaces/transforms/selection'\nimport { Editor } from '../interfaces/editor'\nimport { Transforms } from '../interfaces/transforms'\nimport { Range } from '../interfaces/range'\nimport { Scrubber } from '../interfaces/scrubber'\n\nexport const select: SelectionTransforms['select'] = (editor, target) => {\n  const { selection } = editor\n  target = Editor.range(editor, target)\n\n  if (selection) {\n    Transforms.setSelection(editor, target)\n    return\n  }\n\n  if (!Range.isRange(target)) {\n    throw new Error(\n      `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${Scrubber.stringify(\n        target\n      )}`\n    )\n  }\n\n  editor.apply({\n    type: 'set_selection',\n    properties: selection,\n    newProperties: target,\n  })\n}\n","import { SelectionTransforms } from '../interfaces/transforms/selection'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\n\nexport const setPoint: SelectionTransforms['setPoint'] = (\n  editor,\n  props,\n  options = {}\n) => {\n  const { selection } = editor\n  let { edge = 'both' } = options\n\n  if (!selection) {\n    return\n  }\n\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n  }\n\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n  }\n\n  const { anchor, focus } = selection\n  const point = edge === 'anchor' ? anchor : focus\n\n  Transforms.setSelection(editor, {\n    [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n  })\n}\n","import { SelectionTransforms } from '../interfaces/transforms/selection'\nimport { Range } from '../interfaces/range'\nimport { Point } from '../interfaces/point'\n\nexport const setSelection: SelectionTransforms['setSelection'] = (\n  editor,\n  props\n) => {\n  const { selection } = editor\n  const oldProps: Partial<Range> | null = {}\n  const newProps: Partial<Range> = {}\n\n  if (!selection) {\n    return\n  }\n\n  for (const k in props) {\n    if (\n      (k === 'anchor' &&\n        props.anchor != null &&\n        !Point.equals(props.anchor, selection.anchor)) ||\n      (k === 'focus' &&\n        props.focus != null &&\n        !Point.equals(props.focus, selection.focus)) ||\n      (k !== 'anchor' &&\n        k !== 'focus' &&\n        props[<keyof Range>k] !== selection[<keyof Range>k])\n    ) {\n      oldProps[<keyof Range>k] = selection[<keyof Range>k]\n      newProps[<keyof Range>k] = props[<keyof Range>k]\n    }\n  }\n\n  if (Object.keys(oldProps).length > 0) {\n    editor.apply({\n      type: 'set_selection',\n      properties: oldProps,\n      newProperties: newProps,\n    })\n  }\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Node } from '../interfaces/node'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\nimport { Point } from '../interfaces/point'\nimport { Text } from '../interfaces/text'\nimport { Element } from '../interfaces/element'\nimport { Path } from '../interfaces/path'\nimport { getDefaultInsertLocation } from '../utils'\nimport { batchDirtyPaths } from '../core/batch-dirty-paths'\nimport { BaseInsertNodeOperation } from '../interfaces'\nimport { updateDirtyPaths } from '../core/update-dirty-paths'\n\nexport const insertNodes: NodeTransforms['insertNodes'] = (\n  editor,\n  nodes,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    const {\n      hanging = false,\n      voids = false,\n      mode = 'lowest',\n      batchDirty = true,\n    } = options\n    let { at, match, select } = options\n\n    if (Node.isNode(nodes)) {\n      nodes = [nodes]\n    }\n\n    if (nodes.length === 0) {\n      return\n    }\n\n    const [node] = nodes\n\n    if (!at) {\n      at = getDefaultInsertLocation(editor)\n      if (select !== false) {\n        select = true\n      }\n    }\n\n    if (select == null) {\n      select = false\n    }\n\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, { voids })\n      }\n\n      if (Range.isCollapsed(at)) {\n        at = at.anchor\n      } else {\n        const [, end] = Range.edges(at)\n        const pointRef = Editor.pointRef(editor, end)\n        Transforms.delete(editor, { at })\n        at = pointRef.unref()!\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      if (match == null) {\n        if (Text.isText(node)) {\n          match = n => Text.isText(n)\n        } else if (editor.isInline(node)) {\n          match = n => Text.isText(n) || Editor.isInline(editor, n)\n        } else {\n          match = n => Element.isElement(n) && Editor.isBlock(editor, n)\n        }\n      }\n\n      const [entry] = Editor.nodes(editor, {\n        at: at.path,\n        match,\n        mode,\n        voids,\n      })\n\n      if (entry) {\n        const [, matchPath] = entry\n        const pathRef = Editor.pathRef(editor, matchPath)\n        const isAtEnd = Editor.isEnd(editor, at, matchPath)\n        Transforms.splitNodes(editor, { at, match, mode, voids })\n        const path = pathRef.unref()!\n        at = isAtEnd ? Path.next(path) : path\n      } else {\n        return\n      }\n    }\n\n    const parentPath = Path.parent(at)\n    let index = at[at.length - 1]\n\n    if (!voids && Editor.void(editor, { at: parentPath })) {\n      return\n    }\n\n    if (batchDirty) {\n      // PERF: batch update dirty paths\n      // batched ops used to transform existing dirty paths\n      const batchedOps: BaseInsertNodeOperation[] = []\n      const newDirtyPaths: Path[] = Path.levels(parentPath)\n      batchDirtyPaths(\n        editor,\n        () => {\n          for (const node of nodes as Node[]) {\n            const path = parentPath.concat(index)\n            index++\n\n            const op: BaseInsertNodeOperation = {\n              type: 'insert_node',\n              path,\n              node,\n            }\n            editor.apply(op)\n            at = Path.next(at as Path)\n\n            batchedOps.push(op)\n            if (Text.isText(node)) {\n              newDirtyPaths.push(path)\n            } else {\n              newDirtyPaths.push(\n                ...Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n              )\n            }\n          }\n        },\n        () => {\n          updateDirtyPaths(editor, newDirtyPaths, p => {\n            let newPath: Path | null = p\n            for (const op of batchedOps) {\n              if (Path.operationCanTransformPath(op)) {\n                newPath = Path.transform(newPath, op)\n                if (!newPath) {\n                  return null\n                }\n              }\n            }\n            return newPath\n          })\n        }\n      )\n    } else {\n      for (const node of nodes as Node[]) {\n        const path = parentPath.concat(index)\n        index++\n\n        editor.apply({ type: 'insert_node', path, node })\n        at = Path.next(at as Path)\n      }\n    }\n\n    at = Path.previous(at)\n\n    if (select) {\n      const point = Editor.end(editor, at)\n\n      if (point) {\n        Transforms.select(editor, point)\n      }\n    }\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { matchPath } from '../utils/match-path'\nimport { Element } from '../interfaces/element'\nimport { Ancestor, NodeEntry } from '../interfaces/node'\nimport { Transforms } from '../interfaces/transforms'\n\nexport const liftNodes: NodeTransforms['liftNodes'] = (\n  editor,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    const { at = editor.selection, mode = 'lowest', voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = Path.isPath(at)\n        ? matchPath(editor, at)\n        : n => Element.isElement(n) && Editor.isBlock(editor, n)\n    }\n\n    if (!at) {\n      return\n    }\n\n    const matches = Editor.nodes(editor, { at, match, mode, voids })\n    const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!\n\n      if (path.length < 2) {\n        throw new Error(\n          `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n        )\n      }\n\n      const parentNodeEntry = Editor.node(editor, Path.parent(path))\n      const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n      const index = path[path.length - 1]\n      const { length } = parent.children\n\n      if (length === 1) {\n        const toPath = Path.next(parentPath)\n        Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        Transforms.removeNodes(editor, { at: parentPath, voids })\n      } else if (index === 0) {\n        Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n      } else if (index === length - 1) {\n        const toPath = Path.next(parentPath)\n        Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n      } else {\n        const splitPath = Path.next(path)\n        const toPath = Path.next(parentPath)\n        Transforms.splitNodes(editor, { at: splitPath, voids })\n        Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n      }\n    }\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { Element } from '../interfaces/element'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\nimport { Text } from '../interfaces/text'\nimport { Scrubber } from '../interfaces/scrubber'\nimport { Node } from '../interfaces/node'\n\nconst hasSingleChildNest = (editor: Editor, node: Node): boolean => {\n  if (Element.isElement(node)) {\n    const element = node as Element\n    if (Editor.isVoid(editor, node)) {\n      return true\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0])\n    } else {\n      return false\n    }\n  } else if (Editor.isEditor(node)) {\n    return false\n  } else {\n    return true\n  }\n}\n\nexport const mergeNodes: NodeTransforms['mergeNodes'] = (\n  editor,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    let { match, at = editor.selection } = options\n    const { hanging = false, voids = false, mode = 'lowest' } = options\n\n    if (!at) {\n      return\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n)\n      }\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, { voids })\n    }\n\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor\n      } else {\n        const [, end] = Range.edges(at)\n        const pointRef = Editor.pointRef(editor, end)\n        Transforms.delete(editor, { at })\n        at = pointRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n    }\n\n    const [current] = Editor.nodes(editor, { at, match, voids, mode })\n    const prev = Editor.previous(editor, { at, match, voids, mode })\n\n    if (!current || !prev) {\n      return\n    }\n\n    const [node, path] = current\n    const [prevNode, prevPath] = prev\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return\n    }\n\n    const newPath = Path.next(prevPath)\n    const commonPath = Path.common(path, prevPath)\n    const isPreviousSibling = Path.isSibling(path, prevPath)\n    const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n      .slice(commonPath.length)\n      .slice(0, -1)\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: n => levels.includes(n) && hasSingleChildNest(editor, n),\n    })\n\n    const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n    let properties\n    let position\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      const { text, ...rest } = node\n      position = prevNode.text.length\n      properties = rest as Partial<Text>\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      const { children, ...rest } = node\n      position = prevNode.children.length\n      properties = rest as Partial<Element>\n    } else {\n      throw new Error(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${Scrubber.stringify(\n          node\n        )} ${Scrubber.stringify(prevNode)}`\n      )\n    }\n\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n    }\n\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n    }\n\n    if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {\n      Transforms.removeNodes(editor, { at: prevPath, voids })\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties,\n      })\n    }\n\n    if (emptyRef) {\n      emptyRef.unref()\n    }\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { matchPath } from '../utils/match-path'\nimport { Element } from '../interfaces/element'\n\nexport const moveNodes: NodeTransforms['moveNodes'] = (editor, options) => {\n  Editor.withoutNormalizing(editor, () => {\n    const {\n      to,\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!at) {\n      return\n    }\n\n    if (match == null) {\n      match = Path.isPath(at)\n        ? matchPath(editor, at)\n        : n => Element.isElement(n) && Editor.isBlock(editor, n)\n    }\n\n    const toRef = Editor.pathRef(editor, to)\n    const targets = Editor.nodes(editor, { at, match, mode, voids })\n    const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!\n      const newPath = toRef.current!\n\n      if (path.length !== 0) {\n        editor.apply({ type: 'move_node', path, newPath })\n      }\n\n      if (\n        toRef.current &&\n        Path.isSibling(newPath, path) &&\n        Path.isAfter(newPath, path)\n      ) {\n        // When performing a sibling move to a later index, the path at the destination is shifted\n        // to before the insertion point instead of after. To ensure our group of nodes are inserted\n        // in the correct order we increment toRef to account for that\n        toRef.current = Path.next(toRef.current)\n      }\n    }\n\n    toRef.unref()\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { matchPath } from '../utils/match-path'\nimport { Element } from '../interfaces/element'\nimport { Range } from '../interfaces/range'\n\nexport const removeNodes: NodeTransforms['removeNodes'] = (\n  editor,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    const { hanging = false, voids = false, mode = 'lowest' } = options\n    let { at = editor.selection, match } = options\n\n    if (!at) {\n      return\n    }\n\n    if (match == null) {\n      match = Path.isPath(at)\n        ? matchPath(editor, at)\n        : n => Element.isElement(n) && Editor.isBlock(editor, n)\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, { voids })\n    }\n\n    const depths = Editor.nodes(editor, { at, match, mode, voids })\n    const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!\n\n      if (path) {\n        const [node] = Editor.node(editor, path)\n        editor.apply({ type: 'remove_node', path, node })\n      }\n    }\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { matchPath } from '../utils/match-path'\nimport { Element } from '../interfaces/element'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\nimport { Node } from '../interfaces/node'\n\nexport const setNodes: NodeTransforms['setNodes'] = (\n  editor,\n  props: Partial<Node>,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    let { match, at = editor.selection, compare, merge } = options\n    const {\n      hanging = false,\n      mode = 'lowest',\n      split = false,\n      voids = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    if (match == null) {\n      match = Path.isPath(at)\n        ? matchPath(editor, at)\n        : n => Element.isElement(n) && Editor.isBlock(editor, n)\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, { voids })\n    }\n\n    if (split && Range.isRange(at)) {\n      if (\n        Range.isCollapsed(at) &&\n        Editor.leaf(editor, at.anchor)[0].text.length > 0\n      ) {\n        // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n        // set that won't get normalized away\n        return\n      }\n      const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n      const [start, end] = Range.edges(at)\n      const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n      const endAtEndOfNode = Editor.isEnd(editor, end, end.path)\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        mode: splitMode,\n        voids,\n        always: !endAtEndOfNode,\n      })\n      const startAtStartOfNode = Editor.isStart(editor, start, start.path)\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        mode: splitMode,\n        voids,\n        always: !startAtStartOfNode,\n      })\n      at = rangeRef.unref()!\n\n      if (options.at == null) {\n        Transforms.select(editor, at)\n      }\n    }\n\n    if (!compare) {\n      compare = (prop, nodeProp) => prop !== nodeProp\n    }\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids,\n    })) {\n      const properties: Partial<Node> = {}\n      // FIXME: is this correct?\n      const newProperties: Partial<Node> & { [key: string]: unknown } = {}\n\n      // You can't set properties on the editor node.\n      if (path.length === 0) {\n        continue\n      }\n\n      let hasChanges = false\n\n      for (const k in props) {\n        if (k === 'children' || k === 'text') {\n          continue\n        }\n\n        if (compare(props[<keyof Node>k], node[<keyof Node>k])) {\n          hasChanges = true\n          // Omit new properties from the old properties list\n          if (node.hasOwnProperty(k))\n            properties[<keyof Node>k] = node[<keyof Node>k]\n          // Omit properties that have been removed from the new properties list\n          if (merge) {\n            if (props[<keyof Node>k] != null)\n              newProperties[<keyof Node>k] = merge(\n                node[<keyof Node>k],\n                props[<keyof Node>k]\n              )\n          } else {\n            if (props[<keyof Node>k] != null)\n              newProperties[<keyof Node>k] = props[<keyof Node>k]\n          }\n        }\n      }\n\n      if (hasChanges) {\n        editor.apply({\n          type: 'set_node',\n          path,\n          properties,\n          newProperties,\n        })\n      }\n    }\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Element } from '../interfaces/element'\nimport { Range } from '../interfaces/range'\nimport { Path } from '../interfaces/path'\nimport { PointRef } from '../interfaces/point-ref'\nimport { Transforms } from '../interfaces/transforms'\nimport { Node } from '../interfaces/node'\nimport { Point } from '../interfaces/point'\n\n/**\n * Convert a range into a point by deleting it's content.\n */\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nexport const splitNodes: NodeTransforms['splitNodes'] = (\n  editor,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection, height = 0, always = false } = options\n\n    if (match == null) {\n      match = n => Element.isElement(n) && Editor.isBlock(editor, n)\n    }\n\n    if (Range.isRange(at)) {\n      at = deleteRange(editor, at)\n    }\n\n    // If the target is a path, the default height-skipping and position\n    // counters need to account for us potentially splitting at a non-leaf.\n    if (Path.isPath(at)) {\n      const path = at\n      const point = Editor.point(editor, path)\n      const [parent] = Editor.parent(editor, path)\n      match = n => n === parent\n      height = point.path.length - path.length + 1\n      at = point\n      always = true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const beforeRef = Editor.pointRef(editor, at, {\n      affinity: 'backward',\n    })\n    let afterRef: PointRef | undefined\n    try {\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Element.isElement(node) && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const properties = Node.extractProps(node)\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n    } finally {\n      beforeRef.unref()\n      afterRef?.unref()\n    }\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Transforms } from '../interfaces/transforms'\n\nexport const unsetNodes: NodeTransforms['unsetNodes'] = (\n  editor,\n  props,\n  options = {}\n) => {\n  if (!Array.isArray(props)) {\n    props = [props]\n  }\n\n  const obj: any = {}\n\n  for (const key of props) {\n    obj[key] = null\n  }\n\n  Transforms.setNodes(editor, obj, options)\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { matchPath } from '../utils/match-path'\nimport { Element } from '../interfaces/element'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\n\nexport const unwrapNodes: NodeTransforms['unwrapNodes'] = (\n  editor,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    const { mode = 'lowest', split = false, voids = false } = options\n    let { at = editor.selection, match } = options\n\n    if (!at) {\n      return\n    }\n\n    if (match == null) {\n      match = Path.isPath(at)\n        ? matchPath(editor, at)\n        : n => Element.isElement(n) && Editor.isBlock(editor, n)\n    }\n\n    if (Path.isPath(at)) {\n      at = Editor.range(editor, at)\n    }\n\n    const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n    const matches = Editor.nodes(editor, { at, match, mode, voids })\n    const pathRefs = Array.from(\n      matches,\n      ([, p]) => Editor.pathRef(editor, p)\n      // unwrapNode will call liftNode which does not support splitting the node when nested.\n      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n      // that wrap target node. So we reverse the order.\n    ).reverse()\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!\n      const [node] = Editor.node(editor, path)\n      let range = Editor.range(editor, path)\n\n      if (split && rangeRef) {\n        range = Range.intersection(rangeRef.current!, range)!\n      }\n\n      Transforms.liftNodes(editor, {\n        at: range,\n        match: n => Element.isAncestor(node) && node.children.includes(n),\n        voids,\n      })\n    }\n\n    if (rangeRef) {\n      rangeRef.unref()\n    }\n  })\n}\n","import { NodeTransforms } from '../interfaces/transforms/node'\nimport { Editor } from '../interfaces/editor'\nimport { Path } from '../interfaces/path'\nimport { matchPath } from '../utils/match-path'\nimport { Element } from '../interfaces/element'\nimport { Text } from '../interfaces/text'\nimport { Range } from '../interfaces/range'\nimport { Transforms } from '../interfaces/transforms'\nimport { Point } from '../interfaces'\n\nexport const wrapNodes: NodeTransforms['wrapNodes'] = (\n  editor,\n  element,\n  options = {}\n) => {\n  Editor.withoutNormalizing(editor, () => {\n    const { mode = 'lowest', split = false, voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        match = matchPath(editor, at)\n      } else if (editor.isInline(element)) {\n        match = n =>\n          (Element.isElement(n) && Editor.isInline(editor, n)) || Text.isText(n)\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n)\n      }\n    }\n\n    if (split && Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n\n      const rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward',\n      })\n\n      // Always split if we're in the middle of a block, to ensure that text\n      // node boundaries are handled correctly.\n      const isAtBlockEdge = (point: Point) => {\n        const blockAbove = Editor.above(editor, {\n          at: point,\n          match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n        })\n        return blockAbove && Editor.isEdge(editor, point, blockAbove[1])\n      }\n\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        voids,\n        always: !isAtBlockEdge(end),\n      })\n\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        voids,\n        always: !isAtBlockEdge(start),\n      })\n\n      at = rangeRef.unref()!\n\n      if (options.at == null) {\n        Transforms.select(editor, at)\n      }\n    }\n\n    const roots = Array.from(\n      Editor.nodes(editor, {\n        at,\n        match: editor.isInline(element)\n          ? n => Element.isElement(n) && Editor.isBlock(editor, n)\n          : n => Editor.isEditor(n),\n        mode: 'lowest',\n        voids,\n      })\n    )\n\n    for (const [, rootPath] of roots) {\n      const a = Range.isRange(at)\n        ? Range.intersection(at, Editor.range(editor, rootPath))\n        : at\n\n      if (!a) {\n        continue\n      }\n\n      const matches = Array.from(\n        Editor.nodes(editor, { at: a, match, mode, voids })\n      )\n\n      if (matches.length > 0) {\n        const [first] = matches\n        const last = matches[matches.length - 1]\n        const [, firstPath] = first\n        const [, lastPath] = last\n\n        if (firstPath.length === 0 && lastPath.length === 0) {\n          // if there's no matching parent - usually means the node is an editor - don't do anything\n          continue\n        }\n\n        const commonPath = Path.equals(firstPath, lastPath)\n          ? Path.parent(firstPath)\n          : Path.common(firstPath, lastPath)\n\n        const range = Editor.range(editor, firstPath, lastPath)\n        const commonNodeEntry = Editor.node(editor, commonPath)\n        const [commonNode] = commonNodeEntry\n        const depth = commonPath.length + 1\n        const wrapperPath = Path.next(lastPath.slice(0, depth))\n        const wrapper = { ...element, children: [] }\n        Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n        Transforms.moveNodes(editor, {\n          at: range,\n          match: n =>\n            Element.isAncestor(commonNode) && commonNode.children.includes(n),\n          to: wrapperPath.concat(0),\n          voids,\n        })\n      }\n    }\n  })\n}\n","import {\n  addMark,\n  deleteFragment,\n  Editor,\n  getDirtyPaths,\n  getFragment,\n  insertBreak,\n  insertFragment,\n  insertNode,\n  insertSoftBreak,\n  insertText,\n  normalizeNode,\n  removeMark,\n  shouldNormalize,\n} from './'\nimport { apply } from './core'\nimport {\n  above,\n  after,\n  before,\n  deleteBackward,\n  deleteForward,\n  edges,\n  elementReadOnly,\n  end,\n  first,\n  fragment,\n  getVoid,\n  hasBlocks,\n  hasInlines,\n  hasPath,\n  hasTexts,\n  isBlock,\n  isEdge,\n  isEmpty,\n  isEnd,\n  isNormalizing,\n  isStart,\n  last,\n  leaf,\n  levels,\n  marks,\n  next,\n  node,\n  nodes,\n  normalize,\n  parent,\n  path,\n  pathRef,\n  pathRefs,\n  point,\n  pointRef,\n  pointRefs,\n  positions,\n  previous,\n  range,\n  rangeRef,\n  rangeRefs,\n  setNormalizing,\n  shouldMergeNodesRemovePrevNode,\n  start,\n  string,\n  unhangRange,\n  withoutNormalizing,\n} from './editor'\nimport { deleteText } from './transforms-text'\nimport {\n  collapse,\n  deselect,\n  move,\n  select,\n  setPoint,\n  setSelection,\n} from './transforms-selection'\nimport {\n  insertNodes,\n  liftNodes,\n  mergeNodes,\n  moveNodes,\n  removeNodes,\n  setNodes,\n  splitNodes,\n  unsetNodes,\n  unwrapNodes,\n  wrapNodes,\n} from './transforms-node'\n\n/**\n * Create a new Slate `Editor` object.\n */\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isElementReadOnly: () => false,\n    isInline: () => false,\n    isSelectable: () => true,\n    isVoid: () => false,\n    markableVoid: () => false,\n    onChange: () => {},\n\n    // Core\n    apply: (...args) => apply(editor, ...args),\n\n    // Editor\n    addMark: (...args) => addMark(editor, ...args),\n    deleteBackward: (...args) => deleteBackward(editor, ...args),\n    deleteForward: (...args) => deleteForward(editor, ...args),\n    deleteFragment: (...args) => deleteFragment(editor, ...args),\n    getFragment: (...args) => getFragment(editor, ...args),\n    insertBreak: (...args) => insertBreak(editor, ...args),\n    insertSoftBreak: (...args) => insertSoftBreak(editor, ...args),\n    insertFragment: (...args) => insertFragment(editor, ...args),\n    insertNode: (...args) => insertNode(editor, ...args),\n    insertText: (...args) => insertText(editor, ...args),\n    normalizeNode: (...args) => normalizeNode(editor, ...args),\n    removeMark: (...args) => removeMark(editor, ...args),\n    getDirtyPaths: (...args) => getDirtyPaths(editor, ...args),\n    shouldNormalize: (...args) => shouldNormalize(editor, ...args),\n\n    // Editor interface\n    above: (...args) => above(editor, ...args),\n    after: (...args) => after(editor, ...args),\n    before: (...args) => before(editor, ...args),\n    collapse: (...args) => collapse(editor, ...args),\n    delete: (...args) => deleteText(editor, ...args),\n    deselect: (...args) => deselect(editor, ...args),\n    edges: (...args) => edges(editor, ...args),\n    elementReadOnly: (...args) => elementReadOnly(editor, ...args),\n    end: (...args) => end(editor, ...args),\n    first: (...args) => first(editor, ...args),\n    fragment: (...args) => fragment(editor, ...args),\n    getMarks: (...args) => marks(editor, ...args),\n    hasBlocks: (...args) => hasBlocks(editor, ...args),\n    hasInlines: (...args) => hasInlines(editor, ...args),\n    hasPath: (...args) => hasPath(editor, ...args),\n    hasTexts: (...args) => hasTexts(editor, ...args),\n    insertNodes: (...args) => insertNodes(editor, ...args),\n    isBlock: (...args) => isBlock(editor, ...args),\n    isEdge: (...args) => isEdge(editor, ...args),\n    isEmpty: (...args) => isEmpty(editor, ...args),\n    isEnd: (...args) => isEnd(editor, ...args),\n    isNormalizing: (...args) => isNormalizing(editor, ...args),\n    isStart: (...args) => isStart(editor, ...args),\n    last: (...args) => last(editor, ...args),\n    leaf: (...args) => leaf(editor, ...args),\n    levels: (...args) => levels(editor, ...args),\n    liftNodes: (...args) => liftNodes(editor, ...args),\n    mergeNodes: (...args) => mergeNodes(editor, ...args),\n    move: (...args) => move(editor, ...args),\n    moveNodes: (...args) => moveNodes(editor, ...args),\n    next: (...args) => next(editor, ...args),\n    node: (...args) => node(editor, ...args),\n    nodes: (...args) => nodes(editor, ...args),\n    normalize: (...args) => normalize(editor, ...args),\n    parent: (...args) => parent(editor, ...args),\n    path: (...args) => path(editor, ...args),\n    pathRef: (...args) => pathRef(editor, ...args),\n    pathRefs: (...args) => pathRefs(editor, ...args),\n    point: (...args) => point(editor, ...args),\n    pointRef: (...args) => pointRef(editor, ...args),\n    pointRefs: (...args) => pointRefs(editor, ...args),\n    positions: (...args) => positions(editor, ...args),\n    previous: (...args) => previous(editor, ...args),\n    range: (...args) => range(editor, ...args),\n    rangeRef: (...args) => rangeRef(editor, ...args),\n    rangeRefs: (...args) => rangeRefs(editor, ...args),\n    removeNodes: (...args) => removeNodes(editor, ...args),\n    select: (...args) => select(editor, ...args),\n    setNodes: (...args) => setNodes(editor, ...args),\n    setNormalizing: (...args) => setNormalizing(editor, ...args),\n    setPoint: (...args) => setPoint(editor, ...args),\n    setSelection: (...args) => setSelection(editor, ...args),\n    splitNodes: (...args) => splitNodes(editor, ...args),\n    start: (...args) => start(editor, ...args),\n    string: (...args) => string(editor, ...args),\n    unhangRange: (...args) => unhangRange(editor, ...args),\n    unsetNodes: (...args) => unsetNodes(editor, ...args),\n    unwrapNodes: (...args) => unwrapNodes(editor, ...args),\n    void: (...args) => getVoid(editor, ...args),\n    withoutNormalizing: (...args) => withoutNormalizing(editor, ...args),\n    wrapNodes: (...args) => wrapNodes(editor, ...args),\n    shouldMergeNodesRemovePrevNode: (...args) =>\n      shouldMergeNodesRemovePrevNode(editor, ...args),\n  }\n\n  return editor\n}\n"],"names":["PathRef","transform","ref","op","current","affinity","path","Path","unref","PointRef","point","Point","RangeRef","Range","DIRTY_PATHS","WeakMap","DIRTY_PATH_KEYS","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","ancestors","options","arguments","length","undefined","_options$reverse","reverse","paths","levels","slice","common","another","i","av","bv","push","compare","min","Math","endsAfter","as","bs","equals","endsAt","endsBefore","every","n","hasPrevious","isAfter","isAncestor","isBefore","isChild","isCommon","isDescendant","isParent","isPath","value","Array","isArray","isSibling","al","bl","_options$reverse2","list","next","Error","concat","last","operationCanTransformPath","operation","type","parent","previous","relative","ancestor","p","_toConsumableArray","_options$affinity","position","onp","newPath","copy","require$$0","insertChildren","xs","index","_len","newValues","_key","replaceChildren","removeCount","_len2","_key2","removeChildren","modifyDescendant","editor","f","node","Node","get","slicedPath","modifiedNode","pop","ancestorNode","_objectSpread","children","modifyChildren","Text","isText","Scrubber","stringify","modifyLeaf","GeneralTransforms","transformSelection","offset","text","before","after","prevPath","prevIndex","prev","newNode","truePath","newIndex","selection","_iterator","_createForOfIteratorHelper","points","_step","s","done","_step$value","_slicedToArray","key","result","_iterator2","texts","_step2","_step2$value","err","e","preferNext","properties","newProperties","hasOwnProperty","isRange","nextNode","_iterator3","_step3","_step3$value","NodeTransforms","insertNodes","nodes","liftNodes","mergeNodes","moveNodes","removeNodes","setNodes","props","splitNodes","unsetNodes","unwrapNodes","wrapNodes","element","SelectionTransforms","collapse","deselect","move","select","target","setPoint","setSelection","isObject","_typeof","isDeepEqual","a","b","edges","range","anchor","focus","isBackward","end","_Range$edges","_Range$edges2","surrounds","intersectionRange","intersection","includes","_Range$edges3","_Range$edges4","rs","re","_Range$edges5","_Range$edges6","ts","te","_Range$edges7","_Range$edges8","start","isAfterStart","isBeforeEnd","isPoint","rest","_objectWithoutProperties","_excluded","_Range$edges9","_Range$edges10","s1","e1","_Range$edges11","_Range$edges12","s2","e2","isCollapsed","isExpanded","isForward","_Range$edges13","_Range$edges14","affinityAnchor","affinityFocus","isElement","_ref","_ref$deep","deep","isEditor","apply","isChildrenValid","isNodeList","Element","_ref2","_ref2$deep","isElementList","_ref3","_ref3$deep","val","isElementProps","isElementType","elementVal","elementKey","matches","root","entry","child","c","childPath","descendant","Editor","descendants","elements","extractProps","_excluded2","first","fragment","newRoot","produce","r","nodeEntries","pass","_iterator4","_step4","_step4$value","splice","leaf","getIf","has","isNode","_ref4","_ref4$deep","_iterator5","_step5","isTextProps","_options$from","from","to","visited","Set","add","nextIndex","parentPath","string","map","join","_iterator6","_step6","_step6$value","Operation","isNodeOperation","isOperation","endsWith","isOperationList","isSelectionOperation","isTextOperation","inverse","inversePath","inverseNewPath","addMark","deleteFragment","insertBreak","insertSoftBreak","insertFragment","insertNode","insertText","isElementReadOnly","isInline","isSelectable","isVoid","normalizeNode","onChange","removeMark","getDirtyPaths","marks","operations","above","at","deleteBackward","_options$unit","unit","deleteForward","_options$unit2","elementReadOnly","hasBlocks","hasInlines","hasPath","hasTexts","isBlock","isEdge","isEmpty","isEnd","isNormalizing","isStart","getMarks","normalize","pathRef","pathRefs","pointRef","pointRefs","positions","rangeRef","rangeRefs","setNormalizing","unhangRange","_void","withoutNormalizing","fn","shouldMergeNodesRemovePrevNode","prevNode","curNode","Location","isLocation","Span","isSpan","_scrubber","setScrubber","scrubber","JSON","_options$loose","loose","omitText","obj","isTextList","decorations","leaves","dec","mergeDecoration","merge","leafEnd","decorationStart","decorationEnd","Object","assign","leafStart","middle","off","currentOffset","entries","item","isFirst","isLast","getDefaultInsertLocation","matchPath","_Editor$node","_Editor$node2","getCharacterDistance","str","isRTL","isLTR","codepoints","codepointsIteratorRTL","left","CodepointType","None","right","distance","gb11","gb12Or13","char","code","codePointAt","getCodepointType","intersects","ZWJ","ExtPict","endsWithEmojiZWJ","substring","RI","endsWithOddNumberOfRIs","isBoundaryPair","SPACE","PUNCTUATION","CHAMELEON","getWordDistance","dist","started","charDist","_splitByCharacterDist","splitByCharacterDistance","_splitByCharacterDist2","remaining","isWordCharacter","test","_splitByCharacterDist3","_splitByCharacterDist4","nextChar","nextRemaining","char1","charAt","isLowSurrogate","charCodeAt","char2","isHighSurrogate","charCode","reExtend","rePrepend","reSpacingMark","reL","reV","reT","reLV","reLVT","reExtPict","Any","search","Extend","Prepend","SpacingMark","L","V","T","LV","LVT","x","y","NonBoundaryPairs","findIndex","endingEmojiZWJ","endingRIs","match","numRIs","TextTransforms","_delete","_options$voids","voids","_options$at","startRef","endRef","Transforms","startPoint","endPoint","_at","BATCHING_DIRTY_PATHS","isBatchingDirtyPaths","batchDirtyPaths","update","set","updateDirtyPaths","newDirtyPaths","oldDirtyPaths","oldDirtyPathKeys","dirtyPaths","dirtyPathKeys","Promise","resolve","then","previousPath","oldAncestors","newAncestors","newParent","resultPath","nextPath","getFragment","_entry","shouldHaveInlines","currentNode","isInlineOrText","fallbackElement","newChild","elementChild","shouldNormalize","iteration","initialDirtyPathsLength","maxIterations","_options$mode","mode","_Editor$levels","_Editor$levels2","firstMatch","_Editor$parent","_Editor$parent2","parentNode","markableVoid","expandedSelection","markAcceptingVoidSelected","selectedNode","selectedPath","_Editor$parent3","_Editor$parent4","_defineProperty","split","edge","_options$distance","d","_ref$direction","direction","getVoid","some","always","_children","_Editor$nodes","_Editor$nodes2","_match","_anchor","_Editor$leaf","_Editor$leaf2","markedVoid","block","_prev","_block","blockPath","_node2","pointAfterLocation","_Editor$last","_Editor$last2","span","_options$universal","universal","hit","isLower","emit","_options$force","force","getDirtyPathKeys","popDirtyPath","allPaths","allPathKeys","dirtyPath","_entry2","_","refs","depth","_Node$first","_Node$first2","firstPath","_Node$last","_Node$last2","lastPath","_options$edge","isNewBlock","blockText","leafTextRemaining","leafTextOffset","skippedPaths","_loop","hasSkippedAncestor","maybeYield","calcDistance","_ret","pointBeforeLocation","_Editor$first","_Editor$first2","t","endBlock","skip","curNodePath","deleteText","_Editor$void","_Editor$void2","_options$hanging","hanging","furthestVoid","_furthestVoid","voidPath","opts","endOfDoc","startBlock","isAcrossBlocks","isSingleText","startNonEditable","endNonEditable","removedText","_start","filter","forEach","_Editor$leaf3","_Editor$leaf4","startUnref","endUnref","_options$batchDirty","batchDirty","inlineElementMatch","_inlineElementMatch","inlinePath","blockMatch","_blockMatch","isBlockStart","isBlockEnd","isBlockEmpty","firstLeafPath","lastLeafPath","shouldInsert","isRoot","starting","starts","middles","ends","inlineMatch","_inlineMatch","isInlineStart","isInlineEnd","middleRef","splitBlock","oldProps","newProps","k","keys","_nodes","_nodes2","isAtEnd","batchedOps","_i","_batchedOps","_pathRefs","parentNodeEntry","_parentNodeEntry","toPath","splitPath","hasSingleChildNest","_current","commonPath","isPreviousSibling","emptyAncestor","emptyRef","toRef","targets","depths","_options$split","splitMode","endAtEndOfNode","startAtStartOfNode","prop","nodeProp","hasChanges","deleteRange","_options$height","height","_options$always","beforeRef","afterRef","highest","voidMatch","nudge","_voidMatch","voidNode","afterPath","siblingHeight","_highest","highestPath","lowestPath","_afterRef","isAtBlockEdge","blockAbove","roots","_roots$_i","_roots","rootPath","_first","_last","commonNodeEntry","_commonNodeEntry","commonNode","wrapperPath","wrapper","createEditor","args","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","_len7","_key7","_len8","_key8","_len9","_key9","_len10","_key10","_len11","_key11","_len12","_key12","_len13","_key13","_len14","_key14","_len15","_key15","_len16","_key16","_len17","_key17","_len18","_key18","_len19","_key19","_len20","_key20","_len21","_key21","_len22","_key22","_len23","_key23","_len24","_key24","_len25","_key25","_len26","_key26","_len27","_key27","_len28","_key28","_len29","_key29","_len30","_key30","_len31","_key31","_len32","_key32","_len33","_key33","_len34","_key34","_len35","_key35","_len36","_key36","_len37","_key37","_len38","_key38","_len39","_key39","_len40","_key40","_len41","_key41","_len42","_key42","_len43","_key43","_len44","_key44","_len45","_key45","_len46","_key46","_len47","_key47","_len48","_key48","_len49","_key49","_len50","_key50","_len51","_key51","_len52","_key52","_len53","_key53","_len54","_key54","_len55","_key55","_len56","_key56","_len57","_key57","_len58","_key58","_len59","_key59","_len60","_key60","_len61","_key61","_len62","_key62","_len63","_key63","_len64","_key64","_len65","_key65","_len66","_key66","_len67","_key67","_len68","_key68","_len69","_key69","_len70","_key70","_len71","_key71","_len72","_key72","_len73","_key73","_len74","_key74","_len75","_key75","_len76","_key76","_len77","_key77"],"mappings":"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","x_google_ignoreList":[4,5,6,7,8,9,11,12,13,14,15,16,17,18,24,25]}