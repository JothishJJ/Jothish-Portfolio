{"version":3,"file":"experimental.js","sources":["../src/unparse.ts"],"sourcesContent":["import type {ExprNode} from './nodeTypes'\n\nconst IDENT_RE = /^[a-zA-Z_][a-zA-Z_0-9]*/\nconst isIdent = (s: string) => IDENT_RE.test(s)\nconst json = (v: unknown) => JSON.stringify(v)\n\n/** Property accessor: `.name` if identifier-like, else `[\"name\"]` */\nconst prop = (name: string) => (isIdent(name) ? `.${name}` : `[${json(name)}]`)\n/** Property accessor with a custom prefix (e.g. `->`) */\nconst propWith = (prefix: string, name: string) =>\n  `${prefix}${isIdent(name) ? `.${name}` : `[${json(name)}]`}`\n\n/** Join args with `, ` after unparsing */\nconst joinArgs = (args: ExprNode[]) => args.map(unparse).join(', ')\n\n/**\n * Converts a GROQ AST node back into a GROQ query string.\n *\n * **Limitation**: This function cannot preserve parameter references. When a query\n * is parsed with parameters (e.g., `parse(query, {params: {name: \"value\"}})`),\n * the parameters are resolved to their values in the AST. Unparsing such a tree\n * will produce literals instead of parameter references (e.g., `\"value\"` instead\n * of `$name`). This means `parse(unparse(tree))` will produce a different AST\n * when the original tree contained resolved parameters.\n */\n// eslint-disable-next-line complexity\nexport function unparse(node: ExprNode): string {\n  switch (node.type) {\n    case 'AccessAttribute': {\n      // Prefer dotted access for identifiers, else bracket access.\n      if (isIdent(node.name)) {\n        return node.base ? `${unparse(node.base)}.${node.name}` : node.name\n      }\n      // If there's no base, treat it like `This` for bracketed access.\n      const base = node.base || {type: 'This'}\n      return `${unparse(base)}[${json(node.name)}]`\n    }\n\n    case 'AccessElement':\n      return `${unparse(node.base)}[${node.index}]`\n\n    case 'Array':\n      return `[${node.elements\n        .map(({value, isSplat}) => (isSplat ? `...${unparse(value)}` : unparse(value)))\n        .join(', ')}]`\n\n    case 'ArrayCoerce':\n      return `${unparse(node.base)}[]`\n\n    case 'Asc':\n      return `${unparse(node.base)} asc`\n\n    case 'Desc':\n      return `${unparse(node.base)} desc`\n\n    case 'And':\n      return `${unparse(node.left)} && ${unparse(node.right)}`\n\n    case 'Or':\n      return `${unparse(node.left)} || ${unparse(node.right)}`\n\n    case 'OpCall':\n      return `${unparse(node.left)} ${node.op} ${unparse(node.right)}`\n\n    case 'Filter':\n      return `${unparse(node.base)}[${unparse(node.expr)}]`\n\n    case 'Everything':\n      return '*'\n\n    case 'This':\n      return '@'\n\n    case 'Value':\n      return json(node.value)\n\n    case 'PipeFuncCall':\n      return `${unparse(node.base)}|${node.name}(${joinArgs(node.args)})`\n\n    case 'FuncCall':\n      return `${node.namespace}::${node.name}(${joinArgs(node.args)})`\n\n    case 'Deref':\n      return `${unparse(node.base)}->`\n\n    case 'Map':\n    case 'Projection':\n      // Both serialize as base + map-expression\n      return `${unparse(node.base)}${unparseMapExpr(node.expr)}`\n\n    case 'FlatMap':\n      return `${unparse(node.base)}${unparseFlatMapExpr(node.expr)}`\n\n    case 'Object':\n      return `{${node.attributes\n        .map((attr) => {\n          switch (attr.type) {\n            case 'ObjectAttributeValue':\n              return `${json(attr.name)}: ${unparse(attr.value)}`\n            case 'ObjectConditionalSplat':\n              return `${unparse(attr.condition)} => ${unparse(attr.value)}`\n            case 'ObjectSplat':\n              return `...${unparse(attr.value)}`\n            default:\n              throw new Error(`Unknown object attribute type: ${attr['type'] as string}`)\n          }\n        })\n        .join(', ')}}`\n\n    case 'Pos':\n      return `+${unparse(node.base)}`\n\n    case 'Neg':\n      return `-${unparse(node.base)}`\n\n    case 'Group':\n      return `(${unparse(node.base)})`\n\n    case 'Not':\n      return `!${unparse(node.base)}`\n\n    case 'InRange':\n      return `${unparse(node.base)} in ${unparse(node.left)}${\n        node.isInclusive ? '..' : '...'\n      }${unparse(node.right)}`\n\n    case 'Parent':\n      return Array.from({length: node.n}, () => '^').join('.')\n\n    case 'Parameter':\n      return `$${node.name}`\n\n    case 'Slice':\n      return `${unparse(node.base)}[${node.left}${node.isInclusive ? '..' : '...'}${node.right}]`\n\n    case 'Select': {\n      const alts = node.alternatives.map(\n        ({condition, value}) => `${unparse(condition)} => ${unparse(value)}`,\n      )\n      if (node.fallback) alts.push(unparse(node.fallback))\n      return `select(${alts.join(', ')})`\n    }\n\n    case 'Tuple':\n      return `(${node.members.map(unparse).join(', ')})`\n\n    case 'SelectorFuncCall':\n      return `${node.name}(${unparse(node.arg)})`\n\n    case 'SelectorNested':\n      return `${unparseSelector(node.base)}.(${unparseSelector(node.nested)})`\n\n    default:\n      throw new Error(`TODO: ${node['type'] as string}`)\n  }\n}\n\nfunction unparseSelector(node: ExprNode): string {\n  switch (node.type) {\n    case 'AccessAttribute':\n      return node.base ? `${unparseSelector(node.base)}.${node.name}` : node.name\n\n    case 'Group':\n      return `(${unparseSelector(node.base)})`\n\n    case 'Tuple':\n      return `(${node.members.map(unparseSelector).join(', ')})`\n\n    case 'ArrayCoerce':\n      return `${unparseSelector(node.base)}[]`\n\n    case 'Filter':\n      return `${unparseSelector(node.base)}[${unparse(node.expr)}]`\n\n    case 'SelectorFuncCall':\n      return `${node.name}(${unparse(node.arg)})`\n\n    case 'SelectorNested':\n      return `${unparseSelector(node.base)}.(${unparseSelector(node.nested)})`\n\n    default:\n      // Fall back to the general unparser when selector-specific cases donâ€™t apply.\n      return unparse(node)\n  }\n}\n\nfunction unparseMapExpr(node: ExprNode): string {\n  // AccessAttribute chains with special handling for This/Deref\n  if (node.type === 'AccessAttribute') {\n    // this.<name> / this[\"name\"]\n    if (node.base?.type === 'This') return prop(node.name)\n\n    // this->.<name> / this->[\"name\"]\n    if (node.base?.type === 'Deref' && node.base.base?.type === 'This') {\n      return propWith('->', node.name)\n    }\n\n    // (this.attr)->.<name> / ...->[\"name\"]\n    if (node.base?.type === 'Deref' && node.base.base?.type === 'AccessAttribute') {\n      const derefBase = unparseMapExpr(node.base.base)\n      return isIdent(node.name)\n        ? `${derefBase}->.${node.name}`\n        : `${derefBase}->[${json(node.name)}]`\n    }\n\n    // Generic attribute or element bases: append property\n    if (node.base?.type === 'AccessAttribute' || node.base?.type === 'AccessElement') {\n      const base = unparseMapExpr(node.base)\n      return `${base}${prop(node.name)}`\n    }\n  }\n\n  if (node.type === 'AccessElement') {\n    const base = unparseMapExpr(node.base)\n    return `${base}[${node.index}]`\n  }\n\n  if (node.type === 'Deref' && node.base?.type === 'This') {\n    return '->'\n  }\n\n  if (node.type === 'ArrayCoerce') {\n    return `${unparseMapExpr(node.base)}[]`\n  }\n\n  if (node.type === 'Filter') {\n    return `${unparseMapExpr(node.base)}[${unparse(node.expr)}]`\n  }\n\n  if (node.type === 'Projection') {\n    if (node.base?.type === 'This') return unparseMapExpr(node.expr)\n\n    if (node.base?.type === 'Deref') {\n      if (node.base.base?.type === 'This') return `->${unparse(node.expr)}`\n      if (node.base.base?.type === 'AccessAttribute') {\n        const derefBase = unparseMapExpr(node.base.base)\n        return `${derefBase}->${unparse(node.expr)}`\n      }\n    }\n\n    if (node.base?.type === 'Projection') {\n      return unparseMapExpr(node.base) + unparse(node.expr)\n    }\n  }\n\n  if (node.type === 'Map') return unparseMapExpr(node.expr)\n  if (node.type === 'Object') return unparse(node)\n\n  // Fallback to general unparse for anything else\n  return unparse(node)\n}\n\nfunction unparseFlatMapExpr(node: ExprNode): string {\n  if (node.type === 'AccessAttribute') {\n    // this.<name> / this[\"name\"]\n    if (node.base?.type === 'This') return prop(node.name)\n\n    if (node.base?.type === 'Deref') {\n      // this->.<name> / this->[\"name\"]\n      if (node.base.base?.type === 'This') return propWith('->', node.name)\n\n      // Deref with any base expression: <base>->.<name> / <base>->[\"name\"]\n      const derefBase = unparseFlatMapExpr(node.base.base)\n      return isIdent(node.name)\n        ? `${derefBase}->.${node.name}`\n        : `${derefBase}->[${json(node.name)}]`\n    }\n\n    // Generic attribute/element bases\n    if (node.base?.type === 'AccessAttribute' || node.base?.type === 'AccessElement') {\n      const base = unparseFlatMapExpr(node.base)\n      return `${base}${prop(node.name)}`\n    }\n  }\n\n  if (node.type === 'AccessElement') {\n    const base = unparseFlatMapExpr(node.base)\n    return `${base}[${node.index}]`\n  }\n\n  if (node.type === 'ArrayCoerce') {\n    return `${unparseFlatMapExpr(node.base)}[]`\n  }\n\n  if (node.type === 'Map') {\n    const base = unparseFlatMapExpr(node.base)\n    const expr = unparseMapExpr(node.expr)\n    return `${base}${expr}`\n  }\n\n  if (node.type === 'FlatMap') {\n    const base = unparseFlatMapExpr(node.base)\n    const expr = unparseFlatMapExpr(node.expr)\n    return `${base}${expr}`\n  }\n\n  if (node.type === 'Projection') {\n    if (node.base?.type === 'This') return unparse(node.expr)\n    if (node.base?.type === 'Deref' && node.base.base?.type === 'This') {\n      return `->${unparse(node.expr)}`\n    }\n  }\n\n  if (node.type === 'Deref' && node.base?.type === 'This') {\n    return '->'\n  }\n\n  if (node.type === 'Filter') {\n    const base = unparseFlatMapExpr(node.base)\n    return `${base}[${unparse(node.expr)}]`\n  }\n\n  // Fallback to general unparse for anything else\n  return unparse(node)\n}\n"],"names":[],"mappings":"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"}