{"version":3,"file":"1.mjs","sources":["../src/values/Path.ts","../src/values/dateHelpers.ts","../src/values/utils.ts","../src/values/StreamValue.ts","../src/evaluator/equality.ts","../src/evaluator/matching.ts","../src/evaluator/ordering.ts","../src/evaluator/operators.ts","../src/evaluator/scope.ts","../src/evaluator/evaluate.ts","../src/evaluator/constantEvaluate.ts","../src/nodeTypes.ts","../src/evaluator/functions/array.ts","../src/evaluator/functions/dateTime.ts","../src/evaluator/keyPath.ts","../src/evaluator/selector.ts","../src/evaluator/functions/diff.ts","../src/evaluator/functions/delta.ts","../src/evaluator/functions/documents.ts","../src/evaluator/functions/geo.ts","../src/evaluator/functions/string.ts","../src/evaluator/functions/global.ts","../src/evaluator/functions/math.ts","../src/evaluator/pt.ts","../src/evaluator/functions/pt.ts","../src/evaluator/functions/releases.ts","../src/evaluator/functions/sanity.ts","../src/evaluator/functions/text.ts","../src/evaluator/scoring.ts","../src/evaluator/functions/pipeFunctions.ts","../src/evaluator/functions/index.ts","../src/markProcessor.ts","../src/rawParser.js","../src/traversal.ts","../src/parser.ts","../src/typeEvaluator/optimizations.ts","../src/typeEvaluator/typeHelpers.ts","../src/typeEvaluator/booleans.ts","../src/typeEvaluator/functions.ts","../src/typeEvaluator/matching.ts","../src/typeEvaluator/scope.ts","../src/typeEvaluator/typeEvaluate.ts"],"sourcesContent":["function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n","const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n","import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport type {\n  AnyStaticValue,\n  ArrayValue,\n  BooleanValue,\n  DateTimeValue,\n  GroqType,\n  NullValue,\n  PathValue,\n  StringValue,\n  Value,\n} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  asStatic(): this {\n    return this\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): DateTimeValue | NullValue {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): AnyStaticValue {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): StringValue {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): PathValue {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\nexport function fromArray(val: unknown[]): ArrayValue {\n  return new StaticValue(val, 'array')\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns a normalized JavaScript value. This eliminates internal values\n * such as DateTime and Path by turning them into the JSON representation.\n */\nexport function toJS(val: AnyStaticValue): unknown {\n  const normalized = maybeNormalize(val.data)\n  if (normalized === undefined) return val.data\n  return normalized\n}\n\n/**\n * maybeNormalize eliminates custom values such as DateTime and Path.\n * This method returns `undefined` in the scenario where the data contains no\n * custom values and the data is already normalized.\n */\nfunction maybeNormalize(data: unknown): unknown | undefined {\n  if (data === null || typeof data === 'undefined') return\n\n  if (Array.isArray(data)) {\n    let result: undefined | unknown[]\n    for (let i = 0; i < data.length; i++) {\n      let normalized = maybeNormalize(data[i])\n      if (normalized !== undefined && result === undefined) {\n        // This is the first value which had to be converted.\n        result = data.slice(0, i)\n      }\n\n      if (result !== undefined) {\n        if (normalized === undefined) normalized = data[i]\n        result.push(normalized)\n      }\n    }\n\n    return result\n  }\n\n  if (typeof data === 'object') {\n    if ('toJSON' in data && typeof data.toJSON === 'function') {\n      return data.toJSON()\n    }\n\n    const entries = Object.entries(data)\n    let result: undefined | Record<string, unknown>\n\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]!\n      let normalized = maybeNormalize(value)\n      if (normalized !== undefined && result === undefined) {\n        // This is the first value which had to be converted.\n        result = Object.fromEntries(entries.slice(0, i))\n      }\n\n      if (result !== undefined) {\n        if (normalized === undefined) normalized = value\n        result[key] = normalized\n      }\n    }\n\n    return result\n  }\n\n  return\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n","import type {ArrayValue, Value} from './types'\nimport {StaticValue} from './utils'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any[]> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async asStatic(): Promise<ArrayValue> {\n    return new StaticValue(await this.get(), 'array')\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    let currentRejector: (reason?: any) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve, reject) => {\n        currentResolver = resolve\n        currentRejector = reject\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      try {\n        for await (const value of this.generator()) {\n          this.data.push(value)\n          tick()\n        }\n\n        this.isDone = true\n        tick()\n      } catch (error) {\n        currentRejector(error)\n      }\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n","import type {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  if (a === null || b === null) return a === b\n  const typeOfA = typeof a\n  const typeOfB = typeof b\n  if (typeOfA === 'undefined' && typeOfB === 'undefined') return true\n  if (typeOfA === 'function' && typeOfB === 'function') return a === b\n  if (typeOfA === 'object' && typeOfB === 'object') {\n    const keysOfA = Object.keys(a)\n    const keysOfB = Object.keys(b)\n    if (keysOfA.length !== keysOfB.length) return false\n    for (const key of keysOfA) {\n      if (!deepEqual(a[key], b[key])) return false\n    }\n    return true\n  }\n  return a === b\n}\n","import type {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i'),\n  )\n}\n\nexport type GatheredText<T> = {\n  parts: T[]\n  /** This is true if all of the values in the array were strings. */\n  success: boolean\n}\n\nexport function gatherText<T>(\n  value: Value,\n  flatMap: (str: string) => T[],\n): Promise<GatheredText<T>> | GatheredText<T> {\n  if (value.type === 'string') {\n    return {parts: flatMap(value.data), success: true}\n  }\n\n  if (value.type === 'array') {\n    let success = true\n    const parts: T[] = []\n\n    for (const part of value.data) {\n      if (typeof part === 'string') {\n        parts.push(...flatMap(part))\n      } else {\n        success = false\n      }\n    }\n\n    return {parts, success}\n  }\n\n  if (value.type === 'stream') {\n    return (async () => {\n      let success = true\n      const parts: T[] = []\n\n      for await (const part of value) {\n        if (part.type === 'string') {\n          parts.push(...flatMap(part.data))\n        } else {\n          success = false\n        }\n      }\n      return {parts, success}\n    })()\n  }\n\n  return {parts: [], success: false}\n}\n","import {getType, type GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n","import type {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  type Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {\n  gatherText,\n  matchAnalyzePattern,\n  matchText,\n  matchTokenize,\n  type GatheredText,\n  type Pattern,\n  type Token,\n} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  'in': function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.type === 'array') {\n      for (const b of right.data) {\n        if (isEqual(left, fromJS(b))) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    if (right.type === 'stream') {\n      return (async () => {\n        for await (const b of right) {\n          if (isEqual(left, b)) {\n            return TRUE_VALUE\n          }\n        }\n\n        return FALSE_VALUE\n      })()\n    }\n\n    return NULL_VALUE\n  },\n\n  'match': function match(left, right) {\n    const tokens = gatherText(left, (part) => matchTokenize(part))\n    const patterns = gatherText(right, (part) => matchAnalyzePattern(part))\n\n    const process = (tokens: GatheredText<Token>, patterns: GatheredText<Pattern>) => {\n      if (!patterns.success) {\n        return FALSE_VALUE\n      }\n\n      const matched = matchText(tokens.parts, patterns.parts)\n\n      return matched ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if ('then' in tokens || 'then' in patterns) {\n      return (async () => process(await tokens, await patterns))()\n    }\n\n    return process(tokens, patterns)\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n","import type {Value} from '../values'\nimport type {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null,\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromArray,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  type AnyStaticValue,\n  type ObjectValue,\n  type Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport type {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(node: ExprNode, scope: Scope): Value | PromiseLike<Value> {\n  return executeAsync(node, scope)\n}\n\nexport function executeSync(node: ExprNode, scope: Scope): AnyStaticValue {\n  const exec = EXECUTORS[node.type]\n  return exec.executeSync(node as any, scope)\n}\n\nexport function executeAsync(node: ExprNode, scope: Scope): Promise<Value> {\n  const exec = EXECUTORS[node.type]\n  return exec.executeAsync(node as any, scope)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: Executor<NarrowNode<ExprNode, key>>\n}\n\n/**\n * Defines an executor which is only valid in `evaluateAsync`.\n *\n * @deprecated This is a temporary helper. Over time we want everything to be both sync and async.\n **/\nexport function asyncOnlyExecutor<N = ExprNode>(\n  executeAsync: (node: N, scope: Scope) => Promise<Value>,\n): Executor<N> {\n  return {\n    executeSync() {\n      throw new Error('executeSync not supported')\n    },\n    executeAsync,\n  }\n}\n\nexport function constantExecutor<N = ExprNode>(fn: (node: N, scope: Scope) => Value): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const value = fn(node, scope)\n      if (value.type === 'stream') throw new Error('Stream encountered in evaluateSync')\n      return value\n    },\n    async executeAsync(node, scope) {\n      return fn(node, scope)\n    },\n  }\n}\n\nexport function mappedExecutor<N = ExprNode>(\n  map: (node: N) => ExprNode[],\n  reduce: (node: N, ...values: AnyStaticValue[]) => Value,\n): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const nodes = map(node)\n      const values = nodes.map((node) => executeSync(node, scope))\n      const value = reduce(node, ...values)\n      if (value.type === 'stream')\n        throw new Error('Stream/iterator not supported in synchronous mode')\n      return value\n    },\n    async executeAsync(node, scope) {\n      const nodes = map(node)\n      const values = await Promise.all(\n        nodes.map((node) => executeAsync(node, scope).then((value) => value.asStatic())),\n      )\n      return reduce(node, ...values)\n    },\n  }\n}\n\nexport const STOP_ITERATOR = Symbol()\n\n/**\n * An executor for procesing an array into a single value.\n *\n * @param map Returns a set of nodes which will be executed.\n * @param init Called once to produce an internal state.\n * @param reduce Called per item in the array.\n * @param wrap Turns the state into a static value.\n */\nexport function arrayReducerExecutor<N = ExprNode, State = unknown>(\n  map: (node: N) => {array: ExprNode; args?: ExprNode[]},\n  init: (node: N, ...args: AnyStaticValue[]) => State,\n  reduce: (\n    node: N,\n    state: State,\n    item: unknown,\n    ...args: AnyStaticValue[]\n  ) => State | typeof STOP_ITERATOR,\n  wrap: (state: State) => AnyStaticValue,\n): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const {array: arrayNode, args: argNodes = []} = map(node)\n      const arr = executeSync(arrayNode, scope)\n      if (arr.type !== 'array') return NULL_VALUE\n      const args = argNodes.map((node) => executeSync(node, scope))\n      let state = init(node, ...args)\n      for (const item of arr.data) {\n        const result = reduce(node, state, item, ...args)\n        if (result === STOP_ITERATOR) return NULL_VALUE\n        state = result\n      }\n      return wrap(state)\n    },\n    async executeAsync(node, scope) {\n      const {array: arrayNode, args: argNodes = []} = map(node)\n      const arr = await executeAsync(arrayNode, scope)\n      if (arr.type !== 'array' && arr.type !== 'stream') return NULL_VALUE\n\n      const args = await Promise.all(\n        argNodes.map((node) => executeAsync(node, scope).then((v) => v.asStatic())),\n      )\n\n      let state = init(node, ...args)\n\n      if (arr.type === 'stream') {\n        for await (const item of arr) {\n          const result = reduce(node, state, await item.get(), ...args)\n          if (result === STOP_ITERATOR) return NULL_VALUE\n          state = result\n        }\n      } else {\n        for (const item of arr.data) {\n          const result = reduce(node, state, item, ...args)\n          if (result === STOP_ITERATOR) return NULL_VALUE\n          state = result\n        }\n      }\n\n      return wrap(state)\n    },\n  }\n}\n\n/**\n * An executor which processes an array and returns another array.\n */\nexport function arrayExecutor<N = ExprNode, S = undefined>(\n  map: (node: N) => {array: ExprNode; inner?: ExprNode; state?: S},\n  reduce: (node: N, item: unknown, inner: unknown, state?: S) => Iterable<unknown>,\n  {hidden = false}: {hidden?: boolean} = {},\n): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const mapping = map(node)\n      const arr = executeSync(mapping.array, scope)\n      if (arr.type !== 'array') return NULL_VALUE\n      const result: unknown[] = []\n      for (const item of arr.data) {\n        let inner: unknown\n        if (mapping.inner) {\n          const newScope = hidden\n            ? scope.createHidden(fromJS(item))\n            : scope.createNested(fromJS(item))\n          inner = executeSync(mapping.inner, newScope).data\n        }\n        for (const entry of reduce(node, item, inner, mapping.state)) {\n          result.push(entry)\n        }\n      }\n      return fromArray(result)\n    },\n\n    async executeAsync(node, scope) {\n      const mapping = map(node)\n      const arr = await executeAsync(mapping.array, scope)\n      if (!arr.isArray()) return NULL_VALUE\n\n      return new StreamValue(async function* () {\n        for await (const item of arr) {\n          let inner: unknown\n          if (mapping.inner) {\n            const newScope = hidden ? scope.createHidden(item) : scope.createNested(item)\n            const innerValue = await executeAsync(mapping.inner, newScope)\n            inner = await innerValue.get()\n          }\n          for (const entry of reduce(node, await item.get(), inner, mapping.state)) {\n            yield fromJS(entry)\n          }\n        }\n      })\n    },\n  }\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This: constantExecutor((_, scope) => {\n    return scope.value\n  }),\n\n  SelectorNested: constantExecutor(() => {\n    throw new Error('Unexpected node type: SelectorNested')\n  }),\n\n  SelectorFuncCall: constantExecutor(() => {\n    throw new Error('Unexpected node type: SelectorFuncCall')\n  }),\n\n  Everything: constantExecutor((_, scope) => {\n    return scope.source\n  }),\n\n  Parameter: constantExecutor(({name}, scope) => {\n    return fromJS(scope.params[name])\n  }),\n\n  Context: constantExecutor(({key}, scope) => {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  }),\n\n  Parent: constantExecutor(({n}, scope) => {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  }),\n\n  OpCall: {\n    async executeAsync({op, left, right}, scope) {\n      const func = operators[op]\n      if (!func) {\n        throw new Error(`Unknown operator: ${op}`)\n      }\n      const leftValue = await executeAsync(left, scope)\n      const rightValue = await executeAsync(right, scope)\n\n      return func(leftValue, rightValue)\n    },\n    executeSync({op, left, right}, scope) {\n      const func = operators[op]\n      if (!func) {\n        throw new Error(`Unknown operator: ${op}`)\n      }\n      const leftValue = executeSync(left, scope)\n      const rightValue = executeSync(right, scope)\n\n      const result = func(leftValue, rightValue)\n      if ('then' in result || result.type === 'stream')\n        throw new Error(`Operator ${op} not possible in evaluteSync`)\n      return result\n    },\n  },\n\n  Select: {\n    executeSync({alternatives, fallback}, scope) {\n      for (const alt of alternatives) {\n        const altCond = executeSync(alt.condition, scope)\n        if (altCond.type === 'boolean' && altCond.data === true) {\n          return executeSync(alt.value, scope)\n        }\n      }\n\n      if (fallback) {\n        return executeSync(fallback, scope)\n      }\n\n      return NULL_VALUE\n    },\n\n    async executeAsync({alternatives, fallback}, scope) {\n      for (const alt of alternatives) {\n        const altCond = await executeAsync(alt.condition, scope)\n        if (altCond.type === 'boolean' && altCond.data === true) {\n          return executeAsync(alt.value, scope)\n        }\n      }\n\n      if (fallback) {\n        return executeAsync(fallback, scope)\n      }\n\n      return NULL_VALUE\n    },\n  },\n\n  InRange: mappedExecutor(\n    ({base, left, right}) => [base, left, right],\n    ({isInclusive}, value, leftValue, rightValue) => {\n      const leftCmp = partialCompare(value.data, leftValue.data)\n      if (leftCmp === null) {\n        return NULL_VALUE\n      }\n      const rightCmp = partialCompare(value.data, rightValue.data)\n      if (rightCmp === null) {\n        return NULL_VALUE\n      }\n\n      if (isInclusive) {\n        return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n      }\n\n      return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n    },\n  ),\n\n  Filter: arrayExecutor(\n    ({base, expr}) => ({array: base, inner: expr}),\n    function* (_, elem, inner) {\n      if (inner === true) yield elem\n    },\n  ),\n\n  Projection: {\n    executeSync({base, expr}, scope) {\n      const baseValue = executeSync(base, scope)\n\n      if (baseValue.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const newScope = scope.createNested(baseValue)\n      return executeSync(expr, newScope)\n    },\n\n    async executeAsync({base, expr}, scope) {\n      const baseValue = await executeAsync(base, scope)\n      if (baseValue.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const newScope = scope.createNested(baseValue)\n      return executeAsync(expr, newScope)\n    },\n  },\n\n  FuncCall: {\n    executeAsync({func, args}, scope) {\n      return func.executeAsync(args, scope)\n    },\n\n    executeSync({func, args}, scope) {\n      return func.executeSync(args, scope)\n    },\n  },\n\n  PipeFuncCall: {\n    async executeAsync({func, base, args}, scope) {\n      const baseValue = await executeAsync(base, scope)\n      if (baseValue.type !== 'stream' && baseValue.type !== 'array') return NULL_VALUE\n      return func.executeAsync({base: baseValue, args}, scope)\n    },\n\n    executeSync({func, base, args}, scope) {\n      const baseValue = executeSync(base, scope)\n      if (baseValue.type !== 'array') return NULL_VALUE\n      return func.executeSync({base: baseValue, args}, scope)\n    },\n  },\n\n  AccessAttribute: mappedExecutor(\n    ({base}) => [base || {type: 'This'}],\n    ({name}, value) => {\n      if (value.type === 'object') {\n        if (value.data.hasOwnProperty(name)) {\n          return fromJS(value.data[name]) as ObjectValue\n        }\n      }\n\n      return NULL_VALUE\n    },\n  ),\n\n  AccessElement: mappedExecutor(\n    ({base}) => [base],\n    ({index}, baseValue) => {\n      if (baseValue.type !== 'array') return NULL_VALUE\n      const data = baseValue.data\n      const finalIndex = index < 0 ? index + data.length : index\n      return fromJS(data[finalIndex])\n    },\n  ),\n\n  Slice: mappedExecutor(\n    ({base}) => [base],\n    ({left, right, isInclusive}, baseValue) => {\n      if (baseValue.type !== 'array') {\n        return NULL_VALUE\n      }\n\n      // OPT: Here we can optimize when either indices are >= 0\n      const array = baseValue.data\n\n      let leftIdx = left\n      let rightIdx = right\n\n      // Handle negative index\n      if (leftIdx < 0) {\n        leftIdx = array.length + leftIdx\n      }\n      if (rightIdx < 0) {\n        rightIdx = array.length + rightIdx\n      }\n\n      // Convert from inclusive to exclusive index\n      if (isInclusive) {\n        rightIdx++\n      }\n\n      if (leftIdx < 0) {\n        leftIdx = 0\n      }\n      if (rightIdx < 0) {\n        rightIdx = 0\n      }\n\n      // Note: At this point the indices might point out-of-bound, but\n      // .slice handles this correctly.\n\n      return fromArray(array.slice(leftIdx, rightIdx))\n    },\n  ),\n\n  Deref: {\n    executeSync({base}, scope) {\n      const value = executeSync(base, scope)\n\n      if (value.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const id = value.data['_ref']\n      if (typeof id !== 'string') {\n        return NULL_VALUE\n      }\n\n      if (scope.context.dereference) {\n        const value = scope.context.dereference({_ref: id})\n        if (value && typeof value === 'object' && 'then' in value) {\n          throw new Error('Dereference returned promise in synchronous mode')\n        }\n\n        return fromJS(value) as AnyStaticValue\n      }\n\n      if (scope.source.type !== 'array') {\n        return NULL_VALUE\n      }\n\n      for (const doc of scope.source.data) {\n        if (doc && typeof doc === 'object' && '_id' in doc && id === doc['_id']) {\n          return fromJS(doc) as ObjectValue\n        }\n      }\n\n      return NULL_VALUE\n    },\n\n    async executeAsync({base}, scope) {\n      const value = await executeAsync(base, scope)\n\n      if (!scope.source.isArray()) {\n        return NULL_VALUE\n      }\n\n      if (value.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const id = value.data['_ref']\n      if (typeof id !== 'string') {\n        return NULL_VALUE\n      }\n\n      if (scope.context.dereference) {\n        return fromJS(await scope.context.dereference({_ref: id}))\n      }\n\n      for await (const doc of scope.source) {\n        if (doc.type === 'object' && id === doc.data['_id']) {\n          return doc\n        }\n      }\n\n      return NULL_VALUE\n    },\n  },\n\n  Value: constantExecutor(({value}) => {\n    return fromJS(value)\n  }),\n\n  Group: {\n    executeSync({base}, scope) {\n      return executeSync(base, scope)\n    },\n    executeAsync({base}, scope) {\n      return executeAsync(base, scope)\n    },\n  },\n\n  Object: {\n    executeSync({attributes}, scope) {\n      const result: {[key: string]: any} = {}\n      for (const attr of attributes) {\n        const attrType = attr.type\n        switch (attr.type) {\n          case 'ObjectAttributeValue': {\n            const value = executeSync(attr.value, scope)\n            result[attr.name] = value.data\n            break\n          }\n\n          case 'ObjectConditionalSplat': {\n            const cond = executeSync(attr.condition, scope)\n            if (cond.type !== 'boolean' || cond.data === false) {\n              continue\n            }\n\n            const value = executeSync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          case 'ObjectSplat': {\n            const value = executeSync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          default:\n            throw new Error(`Unknown node type: ${attrType}`)\n        }\n      }\n      return fromJS(result) as ObjectValue\n    },\n\n    async executeAsync({attributes}, scope) {\n      const result: {[key: string]: any} = {}\n      for (const attr of attributes) {\n        const attrType = attr.type\n        switch (attr.type) {\n          case 'ObjectAttributeValue': {\n            const value = await executeAsync(attr.value, scope)\n            result[attr.name] = await value.get()\n            break\n          }\n\n          case 'ObjectConditionalSplat': {\n            const cond = await executeAsync(attr.condition, scope)\n            if (cond.type !== 'boolean' || cond.data === false) {\n              continue\n            }\n\n            const value = await executeAsync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          case 'ObjectSplat': {\n            const value = await executeAsync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          default:\n            throw new Error(`Unknown node type: ${attrType}`)\n        }\n      }\n      return fromJS(result)\n    },\n  },\n\n  Array: {\n    executeSync({elements}, scope) {\n      const result = []\n      for (const element of elements) {\n        const value = executeSync(element.value, scope)\n        if (element.isSplat) {\n          if (value.type === 'array') {\n            for (const v of value.data) {\n              result.push(v)\n            }\n          }\n        } else {\n          result.push(value.data)\n        }\n      }\n\n      return fromArray(result)\n    },\n\n    async executeAsync({elements}, scope) {\n      return new StreamValue(async function* () {\n        for (const element of elements) {\n          const value = await executeAsync(element.value, scope)\n          if (element.isSplat) {\n            if (value.isArray()) {\n              for await (const v of value) {\n                yield v\n              }\n            }\n          } else {\n            yield value\n          }\n        }\n      })\n    },\n  },\n\n  Tuple: constantExecutor(() => {\n    throw new Error('tuples can not be evaluated')\n  }),\n\n  Or: mappedExecutor(\n    ({left, right}) => [left, right],\n    (_, leftValue, rightValue) => {\n      if (leftValue.type === 'boolean') {\n        if (leftValue.data === true) {\n          return TRUE_VALUE\n        }\n      }\n\n      if (rightValue.type === 'boolean') {\n        if (rightValue.data === true) {\n          return TRUE_VALUE\n        }\n      }\n\n      if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n        return NULL_VALUE\n      }\n\n      return FALSE_VALUE\n    },\n  ),\n\n  And: mappedExecutor(\n    ({left, right}) => [left, right],\n    (_, leftValue, rightValue) => {\n      if (leftValue.type === 'boolean') {\n        if (leftValue.data === false) {\n          return FALSE_VALUE\n        }\n      }\n\n      if (rightValue.type === 'boolean') {\n        if (rightValue.data === false) {\n          return FALSE_VALUE\n        }\n      }\n\n      if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n        return NULL_VALUE\n      }\n\n      return TRUE_VALUE\n    },\n  ),\n\n  Not: mappedExecutor(\n    ({base}) => [base],\n    (_, value) => {\n      if (value.type !== 'boolean') {\n        return NULL_VALUE\n      }\n      return value.data ? FALSE_VALUE : TRUE_VALUE\n    },\n  ),\n\n  Neg: mappedExecutor(\n    ({base}) => [base],\n    (_, value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    },\n  ),\n\n  Pos: mappedExecutor(\n    ({base}) => [base],\n    (_, value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    },\n  ),\n\n  Asc: constantExecutor(() => NULL_VALUE),\n  Desc: constantExecutor(() => NULL_VALUE),\n\n  ArrayCoerce: {\n    executeSync({base}, scope) {\n      const value = executeSync(base, scope)\n      return value.isArray() ? value : NULL_VALUE\n    },\n\n    async executeAsync({base}, scope) {\n      const value = await executeAsync(base, scope)\n      return value.isArray() ? value : NULL_VALUE\n    },\n  },\n\n  Map: arrayExecutor(\n    ({base, expr}) => ({array: base, inner: expr}),\n    function* (_, _item, inner) {\n      yield inner\n    },\n    {hidden: true},\n  ),\n\n  FlatMap: arrayExecutor(\n    ({base, expr}) => ({array: base, inner: expr}),\n    function* (_, _item, inner) {\n      if (Array.isArray(inner)) {\n        for (const innerInner of inner) {\n          yield innerInner\n        }\n      } else {\n        yield inner\n      }\n    },\n    {hidden: true},\n  ),\n}\n\n/**\n * Evaluates a query.\n * @internal\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {},\n): Value | PromiseLike<Value> {\n  return executeAsync(tree, scopeFromOptions(options))\n}\n\n/**\n * Evaluates a query synchronously.\n *\n * This currently only supports a tiny subset of the GROQ language.\n * @internal\n */\nexport function evaluateQuerySync(tree: ExprNode, options: EvaluateOptions = {}): AnyStaticValue {\n  return executeSync(tree, scopeFromOptions(options))\n}\n\nfunction scopeFromOptions(options: EvaluateOptions): Scope {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  return new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference,\n    },\n    null,\n  )\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, type AnyStaticValue} from '../values'\nimport {executeSync} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n      return canConstantEvaluate(node.base)\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null,\n)\n\nexport function tryConstantEvaluate(node: ExprNode): AnyStaticValue | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): AnyStaticValue {\n  return executeSync(node, DUMMY_SCOPE)\n}\n","import type {GroqFunction, GroqPipeFunction} from './evaluator/functions'\n\n/** Any sort of node which appears as syntax */\nexport type SyntaxNode = ExprNode | ArrayElementNode | ObjectAttributeNode | SelectAlternativeNode\n\nexport type ObjectAttributeNode =\n  | ObjectAttributeValueNode\n  | ObjectConditionalSplatNode\n  | ObjectSplatNode\n\n/**\n * A node which can be evaluated into a value.\n * @public\n */\nexport type ExprNode =\n  | AccessAttributeNode\n  | AccessElementNode\n  | AndNode\n  | ArrayNode\n  | ArrayCoerceNode\n  | AscNode\n  | ContextNode\n  | DerefNode\n  | DescNode\n  | EverythingNode\n  | FilterNode\n  | FlatMapNode\n  | FuncCallNode\n  | GroupNode\n  | InRangeNode\n  | MapNode\n  | NegNode\n  | NotNode\n  | ObjectNode\n  | OpCallNode\n  | OrNode\n  | ParameterNode\n  | ParentNode\n  | PipeFuncCallNode\n  | PosNode\n  | ProjectionNode\n  | SelectNode\n  | SelectorNode\n  | SliceNode\n  | ThisNode\n  | TupleNode\n  | ValueNode\n\nexport type OpCall =\n  | '=='\n  | '!='\n  | '>'\n  | '>='\n  | '<'\n  | '<='\n  | '+'\n  | '-'\n  | '*'\n  | '/'\n  | '%'\n  | '**'\n  | 'in'\n  | 'match'\n\n/** The base interface for SyntaxNode. */\nexport interface BaseNode {\n  type: string\n}\n\nexport interface AndNode extends BaseNode {\n  type: 'And'\n  left: ExprNode\n  right: ExprNode\n}\n\nexport interface ArrayElementNode extends BaseNode {\n  type: 'ArrayElement'\n  value: ExprNode\n  isSplat: boolean\n}\n\nexport interface ArrayNode extends BaseNode {\n  type: 'Array'\n  elements: ArrayElementNode[]\n}\n\nexport interface ArrayCoerceNode<Base = ExprNode> extends BaseNode {\n  type: 'ArrayCoerce'\n  base: Base\n}\n\nexport interface AscNode extends BaseNode {\n  type: 'Asc'\n  base: ExprNode\n}\n\nexport interface ContextNode extends BaseNode {\n  type: 'Context'\n  key: string\n}\n\nexport interface DerefNode extends BaseNode {\n  type: 'Deref'\n  base: ExprNode\n}\n\nexport interface DescNode extends BaseNode {\n  type: 'Desc'\n  base: ExprNode\n}\n\nexport interface EverythingNode extends BaseNode {\n  type: 'Everything'\n}\n\nexport interface FuncCallNode extends BaseNode {\n  type: 'FuncCall'\n  func: GroqFunction\n  namespace: string\n  name: string\n  args: ExprNode[]\n}\n\nexport interface GroupNode<Base = ExprNode> extends BaseNode {\n  type: 'Group'\n  base: Base\n}\n\nexport interface InRangeNode extends BaseNode {\n  type: 'InRange'\n  base: ExprNode\n  left: ExprNode\n  right: ExprNode\n  isInclusive: boolean\n}\n\nexport interface NegNode extends BaseNode {\n  type: 'Neg'\n  base: ExprNode\n}\n\nexport interface NotNode extends BaseNode {\n  type: 'Not'\n  base: ExprNode\n}\n\nexport interface ObjectAttributeValueNode extends BaseNode {\n  type: 'ObjectAttributeValue'\n  name: string\n  value: ExprNode\n}\n\nexport interface ObjectConditionalSplatNode extends BaseNode {\n  type: 'ObjectConditionalSplat'\n  condition: ExprNode\n  value: ExprNode\n}\n\nexport interface ObjectNode extends BaseNode {\n  type: 'Object'\n  attributes: ObjectAttributeNode[]\n}\n\nexport interface ObjectSplatNode extends BaseNode {\n  type: 'ObjectSplat'\n  value: ExprNode\n}\n\nexport interface OpCallNode extends BaseNode {\n  type: 'OpCall'\n  op: OpCall\n  left: ExprNode\n  right: ExprNode\n}\n\nexport interface OrNode extends BaseNode {\n  type: 'Or'\n  left: ExprNode\n  right: ExprNode\n}\n\nexport interface ParameterNode extends BaseNode {\n  type: 'Parameter'\n  name: string\n}\n\nexport interface ParentNode extends BaseNode {\n  type: 'Parent'\n  n: number\n}\n\nexport interface PipeFuncCallNode extends BaseNode {\n  type: 'PipeFuncCall'\n  func: GroqPipeFunction\n  base: ExprNode\n  name: string\n  args: ExprNode[]\n}\n\nexport interface PosNode extends BaseNode {\n  type: 'Pos'\n  base: ExprNode\n}\n\nexport interface SelectAlternativeNode extends BaseNode {\n  type: 'SelectAlternative'\n  condition: ExprNode\n  value: ExprNode\n}\n\nexport interface SelectNode extends BaseNode {\n  type: 'Select'\n  alternatives: SelectAlternativeNode[]\n  fallback?: ExprNode\n}\n\nexport type SelectorNode =\n  | AccessAttributeNode<SelectorNode>\n  | SelectorFuncCallNode\n  | GroupNode<SelectorNode>\n  | TupleNode<SelectorNode>\n  | ArrayCoerceNode<SelectorNode>\n  | FilterNode<SelectorNode>\n  | SelectorNestedNode\nexport function isSelectorNode(node: BaseNode): node is SelectorNode {\n  return [\n    'AccessAttribute',\n    'SelectorFuncCall',\n    'Group',\n    'Tuple',\n    'ArrayCoerce',\n    'Filter',\n    'SelectorNested',\n  ].includes(node.type)\n}\n\nexport interface SelectorFuncCallNode extends BaseNode {\n  type: 'SelectorFuncCall'\n  name: 'anywhere'\n  arg: ExprNode\n}\n\nexport type SelectorNested =\n  | AccessAttributeNode<SelectorNode>\n  | ArrayCoerceNode<SelectorNode>\n  | FilterNode<SelectorNode>\n  | GroupNode<SelectorNode>\n  | TupleNode<SelectorNode>\nexport function isSelectorNested(node: BaseNode): node is SelectorNested {\n  return ['AccessAttribute', 'ArrayCoerce', 'Filter', 'Group', 'Tuple', 'SelectorNested'].includes(\n    node.type,\n  )\n}\n\nexport interface SelectorNestedNode extends BaseNode {\n  type: 'SelectorNested'\n  base: SelectorNode\n  nested: SelectorNested\n}\n\nexport interface ThisNode extends BaseNode {\n  type: 'This'\n}\n\nexport interface TupleNode<Base = ExprNode> extends BaseNode {\n  type: 'Tuple'\n  members: Array<Base>\n}\n\nexport interface ValueNode<P = any> {\n  type: 'Value'\n  value: P\n}\n\nexport interface FlatMapNode extends BaseNode {\n  type: 'FlatMap'\n  base: ExprNode\n  expr: ExprNode\n}\n\nexport interface MapNode extends BaseNode {\n  type: 'Map'\n  base: ExprNode\n  expr: ExprNode\n}\n\nexport interface AccessAttributeNode<T = ExprNode> extends BaseNode {\n  type: 'AccessAttribute'\n  base?: T\n  name: string\n}\n\nexport interface AccessElementNode extends BaseNode {\n  type: 'AccessElement'\n  base: ExprNode\n  index: number\n}\n\nexport interface SliceNode extends BaseNode {\n  type: 'Slice'\n  base: ExprNode\n  left: number\n  right: number\n  isInclusive: boolean\n}\n\nexport interface FilterNode<Base = ExprNode> extends BaseNode {\n  type: 'Filter'\n  base: Base\n  expr: ExprNode\n}\n\nexport interface ProjectionNode extends BaseNode {\n  type: 'Projection'\n  base: ExprNode\n  expr: ExprNode\n}\n","import type {FunctionSet} from '.'\nimport {FALSE_VALUE, fromJS, fromString, getType, NULL_VALUE, TRUE_VALUE} from '../../values'\nimport {isEqual} from '../equality'\nimport {arrayExecutor, mappedExecutor} from '../evaluate'\n\nconst array: FunctionSet = {}\n\narray['join'] = mappedExecutor(\n  (args) => args,\n  (_, arr, sep) => {\n    if (arr.type !== 'array') {\n      return NULL_VALUE\n    }\n    if (sep.type !== 'string') {\n      return NULL_VALUE\n    }\n    let buf = ''\n    let needSep = false\n    for (const elem of arr.data) {\n      if (needSep) {\n        buf += sep.data\n      }\n      switch (getType(elem)) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          buf += `${elem}`\n          break\n        default:\n          return NULL_VALUE\n      }\n      needSep = true\n    }\n    return fromString(buf)\n  },\n)\narray['join'].arity = 2\n\narray['compact'] = arrayExecutor(\n  ([array]) => ({array: array!}),\n  function* (_, item) {\n    if (item !== null) yield item\n  },\n)\narray['compact'].arity = 1\n\narray['unique'] = arrayExecutor(\n  (args) => ({array: args[0]!, state: new Set()}),\n  function* (_node, iter, _inner, added) {\n    switch (getType(iter)) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        if (!added!.has(iter)) {\n          added!.add(iter)\n          yield iter\n        }\n        break\n      default:\n        yield iter\n    }\n  },\n)\narray['unique'].arity = 1\n\narray['intersects'] = mappedExecutor(\n  (args) => args,\n  (_, arr1, arr2) => {\n    // Intersects returns true if the two arrays have at least one element in common. Only\n    // primitives are supported; non-primitives are ignored.\n    if (arr1.type !== 'array' || arr2.type !== 'array') {\n      return NULL_VALUE\n    }\n\n    for (const v1 of arr1.data) {\n      for (const v2 of arr2.data) {\n        if (isEqual(fromJS(v1), fromJS(v2))) {\n          return TRUE_VALUE\n        }\n      }\n    }\n\n    return FALSE_VALUE\n  },\n)\narray['intersects'].arity = 2\n\nexport default array\n","import type {FunctionSet} from '.'\nimport {DateTime, fromDateTime} from '../../values'\nimport {constantExecutor} from '../evaluate'\n\nconst dateTime: FunctionSet = {}\ndateTime['now'] = constantExecutor((_, scope) =>\n  fromDateTime(new DateTime(scope.context.timestamp)),\n)\ndateTime['now'].arity = 0\n\nexport default dateTime\n","import {fromJS, type Value} from '../values'\nimport {deepEqual} from './equality'\nimport type {KeyPath} from './types'\n\nexport async function valueAtPath(arg: Value, keyPath: KeyPath): Promise<any> {\n  function tryAccessor(arg: any, accessor: string | number): any | undefined {\n    try {\n      return arg[accessor]\n    } catch {\n      // ignore the error\n      return undefined\n    }\n  }\n\n  let current = await arg.get()\n  for (const part of keyPath) {\n    current = tryAccessor(current, part)\n    if (!current) break\n  }\n  return current\n}\n\nexport function startsWith(keyPath: KeyPath, prefix: KeyPath): boolean {\n  return prefix.every((item, index) => keyPath[index] === item)\n}\n\nexport async function* diffKeyPaths(before: Value, after: Value): AsyncGenerator<KeyPath> {\n  // a queue of paths to investigate for differences\n  const currPaths: KeyPath[] = [[]]\n  while (currPaths.length > 0) {\n    const currPath: KeyPath = currPaths.shift() || []\n    const b = fromJS(await valueAtPath(before, currPath))\n    const a = fromJS(await valueAtPath(after, currPath))\n\n    if (a.type !== b.type) {\n      yield currPath\n    } else if (\n      (a.type === 'string' && b.type === 'string') ||\n      (a.type === 'boolean' && b.type === 'boolean') ||\n      (a.type === 'null' && b.type === 'null') ||\n      (a.type === 'number' && b.type === 'number')\n    ) {\n      if (a.data !== b.data) yield currPath\n    } else if (a.type === 'datetime' && b.type === 'datetime') {\n      if (!a.data.equals(b.data)) yield currPath\n    } else if (a.type === 'object' && b.type === 'object') {\n      if (!deepEqual(a.data, b.data)) {\n        const aKeys = Object.keys(a.data)\n        const bKeys = Object.keys(b.data)\n        const keys = new Set(aKeys.concat(bKeys))\n        keys.forEach((key) => {\n          currPaths.push([...currPath, key])\n        })\n      }\n    } else if (a.type === 'array' && b.type === 'array') {\n      if (a.data.length !== b.data.length) {\n        yield currPath\n      } else if (!deepEqual(a.data, b.data)) {\n        for (let i = 0; i < b.data.length; i++) {\n          currPaths.push([...currPath, i])\n        }\n      }\n    } else if (a.type === 'stream' && b.type === 'stream') {\n      const arrayA = await a.get()\n      const arrayB = await b.get()\n\n      if (arrayA.length !== arrayB.length) {\n        yield currPath\n      } else if (!deepEqual(arrayA, arrayB)) {\n        for (let i = 0; i < arrayB.length; i++) {\n          currPaths.push([...currPath, i])\n        }\n      }\n    }\n  }\n}\n","import type {ExprNode, FilterNode, SelectorNode} from '../nodeTypes'\nimport {fromJS, type Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {valueAtPath} from './keyPath'\nimport type {Scope} from './scope'\nimport type {KeyPath} from './types'\n\nexport async function evaluateSelector(\n  node: SelectorNode,\n  value: Value,\n  scope: Scope,\n): Promise<KeyPath[]> {\n  switch (node.type) {\n    case 'Group':\n      return await evaluateSelector(node.base, value, scope)\n    case 'Tuple':\n      const tuplePaths: Array<KeyPath> = []\n      for (const member of node.members) {\n        const memberPaths = await evaluateSelector(member, value, scope)\n        tuplePaths.push(...memberPaths)\n      }\n      return tuplePaths\n    case 'AccessAttribute':\n      if (node.base) {\n        const accessPaths = await evaluateSelector(node.base, value, scope)\n        return accessPaths.map((path) => [...path, node.name])\n      }\n\n      return [[node.name]]\n    case 'ArrayCoerce': {\n      const paths = await evaluateSelector(node.base, value, scope)\n\n      const arrayPaths: KeyPath[] = []\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath)\n\n        if (Array.isArray(innerValue)) {\n          for (let i = 0; i < innerValue.length; i++) {\n            arrayPaths.push([...keyPath, i])\n          }\n        }\n      }\n\n      return arrayPaths\n    }\n    case 'Filter': {\n      const paths = await evaluateSelector(node.base, value, scope)\n\n      // create a special filter to use the current value by making the base `this`\n      const filter: FilterNode = {\n        ...node,\n        base: {type: 'This'},\n      }\n\n      const arrayPaths: KeyPath[] = []\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath)\n        if (Array.isArray(innerValue)) {\n          for (let i = 0; i < innerValue.length; i++) {\n            const item = innerValue[i]\n            const nestedScope = scope.createNested(fromJS([item]))\n            const result = await evaluate(filter, nestedScope)\n            const matched = await result.get()\n            if (matched.length > 0) arrayPaths.push([...keyPath, i])\n          }\n        }\n      }\n\n      return arrayPaths\n    }\n    case 'SelectorFuncCall': {\n      return anywhere(node.arg, scope.createHidden(value))\n    }\n    case 'SelectorNested': {\n      const {base, nested: expr} = node\n\n      const paths = await evaluateSelector(base, value, scope)\n      const nestedPaths: KeyPath[] = []\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath)\n\n        switch (expr.type) {\n          case 'AccessAttribute':\n          case 'ArrayCoerce':\n          case 'Filter':\n            const accessPaths = await evaluateSelector(expr, fromJS(innerValue), scope)\n            for (let i = 0; i < accessPaths.length; i++) {\n              nestedPaths.push([...keyPath, ...accessPaths[i]])\n            }\n            break\n\n          case 'Group':\n            const innerResult = await evaluateSelector(expr.base, fromJS(innerValue), scope)\n            for (const innerKeyPath of innerResult) {\n              nestedPaths.push([...keyPath, ...innerKeyPath])\n            }\n            break\n\n          case 'Tuple':\n            for (const inner of expr.members) {\n              const innerResult = await evaluateSelector(inner, fromJS(innerValue), scope)\n              for (const innerKeyPath of innerResult) {\n                nestedPaths.push([...keyPath, ...innerKeyPath])\n              }\n            }\n        }\n      }\n      return nestedPaths\n    }\n  }\n}\n\nasync function anywhere(expr: ExprNode, scope: Scope, base: KeyPath = []): Promise<KeyPath[]> {\n  const value = scope.value\n\n  const pathList: KeyPath[] = []\n  if (value.isArray()) {\n    const arr: any[] = await value.get()\n    for (let i = 0; i < arr.length; i++) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(arr[i])), [...base, i])\n      pathList.push(...subPaths)\n    }\n  } else if (value.type === 'object') {\n    const result = await evaluate(expr, scope)\n    if (result.type === 'boolean' && result.data === true) {\n      pathList.push(base)\n    }\n\n    for (const key of Object.keys(value.data)) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(value.data[key])), [\n        ...base,\n        key,\n      ])\n      pathList.push(...subPaths)\n    }\n  }\n\n  return pathList\n}\n","import type {FunctionSet} from '.'\nimport {isSelectorNode, type SelectorNode} from '../../nodeTypes'\nimport {FALSE_VALUE, TRUE_VALUE, type BooleanValue, type Value} from '../../values'\nimport {deepEqual} from '../equality'\nimport {asyncOnlyExecutor, executeAsync} from '../evaluate'\nimport {diffKeyPaths, startsWith, valueAtPath} from '../keyPath'\nimport type {Scope} from '../scope'\nimport {evaluateSelector} from '../selector'\n\nexport async function changedAny(\n  before: Value,\n  after: Value,\n  selector: SelectorNode,\n  scope: Scope,\n): Promise<BooleanValue> {\n  const beforeSelectorScope = scope.createHidden(before)\n  const beforePaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope,\n  )\n  const afterSelectorScope = scope.createHidden(after)\n  const afterPaths = await evaluateSelector(selector, afterSelectorScope.value, afterSelectorScope)\n  if (beforePaths.length !== afterPaths.length) {\n    return TRUE_VALUE\n  }\n\n  for (const path of beforePaths) {\n    for (let i = 0; i < path.length; i++) {\n      if (typeof path[i] === 'number') {\n        const slice = path.slice(0, i)\n        const beforeArr = await valueAtPath(before, slice)\n        const afterArr = await valueAtPath(after, slice)\n\n        if (\n          !Array.isArray(beforeArr) ||\n          !Array.isArray(afterArr) ||\n          beforeArr.length !== afterArr.length\n        ) {\n          return TRUE_VALUE\n        }\n      }\n    }\n\n    const beforeValue = await valueAtPath(before, path)\n    const afterValue = await valueAtPath(after, path)\n\n    if (!deepEqual(beforeValue, afterValue)) {\n      return TRUE_VALUE\n    }\n  }\n\n  return FALSE_VALUE\n}\n\nexport async function changedOnly(\n  before: Value,\n  after: Value,\n  selector: SelectorNode,\n  scope: Scope,\n): Promise<BooleanValue> {\n  const beforeSelectorScope = scope.createHidden(before)\n  const selectedPaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope,\n  )\n\n  for await (const diffPath of diffKeyPaths(before, after)) {\n    let found = false\n    for (const selectedPath of selectedPaths) {\n      // it matches if the diff path starts with the selected path\n      const match = startsWith(diffPath, selectedPath)\n      if (match) {\n        found = true\n        break\n      }\n    }\n    if (!found) {\n      return FALSE_VALUE\n    }\n  }\n\n  return TRUE_VALUE\n}\n\nconst diff: FunctionSet = {}\ndiff['changedAny'] = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0]\n  const rhs = args[1]\n  const selector = args[2]\n  if (!isSelectorNode(selector)) throw new Error('changedAny third argument must be a selector')\n\n  const before = await executeAsync(lhs, scope)\n  const after = await executeAsync(rhs, scope)\n\n  return changedAny(before, after, selector, scope)\n})\ndiff['changedAny'].arity = 3\n\ndiff['changedOnly'] = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0]\n  const rhs = args[1]\n  const selector = args[2]\n  if (!isSelectorNode(selector)) throw new Error('changedOnly third argument must be a selector')\n\n  const before = await executeAsync(lhs, scope)\n  const after = await executeAsync(rhs, scope)\n\n  return changedOnly(before, after, selector, scope)\n})\ndiff['changedOnly'].arity = 3\n\nexport default diff\n","import type {FunctionSet} from '.'\nimport {isSelectorNode} from '../../nodeTypes'\nimport {fromString, NULL_VALUE} from '../../values'\nimport {asyncOnlyExecutor, constantExecutor} from '../evaluate'\nimport {changedAny, changedOnly} from './diff'\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta['operation'] = constantExecutor((_, scope) => {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n})\n\ndelta['changedAny'] = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE\n  const after = scope.context.after || NULL_VALUE\n  const selector = args[0]\n  if (!isSelectorNode(selector)) throw new Error('changedAny first argument must be a selector')\n\n  return changedAny(before, after, selector, scope)\n})\ndelta['changedAny'].arity = 1\ndelta['changedAny'].mode = 'delta'\n\ndelta['changedOnly'] = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE\n  const after = scope.context.after || NULL_VALUE\n  const selector = args[0]\n  if (!isSelectorNode(selector)) throw new Error('changedOnly first argument must be a selector')\n\n  return changedOnly(before, after, selector, scope)\n})\ndelta['changedOnly'].arity = 1\ndelta['changedOnly'].mode = 'delta'\n\nexport default delta\n","import type {FunctionSet} from '.'\nimport {constantExecutor} from '../evaluate'\n\nconst documents: FunctionSet = {}\ndocuments['get'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\nexport default documents\n","import type {FunctionSet} from '.'\nimport {constantExecutor} from '../evaluate'\n\nconst geo: FunctionSet = {}\ngeo['latLng'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ngeo['contains'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ngeo['intersects'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ngeo['distance'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\n\nexport default geo\n","import type {FunctionSet} from '.'\nimport {FALSE_VALUE, fromArray, fromString, NULL_VALUE, TRUE_VALUE} from '../../values'\nimport {mappedExecutor} from '../evaluate'\n\nconst string: FunctionSet = {}\n\nstring['lower'] = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    if (value.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return fromString(value.data.toLowerCase())\n  },\n)\nstring['lower'].arity = 1\n\nstring['upper'] = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    if (value.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return fromString(value.data.toUpperCase())\n  },\n)\nstring['upper'].arity = 1\n\nstring['split'] = mappedExecutor(\n  (args) => args,\n  (_, str, sep) => {\n    if (str.type !== 'string') {\n      return NULL_VALUE\n    }\n    if (sep.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    if (str.data.length === 0) {\n      return fromArray([])\n    }\n    if (sep.data.length === 0) {\n      // This uses a Unicode codepoint splitting algorithm\n      return fromArray(Array.from(str.data))\n    }\n    return fromArray(str.data.split(sep.data))\n  },\n)\nstring['split'].arity = 2\n\nstring['startsWith'] = mappedExecutor(\n  (args) => args,\n  (_, str, prefix) => {\n    if (str.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    if (prefix.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n  },\n)\nstring['startsWith'].arity = 2\n\nexport default string\n","import type {FunctionSet} from '.'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  TRUE_VALUE,\n} from '../../values'\nimport {\n  arrayReducerExecutor,\n  constantExecutor,\n  executeAsync,\n  executeSync,\n  mappedExecutor,\n} from '../evaluate'\nimport string from './string'\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\n_global['anywhere'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\n\n_global['anywhere'].arity = 1\n\n_global['coalesce'] = {\n  async executeAsync(args, scope) {\n    for (const arg of args) {\n      const value = await executeAsync(arg, scope)\n      if (value.type !== 'null') {\n        return value\n      }\n    }\n    return NULL_VALUE\n  },\n\n  executeSync(args, scope) {\n    for (const arg of args) {\n      const value = executeSync(arg, scope)\n      if (value.type !== 'null') {\n        return value\n      }\n    }\n    return NULL_VALUE\n  },\n}\n\n_global['count'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => 0,\n  (_, count) => count + 1,\n  fromNumber,\n)\n_global['count'].arity = 1\n\n_global['dateTime'] = mappedExecutor(\n  (args) => args,\n  (_, val) => {\n    if (val.type === 'datetime') {\n      return val\n    }\n    if (val.type !== 'string') {\n      return NULL_VALUE\n    }\n    return DateTime.parseToValue(val.data)\n  },\n)\n_global['dateTime'].arity = 1\n\n_global['defined'] = mappedExecutor(\n  (args) => args,\n  (_, inner) => {\n    return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n  },\n)\n_global['defined'].arity = 1\n\n// eslint-disable-next-line require-await\n_global['identity'] = constantExecutor((_args, scope) => {\n  return fromString(scope.context.identity)\n})\n_global['identity'].arity = 0\n\n_global['length'] = mappedExecutor(\n  (args) => args,\n  (_, inner) => {\n    if (inner.type === 'string') {\n      return fromNumber(countUTF8(inner.data))\n    }\n\n    if (inner.type === 'array') {\n      return fromNumber(inner.data.length)\n    }\n\n    return NULL_VALUE\n  },\n)\n_global['length'].arity = 1\n\n_global['path'] = mappedExecutor(\n  (args) => args,\n  (_, inner) => {\n    if (inner.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return fromPath(new Path(inner.data))\n  },\n)\n_global['path'].arity = 1\n\n_global['string'] = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    switch (value.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        return fromString(`${value.data}`)\n      default:\n        return NULL_VALUE\n    }\n  },\n)\n_global['string'].arity = 1\n\n_global['references'] = mappedExecutor(\n  (args) => [{type: 'This'}, ...args],\n  (_, scopeValue, ...args) => {\n    const pathSet = new Set<string>()\n    for (const path of args) {\n      if (path.type === 'string') {\n        pathSet.add(path.data)\n      } else if (path.type === 'array') {\n        for (const elem of path.data) {\n          if (typeof elem === 'string') {\n            pathSet.add(elem)\n          }\n        }\n      }\n    }\n\n    if (pathSet.size === 0) {\n      return FALSE_VALUE\n    }\n\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n  },\n)\n_global['references'].arity = (c) => c >= 1\n\n_global['round'] = mappedExecutor(\n  (args) => args,\n  (_, value, precValue) => {\n    if (value.type !== 'number') {\n      return NULL_VALUE\n    }\n\n    const num = value.data\n    let prec = 0\n\n    if (precValue) {\n      if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n        return NULL_VALUE\n      }\n      prec = precValue.data\n    }\n\n    if (prec === 0) {\n      if (num < 0) {\n        // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n        // The behavior we're interested in is to \"round half away from zero\".\n        return fromNumber(-Math.round(-num))\n      }\n      return fromNumber(Math.round(num))\n    }\n    return fromNumber(Number(num.toFixed(prec)))\n  },\n)\n_global['round'].arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global['now'] = constantExecutor((_args, scope) => {\n  return fromString(scope.context.timestamp.toISOString())\n})\n_global['now'].arity = 0\n\n// eslint-disable-next-line require-await\n_global['boost'] = constantExecutor(() => {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n})\n\n_global['boost'].arity = 2\n\n_global['lower'] = string['lower']\n_global['upper'] = string['upper']\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nexport default _global\n","import type {FunctionSet} from '.'\nimport {fromNumber, NULL_VALUE} from '../../values'\nimport {arrayReducerExecutor, STOP_ITERATOR} from '../evaluate'\n\nconst math: FunctionSet = {}\nmath['min'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => undefined as undefined | number,\n  (_, n, item) => {\n    if (item === null) return n\n    if (typeof item !== 'number') return STOP_ITERATOR\n    if (n === undefined || item < n) return item\n    return n\n  },\n  (n) => (n === undefined ? NULL_VALUE : fromNumber(n)),\n)\nmath['min'].arity = 1\n\nmath['max'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => undefined as undefined | number,\n  (_, n, item) => {\n    if (item === null) return n\n    if (typeof item !== 'number') return STOP_ITERATOR\n    if (n === undefined || item > n) return item\n    return n\n  },\n  (n) => (n === undefined ? NULL_VALUE : fromNumber(n)),\n)\nmath['max'].arity = 1\n\nmath['sum'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => 0,\n  (_, n, item) => {\n    if (item === null) return n\n    if (typeof item !== 'number') return STOP_ITERATOR\n    return n + item\n  },\n  fromNumber,\n)\nmath['sum'].arity = 1\n\nmath['avg'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => ({count: 0, sum: 0}),\n  (_, {count, sum}, item) => {\n    if (item === null) return {count, sum}\n    if (typeof item !== 'number') return STOP_ITERATOR\n    return {count: count + 1, sum: sum + item}\n  },\n  ({count, sum}) => (count === 0 ? NULL_VALUE : fromNumber(sum / count)),\n)\nmath['avg'].arity = 1\n\nexport default math\n","import type {AnyStaticValue} from '../values'\n\nexport function portableTextContent(value: AnyStaticValue): string | null {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.type === 'array') {\n    const texts = arrayText(value.data)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nfunction arrayText(value: unknown[], result: string[] = []): string[] {\n  for (const block of value) {\n    if (Array.isArray(block)) {\n      arrayText(block, result)\n    } else if (typeof block === 'object' && block) {\n      const text = blockText(block as Record<string, unknown>)\n      if (text !== null) result.push(text)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj['_type'] !== 'string') return null\n  const children = obj['children']\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n","import type {FunctionSet} from '.'\nimport {fromString, NULL_VALUE} from '../../values'\nimport {portableTextContent} from '../pt'\nimport {mappedExecutor} from '../evaluate'\n\nconst pt: FunctionSet = {}\npt['text'] = mappedExecutor(\n  (args) => args,\n  function (_, value) {\n    const text = portableTextContent(value)\n\n    if (text === null) {\n      return NULL_VALUE\n    }\n\n    return fromString(text)\n  },\n)\n\npt['text'].arity = 1\n\nexport default pt\n","import type {FunctionSet} from '.'\nimport {arrayExecutor} from '../evaluate'\n\nconst releases: FunctionSet = {}\n\n// eslint-disable-next-line require-await\nreleases['all'] = arrayExecutor(\n  () => ({array: {type: 'Everything'}}),\n  function* (_, value) {\n    if (\n      typeof value === 'object' &&\n      value &&\n      '_type' in value &&\n      value._type === 'system.release'\n    ) {\n      yield value\n    }\n  },\n)\nreleases['all'].arity = 0\n\nexport default releases\n","import type {FunctionSet} from '.'\nimport {FALSE_VALUE, fromString, NULL_VALUE, TRUE_VALUE} from '../../values'\nimport {constantExecutor, mappedExecutor} from '../evaluate'\n\nconst sanity: FunctionSet = {}\nsanity['projectId'] = constantExecutor((_, scope) => {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n})\nsanity['dataset'] = constantExecutor((_, scope) => {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n})\n\n// eslint-disable-next-line require-await\nsanity['versionOf'] = mappedExecutor(\n  ([value]) => [value!, {type: 'This'}],\n  (_, value, val) => {\n    if (value.type !== 'string') return NULL_VALUE\n    const baseId = value.data\n\n    if (val.type !== 'object') return NULL_VALUE\n    if (typeof val.data['_id'] !== 'string') return NULL_VALUE\n\n    // published document\n    if (val.data['_id'] === baseId) return TRUE_VALUE\n\n    const components = val.data['_id'].split('.')\n\n    // draft document\n    if (\n      components.length >= 2 &&\n      components[0] === 'drafts' &&\n      components.slice(1).join('.') === baseId\n    ) {\n      return TRUE_VALUE\n    }\n\n    // version document\n    if (\n      components.length >= 3 &&\n      components[0] === 'versions' &&\n      components.slice(2).join('.') === baseId\n    ) {\n      return TRUE_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n)\nsanity['versionOf'].arity = 1\n\n// eslint-disable-next-line require-await\nsanity['partOfRelease'] = mappedExecutor(\n  (args) => [args[0]!, {type: 'This'}],\n  (_, value, val) => {\n    if (value.type !== 'string') return NULL_VALUE\n    const baseId = value.data\n\n    if (val.type !== 'object') return NULL_VALUE\n\n    if (typeof val.data['_id'] !== 'string') return NULL_VALUE\n\n    const components = val.data['_id'].split('.')\n    if (components.length >= 3 && components[0] === 'versions' && components[1] === baseId) {\n      return TRUE_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n)\nsanity['partOfRelease'].arity = 1\n\nexport default sanity\n","import type {FunctionSet} from '.'\nimport {constantExecutor} from '../evaluate'\n\n/**\n * Text query function - no-op implementation.\n *\n * groq-js has no search engine, but we provide this no-op implementation\n * to avoid throwing errors when parsing queries that use text::query().\n */\nconst text: FunctionSet = {}\ntext['query'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ntext['query'].arity = 1\n\nexport default text\n","import type {ExprNode} from '../nodeTypes'\nimport type {Value} from '../values'\nimport {executeAsync, executeSync} from './evaluate'\nimport {\n  gatherText,\n  matchPatternRegex,\n  matchTokenize,\n  type GatheredText,\n  type Token,\n} from './matching'\nimport {Scope} from './scope'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScoreAsync(node: ExprNode, scope: Scope): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScoreAsync(node.left, node.right, scope)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScoreAsync(node.args[0]!, scope)\n    const boost = await executeAsync(node.args[1]!, scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScoreAsync(node.left, scope)\n      const rightScore = await evaluateScoreAsync(node.right, scope)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScoreAsync(node.left, scope)\n      const rightScore = await evaluateScoreAsync(node.right, scope)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await executeAsync(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nexport function evaluateScoreSync(node: ExprNode, scope: Scope): number {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScoreSync(node.left, node.right, scope)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = evaluateScoreSync(node.args[0]!, scope)\n    const boost = executeSync(node.args[1]!, scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = evaluateScoreSync(node.left, scope)\n      const rightScore = evaluateScoreSync(node.right, scope)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = evaluateScoreSync(node.left, scope)\n      const rightScore = evaluateScoreSync(node.right, scope)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = executeSync(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nfunction evaluateMatchScoreSync(left: ExprNode, right: ExprNode, scope: Scope): number {\n  const text = executeSync(left, scope)\n  const pattern = executeSync(right, scope)\n  const result = processMatchScore(text, pattern)\n  if (typeof result === 'number') return result\n  throw new Error('Found synchronous value in match()')\n}\n\nasync function evaluateMatchScoreAsync(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n): Promise<number> {\n  const text = await executeAsync(left, scope)\n  const pattern = await executeAsync(right, scope)\n  return processMatchScore(text, pattern)\n}\n\nfunction processMatchScore(text: Value, pattern: Value): Promise<number> | number {\n  const tokens = gatherText(text, (part) => matchTokenize(part))\n  const terms = gatherText(pattern, (part) => matchPatternRegex(part))\n\n  const process = (tokens: GatheredText<Token>, terms: GatheredText<RegExp>): number => {\n    if (!terms.success) return 0\n\n    if (tokens.parts.length === 0 || terms.parts.length === 0) {\n      return 0\n    }\n\n    let score = 0\n\n    for (const re of terms.parts) {\n      const freq = tokens.parts.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n      score += (freq * (BM25k + 1)) / (freq + BM25k)\n    }\n\n    return score\n  }\n\n  if ('then' in tokens || 'then' in terms) {\n    return (async () => process(await tokens, await terms))()\n  }\n\n  return process(tokens, terms)\n}\n","import type {GroqPipeFunction, WithOptions} from '.'\nimport type {ExprNode} from '../../nodeTypes'\nimport {fromArray, fromJS, getType} from '../../values'\nimport {executeAsync, executeSync} from '../evaluate'\nimport {totalCompare} from '../ordering'\nimport {evaluateScoreAsync, evaluateScoreSync} from '../scoring'\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\ntype Direction = 'asc' | 'desc'\ntype AuxItem = [unknown, number, ...unknown[]]\n\nfunction extractOrderArgs(args: ExprNode[]): {mappers: ExprNode[]; directions: Direction[]} {\n  const mappers = []\n  const directions: Direction[] = []\n\n  for (let mapper of args) {\n    let direction: Direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n  }\n  return {mappers, directions}\n}\n\nfunction sortArray(aux: AuxItem[], directions: Direction[]): unknown[] {\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < directions.length; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return aux.map((v) => v[0])\n}\n\nconst pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions['order'] = {\n  executeSync({base, args}, scope) {\n    const {mappers, directions} = extractOrderArgs(args)\n    const aux: AuxItem[] = []\n\n    let idx = 0\n    const n = directions.length\n\n    for (const value of base.data) {\n      const newScope = scope.createNested(fromJS(value))\n      const tuple: AuxItem = [value, idx]\n      for (let i = 0; i < n; i++) {\n        const result = executeSync(mappers[i]!, newScope)\n        tuple.push(result.data)\n      }\n      aux.push(tuple)\n      idx++\n    }\n\n    return fromArray(sortArray(aux, directions))\n  },\n\n  async executeAsync({base, args}, scope) {\n    const {mappers, directions} = extractOrderArgs(args)\n    const aux: AuxItem[] = []\n\n    let idx = 0\n    const n = directions.length\n\n    for await (const value of base) {\n      const newScope = scope.createNested(value)\n      const tuple: AuxItem = [await value.get(), idx]\n      for (let i = 0; i < n; i++) {\n        const result = await executeAsync(mappers[i]!, newScope)\n        tuple.push(await result.get())\n      }\n      aux.push(tuple)\n      idx++\n    }\n\n    return fromArray(sortArray(aux, directions))\n  },\n}\npipeFunctions['order'].arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\npipeFunctions['score'] = {\n  async executeAsync({base, args}, scope) {\n    // Anything that isn't an object should be sorted first.\n    const unknown: Array<any> = []\n    const scored: Array<ObjectWithScore> = []\n\n    for await (const value of base) {\n      if (value.type !== 'object') {\n        unknown.push(await value.get())\n        continue\n      }\n\n      const newScope = scope.createNested(value)\n      let valueScore = typeof value.data['_score'] === 'number' ? value.data['_score'] : 0\n\n      for (const arg of args) {\n        valueScore += await evaluateScoreAsync(arg, newScope)\n      }\n\n      const newObject = Object.assign({}, value.data, {_score: valueScore})\n      scored.push(newObject)\n    }\n\n    scored.sort((a, b) => b._score - a._score)\n    return fromJS(scored)\n  },\n  executeSync({base, args}, scope) {\n    // Anything that isn't an object should be sorted first.\n    const unknown: Array<any> = []\n    const scored: Array<ObjectWithScore> = []\n\n    for (const value of base.data) {\n      if (getType(value) !== 'object') {\n        unknown.push(value)\n        continue\n      }\n\n      const valueObj = value as Record<string, unknown>\n\n      const newScope = scope.createNested(fromJS(value))\n      let valueScore = typeof valueObj['_score'] === 'number' ? valueObj['_score'] : 0\n\n      for (const arg of args) {\n        valueScore += evaluateScoreSync(arg, newScope)\n      }\n\n      const newObject = Object.assign({}, valueObj, {_score: valueScore})\n      scored.push(newObject)\n    }\n\n    scored.sort((a, b) => b._score - a._score)\n    return fromArray(scored)\n  },\n}\npipeFunctions['score'].arity = (count) => count >= 1\n\nexport default pipeFunctions\n","import {type ExprNode} from '../../nodeTypes'\nimport {StreamValue, type ArrayValue} from '../../values'\nimport type {Executor} from '../types'\nimport array from './array'\nimport dateTime from './dateTime'\nimport delta from './delta'\nimport diff from './diff'\nimport documents from './documents'\nimport geo from './geo'\nimport _global from './global'\nimport math from './math'\nimport pt from './pt'\nimport releases from './releases'\nimport sanity from './sanity'\nimport string from './string'\nimport text from './text'\n\nexport {default as pipeFunctions} from './pipeFunctions'\n\n/** @public */\nexport type GroqFunctionArg = ExprNode\n\n/** @internal */\nexport type WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\n/** @public */\nexport type GroqFunction = Executor<GroqFunctionArg[]>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\nexport type GroqPipeFunction = Executor<\n  {base: ArrayValue | StreamValue; args: ExprNode[]},\n  {base: ArrayValue; args: ExprNode[]}\n>\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime,\n  releases,\n  text,\n  geo,\n  documents,\n}\n","import type {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n","'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', message: 'Unexpected end of query', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let result = parseGroupOrTuple(str, pos)\n      if (result.type === 'error') return result\n\n      pos = result.position\n      marks = result.marks\n\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', message: 'Expected \"]\" after array expression', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', message: 'Exponent must be a number', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', message: 'Expected expression', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    } // ignore if type === 'error'\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', message: 'Expected identifier', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // desc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')')\n                return {type: 'error', message: 'Expected \")\" in group', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseGroupOrTuple(str, pos) {\n  const startPos = pos\n  let marks\n  let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n  if (rhs.type === 'error') return rhs\n  pos = skipWS(str, rhs.position)\n  switch (str[pos]) {\n    case ',': {\n      // Tuples\n      marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n      pos = skipWS(str, pos + 1)\n      while (true) {\n        rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        marks.push(...rhs.marks)\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ',') break\n        pos = skipWS(str, pos + 1)\n      }\n      if (str[pos] !== ')')\n        return {type: 'error', message: 'Expected \")\" after tuple expression', position: pos}\n      pos++\n      marks.push({name: 'tuple_end', position: pos})\n      break\n    }\n    case ')': {\n      pos++\n      marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n      break\n    }\n    default:\n      return {type: 'error', message: `Unexpected character \"${str[pos]}\"`, position: pos}\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n\n      // allow tuples/groups in a traversal for selectors\n      if (str[pos] === '(') {\n        return parseGroupOrTuple(str, pos)\n      }\n\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', message: 'Expected identifier after \".\"', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>')\n        return {type: 'error', message: 'Expected \">\" in reference', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos},\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']')\n          return {type: 'error', message: 'Expected \"]\" after array expression', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']')\n        return {type: 'error', message: 'Expected \"]\" after array expression', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', message: 'Unexpected character in traversal', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', message: 'Expected function name', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(')\n      return {type: 'error', message: 'Expected \"(\" after function name', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', message: 'Expected \")\" after function arguments', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', message: 'Expected \"}\" after object', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', message: 'Unexpected end of query', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n","/* eslint-disable camelcase */\nimport type {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null,\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n","/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {type GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {MarkProcessor, type MarkVisitor} from './markProcessor'\nimport {\n  isSelectorNested,\n  type ArrayElementNode,\n  type ExprNode,\n  type FuncCallNode,\n  type ObjectAttributeNode,\n  type ObjectSplatNode,\n  type OpCall,\n  type ParentNode,\n  type SelectNode,\n  type SelectorNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  type TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport type {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n}\n\ntype TraverseFunc = (right: TraversalResult | null) => TraversalResult\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public override name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<TraverseFunc> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        args.push(p.process(SELECTOR_BUILDER))\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      namespace,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair() {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc() {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc() {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<TraverseFunc> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right,\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs,\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right,\n      )\n  },\n\n  array_postfix() {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<SelectorNode> = {\n  group(p) {\n    return p.process(SELECTOR_BUILDER)\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    let node: SelectorNode = p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      if (p.getMark().name === 'array_postfix') {\n        p.shift()\n\n        node = {type: 'ArrayCoerce', base: node}\n      } else if (p.getMark().name === 'square_bracket') {\n        p.shift()\n\n        const expr = p.process(EXPR_BUILDER)\n\n        const value = tryConstantEvaluate(expr)\n        if (value && value.type === 'number') {\n          throw new Error('Invalid array access expression')\n        } else if (value && value.type === 'string') {\n          node = {type: 'AccessAttribute', base: node, name: value.data}\n        } else {\n          node = {type: 'Filter', base: node, expr}\n        }\n      } else if (p.getMark().name === 'attr_access') {\n        p.shift()\n        const name = p.processString()\n        node = {type: 'AccessAttribute', base: node, name}\n      } else if (p.getMark().name === 'tuple' || p.getMark().name === 'group') {\n        const selector = p.process(SELECTOR_BUILDER)\n        if (!isSelectorNested(selector))\n          throw new Error(`Unexpected result parsing nested selector: ${selector.type}`)\n        node = {type: 'SelectorNested', base: node, nested: selector}\n      } else {\n        throw new Error('Invalid selector syntax')\n      }\n    }\n    p.shift()\n    return node\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n    return {type: 'AccessAttribute', name}\n  },\n\n  attr_access() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  neg() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    const selectors: Array<SelectorNode> = []\n    while (p.getMark().name !== 'tuple_end') {\n      selectors.push(p.process(SELECTOR_BUILDER))\n    }\n    p.shift()\n\n    return {type: 'Tuple', members: selectors}\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER['func_call'](p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) {\n      return {\n        type: 'SelectorFuncCall',\n        name: 'anywhere',\n        arg: func.args[0],\n      }\n    }\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param() {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'PipeFuncCall' ||\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce' ||\n    node.type === 'Group'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`,\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public override name = 'GroqSyntaxError'\n\n  constructor(position: number, detail: string) {\n    super(`Syntax error in GROQ query at position ${position}${detail ? ': ' + detail : ''}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position, result.message)\n  }\n  const processor = new MarkProcessor(input, result.marks, options)\n  return processor.process(EXPR_BUILDER)\n}\n","import type {TypeNode} from './types'\n\nconst {compare} = new Intl.Collator('en')\nfunction typeNodesSorter(a: TypeNode, b: TypeNode): number {\n  if (a.type === 'null') {\n    return 1\n  }\n  return compare(hashField(a), hashField(b))\n}\n\nconst hashCache = new WeakMap<TypeNode, string>()\n\nexport function hashField(field: TypeNode): string {\n  if (hashCache.has(field)) {\n    return hashCache.get(field)!\n  }\n  const hash = calculateFieldHash(field)\n  hashCache.set(field, hash)\n  return hash\n}\n\nfunction calculateFieldHash(field: TypeNode): string {\n  switch (field.type) {\n    case 'string':\n    case 'number':\n    case 'boolean': {\n      if (field.value !== undefined) {\n        return `${field.type}(${field.value})`\n      }\n\n      return `${field.type}`\n    }\n\n    case 'null':\n    case 'unknown': {\n      return field.type\n    }\n\n    case 'array': {\n      return `${field.type}(${hashField(field.of)})`\n    }\n\n    case 'object': {\n      const attributes = Object.entries(field.attributes)\n      attributes.sort(([a], [b]) => compare(a, b)) // sort them by name\n      return `${field.type}:(${attributes\n        .map(\n          ([key, value]) =>\n            `${key}:${hashField(value.value)}(${value.optional ? 'optional' : 'non-optional'})`,\n        )\n        .join(',')}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : 'no-rest'}`\n    }\n\n    case 'union': {\n      const sorted = [...field.of]\n      sorted.sort(typeNodesSorter)\n      return `${field.type}(${sorted.map(hashField).join(',')})`\n    }\n\n    case 'inline': {\n      return `${field.type}(${field.name})`\n    }\n\n    default: {\n      // @ts-expect-error - we should never reach this, make sure we cover all type cases\n      return field.type\n    }\n  }\n}\n\nexport function removeDuplicateTypeNodes(typeNodes: TypeNode[]): TypeNode[] {\n  const seenTypes = new Set<string>()\n  const newTypeNodes = []\n\n  const sortedTypeNodes = [...typeNodes]\n  sortedTypeNodes.sort(typeNodesSorter)\n\n  for (const typeNode of sortedTypeNodes) {\n    const hash = hashField(typeNode)\n    if (hash === null) {\n      newTypeNodes.push(typeNode)\n      continue\n    }\n    if (seenTypes.has(hash)) {\n      continue\n    }\n\n    seenTypes.add(hash)\n    newTypeNodes.push(typeNode)\n  }\n\n  return newTypeNodes\n}\n\nexport function optimizeUnions(field: TypeNode): TypeNode {\n  if (field.type === 'union') {\n    if (field.of.length === 0) {\n      return field\n    }\n\n    field.of = removeDuplicateTypeNodes(field.of)\n\n    if (field.of.length === 1) {\n      return optimizeUnions(field.of[0])\n    }\n\n    // flatten union\n    for (let idx = 0; field.of.length > idx; idx++) {\n      const subField = field.of[idx]\n      if (subField.type === 'union') {\n        field.of.splice(idx, 1, ...subField.of)\n        idx--\n        continue\n      }\n\n      field.of[idx] = optimizeUnions(subField)\n    }\n\n    field.of.sort((a, b) => {\n      if (a.type === 'null') {\n        return 1\n      }\n      return compare(hashField(a), hashField(b))\n    })\n\n    return field\n  }\n\n  if (field.type === 'array') {\n    field.of = optimizeUnions(field.of)\n    return field\n  }\n\n  if (field.type === 'object') {\n    for (const idx in field.attributes) {\n      if (!Object.hasOwn(field.attributes, idx)) {\n        continue\n      }\n\n      field.attributes[idx].value = optimizeUnions(field.attributes[idx].value)\n    }\n    return field\n  }\n\n  return field\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {optimizeUnions} from './optimizations'\nimport type {Scope} from './scope'\nimport type {\n  ArrayTypeNode,\n  BooleanTypeNode,\n  InlineTypeNode,\n  NullTypeNode,\n  NumberTypeNode,\n  ObjectAttribute,\n  ObjectTypeNode,\n  StringTypeNode,\n  TypeNode,\n  UnionTypeNode,\n  UnknownTypeNode,\n} from './types'\n\n/**\n * createReferenceTypeNode creates a ObjectTypeNode representing a reference type\n * it adds required attributes for a reference type.\n * @param name - The name of the reference type\n * @param inArray - Whether the reference is in an array\n * @returns A ObjectTypeNode representing a reference type\n * @internal\n */\nexport function createReferenceTypeNode(name: string, inArray: boolean = false): ObjectTypeNode {\n  const attributes: Record<string, ObjectAttribute> = {\n    _ref: {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n      },\n    },\n    _type: {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n        value: 'reference',\n      },\n    },\n    _weak: {\n      type: 'objectAttribute',\n      value: {\n        type: 'boolean',\n      },\n      optional: true,\n    },\n  }\n\n  if (inArray) {\n    attributes['_key'] = {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n      },\n    } satisfies ObjectAttribute\n  }\n\n  return {\n    type: 'object',\n    attributes,\n    dereferencesTo: name,\n  } satisfies ObjectTypeNode\n}\n\nexport function nullUnion(node: TypeNode): UnionTypeNode {\n  if (node.type === 'union') {\n    return unionOf(...node.of, {type: 'null'})\n  }\n\n  return unionOf(node, {type: 'null'})\n}\n\nexport function unionOf(...nodes: TypeNode[]): UnionTypeNode {\n  return {\n    type: 'union',\n    of: nodes,\n  } satisfies UnionTypeNode\n}\n\nexport type ConcreteTypeNode =\n  | BooleanTypeNode\n  | NullTypeNode\n  | NumberTypeNode\n  | StringTypeNode\n  | ArrayTypeNode\n  | ObjectTypeNode\n\nexport function resolveInline(node: TypeNode, scope: Scope): Exclude<TypeNode, InlineTypeNode> {\n  if (node.type === 'inline') {\n    const resolvedInline = scope.context.lookupTypeDeclaration(node)\n    return resolveInline(resolvedInline, scope)\n  }\n\n  return node\n}\n\n/**\n * mapNode extracts either a _concrete type_ OR an _unknown type_ from a type node, applies the mapping\n * function to it and returns. Most notably, this will work through unions\n * (applying the mapping function for each variant) and inline (resolving the\n * reference).\n **/\nexport function mapNode<T extends TypeNode = TypeNode>(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ConcreteTypeNode | UnknownTypeNode) => T,\n  mergeUnions: (nodes: TypeNode[]) => TypeNode = (nodes) =>\n    optimizeUnions({type: 'union', of: nodes}),\n): TypeNode {\n  switch (node.type) {\n    case 'boolean':\n    case 'array':\n    case 'null':\n    case 'object':\n    case 'string':\n    case 'number':\n    case 'unknown':\n      return mapper(node)\n    case 'union':\n      return mergeUnions(node.of.map((inner) => mapNode(inner, scope, mapper), mergeUnions))\n    case 'inline': {\n      const resolvedInline = resolveInline(node, scope)\n      return mapNode(resolvedInline, scope, mapper, mergeUnions)\n    }\n    default:\n      // @ts-expect-error - all types should be handled\n      throw new Error(`Unknown type: ${node.type}`)\n  }\n}\n\nexport function isFuncCall(node: ExprNode, name: string): boolean {\n  if (node.type === 'Group') {\n    return isFuncCall(node.base, name)\n  }\n\n  return node.type === 'FuncCall' && `${node.namespace}::${node.name}` === name\n}\n\nexport function createGeoJson(type: 'Point' | 'LineString' | 'Polygon' = 'Point'): ObjectTypeNode {\n  let coordinateAttribute: ArrayTypeNode = {\n    type: 'array',\n    of: {\n      type: 'number',\n    },\n  }\n  if (type === 'LineString') {\n    coordinateAttribute = {\n      type: 'array',\n      of: {\n        type: 'array',\n        of: {\n          type: 'number',\n        },\n      },\n    } satisfies ArrayTypeNode\n  }\n  if (type === 'Polygon') {\n    coordinateAttribute = {\n      type: 'array',\n      of: {\n        type: 'array',\n        of: {\n          type: 'array',\n          of: {\n            type: 'number',\n          },\n        },\n      },\n    }\n  }\n  return {\n    type: 'object',\n    attributes: {\n      type: {\n        type: 'objectAttribute',\n        value: {\n          type: 'string',\n          value: type,\n        },\n      },\n      coordinates: {\n        type: 'objectAttribute',\n        value: coordinateAttribute,\n      },\n    },\n  } satisfies ObjectTypeNode\n}\n","import type {Scope} from './scope'\nimport {nullUnion, resolveInline} from './typeHelpers'\nimport type {TypeNode} from './types'\n\ntype BooleanInterpretation = {\n  canBeTrue: boolean\n  canBeFalse: boolean\n  canBeNull: boolean\n}\n\n/**\n * booleanValue takes a TypeNode and returns a BooleanInterpretation.\n * BooleanInterpretation is a matrix of three booleans:\n * - canBeTrue: whether the TypeNode can resolve to true\n * - canBeFalse: whether the TypeNode can resolve to false\n * - canBeNull: whether the TypeNode can resolve to null\n * This is a helper method intended to determine the possible values of a boolean expression.\n * When resolving a boolean expression, we might not be able to determine the exact value of the expression,\n * but we can determine the possible values of the expression, Multiple values can be true at the same time.\n *\n * @param node - The TypeNode to evaluate\n * @returns BooleanInterpretation\n * @internal\n */\nexport function booleanValue(node: TypeNode, scope: Scope): BooleanInterpretation {\n  switch (node.type) {\n    case 'unknown': {\n      return {canBeTrue: true, canBeFalse: true, canBeNull: true}\n    }\n    case 'boolean': {\n      if (node.value === true) {\n        return {canBeTrue: true, canBeFalse: false, canBeNull: false}\n      }\n      if (node.value === false) {\n        return {canBeTrue: false, canBeFalse: true, canBeNull: false}\n      }\n\n      return {canBeTrue: true, canBeFalse: true, canBeNull: false}\n    }\n    case 'union': {\n      const value = {canBeTrue: false, canBeFalse: false, canBeNull: false}\n      for (const sub of node.of) {\n        const match = booleanValue(sub, scope)\n        if (match.canBeNull) {\n          value.canBeNull = true\n        }\n        if (match.canBeTrue) {\n          value.canBeTrue = true\n        }\n        if (match.canBeFalse) {\n          value.canBeFalse = true\n        }\n      }\n      return value\n    }\n    case 'inline': {\n      const resolved = resolveInline(node, scope)\n      return booleanValue(resolved, scope)\n    }\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'object':\n    case 'array': {\n      return {canBeTrue: false, canBeFalse: false, canBeNull: true}\n    }\n    default: {\n      // @ts-expect-error - we should have handled all cases\n      throw new Error(`unknown node type ${node.type}`)\n    }\n  }\n}\n\nexport function booleanOr(\n  left: BooleanInterpretation,\n  right: BooleanInterpretation,\n): BooleanInterpretation {\n  // If either side can only be true, the expression can only be true, so we short-circuit\n  if (left.canBeTrue && !left.canBeFalse && !left.canBeNull) return left\n  if (right.canBeTrue && !right.canBeFalse && !right.canBeNull) return right\n\n  return {\n    // Either side can be true for the expression to be true\n    canBeTrue: left.canBeTrue || right.canBeTrue,\n    // Both sides must be false for the expression to be false\n    canBeFalse: left.canBeFalse && right.canBeFalse,\n    // if either side can be null, the expression can be null if the other side can't only be true\n    canBeNull: left.canBeNull || right.canBeNull,\n  }\n}\n\nexport function booleanAnd(\n  left: BooleanInterpretation,\n  right: BooleanInterpretation,\n): BooleanInterpretation {\n  // If either side can only be fales, the expression can only be false, so we short-circuit\n  if (left.canBeFalse && !left.canBeTrue && !left.canBeNull) return left\n  if (right.canBeFalse && !right.canBeTrue && !right.canBeNull) return right\n\n  return {\n    // Both sides must be true for the expression to be true\n    canBeTrue: left.canBeTrue && right.canBeTrue,\n    // if either side can be false, the expression can be false\n    canBeFalse: left.canBeFalse || right.canBeFalse,\n    // if either side can be null, the expression can be null\n    canBeNull: left.canBeNull || right.canBeNull,\n  }\n}\n\nexport function booleanInterpretationToTypeNode(bool: BooleanInterpretation): TypeNode {\n  if (bool.canBeTrue) {\n    if (bool.canBeFalse) {\n      if (bool.canBeNull) {\n        return nullUnion({type: 'boolean'})\n      }\n      return {type: 'boolean'}\n    }\n    if (bool.canBeNull) {\n      return nullUnion({type: 'boolean', value: true})\n    }\n    return {type: 'boolean', value: true}\n  }\n\n  if (bool.canBeFalse) {\n    if (bool.canBeNull) {\n      return nullUnion({type: 'boolean', value: false})\n    }\n    return {type: 'boolean', value: false}\n  }\n  return {type: 'null'}\n}\n","/* eslint-disable max-statements */\nimport type {FuncCallNode} from '../nodeTypes'\nimport {optimizeUnions} from './optimizations'\nimport type {Scope} from './scope'\nimport {walk} from './typeEvaluate'\nimport {createGeoJson, mapNode, nullUnion} from './typeHelpers'\nimport type {NullTypeNode, TypeNode} from './types'\n\nfunction unionWithoutNull(unionTypeNode: TypeNode): TypeNode {\n  if (unionTypeNode.type === 'union') {\n    return {\n      type: 'union',\n      of: unionTypeNode.of.filter((type) => type.type !== 'null'),\n    }\n  }\n  return unionTypeNode\n}\n\n// eslint-disable-next-line complexity\nexport function handleFuncCallNode(node: FuncCallNode, scope: Scope): TypeNode {\n  switch (`${node.namespace}.${node.name}`) {\n    case 'array.compact': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'unknown'}})\n        }\n        if (arg.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        const of = mapNode(arg.of, scope, (of) => of)\n        return {\n          type: 'array',\n          of: unionWithoutNull(of),\n        }\n      })\n    }\n\n    case 'array.join': {\n      const arrayArg = walk({node: node.args[0], scope})\n      const sepArg = walk({node: node.args[1], scope})\n\n      return mapNode(arrayArg, scope, (arrayArg) =>\n        mapNode(sepArg, scope, (sepArg) => {\n          if (arrayArg.type === 'unknown' || sepArg.type === 'unknown') {\n            return nullUnion({type: 'string'})\n          }\n          if (arrayArg.type !== 'array' || sepArg.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return mapNode(arrayArg.of, scope, (of) => {\n            if (of.type === 'unknown') {\n              return nullUnion({type: 'string'})\n            }\n            // we can only join strings, numbers, and booleans\n            if (of.type !== 'string' && of.type !== 'number' && of.type !== 'boolean') {\n              return {type: 'null'}\n            }\n\n            return {type: 'string'}\n          })\n        }),\n      )\n    }\n\n    case 'array.unique': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'unknown'}})\n        }\n        if (arg.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        return arg\n      })\n    }\n\n    case 'array.intersects': {\n      const arg1 = walk({node: node.args[0], scope})\n      const arg2 = walk({node: node.args[1], scope})\n\n      return mapNode(arg1, scope, (arg1) =>\n        mapNode(arg2, scope, (arg2) => {\n          if (arg1.type !== 'array') {\n            return {type: 'null'}\n          }\n\n          if (arg2.type !== 'array') {\n            return {type: 'null'}\n          }\n\n          return {type: 'boolean'}\n        }),\n      )\n    }\n\n    case 'global.lower': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type !== 'string') {\n          return {type: 'null'}\n        }\n        if (arg.value !== undefined) {\n          return {\n            type: 'string',\n            value: arg.value.toLowerCase(),\n          }\n        }\n        return {type: 'string'}\n      })\n    }\n    case 'global.upper': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n        if (arg.type !== 'string') {\n          return {type: 'null'}\n        }\n        if (arg.value !== undefined) {\n          return {\n            type: 'string',\n            value: arg.value.toUpperCase(),\n          }\n        }\n        return {type: 'string'}\n      })\n    }\n    case 'dateTime.now': {\n      return {type: 'string'}\n    }\n    case 'global.now': {\n      return {type: 'string'}\n    }\n    case 'global.defined': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (node) => {\n        if (node.type === 'unknown') {\n          return {type: 'boolean'}\n        }\n\n        return {type: 'boolean', value: node.type !== 'null'}\n      })\n    }\n    case 'global.path': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'string') {\n          return {type: 'string'}\n        }\n\n        return {type: 'null'}\n      })\n    }\n    case 'global.coalesce': {\n      if (node.args.length === 0) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      const typeNodes: TypeNode[] = []\n      let canBeNull = true\n      for (const arg of node.args) {\n        const argNode = optimizeUnions(walk({node: arg, scope}))\n\n        // Check if all types are null\n        const allNull =\n          argNode.type === 'null' ||\n          (argNode.type === 'union' && argNode.of.every((t) => t.type === 'null'))\n\n        // Can the argument be null, if all is null, unknown, or if its a union with at least one null or unknown\n        canBeNull =\n          allNull ||\n          argNode.type === 'unknown' ||\n          (argNode.type === 'union' &&\n            argNode.of.some((t) => t.type === 'null' || t.type === 'unknown'))\n\n        // As long as some type is not null or unknown, we add it to the union, but skip nulls\n        if (!allNull) {\n          typeNodes.push(unionWithoutNull(argNode))\n        }\n\n        // If we have a type that can't be null, we can break.\n        if (!canBeNull) {\n          break\n        }\n      }\n\n      // If the last argument can be null, we add null to the union\n      if (canBeNull) {\n        typeNodes.push({type: 'null'} satisfies NullTypeNode)\n      }\n\n      return {\n        type: 'union',\n        of: typeNodes,\n      }\n    }\n\n    case 'global.count': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'array') {\n          return {type: 'number'}\n        }\n\n        return {type: 'null'} satisfies NullTypeNode\n      })\n    }\n\n    case 'global.dateTime': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'string') {\n          return nullUnion({type: 'string'}) // we don't know wether the string is a valid date or not, so we return a [null, string]-union\n        }\n\n        return {type: 'null'} satisfies NullTypeNode\n      })\n    }\n\n    case 'global.length': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n        if (arg.type === 'array' || arg.type === 'string') {\n          return {type: 'number'}\n        }\n\n        return {type: 'null'}\n      })\n    }\n\n    case 'global.references': {\n      return {type: 'boolean'}\n    }\n\n    case 'global.round': {\n      const numNode = walk({node: node.args[0], scope})\n\n      return mapNode(numNode, scope, (num) => {\n        if (num.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        if (num.type !== 'number') {\n          return {type: 'null'}\n        }\n        if (node.args.length === 2) {\n          const precisionNode = walk({node: node.args[1], scope})\n          return mapNode(precisionNode, scope, (precision) => {\n            if (precision.type === 'unknown') {\n              return nullUnion({type: 'number'})\n            }\n\n            if (precision.type !== 'number') {\n              return {type: 'null'}\n            }\n\n            return {type: 'number'}\n          })\n        }\n\n        return {type: 'number'}\n      })\n    }\n\n    case 'global.string': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (node.type === 'string' || node.type === 'number' || node.type === 'boolean') {\n          if (node.value) {\n            return {\n              type: 'string',\n              value: node.value.toString(),\n            }\n          }\n\n          return {\n            type: 'string',\n          }\n        }\n\n        return {type: 'null'}\n      })\n    }\n\n    case 'math.sum': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers, but we should also ignore nulls\n          if (node.type === 'number' || node.type === 'null') {\n            return {type: 'number'}\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'math.avg': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers\n          if (node.type === 'number') {\n            return {type: 'number'}\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'math.max':\n    case 'math.min': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers\n          if (node.type === 'number') {\n            return node\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'pt.text': {\n      if (node.args.length === 0) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      return {\n        type: 'string',\n      }\n    }\n\n    case 'string.startsWith': {\n      const strTypeNode = walk({node: node.args[0], scope})\n      const prefixTypeNode = walk({node: node.args[1], scope})\n      return mapNode(strTypeNode, scope, (strNode) => {\n        return mapNode(prefixTypeNode, scope, (prefixNode) => {\n          if (strNode.type === 'unknown' || prefixNode.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n\n          if (strNode.type !== 'string' || prefixNode.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return {type: 'boolean'}\n        })\n      })\n    }\n    case 'string.split': {\n      const strTypeNode = walk({node: node.args[0], scope})\n      const sepTypeNode = walk({node: node.args[1], scope})\n      return mapNode(strTypeNode, scope, (strNode) => {\n        return mapNode(sepTypeNode, scope, (sepNode) => {\n          if (strNode.type === 'unknown' || sepNode.type === 'unknown') {\n            return nullUnion({type: 'array', of: {type: 'string'}})\n          }\n\n          if (strNode.type !== 'string' || sepNode.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return {type: 'array', of: {type: 'string'}}\n        })\n      })\n    }\n    case 'geo.latLng': {\n      const latTypeNode = walk({node: node.args[0], scope})\n      const lngTypeNode = walk({node: node.args[1], scope})\n      return mapNode(latTypeNode, scope, (latNode) => {\n        return mapNode(lngTypeNode, scope, (lngNode) => {\n          if (latNode.type == 'unknown' || lngNode.type == 'unknown') {\n            return nullUnion(createGeoJson())\n          }\n          if (latNode.type !== 'number' || lngNode.type !== 'number') {\n            return {type: 'null'}\n          }\n\n          return nullUnion(createGeoJson())\n        })\n      })\n    }\n    case 'geo.contains': {\n      return nullUnion({type: 'boolean'})\n    }\n    case 'geo.intersects': {\n      return nullUnion({type: 'boolean'})\n    }\n    case 'geo.distance': {\n      return nullUnion({type: 'number'})\n    }\n    case 'sanity.versionOf': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return nullUnion({type: 'boolean'})\n        }\n        if (typeNode.type !== 'string') {\n          return {type: 'null'}\n        }\n        return {type: 'boolean'}\n      })\n    }\n    case 'sanity.partOfRelease': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return nullUnion({type: 'boolean'})\n        }\n\n        if (typeNode.type !== 'string') {\n          return {type: 'null'}\n        }\n        return {type: 'boolean'}\n      })\n    }\n    case 'documents.get': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return typeNode\n        }\n\n        if (typeNode.type !== 'object') {\n          return {type: 'null'}\n        }\n\n        return {type: 'unknown'}\n      })\n    }\n    default: {\n      return {type: 'unknown'}\n    }\n  }\n}\n","import {\n  matchAnalyzePattern,\n  matchText,\n  matchTokenize,\n  type Pattern,\n  type Token,\n} from '../evaluator/matching'\nimport type {ConcreteTypeNode} from './typeHelpers'\n\nexport function match(left: ConcreteTypeNode, right: ConcreteTypeNode): boolean | undefined {\n  let tokens: Token[] = []\n  let patterns: Pattern[] = []\n  if (left.type === 'string') {\n    if (left.value === undefined) {\n      return undefined\n    }\n    tokens = tokens.concat(matchTokenize(left.value))\n  }\n  if (left.type === 'array') {\n    if (left.of.type === 'unknown') {\n      return undefined\n    }\n    if (left.of.type === 'string') {\n      // eslint-disable-next-line max-depth\n      if (left.of.value === undefined) {\n        return undefined\n      }\n\n      tokens = tokens.concat(matchTokenize(left.of.value))\n    }\n    if (left.of.type === 'union') {\n      // eslint-disable-next-line max-depth\n      for (const node of left.of.of) {\n        // eslint-disable-next-line max-depth\n        if (node.type === 'string' && node.value !== undefined) {\n          tokens = tokens.concat(matchTokenize(node.value))\n        }\n      }\n    }\n  }\n\n  if (right.type === 'string') {\n    if (right.value === undefined) {\n      return undefined\n    }\n    patterns = patterns.concat(matchAnalyzePattern(right.value))\n  }\n  if (right.type === 'array') {\n    if (right.of.type === 'unknown') {\n      return undefined\n    }\n    if (right.of.type === 'string') {\n      // eslint-disable-next-line max-depth\n      if (right.of.value === undefined) {\n        return undefined\n      }\n      patterns = patterns.concat(matchAnalyzePattern(right.of.value))\n    }\n    if (right.of.type === 'union') {\n      // eslint-disable-next-line max-depth\n      for (const node of right.of.of) {\n        // eslint-disable-next-line max-depth\n        if (node.type === 'string') {\n          // eslint-disable-next-line max-depth\n          if (node.value === undefined) {\n            return undefined\n          }\n          patterns = patterns.concat(matchAnalyzePattern(node.value))\n        }\n\n        // eslint-disable-next-line max-depth\n        if (node.type !== 'string') {\n          return false\n        }\n      }\n    }\n  }\n  return matchText(tokens, patterns)\n}\n","import debug from 'debug'\n\nimport type {InlineTypeNode, NullTypeNode, Schema, TypeNode, UnionTypeNode} from './types'\n\nconst $trace = debug('typeEvaluator:scope:trace')\n$trace.log = console.log.bind(console) // eslint-disable-line no-console\n\nexport class Context {\n  readonly schema: Schema\n\n  constructor(schema: Schema) {\n    this.schema = schema\n  }\n\n  lookupRef(refTo: string): TypeNode {\n    for (const val of this.schema) {\n      if (val.type === 'document') {\n        if (val.name === refTo) {\n          return {\n            type: 'object',\n            attributes: val.attributes,\n          }\n        }\n      }\n    }\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  lookupTypeDeclaration(alias: InlineTypeNode): TypeNode {\n    for (const val of this.schema) {\n      if (val.type === 'type') {\n        if (val.name === alias.name) {\n          return val.value\n        }\n      }\n    }\n    return {type: 'null'} satisfies NullTypeNode\n  }\n}\n\nexport class Scope {\n  public value: UnionTypeNode\n  public parent: Scope | undefined\n  public context: Context\n  public isHidden: boolean\n\n  constructor(value: TypeNode[], parent?: Scope, context?: Context) {\n    this.value = {type: 'union', of: value} satisfies UnionTypeNode\n    this.parent = parent\n    this.context = context || parent?.context || new Context([])\n    this.isHidden = false\n  }\n\n  createNested(value: TypeNode[]): Scope {\n    if (this.isHidden) {\n      return new Scope(value, this.parent, this.context)\n    }\n    return new Scope(value, this, this.context)\n  }\n\n  createHidden(value: TypeNode[]): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import debug from 'debug'\n\nimport type {\n  AccessAttributeNode,\n  AccessElementNode,\n  AndNode,\n  ArrayCoerceNode,\n  ArrayNode,\n  DerefNode,\n  EverythingNode,\n  ExprNode,\n  FilterNode,\n  FlatMapNode,\n  MapNode,\n  NegNode,\n  NotNode,\n  ObjectConditionalSplatNode,\n  ObjectNode,\n  ObjectSplatNode,\n  OpCall,\n  OpCallNode,\n  OrNode,\n  ParentNode,\n  PosNode,\n  ProjectionNode,\n  SelectNode,\n  SliceNode,\n  ValueNode,\n} from '../nodeTypes'\nimport {booleanAnd, booleanInterpretationToTypeNode, booleanOr, booleanValue} from './booleans'\nimport {handleFuncCallNode} from './functions'\nimport {match} from './matching'\nimport {optimizeUnions} from './optimizations'\nimport {Context, Scope} from './scope'\nimport {isFuncCall, mapNode, nullUnion, resolveInline} from './typeHelpers'\nimport type {\n  ArrayTypeNode,\n  BooleanTypeNode,\n  Document,\n  NullTypeNode,\n  NumberTypeNode,\n  ObjectAttribute,\n  ObjectTypeNode,\n  PrimitiveTypeNode,\n  Schema,\n  StringTypeNode,\n  TypeNode,\n  UnionTypeNode,\n  UnknownTypeNode,\n} from './types'\n\nconst $trace = debug('typeEvaluator:evaluate:trace')\n$trace.log = console.log.bind(console) // eslint-disable-line no-console\n// log to stdout\nconst $debug = debug('typeEvaluator:evaluate:debug')\n// log to stdout\n$debug.log = console.log.bind(console) // eslint-disable-line no-console\nconst $warn = debug('typeEvaluator:evaluate:warn')\n\n/**\n * Evaluates the type of a query and schema.\n *\n * @param ast - The query ast to evaluate.\n * @param schema - The schemas to use for type evaluation.\n * @returns The type of the query.\n * @beta\n */\nexport function typeEvaluate(ast: ExprNode, schema: Schema): TypeNode {\n  $debug('evaluateQueryType.ast %O', ast)\n  $debug('evaluateQueryType.schema %O', schema)\n  const parsed = walk({\n    node: ast,\n    scope: new Scope([], undefined, new Context(schema)),\n  })\n\n  $trace('evaluateQueryType.parsed %O', parsed)\n  const optimized = optimizeUnions(parsed)\n  $debug('evaluateQueryType.optimized %O', optimized)\n\n  return optimized\n}\n\nfunction mapDeref(node: TypeNode, scope: Scope): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'array') {\n      return {\n        type: 'array',\n        of: mapDeref(base.of, scope),\n      }\n    }\n\n    if (base.type === 'object') {\n      if (base.dereferencesTo !== undefined) {\n        return scope.context.lookupRef(base.dereferencesTo)\n      }\n\n      if (base.rest !== undefined) {\n        return mapDeref(resolveInline(base.rest, scope), scope)\n      }\n    }\n\n    return {type: 'null'}\n  })\n}\n\nfunction handleDerefNode(node: DerefNode, scope: Scope): TypeNode {\n  $trace('deref.node %O', node)\n  const derefedNode = mapDeref(walk({node: node.base, scope}), scope)\n  $trace('deref.derefedNode %O', derefedNode)\n\n  return derefedNode\n}\n\nfunction handleObjectSplatNode(\n  attr: ObjectSplatNode | ObjectConditionalSplatNode,\n  scope: Scope,\n): TypeNode {\n  const value = walk({node: attr.value, scope})\n  $trace('object.splat.value %O', value)\n  return mapNode(value, scope, (node) => {\n    // splatting over unknown is unknown, we can't know what the attributes are\n    if (node.type === 'unknown') {\n      return {type: 'unknown'}\n    }\n    // splatting over a non-object is a no-op\n    if (node.type !== 'object') {\n      return {type: 'object', attributes: {}}\n    }\n\n    const attributes: Record<string, ObjectAttribute> = {}\n    for (const name in node.attributes) {\n      if (!node.attributes.hasOwnProperty(name)) {\n        continue\n      }\n      attributes[name] = node.attributes[name]\n    }\n\n    if (node.rest !== undefined) {\n      // Rest is either an object, inline, or unknown - we need to resolve it if it's an inline\n      const resolvedRest = resolveInline(node.rest, scope)\n\n      // if the rest is unknown the entire object is unknown\n      if (resolvedRest.type === 'unknown') {\n        return {type: 'unknown'}\n      }\n      if (resolvedRest.type !== 'object') {\n        return {type: 'null'}\n      }\n      for (const name in resolvedRest.attributes) {\n        // eslint-disable-next-line\n        if (!resolvedRest.attributes.hasOwnProperty(name)) {\n          continue\n        }\n        attributes[name] = resolvedRest.attributes[name]\n      }\n    }\n    return {type: 'object', attributes}\n  })\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction handleObjectNode(node: ObjectNode, scope: Scope): TypeNode {\n  $trace('object.node %O', node)\n\n  if (node.attributes.length === 0) {\n    return {\n      type: 'object',\n      attributes: {},\n    } satisfies ObjectTypeNode\n  }\n\n  // let attributes we a entry of [name, value] or null. We need to keep track of nulls to handle conditional splats\n  // since we care about the order of the attributes. Later attribute keys will overwrite earlier ones.\n  const objectAttributes: [number, string, ObjectAttribute][] = []\n\n  const splatVariants: [number, ObjectTypeNode | UnionTypeNode<ObjectTypeNode>][] = []\n\n  // We keep track of conditional splats separately, since we need to merge them into an object or an union of objects at the end.\n  // keep track of the index of the conditional splat to be able to merge the attributes correctly.\n  const conditionalVariants: [number, UnionTypeNode<ObjectTypeNode>][] = []\n\n  for (const [idx, attr] of node.attributes.entries()) {\n    if (attr.type === 'ObjectAttributeValue') {\n      const attributeNode = walk({node: attr.value, scope})\n      objectAttributes.push([\n        idx,\n        attr.name,\n        {\n          type: 'objectAttribute',\n          value: attributeNode,\n        },\n      ])\n      continue\n    }\n\n    if (attr.type === 'ObjectSplat') {\n      const attributeNode = handleObjectSplatNode(attr, scope)\n      $trace('object.splat.result %O', attributeNode)\n      switch (attributeNode.type) {\n        case 'object': {\n          splatVariants.push([idx, attributeNode])\n          continue\n        }\n        case 'union': {\n          for (const node of attributeNode.of) {\n            // if one of the nodes is unknown we mark the entire object as unknown as we can't infer the type of the object\n            // eslint-disable-next-line max-depth\n            if (node.type === 'unknown') {\n              return node\n            }\n          }\n          splatVariants.push([idx, attributeNode as UnionTypeNode<ObjectTypeNode>])\n          continue\n        }\n        default: {\n          return {type: 'unknown'}\n        }\n      }\n    }\n\n    if (attr.type === 'ObjectConditionalSplat') {\n      const condition = booleanValue(walk({node: attr.condition, scope}), scope)\n      $trace('object.conditional.splat.condition %O', condition)\n      // condition is never met, skip this attribute\n      if (condition.canBeTrue === false) {\n        continue\n      }\n\n      const attributeNode = handleObjectSplatNode(attr, scope)\n      $trace('object.conditional.splat.result %O', attributeNode)\n      // condition is always met, we can treat this as a normal splat\n      if (condition.canBeFalse === false && condition.canBeNull === false) {\n        switch (attributeNode.type) {\n          case 'object': {\n            splatVariants.push([idx, attributeNode])\n            continue\n          }\n          case 'union': {\n            // eslint-disable-next-line max-depth\n            for (const node of attributeNode.of) {\n              // eslint-disable-next-line max-depth\n              if (node.type !== 'object') {\n                return {type: 'unknown'}\n              }\n            }\n            splatVariants.push([idx, attributeNode as UnionTypeNode<ObjectTypeNode>])\n            continue\n          }\n          default: {\n            return {type: 'unknown'}\n          }\n        }\n      }\n\n      const variant = mapNode(attributeNode, scope, (attributeNode) => {\n        $trace('object.conditional.splat.result.concrete %O', attributeNode)\n        if (attributeNode.type !== 'object') {\n          return {type: 'unknown'}\n        }\n\n        return {\n          type: 'object',\n          attributes: attributeNode.attributes,\n        } satisfies ObjectTypeNode\n      })\n\n      if (variant.type === 'union') {\n        for (const node of variant.of) {\n          // We can only splat objects, so we bail out if we encounter a non-object node.\n          // eslint-disable-next-line max-depth\n          if (node.type !== 'object') {\n            return {type: 'unknown'}\n          }\n        }\n        variant.of.push({type: 'object', attributes: {}} as ObjectTypeNode) // add an empty object to the union, since it's conditional\n        conditionalVariants.push([idx, variant as UnionTypeNode<ObjectTypeNode>])\n        continue\n      }\n      // If the variant is not an object or a union of objects, we bail out early.\n      if (variant.type !== 'object') {\n        return {type: 'unknown'}\n      }\n\n      conditionalVariants.push([\n        idx,\n        {\n          type: 'union',\n          of: [{type: 'object', attributes: {}}, variant],\n        },\n      ])\n      continue\n    }\n\n    // @ts-expect-error - we should have handled all cases of ObjectAttributeNode\n    throw new Error(`Unknown object attribute type: ${attr.type}`)\n  }\n\n  const guaranteedAttributes: [number, string, ObjectAttribute<TypeNode>][] = []\n  guaranteedAttributes.push(...objectAttributes)\n\n  for (const [idx, splatNode] of splatVariants) {\n    if (splatNode.type === 'object') {\n      for (const name in splatNode.attributes) {\n        if (!splatNode.attributes.hasOwnProperty(name)) {\n          continue\n        }\n        const attribute = splatNode.attributes[name]\n        guaranteedAttributes.push([idx, name, attribute])\n      }\n      continue\n    }\n\n    // it's a union of objects, so we keep this as a conditional variant\n    conditionalVariants.push([idx, splatNode])\n  }\n\n  // make sure they are sorted from lowest index to highest, this ensures that\n  // attributes with a higher index overwrite attributes with a lower index.\n  guaranteedAttributes.sort(([a], [b]) => a - b)\n\n  // If we have no conditional variants, we can just return the object with the guaranteed attributes.\n  if (conditionalVariants.length === 0) {\n    return {\n      type: 'object',\n      attributes: Object.fromEntries(\n        guaranteedAttributes.map(([, name, attribute]) => [name, attribute]),\n      ),\n    } satisfies ObjectTypeNode\n  }\n\n  // matrix should be a result of if given we have variants [a,b,c] this would lead to a union of [a, a|b, a|c, a|b|c, b|c, c, {EMPTY}]\n  // if it's given we have variants A + [a|b|c] this would lead to a union of [Aa, Aa|Ab, Aa|Ac, Aa|Ab|Ac, Ab|Ac, Ac, A]\n  const matrix: (ObjectTypeNode | UnionTypeNode<ObjectTypeNode>)[] = []\n\n  for (const [unionIdx, union] of conditionalVariants) {\n    const unionGuaranteedBefore: [number, string, ObjectAttribute][] = []\n    const unionGuaranteedAfter: [number, string, ObjectAttribute][] = []\n\n    // Collect all guaranteed attributes before and after the conditional variant.\n    for (const [guaranteedIndex, name, attribute] of guaranteedAttributes) {\n      if (guaranteedIndex < unionIdx) {\n        unionGuaranteedBefore.push([guaranteedIndex, name, attribute])\n      }\n      if (guaranteedIndex > unionIdx) {\n        unionGuaranteedAfter.push([guaranteedIndex, name, attribute])\n      }\n    }\n\n    // build a map of variants from other conditions.\n    const allVariantsAttributes: [number, Record<string, ObjectAttribute>[]][] = []\n    for (const [conditionalVariantIdx, otherUnion] of conditionalVariants) {\n      // We need to build a matrix of all possible combinations of the attributes of the other variants.\n      // start with an empty object, since it's condtional.\n      const variantAttributes: Record<string, ObjectAttribute>[] = []\n      for (const node of otherUnion.of) {\n        variantAttributes.push(node.attributes)\n      }\n      allVariantsAttributes.push([conditionalVariantIdx, variantAttributes])\n    }\n\n    /* eslint-disable max-depth */\n    for (const node of union.of) {\n      matrix.push({\n        type: 'object',\n        attributes: {\n          ...Object.fromEntries(\n            unionGuaranteedBefore.map(([, name, attribute]) => [name, attribute]),\n          ),\n          ...node.attributes,\n          ...Object.fromEntries(\n            unionGuaranteedAfter.map(([, name, attribute]) => [name, attribute]),\n          ),\n        },\n      } satisfies ObjectTypeNode)\n\n      for (const [outerIdx, outerAttributes] of allVariantsAttributes) {\n        for (const outer of outerAttributes) {\n          for (const [innerIdx, innerAttributes] of allVariantsAttributes) {\n            if (outerIdx === innerIdx) {\n              continue\n            }\n\n            for (const inner of innerAttributes) {\n              const _before = [...unionGuaranteedBefore]\n              const _after = [...unionGuaranteedAfter]\n\n              for (const name in outer) {\n                if (!outer.hasOwnProperty(name)) {\n                  continue\n                }\n\n                if (outerIdx === unionIdx) {\n                  continue\n                }\n\n                if (outerIdx < unionIdx) {\n                  _before.push([outerIdx, name, outer[name]])\n                }\n\n                if (outerIdx > unionIdx) {\n                  _after.push([outerIdx, name, outer[name]])\n                }\n              }\n\n              for (const name in inner) {\n                if (!inner.hasOwnProperty(name)) {\n                  continue\n                }\n                if (outerIdx === unionIdx) {\n                  continue\n                }\n\n                if (innerIdx < unionIdx) {\n                  _before.push([innerIdx, name, inner[name]])\n                }\n\n                if (innerIdx > unionIdx) {\n                  _after.push([innerIdx, name, inner[name]])\n                }\n              }\n              _before.sort(([a], [b]) => a - b)\n              _after.sort(([a], [b]) => a - b)\n\n              const before: Record<string, ObjectAttribute> = Object.fromEntries(\n                _before.map(([, name, attribute]) => [name, attribute]),\n              )\n\n              const after: Record<string, ObjectAttribute> = Object.fromEntries(\n                _after.map(([, name, attribute]) => [name, attribute]),\n              )\n\n              matrix.push({\n                type: 'object',\n                attributes: {\n                  ...before,\n                  ...node.attributes,\n                  ...after,\n                },\n              })\n            }\n          }\n        }\n      }\n    }\n    /* eslint-disable max-depth */\n  }\n\n  return optimizeUnions({\n    type: 'union',\n    of: matrix,\n  })\n}\n\n// eslint-disable-next-line max-statements\nfunction handleOpCallNode(node: OpCallNode, scope: Scope): TypeNode {\n  $trace('opcall.node %O', node)\n  const lhs = walk({node: node.left, scope})\n  const rhs = walk({node: node.right, scope})\n  return mapNode(lhs, scope, (left) =>\n    // eslint-disable-next-line complexity, max-statements\n    mapNode(rhs, scope, (right) => {\n      $trace('opcall.node.concrete \"%s\" %O', node.op, {left, right})\n\n      switch (node.op) {\n        case '==': {\n          // == always returns a boolean, no matter the compared types.\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return {type: 'boolean'}\n          }\n          if (left.type !== right.type) {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          if (left.type === 'null') {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          return {\n            type: 'boolean',\n            value: evaluateComparison(node.op, left, right),\n          } satisfies BooleanTypeNode\n        }\n        case '!=': {\n          // != always returns a boolean, no matter the compared types.\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return {type: 'boolean'}\n          }\n          if (left.type !== right.type) {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n          if (left.type === 'null') {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n\n          let value = evaluateComparison('==', left, right)\n          if (value !== undefined) value = !value\n          return {\n            type: 'boolean',\n            value,\n          } satisfies BooleanTypeNode\n        }\n        case '>':\n        case '>=':\n        case '<':\n        case '<=': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n          if (left.type !== right.type) {\n            return {type: 'null'} satisfies NullTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {type: 'null'} satisfies NullTypeNode\n          }\n          return {\n            type: 'boolean',\n            value: evaluateComparison(node.op, left, right),\n          } satisfies BooleanTypeNode\n        }\n        case 'in': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n          if (right.type !== 'array') {\n            // Special case for global::path, since it can be used with in operator, but the type returned otherwise is a string\n            if (isFuncCall(node.right, 'global::path')) {\n              return {type: 'boolean'}\n            }\n            return {type: 'null'}\n          }\n          if (!isPrimitiveTypeNode(left) && left.type !== 'null') {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          return mapNode(right.of, scope, (arrayTypeNode) => {\n            if (arrayTypeNode.type === 'unknown') {\n              return nullUnion({type: 'boolean'})\n            }\n\n            if (left.type === 'null') {\n              return {\n                type: 'boolean',\n                value: arrayTypeNode.type === 'null',\n              } satisfies BooleanTypeNode\n            }\n\n            if (left.value === undefined) {\n              return {\n                type: 'boolean',\n              } satisfies BooleanTypeNode\n            }\n            if (isPrimitiveTypeNode(arrayTypeNode)) {\n              if (arrayTypeNode.value === undefined) {\n                return {\n                  type: 'boolean',\n                } satisfies BooleanTypeNode\n              }\n\n              return {\n                type: 'boolean',\n                value: left.value === arrayTypeNode.value,\n              } satisfies BooleanTypeNode\n            }\n\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          })\n        }\n        case 'match': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            // match always returns a boolean, no matter the compared types.\n            return {type: 'boolean'}\n          }\n          return {\n            type: 'boolean',\n            value: match(left, right),\n          } satisfies BooleanTypeNode\n        }\n        case '+': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            // + is ambiguous without the concrete types of the operands, so we return unknown and leave the excersise to the caller\n            return {type: 'unknown'}\n          }\n          if (left.type === 'string' && right.type === 'string') {\n            return {\n              type: 'string',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value + right.value\n                  : undefined,\n            }\n          }\n\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value + right.value\n                  : undefined,\n            }\n          }\n          if (left.type === 'array' && right.type === 'array') {\n            return {\n              type: 'array',\n              of: {\n                type: 'union',\n                of: [left.of, right.of],\n              },\n            } satisfies ArrayTypeNode\n          }\n          if (left.type === 'object' && right.type === 'object') {\n            return {\n              type: 'object',\n              attributes: {...left.attributes, ...right.attributes},\n            } satisfies ObjectTypeNode\n          }\n          return {type: 'null'}\n        }\n        case '-': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value - right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '*': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value * right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '/': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value / right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '**': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value ** right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '%': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value % right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        default: {\n          // TS only: make sure we handle all cases\n          node.op satisfies never\n\n          return {\n            type: 'unknown',\n          } satisfies UnknownTypeNode\n        }\n      }\n    }),\n  )\n}\n\nfunction handleSelectNode(node: SelectNode, scope: Scope): TypeNode {\n  const values: TypeNode[] = []\n  let guaranteed = false\n  for (const alternative of node.alternatives) {\n    const conditionValue = walk({node: alternative.condition, scope})\n    const conditionScope = resolveFilter(alternative.condition, scope)\n    if (conditionScope.type === 'union' && conditionScope.of.length > 0) {\n      values.push(walk({node: alternative.value, scope: scope.createHidden(conditionScope.of)}))\n    }\n    if (conditionValue.type === 'boolean' && conditionValue.value === true) {\n      guaranteed = true\n    }\n  }\n  if (node.fallback && !guaranteed) {\n    values.push(walk({node: node.fallback, scope}))\n  }\n  if (values.length === 0) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  return {\n    type: 'union',\n    of: values,\n  } satisfies UnionTypeNode\n}\n\nfunction handleArrayCoerceNode(node: ArrayCoerceNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('arrayCoerce.base %O', base)\n  return mapArray(base, scope, (base) => base)\n}\nfunction handleFlatMap(node: FlatMapNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapArray(base, scope, (base) => {\n    const inner = walk({node: node.expr, scope: scope.createHidden([base.of])})\n\n    return mapNode(\n      inner,\n      scope,\n      (inner) => {\n        if (inner.type === 'array') {\n          return inner\n        }\n\n        return {type: 'array', of: inner}\n      },\n      (nodes) => {\n        const inner: TypeNode[] = []\n        for (const node of nodes) {\n          // Bail out early if we've detected an unknown.\n          if (node.type === 'unknown') return {type: 'array', of: node}\n          // The mapper above ensures that all types returned are arrays.\n          if (node.type !== 'array') throw new Error(`Unexpected type: ${node.type}`)\n          inner.push(node.of)\n        }\n        return {\n          type: 'array',\n          of: optimizeUnions({type: 'union', of: inner}),\n        }\n      },\n    )\n  })\n}\nfunction handleMap(node: MapNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('map.base %O', base)\n\n  return mapArray(base, scope, (base) => {\n    return {\n      type: 'array',\n      of: walk({node: node.expr, scope: scope.createHidden([base.of])}),\n    }\n  })\n}\n\nfunction handleProjectionNode(node: ProjectionNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('projection.base %O', base)\n\n  return mapObject(base, scope, (base) =>\n    walk({node: node.expr, scope: scope.createNested([base])}),\n  )\n}\n\nfunction createFilterScope(base: TypeNode, scope: Scope): Scope {\n  if (base.type === 'array') {\n    if (base.of.type === 'union') {\n      return scope.createNested(base.of.of)\n    }\n    return scope.createNested([base.of])\n  }\n\n  return scope.createNested([base])\n}\nfunction handleFilterNode(node: FilterNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('filter.base %O', base)\n\n  return mapNode(base, scope, (base) => {\n    $trace('filter.resolving %O', base)\n    if (base.type === 'null') {\n      return base\n    }\n\n    const resolved = resolveFilter(node.expr, createFilterScope(base, scope))\n    $trace('filter.resolved %O', resolved)\n\n    return {\n      type: 'array',\n      of: resolved,\n    }\n  })\n}\n\nexport function handleAccessAttributeNode(node: AccessAttributeNode, scope: Scope): TypeNode {\n  let attributeBase: TypeNode = scope.value\n  if (node.base) {\n    attributeBase = walk({node: node.base, scope})\n  }\n\n  $trace('accessAttribute.base %s %O', node.name, attributeBase)\n  return handleAccessAttributeBase(attributeBase, node.name, scope)\n}\n\nfunction handleAccessAttributeBase(base: TypeNode, name: string, scope: Scope): TypeNode {\n  return mapObject(base, scope, (base) => {\n    $trace(`Looking for attribute \"%s\" in object %O`, name, base)\n\n    const attribute = base.attributes[name]\n    if (attribute !== undefined) {\n      $debug(`accessAttribute.attribute found ${name} %O`, attribute)\n      if (attribute.optional) {\n        return nullUnion(attribute.value)\n      }\n\n      return attribute.value\n    }\n\n    if (base.rest) {\n      return handleAccessAttributeBase(base.rest, name, scope)\n    }\n    $warn(`attribute \"${name}\" not found in object`)\n    return {type: 'null'}\n  })\n}\n\nfunction handleAccessElementNode(node: AccessElementNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('accessElement.base %O', base)\n  return mapArray(base, scope, (base) => nullUnion(base.of))\n}\n\nfunction handleArrayNode(node: ArrayNode, scope: Scope): TypeNode {\n  const of: TypeNode[] = []\n  for (const el of node.elements) {\n    const node = walk({node: el.value, scope})\n    if (node !== null) {\n      of.push(node)\n    }\n  }\n  return {\n    type: 'array',\n    of: {\n      type: 'union',\n      of,\n    } satisfies UnionTypeNode,\n  } satisfies ArrayTypeNode\n}\n\nfunction handleValueNode(node: ValueNode, scope: Scope): TypeNode {\n  if (node.value === null) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n  switch (typeof node.value) {\n    case 'string':\n      return {\n        type: 'string',\n        value: node.value,\n      } satisfies StringTypeNode\n    case 'number':\n      return {\n        type: 'number',\n        value: node.value,\n      } satisfies NumberTypeNode\n    case 'boolean':\n      return {\n        type: 'boolean',\n        value: node.value,\n      } satisfies BooleanTypeNode\n    case 'object':\n      if (node.value === null) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      if (Array.isArray(node.value)) {\n        return {\n          type: 'array',\n          of: {\n            type: 'union',\n            of: node.value.map((value) => walk({node: {type: 'Value', value}, scope})),\n          },\n        } satisfies ArrayTypeNode\n      }\n      return {\n        type: 'object',\n        attributes: Object.fromEntries(\n          Object.entries(node.value).map(([key, value]) => [\n            key,\n            {\n              type: 'objectAttribute',\n              value: walk({node: {type: 'Value', value}, scope}),\n            },\n          ]),\n        ),\n      } satisfies ObjectTypeNode\n    default:\n      return {type: 'unknown'} satisfies UnknownTypeNode\n  }\n}\n\nfunction handleSlice(node: SliceNode, scope: Scope): TypeNode {\n  $trace('slice.node %O', node)\n  const base = walk({node: node.base, scope})\n  return mapArray(base, scope, (base) => base)\n}\n\nfunction handleParentNode({n}: ParentNode, scope: Scope): TypeNode {\n  $trace('handle.parent.currentScope %d %O', n, scope)\n\n  let current: Scope | undefined = scope\n  for (let i = 0; i < n; i++) {\n    // make sure we are not in a hidden scope\n    while (current?.isHidden) {\n      current = current.parent\n    }\n    current = current?.parent\n  }\n  $trace('handle.parent.newScope %d %O', n, current)\n\n  if (!current) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  if (current.value.of.length === 0) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  return current.value\n}\n\nfunction handleNotNode(node: NotNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'boolean'})\n    }\n\n    if (base.type === 'boolean') {\n      if (base.value !== undefined) {\n        return {type: 'boolean', value: base.value === false}\n      }\n      return {type: 'boolean'}\n    }\n\n    return {type: 'null'}\n  })\n}\n\nfunction handleNegNode(node: NegNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'number'})\n    }\n\n    if (base.type !== 'number') {\n      return {type: 'null'}\n    }\n    if (base.value !== undefined) {\n      return {type: 'number', value: -base.value}\n    }\n    return base\n  })\n}\nfunction handlePosNode(node: PosNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'number'})\n    }\n    if (base.type !== 'number') {\n      return {type: 'null'}\n    }\n    return base\n  })\n}\n\nfunction handleEverythingNode(_: EverythingNode, scope: Scope): TypeNode {\n  return {\n    type: 'array',\n    of: {\n      type: 'union',\n      of: scope.context.schema\n        .filter((obj): obj is Document => obj.type === 'document')\n        .map((doc) => ({\n          type: 'object',\n          attributes: doc.attributes,\n        })),\n    },\n  } satisfies ArrayTypeNode<UnionTypeNode<ObjectTypeNode>>\n}\n\nfunction handleAndNode(node: AndNode, scope: Scope): TypeNode {\n  const left = walk({node: node.left, scope})\n  const right = walk({node: node.right, scope})\n  return mapNode(left, scope, (lhs) =>\n    mapNode(right, scope, (rhs) => {\n      const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope))\n\n      return booleanInterpretationToTypeNode(value)\n    }),\n  )\n}\n\nfunction handleOrNode(node: OrNode, scope: Scope): TypeNode {\n  const left = walk({node: node.left, scope})\n  const right = walk({node: node.right, scope})\n  return mapNode(left, scope, (lhs) =>\n    mapNode(right, scope, (rhs) => {\n      const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope))\n\n      return booleanInterpretationToTypeNode(value)\n    }),\n  )\n}\n\nconst OVERRIDE_TYPE_SYMBOL = Symbol('groq-js.type')\n\n/**\n * `overrideTypeForNode` overrides the inferred type for a specific node: The\n * type evaluator will ignore its built-in logic and instead _always_ return\n * this type. This is intended to be used for testing.\n * @internal - This is only exported for testing purposes.\n */\nexport function overrideTypeForNode(node: ExprNode, type: TypeNode): void {\n  ;(node as any)[OVERRIDE_TYPE_SYMBOL] = type\n}\n\n/**\n * Walks through the AST and evaluates the type of each node.\n *\n * @param node - The AST node to evaluate.\n * @param scope - The current scope.\n * @returns The evaluated type of the node.\n * @internal\n */\n// eslint-disable-next-line complexity\nexport function walk({node, scope}: {node: ExprNode; scope: Scope}): TypeNode {\n  if (OVERRIDE_TYPE_SYMBOL in node) {\n    return node[OVERRIDE_TYPE_SYMBOL] as TypeNode\n  }\n\n  switch (node.type) {\n    // Filtering, traversal & projections\n    case 'Map': {\n      return handleMap(node, scope)\n    }\n    case 'Projection': {\n      return handleProjectionNode(node, scope)\n    }\n    case 'Filter': {\n      return handleFilterNode(node, scope)\n    }\n    case 'AccessAttribute': {\n      return optimizeUnions(handleAccessAttributeNode(node, scope))\n    }\n    case 'AccessElement': {\n      return handleAccessElementNode(node, scope)\n    }\n    case 'ArrayCoerce': {\n      return handleArrayCoerceNode(node, scope)\n    }\n    case 'FlatMap': {\n      return handleFlatMap(node, scope)\n    }\n\n    // Operations\n    case 'OpCall': {\n      return handleOpCallNode(node, scope)\n    }\n\n    case 'And': {\n      return handleAndNode(node, scope)\n    }\n\n    case 'Or': {\n      return handleOrNode(node, scope)\n    }\n\n    case 'Select': {\n      return handleSelectNode(node, scope)\n    }\n    case 'PipeFuncCall': {\n      return walk({node: node.base, scope})\n    }\n\n    // Values\n    case 'Deref': {\n      return handleDerefNode(node, scope)\n    }\n    case 'Object': {\n      return handleObjectNode(node, scope)\n    }\n    case 'Value': {\n      return handleValueNode(node, scope)\n    }\n    case 'Array': {\n      return handleArrayNode(node, scope)\n    }\n\n    // Special cases\n    case 'Everything': {\n      return handleEverythingNode(node, scope)\n    }\n\n    case 'This': {\n      $trace('this %O', scope.value)\n      return scope.value\n    }\n\n    case 'Parent': {\n      return handleParentNode(node, scope)\n    }\n    case 'FuncCall': {\n      return handleFuncCallNode(node, scope)\n    }\n    case 'Group': {\n      return walk({node: node.base, scope})\n    }\n    case 'Not': {\n      return handleNotNode(node, scope)\n    }\n    case 'Parameter': {\n      return {\n        type: 'unknown',\n      }\n    }\n\n    case 'Slice': {\n      return handleSlice(node, scope)\n    }\n    case 'Neg': {\n      return handleNegNode(node, scope)\n    }\n    case 'Pos': {\n      return handlePosNode(node, scope)\n    }\n    // everything else\n    case 'Asc':\n    case 'Desc':\n    case 'Context':\n    case 'Tuple':\n    case 'SelectorFuncCall':\n    case 'SelectorNested':\n    case 'InRange': {\n      return {type: 'unknown'}\n    }\n\n    default: {\n      // @ts-expect-error - we should have handled all cases\n      throw new Error(`unknown node type ${node.type}`)\n    }\n  }\n}\n\nfunction isPrimitiveTypeNode(node: TypeNode): node is PrimitiveTypeNode {\n  return node.type === 'string' || node.type === 'number' || node.type === 'boolean'\n}\n\nfunction evaluateComparison(\n  opcall: OpCall,\n  left: PrimitiveTypeNode,\n  right: PrimitiveTypeNode,\n): boolean | undefined {\n  if (left.value === undefined || right.value === undefined) {\n    return undefined\n  }\n  switch (opcall) {\n    case '==': {\n      return left.value === right.value\n    }\n    case '<': {\n      return left.value < right.value\n    }\n    case '<=': {\n      return left.value <= right.value\n    }\n    case '>': {\n      return left.value > right.value\n    }\n    case '>=': {\n      return left.value >= right.value\n    }\n    default: {\n      throw new Error(`unknown comparison operator ${opcall}`)\n    }\n  }\n}\n\n// eslint-disable-next-line complexity, max-statements\nfunction resolveFilter(expr: ExprNode, scope: Scope): UnionTypeNode {\n  $trace('resolveFilter.expr %O', expr)\n  const filtered = scope.value.of.filter((node) => {\n    // create a new scope with the current scopes parent as the parent. It's only a temporary scope since we only want to resolve the condition\n    // and check if the result can be true.\n    const subScope = scope.createHidden([node])\n    const cond = walk({node: expr, scope: subScope})\n    return booleanValue(cond, subScope).canBeTrue\n  })\n  $trace(\n    `resolveFilter ${expr.type === 'OpCall' ? `${expr.type}/${expr.op}` : expr.type} %O`,\n    filtered,\n  )\n  return {type: 'union', of: filtered}\n}\n\nfunction mapArray(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ArrayTypeNode) => TypeNode,\n): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'unknown') {\n      return base\n    }\n    if (base.type === 'array') {\n      return mapper(base)\n    }\n    return {type: 'null'}\n  })\n}\n\nfunction mapObject(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ObjectTypeNode) => TypeNode,\n): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'unknown') {\n      return base\n    }\n    if (base.type === 'object') {\n      return mapper(base)\n    }\n    return {type: 'null'}\n  })\n}\n"],"names":["string","text","flatMap","tokens","patterns","executeAsync","map","node","array","value","Scope","arg","innerResult","terms","parse","rhs","identLen","rawParse","match","of","arrayArg","sepArg","arg1","arg2","typeNode","$trace","attributeNode","base","inner"],"mappings":"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"}