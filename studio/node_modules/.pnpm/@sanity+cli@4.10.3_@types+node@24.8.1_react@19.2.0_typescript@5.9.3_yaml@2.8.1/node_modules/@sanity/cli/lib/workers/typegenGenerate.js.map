{"version":3,"file":"typegenGenerate.js","sources":["../../src/workers/typegenGenerate.ts"],"sourcesContent":["import {isMainThread, parentPort, workerData as _workerData} from 'node:worker_threads'\n\nimport {\n  findQueriesInPath,\n  getResolver,\n  readSchema,\n  registerBabel,\n  safeParseQuery,\n  TypeGenerator,\n} from '@sanity/codegen'\nimport createDebug from 'debug'\nimport {typeEvaluate, type TypeNode} from 'groq-js'\n\nconst $info = createDebug('sanity:codegen:generate:info')\n\nexport interface TypegenGenerateTypesWorkerData {\n  workDir: string\n  workspaceName?: string\n  schemaPath: string\n  searchPath: string | string[]\n  overloadClientMethods?: boolean\n}\n\nexport type TypegenGenerateTypesWorkerMessage =\n  | {\n      type: 'error'\n      error: Error\n      fatal: boolean\n      query?: string\n      filename?: string\n    }\n  | {\n      type: 'types'\n      filename: string\n      types: {\n        queryName: string\n        query: string\n        type: string\n        unknownTypeNodesGenerated: number\n        typeNodesGenerated: number\n        emptyUnionTypeNodesGenerated: number\n      }[]\n    }\n  | {\n      type: 'schema'\n      filename: string\n      schema: string\n      length: number\n    }\n  | {\n      type: 'typemap'\n      typeMap: string\n    }\n  | {\n      type: 'complete'\n    }\n\nif (isMainThread || !parentPort) {\n  throw new Error('This module must be run as a worker thread')\n}\n\nconst opts = _workerData as TypegenGenerateTypesWorkerData\n\nregisterBabel()\n\nasync function main() {\n  const schema = await readSchema(opts.schemaPath)\n\n  const typeGenerator = new TypeGenerator(schema)\n  const schemaTypes = [typeGenerator.generateSchemaTypes(), TypeGenerator.generateKnownTypes()]\n    .join('\\n')\n    .trim()\n  const resolver = getResolver()\n\n  parentPort?.postMessage({\n    type: 'schema',\n    schema: `${schemaTypes.trim()}\\n`,\n    filename: 'schema.json',\n    length: schema.length,\n  } satisfies TypegenGenerateTypesWorkerMessage)\n\n  const queries = findQueriesInPath({\n    path: opts.searchPath,\n    resolver,\n  })\n\n  const allQueries = []\n\n  for await (const result of queries) {\n    if (result.type === 'error') {\n      parentPort?.postMessage({\n        type: 'error',\n        error: result.error,\n        fatal: false,\n        filename: result.filename,\n      } satisfies TypegenGenerateTypesWorkerMessage)\n      continue\n    }\n    $info(`Processing ${result.queries.length} queries in \"${result.filename}\"...`)\n\n    const fileQueryTypes: {\n      queryName: string\n      query: string\n      type: string\n      typeName: string\n      typeNode: TypeNode\n      unknownTypeNodesGenerated: number\n      typeNodesGenerated: number\n      emptyUnionTypeNodesGenerated: number\n    }[] = []\n    for (const {name: queryName, result: query} of result.queries) {\n      try {\n        const ast = safeParseQuery(query)\n        const queryTypes = typeEvaluate(ast, schema)\n\n        const typeName = `${queryName}Result`\n        const type = typeGenerator.generateTypeNodeTypes(typeName, queryTypes)\n\n        const queryTypeStats = walkAndCountQueryTypeNodeStats(queryTypes)\n        fileQueryTypes.push({\n          queryName,\n          query,\n          typeName,\n          typeNode: queryTypes,\n          type: `${type.trim()}\\n`,\n          unknownTypeNodesGenerated: queryTypeStats.unknownTypes,\n          typeNodesGenerated: queryTypeStats.allTypes,\n          emptyUnionTypeNodesGenerated: queryTypeStats.emptyUnions,\n        })\n      } catch (err) {\n        parentPort?.postMessage({\n          type: 'error',\n          error: new Error(\n            `Error generating types for query \"${queryName}\" in \"${result.filename}\": ${err.message}`,\n            {cause: err},\n          ),\n          fatal: false,\n          query,\n        } satisfies TypegenGenerateTypesWorkerMessage)\n      }\n    }\n\n    if (fileQueryTypes.length > 0) {\n      $info(`Generated types for ${fileQueryTypes.length} queries in \"${result.filename}\"\\n`)\n      parentPort?.postMessage({\n        type: 'types',\n        types: fileQueryTypes,\n        filename: result.filename,\n      } satisfies TypegenGenerateTypesWorkerMessage)\n    }\n\n    if (fileQueryTypes.length > 0) {\n      allQueries.push(...fileQueryTypes)\n    }\n  }\n\n  if (opts.overloadClientMethods && allQueries.length > 0) {\n    const typeMap = `${typeGenerator.generateQueryMap(allQueries).trim()}\\n`\n    parentPort?.postMessage({\n      type: 'typemap',\n      typeMap,\n    } satisfies TypegenGenerateTypesWorkerMessage)\n  }\n\n  parentPort?.postMessage({\n    type: 'complete',\n  } satisfies TypegenGenerateTypesWorkerMessage)\n}\n\nfunction walkAndCountQueryTypeNodeStats(typeNode: TypeNode): {\n  allTypes: number\n  unknownTypes: number\n  emptyUnions: number\n} {\n  switch (typeNode.type) {\n    case 'unknown': {\n      return {allTypes: 1, unknownTypes: 1, emptyUnions: 0}\n    }\n    case 'array': {\n      const acc = walkAndCountQueryTypeNodeStats(typeNode.of)\n      acc.allTypes += 1 // count the array type itself\n      return acc\n    }\n    case 'object': {\n      // if the rest is unknown, we count it as one unknown type\n      if (typeNode.rest && typeNode.rest.type === 'unknown') {\n        return {allTypes: 2, unknownTypes: 1, emptyUnions: 0} // count the object type itself as well\n      }\n\n      const restStats = typeNode.rest\n        ? walkAndCountQueryTypeNodeStats(typeNode.rest)\n        : {allTypes: 1, unknownTypes: 0, emptyUnions: 0} // count the object type itself\n\n      return Object.values(typeNode.attributes).reduce((acc, attribute) => {\n        const {allTypes, unknownTypes, emptyUnions} = walkAndCountQueryTypeNodeStats(\n          attribute.value,\n        )\n        return {\n          allTypes: acc.allTypes + allTypes,\n          unknownTypes: acc.unknownTypes + unknownTypes,\n          emptyUnions: acc.emptyUnions + emptyUnions,\n        }\n      }, restStats)\n    }\n    case 'union': {\n      if (typeNode.of.length === 0) {\n        return {allTypes: 1, unknownTypes: 0, emptyUnions: 1}\n      }\n\n      return typeNode.of.reduce(\n        (acc, type) => {\n          const {allTypes, unknownTypes, emptyUnions} = walkAndCountQueryTypeNodeStats(type)\n          return {\n            allTypes: acc.allTypes + allTypes,\n            unknownTypes: acc.unknownTypes + unknownTypes,\n            emptyUnions: acc.emptyUnions + emptyUnions,\n          }\n        },\n        {allTypes: 1, unknownTypes: 0, emptyUnions: 0}, // count the union type itself\n      )\n    }\n    default: {\n      return {allTypes: 1, unknownTypes: 0, emptyUnions: 0}\n    }\n  }\n}\n\nmain()\n"],"names":["createDebug","isMainThread","parentPort","_workerData","registerBabel","readSchema","TypeGenerator","getResolver","findQueriesInPath","safeParseQuery","typeEvaluate"],"mappings":"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"}