{"version":3,"file":"_internal.js","sources":["../src/descriptors/convert.ts","../src/descriptors/sync.ts","../src/legacy/actionUtils.ts","../src/sanity/builtinTypes/assetSourceData.ts","../src/sanity/builtinTypes/fileAsset.ts","../src/sanity/builtinTypes/geopoint.ts","../src/sanity/builtinTypes/imageAsset.ts","../src/sanity/builtinTypes/imageCrop.ts","../src/sanity/builtinTypes/imageDimensions.ts","../src/sanity/builtinTypes/imageHotspot.ts","../src/sanity/builtinTypes/imageMetadata.ts","../src/sanity/builtinTypes/imagePalette.ts","../src/sanity/builtinTypes/imagePaletteSwatch.ts","../src/sanity/builtinTypes/slug.ts","../src/sanity/builtinTypes/index.ts","../src/sanity/validation/createValidationResult.ts","../src/sanity/groupProblems.ts","../src/sanity/validation/utils/getDupes.ts","../src/core/traverseSchema.ts","../src/sanity/coreTypes.ts","../src/sanity/traverseSchema.ts","../src/sanity/validation/types/array.ts","../src/sanity/validation/utils/isJSONTypeOf.ts","../src/sanity/validation/types/block.ts","../src/sanity/validation/utils/validateNonObjectFieldsProp.ts","../src/sanity/validation/utils/validateTypeName.ts","../src/sanity/validation/types/deprecated.ts","../src/sanity/validation/types/common.ts","../src/sanity/validation/types/crossDatasetReference.ts","../src/sanity/validation/utils/isComponent.ts","../src/sanity/validation/utils/validateComponent.ts","../src/sanity/validation/types/object.ts","../src/sanity/validation/types/document.ts","../src/sanity/validation/types/file.ts","../src/sanity/validation/types/globalDocumentReference.ts","../src/sanity/validation/types/image.ts","../src/sanity/validation/types/reference.ts","../src/sanity/validation/types/rootType.ts","../src/sanity/validation/types/slug.ts","../src/sanity/validateSchema.ts","../src/sanity/validation/ValidationError.ts","../src/sanity/createSchemaFromManifestTypes.ts","../src/sanity/extractSchema.ts","../src/sanity/validateMediaLibraryAssetAspect.ts"],"sourcesContent":["import {\n  type EncodableObject,\n  type EncodableValue,\n  SetBuilder,\n  type SetSynchronization,\n} from '@sanity/descriptors'\nimport {\n  type ArraySchemaType,\n  type FieldGroupDefinition,\n  type FieldsetDefinition,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule as IRule,\n  type Schema,\n  type SchemaType,\n} from '@sanity/types'\nimport {isEqual, isObject} from 'lodash'\n\nimport {Rule} from '../legacy/Rule'\nimport {OWN_PROPS_NAME} from '../legacy/types/constants'\nimport {\n  type ArrayTypeDef,\n  type CommonTypeDef,\n  type CoreTypeDef,\n  type CyclicMarker,\n  type DepthMarker,\n  type FieldReference,\n  type FunctionMarker,\n  type JSXMarker,\n  type ObjectField,\n  type ObjectFieldset,\n  type ObjectGroup,\n  type ObjectI18n,\n  type ObjectI18nValue,\n  type ObjectMessage,\n  type ObjectOrdering,\n  type ObjectOrderingBy,\n  type ReferenceTypeDef,\n  type RegistryType,\n  type Rule as RuleType,\n  type SubtypeDef,\n  type TypeDef,\n  type UndefinedMarker,\n  type UnknownMarker,\n  type Validation,\n  type ValidationMessage,\n} from './types'\n\nconst MAX_DEPTH_UKNOWN = 5\n\ntype UnknownRecord<T> = {[P in keyof T]: unknown}\n\nexport class DescriptorConverter {\n  opts: Options\n  cache: WeakMap<Schema, SetSynchronization<RegistryType>> = new WeakMap()\n\n  constructor(opts: Options) {\n    this.opts = opts\n  }\n\n  /**\n   * Returns a synchronization object for a schema.\n   *\n   * This is automatically cached in a weak map.\n   */\n  get(schema: Schema): SetSynchronization<RegistryType> {\n    let value = this.cache.get(schema)\n    if (value) return value\n\n    const builder = new SetBuilder()\n    for (const name of schema.getLocalTypeNames()) {\n      const typeDef = convertTypeDef(schema.get(name)!, this.opts)\n      builder.addObject('sanity.schema.namedType', {name, typeDef})\n    }\n\n    if (schema.parent) {\n      builder.addSet(this.get(schema.parent))\n    }\n\n    value = builder.build('sanity.schema.registry')\n    this.cache.set(schema, value)\n    return value\n  }\n}\n\nfunction convertCommonTypeDef(schemaType: SchemaType, opts: Options): CommonTypeDef {\n  // Note that OWN_PROPS_NAME is only set on subtypes, not the core types.\n  // We might consider setting OWN_PROPS_NAME on _all_ types to avoid this branch.\n  const ownProps = OWN_PROPS_NAME in schemaType ? (schemaType as any)[OWN_PROPS_NAME] : schemaType\n\n  let fields: ObjectField[] | undefined\n  if (Array.isArray(ownProps.fields)) {\n    fields = (ownProps.fields as ObjectSchemaType['fields']).map(\n      ({name, group, fieldset, type}) => ({\n        name,\n        typeDef: convertTypeDef(type, opts),\n        groups: arrayifyString(group),\n        fieldset,\n      }),\n    )\n  }\n\n  let fieldsets: ObjectFieldset[] | undefined\n  if (Array.isArray(ownProps.fieldsets)) {\n    fieldsets = filterStringKey(\n      'name',\n      (ownProps.fieldsets as Array<UnknownRecord<FieldsetDefinition>>).map(\n        ({name, title, description, group, hidden, readOnly, options}) => ({\n          name,\n          title: maybeString(title),\n          description: maybeString(description),\n          group: maybeString(group),\n          hidden: conditionalTrue(hidden),\n          readOnly: conditionalTrue(readOnly),\n          options: convertUnknown(options),\n        }),\n      ),\n    )\n  }\n\n  let groups: ObjectGroup[] | undefined\n  if (Array.isArray(ownProps.groups)) {\n    groups = filterStringKey(\n      'name',\n      (ownProps.groups as Array<UnknownRecord<FieldGroupDefinition>>).map(\n        ({name, title, hidden, default: def, i18n}) => ({\n          name,\n          title: maybeString(title),\n          hidden: conditionalTrue(hidden),\n          default: maybeTrue(def),\n          i18n: maybeI18n(i18n),\n        }),\n      ),\n    )\n  }\n\n  const reason = ownProps.deprecated?.reason\n\n  let orderings: ObjectOrdering[] | undefined\n  if (Array.isArray(ownProps.orderings)) {\n    orderings = ownProps.orderings\n      .map(maybeOrdering)\n      .filter((o: ObjectOrdering | undefined) => o !== undefined)\n  }\n\n  return {\n    title: maybeString(ownProps.title),\n    description: maybeStringOrJSX(ownProps.description),\n    readOnly: conditionalTrue(ownProps.readOnly),\n    hidden: conditionalTrue(ownProps.hidden),\n    liveEdit: maybeTrue(ownProps.liveEdit),\n    options: convertUnknown(ownProps.options),\n    initialValue: convertUnknown(ownProps.initialValue),\n    deprecated: typeof reason === 'string' ? {reason} : undefined,\n    placeholder: maybeString(ownProps.placeholder),\n    rows: maybeNumberAsString(ownProps.rows),\n    fields,\n    fieldsets,\n    groups,\n    validation: maybeValidations(ownProps),\n    orderings,\n  }\n}\n\n/**\n * Options used when converting the schema.\n *\n * We know we need this in order to handle validations.\n **/\nexport type Options = Record<never, never>\n\nexport function convertTypeDef(schemaType: SchemaType, opts: Options): TypeDef {\n  const common = convertCommonTypeDef(schemaType, opts)\n\n  if (!schemaType.type) {\n    return {\n      extends: null,\n      jsonType: schemaType.jsonType,\n      ...common,\n    } satisfies CoreTypeDef\n  }\n\n  // The types below are somewhat magical: It's only direct subtypes of array/reference which\n  // are allowed to have of/to assigned to them. We handle them specifically here since this\n  // gives us more control over the types.\n\n  switch (schemaType.type.name) {\n    case 'array': {\n      return {\n        extends: 'array',\n        of: (schemaType as ArraySchemaType).of.map((ofType) => ({\n          name: ofType.name,\n          typeDef: convertTypeDef(ofType, opts),\n        })),\n        ...common,\n      } satisfies ArrayTypeDef\n    }\n    case 'reference':\n    case 'globalDocumentReference':\n    case 'crossDatasetReference':\n      return {\n        extends: schemaType.type.name,\n        to: filterStringKey(\n          'name',\n          (schemaType as ReferenceSchemaType).to\n            // The `toType.type` case is for crossDatasetReferences/crossDatasetReference\n            .map((toType) => ({name: toType.name || toType.type?.name || toType.type})),\n        ),\n        ...common,\n      } satisfies ReferenceTypeDef\n    default:\n      return {extends: schemaType.type.name, ...common} satisfies SubtypeDef\n  }\n}\n\nfunction maybeString(val: unknown): string | undefined {\n  return typeof val === 'string' ? val : undefined\n}\n\nfunction maybeNumberAsString(val: unknown): string | undefined {\n  return typeof val === 'number' ? val.toString() : undefined\n}\n\n/** Returns `true` for `true` and undefined for everything else. */\nfunction maybeTrue(val: unknown): true | undefined {\n  return val === true ? true : undefined\n}\n\nfunction conditionalTrue(val: unknown): true | undefined | FunctionMarker {\n  if (typeof val === 'function') return FUNCTION_MARKER\n  return maybeTrue(val)\n}\n\nfunction filterStringKey<T, K extends keyof T>(key: K, arr: T[]): Array<T & {[key in K]: string}> {\n  return arr.filter((obj): obj is T & {[key in K]: string} => typeof obj[key] === 'string')\n}\n\nfunction arrayifyString(val: unknown): string[] | undefined {\n  if (typeof val === 'string') {\n    return [val]\n  }\n\n  if (Array.isArray(val)) {\n    return val.filter((elem) => typeof elem === 'string')\n  }\n\n  return undefined\n}\n\nconst FUNCTION_MARKER: FunctionMarker = {__type: 'function'}\nconst UNKNOWN_MARKER: UnknownMarker = {__type: 'unknown'}\nconst UNDEFINED_MARKER: UndefinedMarker = {__type: 'undefined'}\nconst CYCLIC_MARKER: CyclicMarker = {__type: 'cyclic'}\nconst MAX_DEPTH_MARKER: DepthMarker = {__type: 'maxDepth'}\n\nfunction convertUnknown(\n  val: unknown,\n  seen = new Set(),\n  maxDepth = MAX_DEPTH_UKNOWN,\n): EncodableValue | undefined {\n  if (maxDepth === 0) return MAX_DEPTH_MARKER\n\n  if (typeof val === 'string' || typeof val === 'boolean' || val === null || val === undefined) {\n    return val\n  }\n\n  if (typeof val === 'number') {\n    return {__type: 'number', value: val.toString()}\n  }\n\n  if (typeof val === 'function') return FUNCTION_MARKER\n\n  if (seen.has(val)) {\n    return CYCLIC_MARKER\n  }\n\n  seen.add(val)\n\n  if (isObject(val)) {\n    if (Array.isArray(val)) {\n      return val.map((elem) => {\n        const res = convertUnknown(elem, seen, maxDepth - 1)\n        return res === undefined ? UNDEFINED_MARKER : res\n      })\n    }\n\n    if ('$$typeof' in val && 'type' in val && 'props' in val) {\n      // React element:\n      const {type, props} = val\n      const strType = typeof type === 'function' ? type.name : type\n      if (typeof strType !== 'string') return undefined\n      return {\n        __type: 'jsx',\n        type: strType,\n        props: convertUnknown(props, seen, maxDepth - 1) as EncodableObject,\n      }\n    }\n\n    let hasType = false\n    const result: EncodableObject = {}\n    for (const [key, field] of Object.entries(val)) {\n      if (key === '__type') hasType = true\n      result[key] = convertUnknown(field, seen, maxDepth - 1)\n    }\n\n    return hasType ? {__type: 'object', value: result} : result\n  }\n\n  return UNKNOWN_MARKER\n}\n\nfunction maybeStringOrJSX(val: unknown): string | undefined | JSXMarker {\n  if (typeof val === 'string') return val\n  if (isObject(val) && '$$typeof' in val && 'type' in val && 'props' in val) {\n    const {type, props} = val\n    const strType = typeof type === 'function' ? type.name : type\n    if (typeof strType !== 'string') return undefined\n    return {__type: 'jsx', type: strType, props: convertUnknown(props) as EncodableObject}\n  }\n  return undefined\n}\n\n// maybeValidations attempts to serialize the validations of a type. Note: we need the whole type object and not\n// just the validation property as we need to recreate implied validations of various properties. This are technically\n// inherited and thus lost since we operate on the ownProps.\nfunction maybeValidations(obj: unknown): Validation[] | undefined {\n  if (!isObject(obj) || !('type' in obj)) return undefined\n\n  // Implied rules are rules which are inherited by the types. Since the descriptor operates on the ownProps\n  // it is necessary to add these rule back to ensure we have the default validations for the types.\n  const impliedRules: RuleType[] = []\n\n  if (\n    'options' in obj &&\n    isObject(obj.options) &&\n    'list' in obj.options &&\n    Array.isArray(obj.options.list)\n  ) {\n    impliedRules.push({\n      type: 'enum',\n      values: obj.options.list\n        .map((o) => convertUnknown(extractValueFromListOption(o, obj)))\n        .filter((v: EncodableValue | undefined) => v !== undefined),\n    })\n  }\n\n  switch (obj.type) {\n    case 'url':\n      impliedRules.push({\n        type: 'uri',\n        allowRelative: false,\n      })\n      break\n    case 'slug':\n      impliedRules.push({\n        type: 'custom',\n      })\n      break\n    case 'reference':\n      impliedRules.push({\n        type: 'reference',\n      })\n      break\n    case 'email':\n      impliedRules.push({\n        type: 'email',\n      })\n      break\n    default:\n    // Do nothing\n  }\n\n  // Shortcut\n  if (!('validation' in obj) || !obj.validation) {\n    if (impliedRules.length > 0) {\n      return [\n        {\n          level: 'error',\n          rules: impliedRules,\n        },\n      ]\n    }\n    return undefined\n  }\n\n  const validations: Validation[] = []\n  const rules = Array.isArray(obj.validation) ? obj.validation : [obj.validation]\n  for (const rule of rules) {\n    const validation = maybeValidation(rule)\n    if (validation === undefined) {\n      continue\n    }\n\n    // Add implied rules that aren't already defined in the validation\n    const rulesToAdd = impliedRules.filter((ir) => !validation.rules.some((r) => isEqual(r, ir)))\n    if (rulesToAdd.length > 0) {\n      validation.rules.unshift(...rulesToAdd)\n    }\n\n    // If the validation is already present, skip adding it\n    if (validations.some((v) => isEqual(v, validation))) {\n      continue\n    }\n\n    validations.push(validation)\n  }\n\n  return validations.length > 0 ? validations : undefined\n}\n\nfunction hasValueField(typeDef: unknown): boolean {\n  if (!typeDef || typeof typeDef !== 'object') return false\n  if (!('fields' in typeDef)) {\n    if ('type' in typeDef && typeDef.type) return hasValueField(typeDef.type)\n    return false\n  }\n  if (!Array.isArray(typeDef.fields)) return false\n  return typeDef.fields.some((field) => field.name === 'value')\n}\n\n// This logic is pulled from extractValueFromListOption in packages/sanity/src/core/validation/util/normalizeValidationRules.ts.\n// It has been slightly tweaked to be safer in accessing the value attribute of the option variable\nfunction extractValueFromListOption(option: unknown, typeDef: Record<string, unknown>): unknown {\n  // If you define a `list` option with object items, where the item has a `value` field,\n  // we don't want to treat that as the value but rather the surrounding object\n  // This differs from the case where you have a title/value pair setup for a string/number, for instance\n  if (typeDef.jsonType === 'object' && hasValueField(typeDef)) return option\n\n  if (isObject(option) && 'value' in option && option.value) {\n    return option.value\n  }\n\n  return option\n}\n\nfunction maybeValidation(val: unknown): Validation | undefined {\n  // Handle undefined, false\n  if (!val) {\n    return undefined\n  }\n\n  // Handle function rules - these are functions that return a Rule\n  if (isIRuleFunction(val)) {\n    try {\n      const result = val(new Rule())\n\n      // If the result is a Rule object, attempt to convert it\n      if (isIRule(result)) {\n        // Recursively convert the returned Rule object\n        return maybeValidation(result)\n      }\n\n      throw new Error('failed to convert to plain rule')\n    } catch (error) {\n      // If the function could not convert into a plain rule, mark it as custom\n      return {\n        level: 'error',\n        rules: [{type: 'custom', name: 'function'}],\n      }\n    }\n  }\n\n  // Handle Rule object\n  if (isIRule(val)) {\n    // Determine validation level\n    const level: Validation['level'] = val._level || 'error'\n\n    // Convert message\n    const message = maybeValidationMessage(val._message)\n\n    // Convert RuleSpec array to Rule array\n    const rules: RuleType[] = []\n\n    for (const spec of val._rules || []) {\n      // For custom rule spec, the optional property is determined by the rule.\n      // This is used to determine the behaviour the rule when the value is undefined or null\n      const optional = val._required === 'optional' || undefined\n      const convertedRule = convertRuleSpec(spec, optional)\n      if (convertedRule === undefined) {\n        continue\n      }\n\n      // If the converted spec is a duplicate, skip adding it\n      if (rules.some((r) => isEqual(r, convertedRule))) {\n        continue\n      }\n\n      rules.push(convertedRule)\n    }\n\n    if (rules.length === 0) {\n      return undefined\n    }\n\n    return {\n      level,\n      rules,\n      ...(message && {message}),\n    }\n  }\n\n  return undefined\n}\n\nfunction isIRule(val: unknown): val is IRule {\n  return isObject(val) && '_rules' in val\n}\n\nfunction maybeValidationMessage(val: unknown): ValidationMessage | undefined {\n  if (typeof val === 'string') return val\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  const objectMessage: ObjectMessage = {}\n  for (const [field, value] of Object.entries(val)) {\n    if (typeof field !== 'string' || typeof value !== 'string') {\n      continue\n    }\n    objectMessage[field] = value\n  }\n\n  return Object.keys(objectMessage).length > 0 ? objectMessage : undefined\n}\n\nfunction isIRuleFunction(val: unknown): val is (rule: IRule) => IRule | undefined {\n  return typeof val === 'function'\n}\n\n// eslint-disable-next-line complexity\nfunction convertRuleSpec(spec: unknown, optional?: true | undefined): RuleType | undefined {\n  if (!isObject(spec) || !('flag' in spec)) {\n    return undefined\n  }\n\n  const constraint = 'constraint' in spec ? spec.constraint : undefined\n\n  switch (spec.flag) {\n    case 'integer':\n      return {type: 'integer'}\n    case 'email':\n      return {type: 'email'}\n    case 'unique':\n      return {type: 'uniqueItems'}\n    case 'reference':\n      return {type: 'reference'}\n    case 'assetRequired':\n      return {type: 'assetRequired'}\n    case 'stringCasing':\n      if (constraint === 'uppercase') return {type: 'uppercase'}\n      if (constraint === 'lowercase') return {type: 'lowercase'}\n      return undefined\n    case 'all':\n      if (Array.isArray(constraint)) {\n        const children = constraint\n          .map((childRule) => maybeValidation(childRule))\n          .filter((c) => c !== undefined)\n        if (children.length > 0) {\n          return {type: 'allOf', children}\n        }\n      }\n      return undefined\n    case 'either':\n      if (Array.isArray(constraint)) {\n        const children = constraint\n          .map((childRule) => maybeValidation(childRule))\n          .filter((c) => c !== undefined)\n        if (children.length > 0) {\n          return {type: 'anyOf', children}\n        }\n      }\n      return undefined\n    case 'valid':\n      if (Array.isArray(constraint)) {\n        return {\n          type: 'enum',\n          values: constraint.map((c) => convertUnknown(c)).filter((v) => v !== undefined),\n        }\n      }\n      return undefined\n    case 'min':\n      return {type: 'minimum', value: convertConstraintValue(constraint)}\n    case 'max':\n      return {type: 'maximum', value: convertConstraintValue(constraint)}\n    case 'length':\n      return {type: 'length', value: convertConstraintValue(constraint)}\n    case 'precision':\n      return {type: 'precision', value: convertConstraintValue(constraint)}\n    case 'lessThan':\n      return {type: 'exclusiveMaximum', value: convertConstraintValue(constraint)}\n    case 'greaterThan':\n      return {type: 'exclusiveMinimum', value: convertConstraintValue(constraint)}\n    case 'regex':\n      if (isObject(constraint) && 'pattern' in constraint) {\n        const {pattern} = constraint\n        const invert = 'invert' in constraint ? maybeBoolean(constraint.invert) : undefined\n\n        if (pattern instanceof RegExp) {\n          return {\n            type: 'regex',\n            pattern: pattern.source,\n            ...(invert && {invert: true}),\n          }\n        }\n      }\n      return undefined\n    case 'uri': {\n      const allowRelative =\n        isObject(constraint) &&\n        'options' in constraint &&\n        isObject(constraint.options) &&\n        'allowRelative' in constraint.options\n          ? maybeBoolean(constraint.options.allowRelative)\n          : undefined\n\n      return {\n        type: 'uri',\n        ...(allowRelative !== undefined && {allowRelative}),\n      }\n    }\n    case 'custom':\n      return {type: 'custom', ...(optional && {optional})}\n    case 'media':\n      return {type: 'custom', name: 'media'}\n    case 'type':\n      return undefined\n    case 'presence':\n      if (constraint === 'required') return {type: 'required'}\n      if (constraint === 'optional') return undefined\n      return undefined\n    default:\n      return undefined\n  }\n}\n\nfunction convertConstraintValue(constraint: unknown): string | FieldReference {\n  if (\n    isObject(constraint) &&\n    'type' in constraint &&\n    'path' in constraint &&\n    constraint.type &&\n    constraint.path\n  ) {\n    // This is a FieldReference\n    return {\n      type: 'fieldReference',\n      path: Array.isArray(constraint.path) ? constraint.path : [constraint.path],\n    }\n  }\n  // Convert to string\n  return String(constraint)\n}\n\nfunction maybeBoolean(val: unknown): boolean | undefined {\n  if (typeof val === 'boolean') {\n    return val\n  }\n  return undefined\n}\n\nfunction maybeI18n(val: unknown): ObjectI18n | undefined {\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  // Convert I18nTextRecord to LocalizedMessage format\n  const localizedMessage: ObjectI18n = {}\n  for (const entry of Object.entries(val)) {\n    if (isI18nEntry(entry)) {\n      const [field, value] = entry\n      localizedMessage[field] = {\n        ns: value.ns,\n        key: value.key,\n      }\n    }\n  }\n\n  return Object.keys(localizedMessage).length > 0 ? localizedMessage : undefined\n}\n\nfunction isI18nEntry(entry: [unknown, unknown]): entry is [string, ObjectI18nValue] {\n  const [key, value] = entry\n  return (\n    typeof key === 'string' &&\n    !!value &&\n    typeof value === 'object' &&\n    'key' in value &&\n    'ns' in value &&\n    typeof value.key === 'string' &&\n    typeof value.ns === 'string'\n  )\n}\n\nfunction maybeOrdering(val: unknown): ObjectOrdering | undefined {\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  const name = 'name' in val && typeof val.name === 'string' ? val.name : undefined\n  // A valid ordering _must_ have a name\n  if (name === undefined) return undefined\n\n  // If no title is specified, default to the name\n  const title = 'title' in val && typeof val.title === 'string' ? val.title : name\n  const by = 'by' in val && Array.isArray(val.by) ? val.by : []\n\n  const orderingBy: ObjectOrderingBy[] = []\n  for (const item of by) {\n    const orderingItem = maybeOrderingBy(item)\n    if (orderingItem) {\n      orderingBy.push(orderingItem)\n    }\n  }\n\n  // A valid ordering _must_ have items (by)\n  if (orderingBy.length === 0) return undefined\n\n  const i18n = 'i18n' in val ? maybeI18n(val.i18n) : undefined\n\n  return {\n    name,\n    title,\n    by: orderingBy,\n    ...(i18n && {i18n}),\n  }\n}\n\nfunction maybeOrderingBy(val: unknown): ObjectOrderingBy | undefined {\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  const field = 'field' in val && typeof val.field === 'string' ? val.field : undefined\n  const direction =\n    'direction' in val && (val.direction === 'asc' || val.direction === 'desc')\n      ? val.direction\n      : undefined\n\n  if (!field || !direction) return undefined\n\n  return {field, direction}\n}\n","import {\n  processSetSynchronization,\n  type SetSynchronization,\n  type SynchronizationRequest,\n  type SynchronizationResult,\n} from '@sanity/descriptors'\n\nimport {type RegistryType} from './types'\n\n// This file provides wrapper types/functions for synchronizing a schema.\n// This avoids users of `@sanity/schema` to have to depend on `@sanity/descriptors`.\n\nexport type SchemaSynchronizationRequest = SynchronizationRequest\nexport type SchemaSynchronizationResult = SynchronizationResult\n\n/**\n * Returns the next request that should be generated for synchronizing the\n * schema, based on the previous response from the /synchronize endpoint.\n *\n * @param response - The previous response, or `null` if it's the first request.\n * @returns The next request, or `null` if it's been fully synchronized.\n */\nexport function processSchemaSynchronization(\n  sync: SetSynchronization<RegistryType>,\n  response: SchemaSynchronizationResult | null,\n): SchemaSynchronizationRequest | null {\n  return processSetSynchronization(sync, response)\n}\n","import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {type SchemaType} from '@sanity/types'\nimport {difference} from 'lodash'\n\nconst ACTIONS_FLAG = '__experimental_actions'\n\nconst DEFAULT_ACTIONS = ['create', 'update', 'delete', 'publish']\nconst VALID_ACTIONS = DEFAULT_ACTIONS\n\n// todo: enable this when officially deprecating experimental actions\nconst DEPRECATE_EXPERIMENTAL_ACTIONS = false\n\nconst hasWarned = {}\nconst readActions = (schemaType: SchemaType): string[] => {\n  if (DEPRECATE_EXPERIMENTAL_ACTIONS && !(schemaType.name in hasWarned)) {\n    console.warn(`Heads up! Experimental actions is now deprecated and replaced by Document Actions. Read more about how to migrate on ${generateHelpUrl(\n      'experimental-actions-replaced-by-document-actions',\n    )}\".\n`)\n    ;(hasWarned as any)[schemaType.name] = true\n  }\n\n  return ACTIONS_FLAG in schemaType ? (schemaType[ACTIONS_FLAG] as string[]) : DEFAULT_ACTIONS\n}\n\nconst validateActions = (typeName: string, actions: string[]) => {\n  if (!Array.isArray(actions)) {\n    throw new Error(\n      `The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(\n        ', ',\n      )}`,\n    )\n  }\n\n  const invalid = difference(actions, VALID_ACTIONS)\n\n  if (invalid.length > 0) {\n    throw new Error(\n      `Invalid action${\n        invalid.length > 1 ? 's' : ''\n      } configured for schema type \"${typeName}\": ${invalid.join(\n        ', ',\n      )}. Valid actions are: ${VALID_ACTIONS.join(', ')}`,\n    )\n  }\n\n  return actions\n}\n\nexport const resolveEnabledActions = (schemaType: SchemaType): string[] =>\n  validateActions(schemaType.name, readActions(schemaType))\n\nexport const isActionEnabled = (schemaType: SchemaType, action: string): boolean =>\n  resolveEnabledActions(schemaType).includes(action)\n","export default {\n  name: 'sanity.assetSourceData',\n  title: 'Asset Source Data',\n  type: 'object',\n  fields: [\n    {\n      name: 'name',\n      title: 'Source name',\n      description: 'A canonical name for the source this asset is originating from',\n      type: 'string',\n    },\n    {\n      name: 'id',\n      title: 'Asset Source ID',\n      description:\n        'The unique ID for the asset within the originating source so you can programatically find back to it',\n      type: 'string',\n    },\n    {\n      name: 'url',\n      title: 'Asset information URL',\n      description: 'A URL to find more information about this asset in the originating source',\n      type: 'string',\n    },\n  ],\n}\n","export default {\n  name: 'sanity.fileAsset',\n  title: 'File',\n  type: 'document',\n  fieldsets: [\n    {\n      name: 'system',\n      title: 'System fields',\n      description: 'These fields are managed by the system and not editable',\n    },\n  ],\n  fields: [\n    {\n      name: 'originalFilename',\n      type: 'string',\n      title: 'Original file name',\n      readOnly: true,\n    },\n    {\n      name: 'label',\n      type: 'string',\n      title: 'Label',\n    },\n    {\n      name: 'title',\n      type: 'string',\n      title: 'Title',\n    },\n    {\n      name: 'description',\n      type: 'string',\n      title: 'Description',\n    },\n    {\n      name: 'altText',\n      type: 'string',\n      title: 'Alternative text',\n    },\n    {\n      name: 'sha1hash',\n      type: 'string',\n      title: 'SHA1 hash',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'extension',\n      type: 'string',\n      title: 'File extension',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'mimeType',\n      type: 'string',\n      title: 'Mime type',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'size',\n      type: 'number',\n      title: 'File size in bytes',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'assetId',\n      type: 'string',\n      title: 'Asset ID',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'uploadId',\n      type: 'string',\n      readOnly: true,\n      hidden: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'path',\n      type: 'string',\n      title: 'Path',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'url',\n      type: 'string',\n      title: 'Url',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'source',\n      type: 'sanity.assetSourceData',\n      title: 'Source',\n      readOnly: true,\n      fieldset: 'system',\n    },\n  ],\n  preview: {\n    select: {\n      title: 'originalFilename',\n      path: 'path',\n      mimeType: 'mimeType',\n      size: 'size',\n    },\n    prepare(doc: Record<string, any>) {\n      return {\n        title: doc.title || doc.path.split('/').slice(-1)[0],\n        subtitle: `${doc.mimeType} (${(doc.size / 1024 / 1024).toFixed(2)} MB)`,\n      }\n    },\n  },\n  orderings: [\n    {\n      title: 'File size',\n      name: 'fileSizeDesc',\n      by: [{field: 'size', direction: 'desc'}],\n    },\n  ],\n}\n","export default {\n  title: 'Geographical Point',\n  name: 'geopoint',\n  type: 'object',\n  fields: [\n    {\n      name: 'lat',\n      type: 'number',\n      title: 'Latitude',\n    },\n    {\n      name: 'lng',\n      type: 'number',\n      title: 'Longitude',\n    },\n    {\n      name: 'alt',\n      type: 'number',\n      title: 'Altitude',\n    },\n  ],\n}\n","import {type SanityDocument} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageAsset',\n  title: 'Image',\n  type: 'document',\n  fieldsets: [\n    {\n      name: 'system',\n      title: 'System fields',\n      description: 'These fields are managed by the system and not editable',\n    },\n  ],\n  fields: [\n    {\n      name: 'originalFilename',\n      type: 'string',\n      title: 'Original file name',\n      readOnly: true,\n    },\n    {\n      name: 'label',\n      type: 'string',\n      title: 'Label',\n    },\n    {\n      name: 'title',\n      type: 'string',\n      title: 'Title',\n    },\n    {\n      name: 'description',\n      type: 'string',\n      title: 'Description',\n    },\n    {\n      name: 'altText',\n      type: 'string',\n      title: 'Alternative text',\n    },\n    {\n      name: 'sha1hash',\n      type: 'string',\n      title: 'SHA1 hash',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'extension',\n      type: 'string',\n      readOnly: true,\n      title: 'File extension',\n      fieldset: 'system',\n    },\n    {\n      name: 'mimeType',\n      type: 'string',\n      readOnly: true,\n      title: 'Mime type',\n      fieldset: 'system',\n    },\n    {\n      name: 'size',\n      type: 'number',\n      title: 'File size in bytes',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'assetId',\n      type: 'string',\n      title: 'Asset ID',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'uploadId',\n      type: 'string',\n      readOnly: true,\n      hidden: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'path',\n      type: 'string',\n      title: 'Path',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'url',\n      type: 'string',\n      title: 'Url',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'metadata',\n      type: 'sanity.imageMetadata',\n      title: 'Metadata',\n    },\n    {\n      name: 'source',\n      type: 'sanity.assetSourceData',\n      title: 'Source',\n      readOnly: true,\n      fieldset: 'system',\n    },\n  ],\n  preview: {\n    select: {\n      id: '_id',\n      title: 'originalFilename',\n      mimeType: 'mimeType',\n      size: 'size',\n    },\n    prepare(doc: Partial<SanityDocument>) {\n      return {\n        title: doc.title || (typeof doc.path === 'string' && doc.path.split('/').slice(-1)[0]),\n        media: {asset: {_ref: doc.id}},\n        subtitle: `${doc.mimeType} (${(Number(doc.size) / 1024 / 1024).toFixed(2)} MB)`,\n      }\n    },\n  },\n  orderings: [\n    {\n      title: 'File size',\n      name: 'fileSizeDesc',\n      by: [{field: 'size', direction: 'desc'}],\n    },\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageCrop',\n  title: 'Image crop',\n  type: 'object',\n  fields: [\n    {\n      name: 'top',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'bottom',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'left',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'right',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageDimensions',\n  type: 'object',\n  title: 'Image dimensions',\n  fields: [\n    {\n      name: 'height',\n      type: 'number',\n      title: 'Height',\n      readOnly: true,\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'width',\n      type: 'number',\n      title: 'Width',\n      readOnly: true,\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'aspectRatio',\n      type: 'number',\n      title: 'Aspect ratio',\n      readOnly: true,\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageHotspot',\n  title: 'Image hotspot',\n  type: 'object',\n  fields: [\n    {\n      name: 'x',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'y',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'height',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'width',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n  ],\n}\n","export default {\n  name: 'sanity.imageMetadata',\n  title: 'Image metadata',\n  type: 'object',\n  fieldsets: [\n    {\n      name: 'extra',\n      title: 'Extra metadata…',\n      options: {\n        collapsable: true,\n      },\n    },\n  ],\n  fields: [\n    {\n      name: 'location',\n      type: 'geopoint',\n    },\n    {\n      name: 'dimensions',\n      title: 'Dimensions',\n      type: 'sanity.imageDimensions',\n      fieldset: 'extra',\n    },\n    {\n      name: 'palette',\n      type: 'sanity.imagePalette',\n      title: 'Palette',\n      fieldset: 'extra',\n    },\n    {\n      name: 'lqip',\n      title: 'LQIP (Low-Quality Image Placeholder)',\n      type: 'string',\n      readOnly: true,\n    },\n    {\n      name: 'blurHash',\n      title: 'BlurHash',\n      type: 'string',\n      readOnly: true,\n    },\n    {\n      name: 'hasAlpha',\n      title: 'Has alpha channel',\n      type: 'boolean',\n      readOnly: true,\n    },\n    {\n      name: 'isOpaque',\n      title: 'Is opaque',\n      type: 'boolean',\n      readOnly: true,\n    },\n  ],\n}\n","export default {\n  name: 'sanity.imagePalette',\n  title: 'Image palette',\n  type: 'object',\n  fields: [\n    {name: 'darkMuted', type: 'sanity.imagePaletteSwatch', title: 'Dark Muted'},\n    {name: 'lightVibrant', type: 'sanity.imagePaletteSwatch', title: 'Light Vibrant'},\n    {name: 'darkVibrant', type: 'sanity.imagePaletteSwatch', title: 'Dark Vibrant'},\n    {name: 'vibrant', type: 'sanity.imagePaletteSwatch', title: 'Vibrant'},\n    {name: 'dominant', type: 'sanity.imagePaletteSwatch', title: 'Dominant'},\n    {name: 'lightMuted', type: 'sanity.imagePaletteSwatch', title: 'Light Muted'},\n    {name: 'muted', type: 'sanity.imagePaletteSwatch', title: 'Muted'},\n  ],\n}\n","export default {\n  name: 'sanity.imagePaletteSwatch',\n  title: 'Image palette swatch',\n  type: 'object',\n  fields: [\n    {name: 'background', type: 'string', title: 'Background', readOnly: true},\n    {name: 'foreground', type: 'string', title: 'Foreground', readOnly: true},\n    {name: 'population', type: 'number', title: 'Population', readOnly: true},\n    {name: 'title', type: 'string', title: 'String', readOnly: true},\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  title: 'Slug',\n  name: 'slug',\n  type: 'object',\n  fields: [\n    {\n      name: 'current',\n      title: 'Current slug',\n      type: 'string',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      // The source field is deprecated/unused, but leaving it included and hidden\n      // to prevent rendering \"Unknown field\" warnings on legacy data\n      name: 'source',\n      title: 'Source field',\n      type: 'string',\n      hidden: true,\n    },\n  ],\n}\n","import assetSourceData from './assetSourceData'\nimport fileAsset from './fileAsset'\nimport geopoint from './geopoint'\nimport imageAsset from './imageAsset'\nimport imageCrop from './imageCrop'\nimport imageDimensions from './imageDimensions'\nimport imageHotspot from './imageHotspot'\nimport imageMetadata from './imageMetadata'\nimport imagePalette from './imagePalette'\nimport imagePaletteSwatch from './imagePaletteSwatch'\nimport slug from './slug'\n\nexport const builtinTypes = [\n  assetSourceData,\n  slug,\n  geopoint,\n  // legacyRichDate,\n  imageAsset,\n  fileAsset,\n  imageCrop,\n  imageHotspot,\n  imageMetadata,\n  imageDimensions,\n  imagePalette,\n  imagePaletteSwatch,\n]\n","import {type SchemaValidationResult} from '../typedefs'\n\n// Temporary solution to ensure we have a central registry over used helpIds\nexport const HELP_IDS = {\n  TYPE_INVALID: 'schema-type-invalid',\n  TYPE_IS_ESM_MODULE: 'schema-type-is-esm-module',\n  TYPE_NAME_RESERVED: 'schema-type-name-reserved',\n  TYPE_MISSING_NAME: 'schema-type-missing-name-or-type',\n  TYPE_MISSING_TYPE: 'schema-type-missing-name-or-type',\n  TYPE_TITLE_RECOMMENDED: 'schema-type-title-is-recommended',\n  TYPE_TITLE_INVALID: 'schema-type-title-is-recommended',\n  OBJECT_FIELDS_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NOT_UNIQUE: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NAME_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_DEFINITION_INVALID_TYPE: 'schema-object-fields-invalid',\n  ARRAY_PREDEFINED_CHOICES_INVALID: 'schema-predefined-choices-invalid',\n  ARRAY_OF_ARRAY: 'schema-array-of-array',\n  ARRAY_OF_INVALID: 'schema-array-of-invalid',\n  ARRAY_OF_NOT_UNIQUE: 'schema-array-of-invalid',\n  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: 'schema-array-of-type-global-type-conflict',\n  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: 'schema-array-of-type-builtin-type-conflict',\n  REFERENCE_TO_INVALID: 'schema-reference-to-invalid',\n  REFERENCE_TO_NOT_UNIQUE: 'schema-reference-to-invalid',\n  REFERENCE_INVALID_OPTIONS: 'schema-reference-invalid-options',\n  REFERENCE_INVALID_OPTIONS_LOCATION: 'schema-reference-options-nesting',\n  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: 'schema-reference-filter-params-combination',\n  SLUG_SLUGIFY_FN_RENAMED: 'slug-slugifyfn-renamed',\n  ASSET_METADATA_FIELD_INVALID: 'asset-metadata-field-invalid',\n  CROSS_DATASET_REFERENCE_INVALID: 'cross-dataset-reference-invalid',\n  GLOBAL_DOCUMENT_REFERENCE_INVALID: 'global-document-reference-invalid',\n  DEPRECATED_BLOCKEDITOR_KEY: 'schema-deprecated-blockeditor-key',\n  STANDALONE_BLOCK_TYPE: 'schema-standalone-block-type',\n}\n\nfunction createValidationResult(\n  severity: SchemaValidationResult['severity'],\n  message: string,\n  helpId: string | null,\n): SchemaValidationResult {\n  if (helpId && !Object.keys(HELP_IDS).some((id) => (HELP_IDS as any)[id] === helpId)) {\n    throw new Error(\n      `Used the unknown helpId \"${helpId}\", please add it to the array in createValidationResult.js`,\n    )\n  }\n  return {\n    severity,\n    message,\n    helpId: helpId!,\n  }\n}\n\nexport const error = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('error', message, helpId!)\n\nexport const warning = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('warning', message, helpId!)\n","import {\n  type SchemaType,\n  type SchemaTypeDefinition,\n  type SchemaValidationProblemGroup,\n} from '@sanity/types'\nimport {flatten, get} from 'lodash'\n\nimport {type ProblemPath, type ProblemPathPropertySegment, type TypeWithProblems} from './typedefs'\nimport {error} from './validation/createValidationResult'\n\n/**\n * @internal\n */\nexport function groupProblems(types: SchemaTypeDefinition[]): SchemaValidationProblemGroup[] {\n  return flatten<TypeWithProblems>(types.map((type) => getTypeProblems(type))).filter(\n    (type) => type.problems.length > 0,\n  )\n}\n\nfunction createTypeWithMembersProblemsAccessor(\n  memberPropertyName: string,\n  getMembers = (type: SchemaType) => get(type, memberPropertyName),\n) {\n  return function getProblems(type: any, parentPath: ProblemPath): TypeWithProblems[] {\n    const currentPath: ProblemPath = [\n      ...parentPath,\n      {kind: 'type', type: type.type, name: type.name},\n    ]\n\n    const members = getMembers(type) || []\n\n    const memberProblems: TypeWithProblems[][] = Array.isArray(members)\n      ? members.map((memberType) => {\n          const propertySegment: ProblemPathPropertySegment = {\n            kind: 'property',\n            name: memberPropertyName,\n          }\n          const memberPath: ProblemPath = [...currentPath, propertySegment]\n          return getTypeProblems(memberType, memberPath as any)\n        })\n      : [\n          [\n            {\n              path: currentPath,\n              problems: [error(`Member declaration (${memberPropertyName}) is not an array`)],\n            },\n          ],\n        ]\n\n    return [\n      {\n        path: currentPath,\n        problems: type._problems || [],\n      },\n      ...flatten(memberProblems),\n    ]\n  }\n}\n\nconst arrify = (val: any) =>\n  Array.isArray(val) ? val : (typeof val === 'undefined' && []) || [val]\n\nconst getObjectProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getImageProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getFileProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getArrayProblems = createTypeWithMembersProblemsAccessor('of')\nconst getReferenceProblems = createTypeWithMembersProblemsAccessor('to', (type) =>\n  'to' in type ? arrify(type.to) : [],\n)\nconst getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor('marks.annotations')\nconst getBlockMemberProblems = createTypeWithMembersProblemsAccessor('of')\nconst getBlockProblems = (type: any, problems: any) => [\n  ...getBlockAnnotationProblems(type, problems),\n  ...getBlockMemberProblems(type, problems),\n]\n\nfunction getDefaultProblems(type: any, path = []): TypeWithProblems[] {\n  return [\n    {\n      path: [...path, {kind: 'type', type: type.type, name: type.name}],\n      problems: type._problems || [],\n    },\n  ]\n}\n\nfunction getTypeProblems(type: SchemaTypeDefinition, path = []): TypeWithProblems[] {\n  switch (type.type) {\n    case 'object': {\n      return getObjectProblems(type, path)\n    }\n    case 'document': {\n      return getObjectProblems(type, path)\n    }\n    case 'array': {\n      return getArrayProblems(type, path)\n    }\n    case 'reference': {\n      return getReferenceProblems(type, path)\n    }\n    case 'block': {\n      return getBlockProblems(type, path)\n    }\n    case 'image': {\n      return getImageProblems(type, path)\n    }\n    case 'file': {\n      return getFileProblems(type, path)\n    }\n    default: {\n      return getDefaultProblems(type, path)\n    }\n  }\n}\n","export function getDupes(array: any, selector = (v: any) => v) {\n  const dupes = array.reduce((acc: any, item: any) => {\n    const key = selector(item)\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(item)\n    return acc\n  }, {})\n\n  return Object.keys(dupes)\n    .map((key) => (dupes[key].length > 1 ? dupes[key] : null))\n    .filter(Boolean)\n}\n","import {flatten, uniq} from 'lodash'\n\nimport {getDupes} from '../sanity/validation/utils/getDupes'\n\ntype SchemaType = Record<string, any>\ntype SchemaTypeDef = Record<string, any>\n\ntype VisitContext = {\n  isRoot: boolean\n  isReserved: (typeName: string) => boolean\n  visit: Visitor\n  index: number\n  isDuplicate: (typeName: string) => boolean\n  getType: (typeName: string) => null | SchemaType\n  getTypeNames: () => Array<string>\n}\n\nexport type Visitor = (typeDef: SchemaTypeDef, arg1: VisitContext) => SchemaType\n\nconst NOOP_VISITOR: Visitor = (typeDef) => typeDef\n\nexport class UnknownType {\n  name: string\n\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nconst TYPE_TYPE = {name: 'type', type: null}\n\nconst FUTURE_RESERVED = ['any', 'time', 'date']\n\nexport function traverseSchema(\n  types: SchemaTypeDef[] = [],\n  coreTypes: SchemaTypeDef[] = [],\n  visitor: Visitor = NOOP_VISITOR,\n) {\n  const coreTypesRegistry = Object.create(null)\n  const registry = Object.create(null)\n\n  const coreTypeNames = coreTypes.map((typeDef) => typeDef.name)\n\n  const reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames)\n\n  const typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean)\n\n  coreTypes.forEach((coreType) => {\n    coreTypesRegistry[coreType.name] = coreType\n  })\n\n  types.forEach((type, i) => {\n    // Allocate a placeholder for each type\n    registry[(type && type.name) || `__unnamed_${i}`] = {}\n  })\n\n  function getType(typeName: any) {\n    return typeName === 'type'\n      ? TYPE_TYPE\n      : coreTypesRegistry[typeName] || registry[typeName] || null\n  }\n\n  const duplicateNames = uniq(flatten(getDupes(typeNames)))\n\n  function isDuplicate(typeName: any) {\n    return duplicateNames.includes(typeName)\n  }\n  function getTypeNames() {\n    return typeNames.concat(coreTypeNames)\n  }\n  function isReserved(typeName: any) {\n    return typeName === 'type' || reservedTypeNames.includes(typeName)\n  }\n\n  const visitType = (isRoot: any) => (typeDef: any, index: any) => {\n    return visitor(typeDef, {\n      visit: visitType(false),\n      isRoot,\n      getType,\n      getTypeNames,\n      isReserved,\n      isDuplicate,\n      index,\n    })\n  }\n\n  coreTypes.forEach((coreTypeDef) => {\n    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef))\n  })\n\n  types.forEach((typeDef, i) => {\n    Object.assign(\n      registry[(typeDef && typeDef.name) || `__unnamed_${i}`],\n      visitType(true)(typeDef, i),\n    )\n  })\n\n  return {\n    get(typeName: string) {\n      const res = registry[typeName] || coreTypesRegistry[typeName]\n      if (res) {\n        return res\n      }\n      throw new Error(`No such type: ${typeName}`)\n    },\n    has(typeName: string): boolean {\n      return typeName in registry || typeName in coreTypesRegistry\n    },\n    getTypeNames(): string[] {\n      return Object.keys(registry)\n    },\n    getTypes() {\n      return this.getTypeNames().map(this.get)\n    },\n    toJSON() {\n      return this.getTypes()\n    },\n  }\n}\n","const coreTypes = [\n  {name: 'array', jsonType: 'array', type: 'type'},\n  {name: 'block', jsonType: 'object', type: 'type'},\n  {name: 'boolean', jsonType: 'boolean', type: 'type'},\n  {name: 'datetime', jsonType: 'string', type: 'type'},\n  {name: 'date', jsonType: 'string', type: 'type'},\n  {name: 'document', jsonType: 'object', type: 'type'},\n  {name: 'email', jsonType: 'string', type: 'type'},\n  {name: 'file', jsonType: 'object', type: 'type'},\n  {name: 'geopoint', jsonType: 'object', type: 'type'},\n  {name: 'image', jsonType: 'object', type: 'type'},\n  {name: 'number', jsonType: 'number', type: 'type'},\n  {name: 'object', jsonType: 'object', type: 'type'},\n  {name: 'reference', jsonType: 'object', type: 'type'},\n  {name: 'crossDatasetReference', jsonType: 'object', type: 'type'},\n  {name: 'globalDocumentReference', jsonType: 'object', type: 'type'},\n  {name: 'slug', jsonType: 'object', type: 'type'},\n  {name: 'span', jsonType: 'object', type: 'type'},\n  {name: 'string', jsonType: 'string', type: 'type'},\n  {name: 'telephone', jsonType: 'string', type: 'type'},\n  {name: 'text', jsonType: 'string', type: 'type'},\n  {name: 'url', jsonType: 'string', type: 'type'},\n] as const\n\nexport const coreTypeNames = coreTypes.map((t) => t.name)\nexport default coreTypes\n","import {traverseSchema, type Visitor} from '../core/traverseSchema'\nimport coreTypes from './coreTypes'\nimport {type _FIXME_} from './typedefs'\n\nexport function traverseSanitySchema(schemaTypes: _FIXME_[], visitor: Visitor) {\n  return traverseSchema(schemaTypes, coreTypes as _FIXME_, visitor)\n}\n","import humanizeList from 'humanize-list'\nimport {flatten, partition} from 'lodash'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction isPrimitiveTypeName(typeName: any) {\n  return typeName === 'string' || typeName === 'number' || typeName === 'boolean'\n}\n\nfunction isAssignable(typeName: any, type: any) {\n  return (typeof type.name === 'string' ? type.name : type.type) === typeName\n}\n\nfunction quote(n: any) {\n  return `\"${n}\"`\n}\n\nfunction pluralize(arr: unknown[], suf = 's') {\n  return arr.length === 1 ? '' : suf\n}\n\nfunction format(value: unknown) {\n  if (Array.isArray(value)) {\n    return `array with ${value.length} entries`\n  }\n  if (typeof value === 'object' && value !== null) {\n    return `object with keys ${humanizeList(Object.keys(value).map(quote))}`\n  }\n  return quote(value)\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  // name should already have been marked\n  const ofIsArray = Array.isArray(typeDef.of)\n\n  if (ofIsArray) {\n    const invalid = typeDef.of.reduce((errs: any, def: any, idx: any) => {\n      if (typeof def.name === 'string') {\n        // If an array member has been given a \"local\" type name, we want to trigger an error if the given member type name\n        // is one of the builtin types\n        //\n        // The following examples should be an error (where book is an existing root level type and reference is a built-in type):\n        //  - (…) of: [{type: 'book', name: 'image'}]\n        //  - (…) of: [{type: 'book', name: 'object'}]\n        //  - (…) of: [{type: 'object', name: 'reference'}]\n        // The following examples are valid (where \"address\" is not defined as a global object type)\n        //  - (…) of: [{type: 'object', name: 'address'}]\n        // The following examples are redundant, but should be allowed (at least for now)\n        //  - (…) of: [{type: 'object', name: 'object'}]\n        //  - (…) of: [{type: 'image', name: 'image'}]\n\n        if (\n          // specifying the same name as the type is redundant, but should not be a hard error at this point\n          // Consider showing a warning for this and deprecate this ability eventually\n          def.name !== def.type &&\n          coreTypeNames.includes(def.name)\n        ) {\n          return errs.concat(\n            error(\n              `Found array member declaration with the same type name as a built-in type (\"${def.name}\"). Array members can not be given the same name as a built-in type.`,\n              HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n            ),\n          )\n        }\n      }\n\n      if (def.type === 'object' && def.name && visitorContext.getType(def.name)) {\n        return errs.concat(\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${def.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        )\n      }\n      if (def.type === 'array') {\n        return errs.concat(\n          error(\n            `Found array member declaration of type \"array\" - multidimensional arrays are not currently supported by Sanity`,\n            HELP_IDS.ARRAY_OF_ARRAY,\n          ),\n        )\n      }\n\n      if (def) {\n        return errs\n      }\n\n      const err = `Found ${def === null ? 'null' : typeof def}, expected member declaration`\n      return errs.concat(\n        error(\n          `Found invalid type member declaration in array at index ${idx}: ${err}`,\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n      )\n    }, [])\n\n    if (invalid.length > 0) {\n      return {\n        ...typeDef,\n        of: [],\n        _problems: invalid,\n      }\n    }\n  }\n\n  const problems = flatten([\n    ofIsArray\n      ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in array. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.ARRAY_OF_NOT_UNIQUE,\n          ),\n        )\n      : error(\n          'The array type is missing or having an invalid value for the required \"of\" property',\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n  ])\n  const of = ofIsArray ? typeDef.of : []\n\n  // Don't allow object types without a name in block arrays\n  const hasObjectTypesWithoutName = of.some(\n    (type: any) => type.type === 'object' && typeof type.name === 'undefined',\n  )\n  const hasBlockType = of.some((ofType: any) => ofType.type === 'block')\n  if (hasBlockType && hasObjectTypesWithoutName) {\n    problems.push(\n      error(\n        \"The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.\",\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const [primitiveTypes, objectTypes] = partition(\n    of,\n    (ofType) =>\n      isPrimitiveTypeName(ofType.type) ||\n      isPrimitiveTypeName(visitorContext.getType(ofType.type)?.jsonType),\n  )\n\n  const isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0\n\n  if (isMixedArray) {\n    const primitiveTypeNames = primitiveTypes.map((t) => t.type)\n    const objectTypeNames = objectTypes.map((t) => t.type)\n    problems.push(\n      error(\n        `The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(\n          primitiveTypeNames,\n        )} ${humanizeList(primitiveTypeNames.map(quote))} and object type${pluralize(\n          objectTypeNames,\n        )} ${humanizeList(objectTypeNames.map(quote))})`,\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const list = typeDef?.options?.list\n  if (!isMixedArray && Array.isArray(list)) {\n    const isArrayOfPrimitives = primitiveTypes.length > 0\n    if (isArrayOfPrimitives) {\n      list.forEach((option) => {\n        const value = option?.value ?? option\n        const isDeclared = primitiveTypes.some((primitiveType) => {\n          return typeof value === visitorContext.getType(primitiveType.type).jsonType\n        })\n        if (!isDeclared) {\n          const formattedTypeList = humanizeList(\n            primitiveTypes.map((t) => t.name || t.type),\n            {conjunction: 'or'},\n          )\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                value,\n              )}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    } else {\n      list.forEach((option) => {\n        const optionTypeName = option._type || 'object'\n        const isDeclared = objectTypes.some((validObjectType) =>\n          isAssignable(optionTypeName, validObjectType),\n        )\n        if (!isDeclared) {\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                option,\n              )}. Must be an object with \"_type\" set to ${humanizeList(\n                objectTypes\n                  .map((t) => t.name || t.type)\n                  .map((t) => (t === 'object' ? 'undefined' : quote(t))),\n                {conjunction: 'or'},\n              )}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    }\n  }\n\n  if (typeDef?.options?.list && typeDef?.options?.layout === 'tags') {\n    problems.push(\n      warning(\n        'Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.',\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    of: of.map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n","export function isJSONTypeOf(type: any, jsonType: any, visitorContext: any) {\n  if ('jsonType' in type) {\n    return type.jsonType === jsonType\n  }\n  const parentType = visitorContext.getType(type.type)\n  if (!parentType) {\n    throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`)\n  }\n  return isJSONTypeOf(parentType, jsonType, visitorContext)\n}\n","import humanizeList from 'humanize-list'\nimport {isPlainObject, omit} from 'lodash'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {isJSONTypeOf} from '../utils/isJSONTypeOf'\n\nconst getTypeOf = (thing: any) => (Array.isArray(thing) ? 'array' : typeof thing)\nconst quote = (str: any) => `\"${str}\"`\nconst allowedKeys = [\n  'components',\n  'lists',\n  'marks',\n  'name',\n  'of',\n  'options',\n  'styles',\n  'title',\n  'type',\n  'validation',\n]\nconst allowedMarkKeys = ['decorators', 'annotations']\nconst allowedStyleKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedDecoratorKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedListKeys = ['title', 'value', 'icon', 'component']\nconst supportedBuiltInObjectTypes = [\n  'file',\n  'image',\n  'object',\n  'reference',\n  'crossDatasetReference',\n  'globalDocumentReference',\n]\n\nexport default function validateBlockType(typeDef: any, visitorContext: any) {\n  const problems = []\n  let styles = typeDef.styles\n  let lists = typeDef.lists\n  let marks = typeDef.marks\n  let members = typeDef.of\n\n  const disallowedKeys = Object.keys(typeDef).filter(\n    (key) => !allowedKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (marks) {\n    marks = validateMarks(typeDef.marks, visitorContext, problems)\n  }\n\n  if (styles) {\n    styles = validateStyles(styles, visitorContext, problems)\n  }\n\n  if (lists) {\n    lists = validateLists(lists, visitorContext, problems)\n  }\n\n  if (members) {\n    members = validateMembers(members, visitorContext, problems)\n  }\n  return {\n    ...omit(typeDef, disallowedKeys),\n    marks,\n    styles,\n    name: typeDef.name || typeDef.type,\n    of: members,\n    _problems: problems,\n  }\n}\n\nfunction validateMarks(marks: any, visitorContext: any, problems: any) {\n  let decorators = marks.decorators\n  let annotations = marks.annotations\n\n  if (!isPlainObject(marks)) {\n    problems.push(error(`\"marks\" declaration should be an object, got ${getTypeOf(marks)}`))\n    return problems\n  }\n\n  const disallowedMarkKeys = Object.keys(marks).filter(\n    (key) => !allowedMarkKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedMarkKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedMarkKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (decorators && !Array.isArray(decorators)) {\n    problems.push(\n      error(`\"marks.decorators\" declaration should be an array, got ${getTypeOf(decorators)}`),\n    )\n  } else if (decorators) {\n    decorators\n      .filter((dec: any) => !!dec.blockEditor)\n      .forEach((dec: any) => {\n        dec.icon = dec.blockEditor.icon\n        dec.component = dec.blockEditor.render\n      })\n    decorators = validateDecorators(decorators, visitorContext, problems)\n  }\n\n  if (annotations && !Array.isArray(annotations)) {\n    problems.push(\n      error(`\"marks.annotations\" declaration should be an array, got ${getTypeOf(annotations)}`),\n    )\n  } else if (annotations) {\n    annotations = validateAnnotations(annotations, visitorContext, problems)\n  }\n\n  return {...marks, decorators, annotations}\n}\n\nfunction validateLists(lists: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(lists)) {\n    problems.push(error(`\"lists\" declaration should be an array, got ${getTypeOf(lists)}`))\n    return problems\n  }\n\n  lists.forEach((list, index) => {\n    if (!isPlainObject(list)) {\n      problems.push(error(`List must be an object, got ${getTypeOf(list)}`))\n      return\n    }\n\n    const name = list.value || `#${index}`\n    const disallowedKeys = Object.keys(list).filter(\n      (key) => !allowedListKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for list ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!list.value) {\n      problems.push(error(`List #${index} is missing required \"value\" property`))\n    } else if (typeof list.value !== 'string') {\n      problems.push(\n        error(\n          `List type #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            list.value,\n          )}`,\n        ),\n      )\n    } else if (!list.title) {\n      problems.push(warning(`List type ${name} is missing recommended \"title\" property`))\n    }\n  })\n  return lists\n}\n\nfunction validateStyles(styles: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(styles)) {\n    problems.push(error(`\"styles\" declaration should be an array, got ${getTypeOf(styles)}`))\n    return problems\n  }\n\n  styles.forEach((style, index) => {\n    if (!isPlainObject(style)) {\n      problems.push(error(`Style must be an object, got ${getTypeOf(style)}`))\n      return\n    }\n\n    const name = style.value || `#${index}`\n    const disallowedKeys = Object.keys(style).filter(\n      (key) => !allowedStyleKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for style ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!style.value) {\n      problems.push(error(`Style #${index} is missing required \"value\" property`))\n    } else if (typeof style.value !== 'string') {\n      problems.push(\n        error(\n          `Style #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            style.value,\n          )}`,\n        ),\n      )\n    } else if (!style.title) {\n      problems.push(warning(`Style ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof style.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Style has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      style.component = style.component || style.blockEditor.render\n    }\n  })\n  return styles\n}\n\nfunction validateDecorators(decorators: any, visitorContext: any, problems: any) {\n  decorators.forEach((decorator: any, index: any) => {\n    if (!isPlainObject(decorator)) {\n      problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`))\n      return\n    }\n\n    const name = decorator.value || `#${index}`\n    const disallowedKeys = Object.keys(decorator).filter(\n      (key) => !allowedDecoratorKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for decorator ${name}: ${humanizeList(\n            disallowedKeys.map(quote),\n          )}`,\n        ),\n      )\n    }\n\n    if (!decorator.value) {\n      problems.push(error(`Decorator #${index} is missing required \"value\" property`))\n    } else if (typeof decorator.value !== 'string') {\n      problems.push(\n        error(\n          `Decorator #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            decorator.value,\n          )}`,\n        ),\n      )\n    } else if (!decorator.title) {\n      problems.push(warning(`Decorator ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof decorator.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Decorator \"${name}\" has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      decorator.icon = decorator.icon || decorator.blockEditor.icon\n      decorator.component = decorator.component || decorator.blockEditor.render\n    }\n  })\n  return decorators\n}\n\nfunction validateAnnotations(annotations: any, visitorContext: any, problems: any) {\n  return annotations.map((annotation: any) => {\n    if (!isPlainObject(annotation)) {\n      return {\n        ...annotation,\n        _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)],\n      }\n    }\n\n    const {_problems} = visitorContext.visit(annotation, visitorContext)\n    const targetType = annotation.type && visitorContext.getType(annotation.type)\n    if (targetType && !isJSONTypeOf(targetType, 'object', visitorContext)) {\n      _problems.push(\n        error(\n          `Annotation cannot have type \"${annotation.type}\" - annotation types must inherit from object`,\n        ),\n      )\n    }\n\n    if (typeof annotation.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Annotation has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      annotation.icon = annotation.icon || annotation.blockEditor.icon\n      if (annotation.blockEditor?.render && !annotation.components?.annotation) {\n        annotation.components = annotation.components || {}\n        annotation.components.annotation =\n          annotation.components.annotation || annotation.blockEditor.render\n      }\n    }\n\n    return {...annotation, _problems}\n  })\n}\n\nfunction validateMembers(members: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(members)) {\n    problems.push(error(`\"of\" declaration should be an array, got ${getTypeOf(members)}`))\n    return undefined\n  }\n\n  return members.map((member) => {\n    const {_problems} = visitorContext.visit(member, visitorContext)\n    if (member.type === 'object' && member.name && visitorContext.getType(member.name)) {\n      return {\n        ...member,\n        _problems: [\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${member.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n\n    // Test that each member is of a support object-like type\n    let type = member\n    while (type && !type.jsonType) {\n      type = visitorContext.getType(type.type)\n    }\n    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n))\n    if (\n      // Must be object-like type (to validate hoisted types)\n      (type && type.jsonType !== 'object') ||\n      // Can't be a core type, or core object type that isn't supported (like 'span')\n      nonObjectCoreTypes.some((coreName) => coreName === member.type)\n    ) {\n      return {\n        ...member,\n        _problems: [\n          error(\n            `Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join(\n              \"', '\",\n            )}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`,\n            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n    return {...member, _problems}\n  })\n}\n","import {type SchemaType} from '@sanity/types'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error} from '../createValidationResult'\n\nexport function validateNonObjectFieldsProp(\n  typeDef: SchemaType,\n  visitorContext: any,\n): SchemaValidationResult[] {\n  if (!('fields' in typeDef)) {\n    return []\n  }\n\n  let type = typeDef\n  while (type && !type.jsonType) {\n    type = visitorContext.getType(type.type)\n  }\n\n  if (type && type.jsonType !== 'object') {\n    return [error(`Type has propery \"fields\", but is not an object/document type.`)]\n  }\n\n  return []\n}\n","import humanize from 'humanize-list'\nimport leven from 'leven'\n\nimport {error, HELP_IDS} from '../createValidationResult'\n\nconst quote = (str: any) => `\"${str}\"`\n\nexport function validateTypeName(typeName: string, visitorContext: any) {\n  const possibleTypeNames = visitorContext.getTypeNames()\n\n  if (!typeName) {\n    return [error(`Type is missing a type.`, HELP_IDS.TYPE_MISSING_TYPE)]\n  }\n\n  if (typeof typeName !== 'string') {\n    return [\n      error(\n        `Type has an invalid \"type\"-property - should be a string.`,\n        HELP_IDS.TYPE_MISSING_TYPE,\n      ),\n    ]\n  }\n\n  const isValid = possibleTypeNames.includes(typeName)\n\n  if (!isValid) {\n    const suggestions = possibleTypeNames\n      .map((possibleTypeName: any) => {\n        return [leven(typeName, possibleTypeName), possibleTypeName]\n      })\n      .filter(([distance]: any) => distance < 3)\n      .map(([_, name]: any) => name)\n\n    const suggestion =\n      suggestions.length > 0\n        ? ` Did you mean ${humanize(suggestions.map(quote), {conjunction: 'or'})}?`\n        : ''\n\n    return [error(`Unknown type: ${typeName}.${suggestion}`)]\n  }\n  return []\n}\n","import {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\n\nexport function validateDeprecatedProperties(type: any): SchemaValidationResult[] {\n  const warnings = []\n\n  if (type?.inputComponent) {\n    warnings.push(\n      warning(`The \"inputComponent\" property is deprecated. Use \"components.input\" instead.`),\n    )\n  }\n\n  if (type?.preview?.component) {\n    warnings.push(\n      warning(`The \"preview.component\" property is deprecated. Use \"components.preview\" instead.`),\n    )\n  }\n\n  if (type?.diffComponent) {\n    warnings.push(\n      warning(`The \"diffComponent\" property is deprecated. Use \"components.diff\" instead.`),\n    )\n  }\n\n  if (type?.options?.editModal) {\n    warnings.push(\n      warning(`The \"options.editModal\" property is deprecated. Use \"options.modal\" instead.`),\n    )\n  }\n\n  if (type?.options?.isHighlighted) {\n    warnings.push(\n      warning(\n        `The \"options.isHighlighted\" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {validateNonObjectFieldsProp} from '../utils/validateNonObjectFieldsProp'\nimport {validateTypeName} from '../utils/validateTypeName'\nimport {validateDeprecatedProperties} from './deprecated'\n\nexport default (typeDef: any, visitorContext: any) => {\n  return {\n    ...typeDef,\n    _problems: [\n      ...validateTypeName(typeDef.type, visitorContext),\n      ...validateNonObjectFieldsProp(typeDef, visitorContext),\n      ...validateDeprecatedProperties(typeDef),\n    ].filter(Boolean),\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nconst VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/\nexport function isValidDatasetName(name: string): string | true {\n  const isValid = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name)\n  return (\n    isValid ||\n    `The provided dataset \"${name}\" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`\n  )\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n          ),\n        )\n      : error(\n          'The cross dataset reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The cross dataset reference type should define at least one referenced type. Please check the \"to\" property.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  normalizedTo.forEach((crossDatasetTypeDef: any, index: any) => {\n    if (!crossDatasetTypeDef.type) {\n      problems.push(\n        error(\n          `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n\n    if (!isPlainObject(crossDatasetTypeDef.preview)) {\n      problems.push(\n        error(\n          `Missing required preview config for the referenced type \"${\n            crossDatasetTypeDef.type || '<unknown type>'\n          }\"`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n  })\n\n  if (typeof typeDef.dataset === 'string') {\n    const datasetValidation = isValidDatasetName(typeDef.dataset)\n    if (datasetValidation !== true) {\n      problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A cross dataset reference must specify a `dataset`',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeDef.studioUrl && typeof typeDef.studioUrl !== 'function') {\n    problems.push(\n      error(\n        'The \"studioUrl\" property on a cross dataset reference must be a function taking \"{id, type}\" as argument and returning a studio url.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","const REACT_SYM_RE = /^Symbol\\(react\\..+\\)$/\n\nexport function isComponentLike(value: any) {\n  const type = typeof value\n  // Note: we're not using `isValidElementType` from react-is here since it accepts too much, e.g. any strings.\n  return (\n    type === 'function' ||\n    (typeof value?.$$typeof === 'symbol' && REACT_SYM_RE.test(String(value?.$$typeof)))\n  )\n}\n","import inspect from '../../inspect'\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\nimport {isComponentLike} from './isComponent'\n\nexport function validateComponent(typeDef: any): SchemaValidationResult[] {\n  const components = 'components' in typeDef ? typeDef.components : false\n  if (!components) {\n    return []\n  }\n\n  const warnings: SchemaValidationResult[] = []\n\n  if (components.input && !isComponentLike(components.input)) {\n    warnings.push(\n      warning(\n        `The \\`components.input\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.input,\n        )}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.field && !isComponentLike(components.field)) {\n    warnings.push(\n      warning(\n        `The \\`components.field\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.field,\n        )}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.item && !isComponentLike(components.item)) {\n    warnings.push(\n      warning(\n        `The \\`components.item\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.item,\n        )}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.preview && !isComponentLike(components.preview)) {\n    warnings.push(\n      warning(\n        `The \\`components.preview\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.preview,\n        )}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {isPlainObject} from 'lodash'\n\nimport inspect from '../../inspect'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nconst VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/\nconst CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/\ninterface Field {\n  name: string\n}\n\ninterface PreviewConfig {\n  select?: {\n    [key: string]: string\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  prepare?: Function\n}\n\nfunction validateFieldName(name: any): Array<any> {\n  if (typeof name !== 'string') {\n    return [\n      error(\n        `Field names must be strings. Saw \"${inspect(name)}\"`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (name.startsWith('_')) {\n    return [\n      error(\n        `Invalid field name \"${name}\". Field names cannot start with underscores \"_\" as it's reserved for system fields.`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n\n  if (!VALID_FIELD_RE.test(name)) {\n    return [\n      error(\n        `Invalid field name: \"${name}\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(\n          VALID_FIELD_RE,\n        )}).`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (!CONVENTIONAL_FIELD_RE.test(name)) {\n    return [\n      warning(\n        'Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' +\n          ' It may be wise to keep special characters out of field names for easier access later on.',\n      ),\n      HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n    ]\n  }\n  return []\n}\n\nexport function validateField(field: any, _visitorContext: any) {\n  if (!isPlainObject(field)) {\n    return [\n      error(\n        `Incorrect type for field definition - should be an object, saw ${inspect(field)}`,\n        HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE,\n      ),\n    ]\n  }\n\n  const problems = []\n  problems.push(\n    ...('name' in field\n      ? validateFieldName(field.name)\n      : [error('Missing field name', HELP_IDS.OBJECT_FIELD_NAME_INVALID)]),\n  )\n  problems.push(...validateComponent(field))\n  return problems\n}\n\nfunction getDuplicateFields(array: Array<Field>): Array<Array<Field> | null> {\n  const dupes: {[name: string]: Array<Field>} = {}\n  array.forEach((field) => {\n    if (!dupes[field.name]) {\n      dupes[field.name] = []\n    }\n    dupes[field.name].push(field)\n  })\n  return Object.keys(dupes)\n    .map((fieldName) => (dupes[fieldName].length > 1 ? dupes[fieldName] : null))\n    .filter(Boolean)\n}\n\nexport function validateFields(fields: any, options = {allowEmpty: false}) {\n  const problems = []\n  const fieldsIsArray = Array.isArray(fields)\n  if (!fieldsIsArray) {\n    return [\n      error(\n        `The \"fields\" property must be an array of fields. Instead saw \"${typeof fields}\"`,\n        HELP_IDS.OBJECT_FIELDS_INVALID,\n      ),\n    ]\n  }\n\n  const fieldsWithNames = fields.filter((field) => typeof field.name === 'string')\n\n  getDuplicateFields(fieldsWithNames).forEach((dupes) => {\n    problems.push(\n      error(\n        `Found ${dupes!.length} fields with name \"${dupes![0].name}\" in object`,\n        HELP_IDS.OBJECT_FIELD_NOT_UNIQUE,\n      ),\n    )\n  })\n\n  if (fields.length === 0 && !options.allowEmpty) {\n    problems.push(error('Object should have at least one field', HELP_IDS.OBJECT_FIELDS_INVALID))\n  }\n\n  const standaloneBlockFields = fields\n    .filter((field) => field.type === 'block')\n    .map((field) => `\"${field.name}\"`)\n\n  if (standaloneBlockFields.length > 0) {\n    const fmtFields = standaloneBlockFields.join(', ')\n    problems.push(\n      error(\n        `Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`,\n        HELP_IDS.STANDALONE_BLOCK_TYPE,\n      ),\n    )\n  }\n\n  return problems\n}\n\nexport function validatePreview(preview: PreviewConfig) {\n  if (!isPlainObject(preview)) {\n    return [error(`The \"preview\" property must be an object, instead saw \"${typeof preview}\"`)]\n  }\n\n  if (typeof preview.prepare !== 'undefined' && typeof preview.prepare !== 'function') {\n    return [\n      error(\n        `The \"preview.prepare\" property must be a function, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  if (!preview.select) {\n    return []\n  }\n\n  if (!isPlainObject(preview.select)) {\n    return [\n      error(\n        `The \"preview.select\" property must be an object, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  return Object.keys(preview.select).reduce((errs: any, key) => {\n    return typeof preview.select![key] === 'string'\n      ? errs\n      : errs.concat(\n          error(\n            `The key \"${key}\" of \"preview.select\" must be a string, instead saw \"${typeof preview\n              .select![key]}\"`,\n          ),\n        )\n  }, [])\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  let problems = validateFields(typeDef.fields)\n\n  let preview = typeDef.preview\n  if (preview) {\n    const previewErrors = validatePreview(typeDef.preview)\n    problems = problems.concat(previewErrors)\n    preview = previewErrors.some((err: any) => err.severity === 'error') ? {} : preview\n  }\n\n  if (\n    typeDef.type !== 'document' &&\n    typeDef.type !== 'object' &&\n    typeof typeDef.initialValue !== 'undefined'\n  ) {\n    problems.push(\n      error(`The \"initialValue\" property is currently only supported for document & object types.`),\n    )\n  }\n\n  return {\n    ...typeDef,\n    preview,\n    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field: any, index: any) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {isPlainObject} from 'lodash'\n\nimport {error} from '../createValidationResult'\nimport object from './object'\n\nexport default (typeDefinition: any, visitorContext: any) => {\n  const typeDef = object(typeDefinition, visitorContext)\n  const {initialValue, initialValues} = typeDef\n\n  const hasInitialValue = typeof initialValue !== 'undefined'\n  if (hasInitialValue && !isPlainObject(initialValue) && typeof initialValue !== 'function') {\n    typeDef._problems.push(\n      error(`The \"initialValue\" property must be either a plain object or a function`),\n    )\n  }\n\n  if (typeof initialValues !== 'undefined') {\n    typeDef._problems.push(error(`Found property \"initialValues\" - did you mean \"initialValue\"?`))\n  }\n\n  return typeDef\n}\n","import {error, HELP_IDS} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  const invalidFieldNames = Array.isArray(fields)\n    ? fields?.filter((field) => field.name === 'asset')\n    : []\n\n  if (\n    typeDef.options &&\n    typeof typeDef.options.metadata !== 'undefined' &&\n    !Array.isArray(typeDef.options.metadata)\n  ) {\n    problems.push(\n      error(\n        `Invalid type for file \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (invalidFieldNames.length > 0) {\n    problems.push(error('The name `asset` is not a valid field name for type `file`.'))\n  }\n\n  return {\n    ...typeDef,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : []\n}\n\nexport function isValidResourceType(resourceType: string): string | true {\n  if (!resourceType) {\n    return 'The resource type must be a non-empty string'\n  }\n  if (resourceType != 'media-library' && resourceType != 'dataset') {\n    return 'The resource type must be either \"media-library\" or \"dataset\"'\n  }\n  return true\n}\n\nexport function isValidResourceId(resourceType: string, resourceId: string): string | true {\n  if (!resourceId) {\n    return 'The resource ID must be a non-empty string'\n  }\n  if (resourceType === 'dataset') {\n    const parts = resourceId.split('.')\n    if (parts.length !== 2) {\n      return 'The resource ID for a dataset reference must be on the form \"<projectId>.<datasetName>\"'\n    }\n    return true\n  }\n  if (resourceType === 'media-library') {\n    return true\n  }\n  return `Cannot validate resource ID for resource type: ${resourceType}`\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n          ),\n        )\n      : error(\n          'The global document reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The global document reference type should define at least one referenced type. Please check the \"to\" property.',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  normalizedTo.forEach((crossDatasetTypeDef: any, index: any) => {\n    if (!crossDatasetTypeDef.type) {\n      problems.push(\n        error(\n          `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n      )\n    }\n\n    if (!isPlainObject(crossDatasetTypeDef.preview)) {\n      problems.push(\n        error(\n          `Missing required preview config for the referenced type \"${\n            crossDatasetTypeDef.type || '<unknown type>'\n          }\"`,\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n      )\n    }\n  })\n\n  if (typeof typeDef.resourceType === 'string') {\n    const validation = isValidResourceType(typeDef.resourceType)\n    if (validation !== true) {\n      problems.push(error(validation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A global document reference must specify a `resourceType`',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeof typeDef.resourceId === 'string') {\n    const datasetValidation = isValidResourceId(typeDef.resourceType, typeDef.resourceId)\n    if (datasetValidation !== true) {\n      problems.push(error(datasetValidation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A global document reference must specify a `resourceId`',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (\n    typeDef.studioUrl &&\n    typeof typeDef.studioUrl !== 'function' &&\n    typeof typeDef.studioUrl !== 'string'\n  ) {\n    problems.push(\n      error(\n        'The \"studioUrl\" property on a global document reference must either be a function taking \"{id, type}\" as argument and returning a studio url, or a string being the base url pointing to a studio.',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nconst autoMeta = ['dimensions', 'hasAlpha', 'isOpaque']\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  let options = typeDef.options\n  const metadata = options?.metadata\n  const superfluousMeta = Array.isArray(metadata)\n    ? metadata.filter((meta) => autoMeta.includes(meta))\n    : []\n\n  const invalidFieldNames = ['asset', 'hotspot', 'crop']\n\n  const fieldsWithInvalidName = Array.isArray(fields)\n    ? fields?.filter((field) => invalidFieldNames.includes(field.name))\n    : []\n\n  if (typeof metadata !== 'undefined' && !Array.isArray(metadata)) {\n    problems.push(\n      error(\n        `Invalid type for image \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (superfluousMeta.length > 0) {\n    problems.push(\n      warning(\n        `Image \\`metadata\\` field contains superfluous properties (they are always included): ${superfluousMeta.join(\n          ', ',\n        )}`,\n      ),\n    )\n    options = {...options, metadata: metadata!.filter((meta) => !autoMeta.includes(meta))}\n  } else if (fieldsWithInvalidName.length > 0) {\n    problems.push(\n      error(\n        `The names \\`${invalidFieldNames.join(\n          '`, `',\n        )}\\` are invalid field names for type \\`image\\`.`,\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    options,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.REFERENCE_TO_INVALID,\n          ),\n        )\n      : error(\n          'The reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.REFERENCE_TO_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The reference type should define at least one accepted type. Please check the \"to\" property.',\n        HELP_IDS.REFERENCE_TO_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const hasName = Boolean(typeDef.name)\n  if (!hasName && Object.keys(typeDef).length === 1) {\n    // Short-circuit on obviously invalid types (only key is _problems)\n    return {\n      ...typeDef,\n      _problems: [\n        error(\n          'Invalid/undefined type declaration, check declaration or the import/export of the schema type.',\n          HELP_IDS.TYPE_INVALID,\n        ),\n      ],\n    }\n  }\n\n  const problems = []\n  if (looksLikeEsmModule(typeDef)) {\n    problems.push(\n      error(\n        'Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property',\n        HELP_IDS.TYPE_IS_ESM_MODULE,\n      ),\n    )\n  } else if (!hasName) {\n    problems.push(error('Missing type name', HELP_IDS.TYPE_MISSING_NAME))\n  } else if (visitorContext.isReserved(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: \"${typeDef.name}\" is a reserved name.`,\n        HELP_IDS.TYPE_NAME_RESERVED,\n      ),\n    )\n  }\n\n  if (visitorContext.isDuplicate(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: A type with name \"${typeDef.name}\" is already defined in the schema.`,\n      ),\n    )\n  }\n\n  problems.push(...validateComponent(typeDef))\n\n  if ('title' in typeDef && typeof typeDef.title !== 'string') {\n    problems.push(warning('Type title is not a string.', HELP_IDS.TYPE_TITLE_INVALID))\n  }\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction looksLikeEsmModule(typeDef: any) {\n  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title)\n}\n","import {HELP_IDS, warning} from '../createValidationResult'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n\n  if (typeDef.options && typeDef.options.slugifyFn) {\n    problems.push(\n      warning(\n        'Heads up! The \"slugifyFn\" option has been renamed to \"slugify\".',\n        HELP_IDS.SLUG_SLUGIFY_FN_RENAMED,\n      ),\n    )\n\n    typeDef.options.slugify = typeDef.options.slugifyFn\n  }\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n","import {traverseSanitySchema} from './traverseSchema'\nimport {type _FIXME_} from './typedefs'\nimport array from './validation/types/array'\nimport block from './validation/types/block'\nimport common from './validation/types/common'\nimport crossDatasetReference from './validation/types/crossDatasetReference'\nimport documentVisitor from './validation/types/document'\nimport file from './validation/types/file'\nimport globalDocumentReference from './validation/types/globalDocumentReference'\nimport image from './validation/types/image'\nimport object from './validation/types/object'\nimport reference from './validation/types/reference'\nimport rootType from './validation/types/rootType'\nimport slug from './validation/types/slug'\n\nconst typeVisitors = {\n  array,\n  object,\n  slug,\n  file,\n  image,\n  block,\n  document: documentVisitor,\n  reference: reference,\n  crossDatasetReference: crossDatasetReference,\n  globalDocumentReference,\n}\n\nconst getNoopVisitor = (visitorContext: any) => (schemaDef: any) => ({\n  name: `<unnamed_type_@_index_${visitorContext.index}>`,\n  ...schemaDef,\n  _problems: [],\n})\n\nfunction combine(...visitors: any) {\n  return (schemaType: any, visitorContext: any) => {\n    return visitors.reduce(\n      (result: any, visitor: any) => {\n        const res = visitor(result, visitorContext)\n        return {\n          ...res,\n          _problems: result._problems.concat(res._problems),\n        }\n      },\n      {_problems: [], ...schemaType},\n    )\n  }\n}\n\ninterface Options {\n  transformTypeVisitors?: (visitors: typeof typeVisitors) => Partial<typeof typeVisitors>\n}\n\n/**\n * @internal\n */\nexport function validateSchema(\n  schemaTypes: _FIXME_,\n  {transformTypeVisitors = (visitors) => visitors}: Options = {},\n) {\n  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {\n    const typeVisitor =\n      (schemaDef &&\n        schemaDef.type &&\n        (transformTypeVisitors(typeVisitors) as any)[schemaDef.type]) ||\n      getNoopVisitor(visitorContext)\n\n    if (visitorContext.isRoot) {\n      return combine(rootType, common, typeVisitor)(schemaDef, visitorContext)\n    }\n\n    return combine(common, typeVisitor)(schemaDef, visitorContext)\n  })\n}\n","import {type SchemaValidationProblemGroup} from '@sanity/types'\n\nexport class ValidationError extends Error {\n  public problems: SchemaValidationProblemGroup[]\n  constructor(problems: SchemaValidationProblemGroup[]) {\n    super('ValidationError')\n    this.problems = problems\n    this.name = 'ValidationError'\n  }\n}\n","import {\n  type CustomValidator,\n  type MediaValidator,\n  type Rule as IRule,\n  type RuleTypeConstraint,\n  type UriValidationOptions,\n} from '@sanity/types'\nimport {cloneDeep, isObject} from 'lodash'\n\nimport {Schema} from '../legacy/Schema'\nimport {builtinTypes} from './builtinTypes'\nimport {groupProblems} from './groupProblems'\nimport {type SchemaValidationResult} from './typedefs'\nimport {validateSchema} from './validateSchema'\nimport {ValidationError} from './validation/ValidationError'\n\nconst builtinSchema = Schema.compile({\n  name: 'studio',\n  types: builtinTypes,\n})\n\nexport function createSchemaFromManifestTypes(schemaDef: {name: string; types: unknown[]}) {\n  const validated = validateSchema(schemaDef.types).getTypes()\n  const validation = groupProblems(validated)\n  const problems = validation.filter((group) =>\n    group.problems.some((problem: SchemaValidationResult) => problem.severity === 'error'),\n  )\n\n  if (problems.length > 0) {\n    throw new ValidationError(problems)\n  }\n\n  return Schema.compile({\n    name: schemaDef.name,\n    types: schemaDef.types.map(coerceType).filter(Boolean),\n    parent: builtinSchema,\n  })\n}\n\n// coerceType attempts to coerce a json schema into a Sanity schema type. This mainly involves\n// converting a json normalized rule into an actual '@sanity/schema' Rule.\nfunction coerceType(obj: unknown) {\n  if (!isObject(obj)) return undefined\n  const typ = cloneDeep(obj)\n  traverse(typ)\n  return typ\n}\n\nfunction traverse(obj: unknown) {\n  if (!isObject(obj)) {\n    return\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(traverse)\n    return\n  }\n\n  for (const v of Object.values(obj)) {\n    traverse(v)\n  }\n\n  coerceValidation(obj)\n}\n\n// Convert a json rule into a '@sanity/schema' Rule.\nfunction coerceValidation(val: unknown) {\n  if (!isObject(val) || !('validation' in val)) return\n\n  // Convert ManifestValidationGroup[] to Rule functions\n  const manifestValidation = Array.isArray(val.validation) ? val.validation : [val.validation]\n\n  val.validation = manifestValidation\n    .map((group) => {\n      if (!isObject(group)) return undefined\n\n      return (baseRule: IRule) => {\n        let rule = baseRule\n        const level = 'level' in group ? group.level : undefined\n        const rules = 'rules' in group ? group.rules : undefined\n        const message = 'message' in group ? group.message : undefined\n\n        if (!rules || !Array.isArray(rules)) return undefined\n\n        // Apply level if specified\n        if (isValidLevel(level) && (message === undefined || typeof message === 'string')) {\n          rule = rule[level](message)\n        }\n\n        // Apply each rule in the group\n        for (const ruleSpec of rules) {\n          rule = applyRuleSpec(rule, ruleSpec)\n        }\n\n        return rule\n      }\n    })\n    .filter(Boolean)\n}\n\nfunction coerceConstraintRule(val: unknown): any {\n  if (!isObject(val)) return undefined\n\n  if (Array.isArray(val)) {\n    return val.map(coerceConstraintRule).filter(Boolean)\n  }\n\n  return (baseRule: any) => {\n    let rule = baseRule\n\n    const rules = '_rules' in val ? val._rules : undefined\n    const level = '_level' in val ? val._level : undefined\n    const message = '_message' in val ? val._message : undefined\n\n    if (!rules || !Array.isArray(rules)) return undefined\n\n    // Apply level if specified\n    if (typeof level === 'string') {\n      rule = rule[level](message)\n    }\n\n    // Apply each rule in the group\n    for (const ruleSpec of rules) {\n      rule = applyRuleSpec(rule, ruleSpec)\n    }\n\n    return rule\n  }\n}\n\n// eslint-disable-next-line complexity\nfunction applyRuleSpec(rule: IRule, ruleSpec: unknown): IRule {\n  if (!ruleSpec || typeof ruleSpec !== 'object') {\n    return rule\n  }\n\n  const flag = 'flag' in ruleSpec ? ruleSpec.flag : undefined\n  const constraint = 'constraint' in ruleSpec ? ruleSpec.constraint : undefined\n\n  switch (flag) {\n    case 'presence':\n      if (constraint === 'required') {\n        return rule.required()\n      } else if (constraint === 'optional') {\n        return rule.optional()\n      }\n      break\n\n    case 'type':\n      if (typeof constraint === 'string') {\n        return rule.type(constraint as RuleTypeConstraint)\n      }\n      break\n\n    case 'min':\n      if (typeof constraint === 'number' || typeof constraint === 'string') {\n        return rule.min(constraint)\n      }\n      break\n\n    case 'max':\n      if (typeof constraint === 'number' || typeof constraint === 'string') {\n        return rule.max(constraint)\n      }\n      break\n\n    case 'length':\n      if (typeof constraint === 'number') {\n        return rule.length(constraint)\n      }\n      break\n\n    case 'integer':\n      return rule.integer()\n\n    case 'email':\n      return rule.email()\n\n    case 'unique':\n      return rule.unique()\n\n    case 'reference':\n      return rule.reference()\n\n    case 'precision':\n      if (typeof constraint === 'number') {\n        return rule.precision(constraint)\n      }\n      break\n\n    case 'positive':\n      return rule.positive()\n\n    case 'negative':\n      return rule.negative()\n\n    case 'greaterThan':\n      if (typeof constraint === 'number') {\n        return rule.greaterThan(constraint)\n      }\n      break\n\n    case 'lessThan':\n      if (typeof constraint === 'number') {\n        return rule.lessThan(constraint)\n      }\n      break\n\n    case 'stringCasing':\n      if (constraint === 'uppercase') {\n        return rule.uppercase()\n      } else if (constraint === 'lowercase') {\n        return rule.lowercase()\n      }\n      break\n\n    case 'valid':\n      if (Array.isArray(constraint)) {\n        return rule.valid(constraint)\n      }\n      break\n\n    case 'regex':\n      if (\n        isObject(constraint) &&\n        'pattern' in constraint &&\n        (typeof constraint.pattern === 'string' || constraint.pattern instanceof RegExp)\n      ) {\n        const options: any = {}\n        if ('name' in constraint && typeof constraint.name === 'string') {\n          options.name = constraint.name\n        }\n        if ('invert' in constraint) {\n          options.invert = constraint.invert\n        }\n        const pattern =\n          typeof constraint.pattern === 'string'\n            ? stringToRegExp(constraint.pattern)\n            : constraint.pattern\n        return rule.regex(pattern, options)\n      }\n      break\n\n    case 'uri':\n      if (isObject(constraint) && 'options' in constraint) {\n        return rule.uri(constraint.options as UriValidationOptions)\n      }\n      break\n\n    case 'assetRequired':\n      return rule.assetRequired()\n\n    case 'all':\n      return rule.all(coerceConstraintRule(constraint))\n\n    case 'either':\n      return rule.either(coerceConstraintRule(constraint))\n\n    case 'custom':\n      // When the manifest schema types are serialized, the custom function will be stripped. We add it back here to keep track that\n      // a rule did exist at one point.\n      if (constraint === undefined) return rule.custom(() => true)\n      if (typeof constraint === 'function') return rule.custom(constraint as CustomValidator)\n      break\n\n    case 'media':\n      // When the manifest schema types are serialized, the custom function will be stripped. We add it back here to keep track that\n      // a rule did exist at one point.\n      if (constraint === undefined) return rule.media(() => true)\n      if (typeof constraint === 'function') return rule.media(constraint as MediaValidator)\n      break\n\n    default:\n      break\n  }\n\n  return rule\n}\n\nconst isValidLevel = (level: unknown): level is 'error' | 'warning' | 'info' => {\n  return !!level && typeof level === 'string' && ['error', 'warning', 'info'].includes(level)\n}\n\nfunction stringToRegExp(str: string): RegExp {\n  // RegExp.toString() returns \"/pattern/flags\"\n  const match = str.match(/^\\/(.*)\\/([gimuy]*)$/)\n  if (match) {\n    return new RegExp(match[1], match[2])\n  }\n  // Fallback if the format doesn't match\n  return new RegExp(str)\n}\n","import {\n  type ArraySchemaType,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type Schema as SchemaDef,\n  type SchemaType as SanitySchemaType,\n  type StringSchemaType,\n} from '@sanity/types'\nimport {\n  type ArrayTypeNode,\n  createReferenceTypeNode,\n  type DocumentSchemaType,\n  type InlineTypeNode,\n  type NullTypeNode,\n  type NumberTypeNode,\n  type ObjectAttribute,\n  type ObjectTypeNode,\n  type SchemaType,\n  type StringTypeNode,\n  type TypeDeclarationSchemaType,\n  type TypeNode,\n  type UnionTypeNode,\n  type UnknownTypeNode,\n} from 'groq-js'\n\nconst documentDefaultFields = (typeName: string): Record<string, ObjectAttribute> => ({\n  _id: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _type: {\n    type: 'objectAttribute',\n    value: {type: 'string', value: typeName},\n  },\n  _createdAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _updatedAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _rev: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n})\nconst typesMap = new Map<string, TypeNode>([\n  ['text', {type: 'string'}],\n  ['url', {type: 'string'}],\n  ['datetime', {type: 'string'}],\n  ['date', {type: 'string'}],\n  ['boolean', {type: 'boolean'}],\n  ['email', {type: 'string'}],\n])\n\nexport interface ExtractSchemaOptions {\n  enforceRequiredFields?: boolean\n}\n\nexport function extractSchema(\n  schemaDef: SchemaDef,\n  extractOptions: ExtractSchemaOptions = {},\n): SchemaType {\n  const inlineFields = new Set<SanitySchemaType>()\n  const documentTypes = new Map<string, DocumentSchemaType>()\n  const schema: SchemaType = []\n\n  // get a list of all the types in the schema, sorted by their dependencies. This ensures that when we check for inline/reference types, we have already processed the type\n  const sortedSchemaTypeNames = sortByDependencies(schemaDef)\n  sortedSchemaTypeNames.forEach((typeName) => {\n    const schemaType = schemaDef.get(typeName)\n    if (schemaType === undefined) {\n      return\n    }\n    const base = convertBaseType(schemaType)\n    if (base === null) {\n      return\n    }\n    if (base.type === 'type') {\n      inlineFields.add(schemaType)\n    }\n    if (base.type === 'document') {\n      documentTypes.set(typeName, base)\n    }\n\n    schema.push(base)\n  })\n\n  function convertBaseType(\n    schemaType: SanitySchemaType,\n  ): DocumentSchemaType | TypeDeclarationSchemaType | null {\n    let typeName: string | undefined\n    if (schemaType.type) {\n      typeName = schemaType.type.name\n    } else if ('jsonType' in schemaType) {\n      typeName = schemaType.jsonType\n    }\n\n    if (typeName === 'document' && isObjectType(schemaType)) {\n      const defaultAttributes = documentDefaultFields(schemaType.name)\n\n      const object = createObject(schemaType)\n      if (object.type === 'unknown') {\n        return null\n      }\n\n      return {\n        name: schemaType.name,\n        type: 'document',\n        attributes: {\n          ...defaultAttributes,\n          ...object.attributes,\n        },\n      }\n    }\n\n    const value = convertSchemaType(schemaType)\n    if (value.type === 'unknown') {\n      return null\n    }\n    if (value.type === 'object') {\n      value.attributes = {\n        _type: {\n          type: 'objectAttribute',\n          value: {\n            type: 'string',\n            value: schemaType.name,\n          },\n        },\n        ...value.attributes,\n      }\n      return {\n        name: schemaType.name,\n        type: 'type',\n        value,\n      }\n    }\n\n    return {\n      name: schemaType.name,\n      type: 'type',\n      value,\n    }\n  }\n\n  function convertSchemaType(schemaType: SanitySchemaType): TypeNode {\n    // if we have already seen the base type, we can just reference it\n    if (inlineFields.has(schemaType.type!)) {\n      return {type: 'inline', name: schemaType.type!.name} satisfies InlineTypeNode\n    }\n\n    // If we have a type that is point to a type, that is pointing to a type, we assume this is a circular reference\n    // and we return an inline type referencing it instead\n    if (schemaType.type?.type?.name === 'object') {\n      return {type: 'inline', name: schemaType.type.name} satisfies InlineTypeNode\n    }\n\n    if (isStringType(schemaType)) {\n      return createStringTypeNodeDefintion(schemaType)\n    }\n\n    if (isNumberType(schemaType)) {\n      return createNumberTypeNodeDefintion(schemaType)\n    }\n\n    // map some known types\n    if (schemaType.type && typesMap.has(schemaType.type.name)) {\n      return typesMap.get(schemaType.type.name)!\n    }\n\n    // Cross dataset references are not supported\n    if (isCrossDatasetReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies UnknownTypeNode // we don't support cross-dataset references at the moment\n    }\n\n    // Global document references are not supported\n    if (isGlobalDocumentReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies UnknownTypeNode // we don't support global document references at the moment\n    }\n\n    if (isReferenceType(schemaType)) {\n      return createReferenceTypeNodeDefintion(schemaType)\n    }\n\n    if (isArrayType(schemaType)) {\n      return createArray(schemaType)\n    }\n\n    if (isObjectType(schemaType)) {\n      return createObject(schemaType)\n    }\n\n    if (lastType(schemaType)?.name === 'document') {\n      const doc = documentTypes.get(schemaType.name)\n      if (doc === undefined) {\n        return {type: 'unknown'} satisfies UnknownTypeNode\n      }\n      return {type: 'object', attributes: doc?.attributes} satisfies ObjectTypeNode\n    }\n\n    throw new Error(`Type \"${schemaType.name}\" not found`)\n  }\n\n  function createObject(\n    schemaType: ObjectSchemaType | SanitySchemaType,\n  ): ObjectTypeNode | UnknownTypeNode {\n    const attributes: Record<string, ObjectAttribute> = {}\n\n    const fields = gatherFields(schemaType)\n    for (const field of fields) {\n      const fieldIsRequired = isFieldRequired(field)\n      const value = convertSchemaType(field.type)\n      if (value === null) {\n        continue\n      }\n\n      // if the field sets assetRequired() we will mark the asset attribute as required\n      // also guard against the case where the field is not an object, though type validation should catch this\n      if (hasAssetRequired(field) && value.type === 'object') {\n        value.attributes.asset.optional = false\n      }\n\n      // if we extract with enforceRequiredFields, we will mark the field as optional only if it is not a required field,\n      // else we will always mark it as optional\n      const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === false : true\n\n      attributes[field.name] = {\n        type: 'objectAttribute',\n        value,\n        optional,\n      }\n    }\n\n    // Ignore empty objects\n    if (Object.keys(attributes).length === 0) {\n      return {type: 'unknown'} satisfies UnknownTypeNode\n    }\n\n    if (schemaType.type?.name !== 'document' && schemaType.name !== 'object') {\n      attributes._type = {\n        type: 'objectAttribute',\n        value: {\n          type: 'string',\n          value: schemaType.name,\n        },\n      }\n    }\n\n    return {\n      type: 'object',\n      attributes,\n    }\n  }\n\n  function createArray(arraySchemaType: ArraySchemaType): ArrayTypeNode | NullTypeNode {\n    const of: TypeNode[] = []\n    for (const item of arraySchemaType.of) {\n      const field = convertSchemaType(item)\n      if (field.type === 'inline') {\n        of.push({\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n          rest: field,\n        } satisfies ObjectTypeNode)\n      } else if (field.type === 'object') {\n        field.rest = {\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n        }\n        of.push(field)\n      } else {\n        of.push(field)\n      }\n    }\n\n    if (of.length === 0) {\n      return {type: 'null'}\n    }\n\n    return {\n      type: 'array',\n      of:\n        of.length > 1\n          ? {\n              type: 'union',\n              of,\n            }\n          : of[0],\n    }\n  }\n\n  return schema\n}\n\nfunction createKeyField(): ObjectAttribute<StringTypeNode> {\n  return {\n    type: 'objectAttribute',\n    value: {\n      type: 'string',\n    },\n  }\n}\n\nfunction isFieldRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let required = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'required') {\n            required = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (required) {\n        return true\n      }\n    }\n\n    if (typeof rule === 'object' && rule !== null && '_required' in rule) {\n      if (rule._required === 'required') {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction hasAssetRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let assetRequired = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'assetRequired') {\n            assetRequired = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (assetRequired) {\n        return true\n      }\n    }\n\n    if (\n      typeof rule === 'object' &&\n      rule !== null &&\n      '_rules' in rule &&\n      Array.isArray(rule._rules)\n    ) {\n      if (rule._rules.some((r) => r.flag === 'assetRequired')) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction isObjectType(typeDef: SanitySchemaType): typeDef is ObjectSchemaType {\n  return isType(typeDef, 'object') || typeDef.jsonType === 'object' || 'fields' in typeDef\n}\nfunction isArrayType(typeDef: SanitySchemaType): typeDef is ArraySchemaType {\n  return isType(typeDef, 'array')\n}\nfunction isReferenceType(typeDef: SanitySchemaType): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\nfunction isCrossDatasetReferenceType(typeDef: SanitySchemaType) {\n  return isType(typeDef, 'crossDatasetReference')\n}\nfunction isGlobalDocumentReferenceType(typeDef: SanitySchemaType) {\n  return isType(typeDef, 'globalDocumentReference')\n}\nfunction isStringType(typeDef: SanitySchemaType): typeDef is StringSchemaType {\n  return isType(typeDef, 'string')\n}\nfunction isNumberType(typeDef: SanitySchemaType): typeDef is NumberSchemaType {\n  return isType(typeDef, 'number')\n}\nfunction createStringTypeNodeDefintion(\n  stringSchemaType: StringSchemaType,\n): StringTypeNode | UnionTypeNode<StringTypeNode> {\n  const listOptions = stringSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'string',\n        value: typeof v === 'string' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'string',\n  }\n}\n\nfunction createNumberTypeNodeDefintion(\n  numberSchemaType: NumberSchemaType,\n): NumberTypeNode | UnionTypeNode<NumberTypeNode> {\n  const listOptions = numberSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'number',\n        value: typeof v === 'number' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'number',\n  }\n}\n\nfunction createReferenceTypeNodeDefintion(\n  reference: ReferenceSchemaType,\n): ObjectTypeNode | UnionTypeNode<ObjectTypeNode> {\n  const references = gatherReferenceNames(reference)\n  if (references.length === 1) {\n    return createReferenceTypeNode(references[0])\n  }\n\n  return {\n    type: 'union',\n    of: references.map((name) => createReferenceTypeNode(name)),\n  }\n}\n\n// Traverse the reference type tree and gather all the reference names\nfunction gatherReferenceNames(type: ReferenceSchemaType): string[] {\n  const allReferences = gatherReferenceTypes(type)\n  // Remove duplicates\n  return [...new Set(allReferences.map((ref) => ref.name))]\n}\n\nfunction gatherReferenceTypes(type: ReferenceSchemaType): ObjectSchemaType[] {\n  const refTo = 'to' in type ? type.to : []\n  if ('type' in type && isReferenceType(type.type!)) {\n    return [...gatherReferenceTypes(type.type), ...refTo]\n  }\n\n  return refTo\n}\n\n// Traverse the type tree and gather all the fields\nfunction gatherFields(type: SanitySchemaType | ObjectSchemaType): ObjectField[] {\n  if ('fields' in type) {\n    return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n  }\n\n  return []\n}\n\n// Traverse the type tree and check if the type or any of its subtypes are of the given type\nfunction isType(\n  typeDef: SanitySchemaType | ObjectField | ObjectFieldType,\n  typeName: string,\n): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\n// Traverse the type tree and return the \"last\" type, ie deepest type in the tree\nfunction lastType(typeDef: SanitySchemaType): SanitySchemaType | undefined {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (!type.type) {\n      return type\n    }\n    type = type.type\n  }\n\n  return undefined\n}\n\n// Sorts the types by their dependencies by using a topological sort depth-first algorithm.\nfunction sortByDependencies(compiledSchema: SchemaDef): string[] {\n  const seen = new Set<SanitySchemaType>()\n\n  // Walks the dependencies of a schema type and adds them to the dependencies set\n  function walkDependencies(\n    schemaType: SanitySchemaType,\n    dependencies: Set<SanitySchemaType>,\n  ): void {\n    if (seen.has(schemaType)) {\n      return\n    }\n    seen.add(schemaType)\n\n    if ('fields' in schemaType) {\n      for (const field of gatherFields(schemaType)) {\n        const last = lastType(field.type)\n        if (last!.name === 'document') {\n          dependencies.add(last!)\n          continue\n        }\n\n        let schemaTypeName: string | undefined\n        if (schemaType.type!.type) {\n          schemaTypeName = field.type.type!.name\n        } else if ('jsonType' in schemaType.type!) {\n          schemaTypeName = field.type.jsonType\n        }\n\n        if (schemaTypeName === 'object' || schemaTypeName === 'block') {\n          if (isReferenceType(field.type)) {\n            field.type.to.forEach((ref) => dependencies.add(ref.type!))\n          } else {\n            dependencies.add(field.type)\n          }\n        }\n        walkDependencies(field.type, dependencies)\n      }\n    } else if ('of' in schemaType) {\n      for (const item of schemaType.of) {\n        walkDependencies(item, dependencies)\n      }\n    }\n  }\n  const dependencyMap = new Map<SanitySchemaType, Set<SanitySchemaType>>()\n  compiledSchema.getTypeNames().forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName)\n    if (schemaType === undefined || schemaType.type === null) {\n      return\n    }\n    const dependencies = new Set<SanitySchemaType>()\n\n    walkDependencies(schemaType, dependencies)\n    dependencyMap.set(schemaType, dependencies)\n    seen.clear() // Clear the seen set for the next type\n  })\n\n  // Sorts the types by their dependencies\n  const typeNames: string[] = []\n  // holds a temporary mark for types that are currently being visited, to detect cyclic dependencies\n  const currentlyVisiting = new Set<SanitySchemaType>()\n\n  // holds a permanent mark for types that have been already visited\n  const visited = new Set<SanitySchemaType>()\n\n  // visit implements a depth-first search\n  function visit(type: SanitySchemaType) {\n    if (visited.has(type)) {\n      return\n    }\n    // If we find a type that is already in the temporary mark, we have a cyclic dependency.\n    if (currentlyVisiting.has(type)) {\n      return\n    }\n    // mark this as a temporary mark, meaning it's being visited\n    currentlyVisiting.add(type)\n    const deps = dependencyMap.get(type)\n    if (deps !== undefined) {\n      deps.forEach((dep) => visit(dep))\n    }\n    currentlyVisiting.delete(type)\n    visited.add(type)\n\n    if (!typeNames.includes(type.name)) {\n      typeNames.unshift(type.name)\n    }\n  }\n  // Visit all types in the dependency map\n  for (const [type] of dependencyMap) {\n    visit(type)\n  }\n\n  return typeNames\n}\n","import {type SchemaValidationProblem} from '@sanity/types'\n\nimport {groupProblems} from './groupProblems'\nimport {validateSchema} from './validateSchema'\n\nfunction unsupportedTypeValidator(typeLabel: string) {\n  return function () {\n    return {\n      _problems: [\n        {\n          severity: 'error',\n          message: `Type unsupported in Media Library aspects: ${typeLabel}.`,\n        },\n      ],\n    }\n  }\n}\n\n/**\n * Ensure that the provided value is a valid Media Library asset aspect that can be safely deployed.\n *\n * @internal\n */\nexport function validateMediaLibraryAssetAspect(\n  maybeAspect: unknown,\n): [isValidMediaLibraryAspect: boolean, validationErrors: SchemaValidationProblem[][]] {\n  const input = [maybeAspect]\n\n  const validated = validateSchema(input, {\n    transformTypeVisitors: (typeVisitors) => ({\n      ...typeVisitors,\n      document: unsupportedTypeValidator('document'),\n      image: unsupportedTypeValidator('image'),\n      file: unsupportedTypeValidator('file'),\n      video: unsupportedTypeValidator('sanity.video'),\n      reference: unsupportedTypeValidator('reference'),\n      crossDatasetReference: unsupportedTypeValidator('cross dataset reference'),\n    }),\n  })\n\n  const validation = groupProblems(validated.getTypes())\n\n  const errors = validation\n    .map((group) => group.problems.filter(({severity}) => severity === 'error'))\n    .filter((problems) => problems.length)\n\n  return [errors.length === 0, errors]\n}\n"],"names":["SetBuilder","OWN_PROPS_NAME","common","isObject","isEqual","Rule","processSetSynchronization","difference","slug","flatten","get","array","coreTypes","coreTypeNames","uniq","quote","humanizeList","partition","omit","isPlainObject","leven","humanize","normalizeToProp","getOptionErrors","inspect","block","Schema","cloneDeep","object","reference","createReferenceTypeNode","typeVisitors"],"mappings":"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"}