{"version":3,"file":"index.js","sources":["../src/cursor.ts","../src/tokenize.ts","../src/parse.ts","../src/stringify.ts","../src/path.ts","../src/match.ts"],"sourcesContent":["interface CursorOptions<T, TExpected> {\n  values: ArrayLike<T>\n  fallback: T\n  validator: (expected: TExpected, value: T, position: number) => void\n}\n\nexport interface Cursor<T, TExpected> {\n  (offset?: number): T\n  position: number\n  hasNext(): boolean\n  consume: (expected?: TExpected) => T\n}\n\nexport function createCursor<T, TExpected>({\n  values,\n  fallback,\n  validator: validate,\n}: CursorOptions<T, TExpected>): Cursor<T, TExpected> {\n  let position = 0\n\n  function peek(offset = 0) {\n    return values[position + offset] ?? fallback\n  }\n\n  function consume(expected?: TExpected) {\n    const current = peek()\n    if (typeof expected !== 'undefined') {\n      validate(expected, current, position)\n    }\n    position++\n    return current\n  }\n\n  function hasNext() {\n    return position < values.length\n  }\n\n  Object.defineProperty(peek, 'position', {get: () => position})\n  return Object.assign(peek, {hasNext, consume}) as Cursor<T, TExpected>\n}\n","import {createCursor, type Cursor} from './cursor'\n\ntype CharacterCursor = Cursor<string, string | RegExp>\n\nexport type Operator = '==' | '!=' | '>' | '<' | '>=' | '<='\nexport type Token =\n  | {type: 'Number'; value: number; position: number}\n  | {type: 'String'; value: string; position: number}\n  | {type: 'Boolean'; value: boolean; position: number}\n  | {type: 'Null'; position: number}\n  | {type: 'Identifier'; value: string; position: number}\n  | {type: 'Operator'; value: Operator; position: number}\n  | {type: '.'; position: number}\n  | {type: '..'; position: number}\n  | {type: '['; position: number}\n  | {type: ']'; position: number}\n  | {type: ','; position: number}\n  | {type: ':'; position: number}\n  | {type: '?'; position: number}\n  | {type: '*'; position: number}\n  | {type: 'This'; position: number}\n  | {type: 'EOF'; position: number}\n\nexport function tokenize(expression: string): Token[] {\n  return tokenizePathExpression(\n    createCursor({\n      values: expression,\n      fallback: '',\n      validator: (expected: string | RegExp, value, position) => {\n        if (typeof expected === 'string' && expected !== value) {\n          throw new SyntaxError(\n            `Expected \\`${expected}\\` at position ${position}${\n              value ? ` but got \\`${value}\\` instead` : ''\n            }`,\n          )\n        }\n\n        if (expected instanceof RegExp && !expected.test(value)) {\n          throw new SyntaxError(\n            `Expected character \\`${value}\\` at position ${position} to match ${expected}`,\n          )\n        }\n      },\n    }),\n  )\n}\n\nfunction tokenizePathExpression(cursor: CharacterCursor): Token[] {\n  const tokens: Token[] = []\n  // Main tokenization loop\n  while (cursor.hasNext()) {\n    const char = cursor()\n    const position = cursor.position\n\n    // skip whitespace\n    if (/\\s/.test(char)) {\n      cursor.consume()\n      continue\n    }\n\n    switch (char) {\n      case '\"': {\n        tokens.push(parseStringLiteral(cursor))\n        continue\n      }\n\n      case \"'\": {\n        tokens.push(parseQuotedIdentifier(cursor))\n        continue\n      }\n\n      case '[':\n      case ']':\n      case ',':\n      case ':':\n      case '?':\n      case '*': {\n        cursor.consume()\n        tokens.push({type: char, position})\n        continue\n      }\n\n      case '$':\n      case '@': {\n        // Check if this is followed by identifier characters\n        if (/[a-zA-Z_$]/.test(cursor(1))) {\n          // This is an identifier starting with $ or @\n          tokens.push(parseIdentifier(cursor))\n          continue\n        }\n\n        // This is a standalone $ or @ (This token)\n        cursor.consume()\n        tokens.push({type: 'This', position})\n        continue\n      }\n\n      case '.': {\n        cursor.consume()\n\n        if (cursor() === '.') {\n          cursor.consume()\n          tokens.push({type: '..', position})\n          continue\n        }\n\n        tokens.push({type: '.', position})\n        continue\n      }\n\n      case '=':\n      case '!':\n      case '>':\n      case '<': {\n        tokens.push(parseOperator(cursor))\n        continue\n      }\n\n      default: {\n        if (/[0-9]/.test(char) || (char === '-' && /[0-9]/.test(cursor(1)))) {\n          tokens.push(parseNumber(cursor))\n          continue\n        }\n\n        if (/[a-zA-Z_$]/.test(char)) {\n          tokens.push(parseIdentifierOrBoolean(cursor))\n          continue\n        }\n\n        throw new Error(`Unexpected character '${char}' at position ${position}`)\n      }\n    }\n  }\n\n  tokens.push({type: 'EOF', position: cursor.position})\n  return tokens\n}\n\nfunction parseStringLiteral(cursor: CharacterCursor): Token {\n  const position = cursor.position\n  let value = ''\n\n  cursor.consume('\"')\n  while (cursor.hasNext() && cursor() !== '\"') {\n    if (cursor() === '\\\\') {\n      value += parseEscapeSequence(cursor)\n    } else {\n      value += cursor.consume()\n    }\n  }\n  cursor.consume('\"')\n\n  return {type: 'String', value, position}\n}\n\nfunction parseQuotedIdentifier(cursor: CharacterCursor): Token {\n  const position = cursor.position\n  let value = ''\n\n  cursor.consume(\"'\")\n  while (cursor.hasNext() && cursor() !== \"'\") {\n    if (cursor() === '\\\\') {\n      value += parseEscapeSequence(cursor)\n    } else {\n      value += cursor.consume()\n    }\n  }\n  cursor.consume(\"'\")\n\n  return {type: 'Identifier', value, position}\n}\n\nfunction parseIdentifier(cursor: CharacterCursor): Token {\n  const position = cursor.position\n  let value = ''\n\n  // First character: [a-zA-Z_$]\n  value += cursor.consume(/[a-zA-Z_$]/)\n\n  // Subsequent characters: [a-zA-Z0-9_$]\n  while (/[a-zA-Z0-9_$]/.test(cursor())) {\n    value += cursor.consume()\n  }\n\n  return {type: 'Identifier', value, position}\n}\n\nfunction parseIdentifierOrBoolean(cursor: CharacterCursor): Token {\n  const position = cursor.position\n  let value = ''\n\n  // First character: [a-zA-Z_$]\n  value += cursor.consume(/[a-zA-Z_$]/)\n\n  // Subsequent characters: [a-zA-Z0-9_$]\n  while (/[a-zA-Z0-9_$]/.test(cursor())) {\n    value += cursor.consume()\n  }\n\n  if (value === 'null') {\n    return {type: 'Null', position}\n  }\n\n  // Check if this is a boolean literal\n  if (value === 'true') {\n    return {type: 'Boolean', value: true, position}\n  }\n  if (value === 'false') {\n    return {type: 'Boolean', value: false, position}\n  }\n\n  return {type: 'Identifier', value, position}\n}\n\nfunction parseEscapeSequence(cursor: CharacterCursor): string {\n  cursor.consume('\\\\')\n  const escaped = cursor.consume()\n  switch (escaped) {\n    case '\"':\n    case \"'\":\n    case '\\\\':\n    case '/': {\n      return escaped\n    }\n    case 'b': {\n      return '\\b'\n    }\n    case 'f': {\n      return '\\f'\n    }\n    case 'n': {\n      return '\\n'\n    }\n    case 'r': {\n      return '\\r'\n    }\n    case 't': {\n      return '\\t'\n    }\n    case 'u': {\n      // Parse Unicode escape sequence \\uXXXX\n      let unicode = ''\n      for (let i = 0; i < 4; i++) {\n        unicode += cursor.consume(/[0-9a-fA-F]/)\n      }\n\n      return String.fromCharCode(parseInt(unicode, 16))\n    }\n    default: {\n      throw new Error(`Invalid escape sequence \\\\${escaped} at position ${cursor.position - 1}`)\n    }\n  }\n}\n\nfunction parseOperator(cursor: CharacterCursor): Token {\n  const position = cursor.position\n  const char = cursor()\n  const next = cursor(1)\n\n  if (char === '=' && next === '=') {\n    cursor.consume()\n    cursor.consume()\n    return {type: 'Operator', value: '==', position}\n  }\n  if (char === '!' && next === '=') {\n    cursor.consume()\n    cursor.consume()\n    return {type: 'Operator', value: '!=', position}\n  }\n  if (char === '>' && next === '=') {\n    cursor.consume()\n    cursor.consume()\n    return {type: 'Operator', value: '>=', position}\n  }\n  if (char === '<' && next === '=') {\n    cursor.consume()\n    cursor.consume()\n    return {type: 'Operator', value: '<=', position}\n  }\n  if (char === '>') {\n    cursor.consume()\n    return {type: 'Operator', value: '>', position}\n  }\n  if (char === '<') {\n    cursor.consume()\n    return {type: 'Operator', value: '<', position}\n  }\n\n  throw new SyntaxError(`Invalid operator at position ${position}`)\n}\n\nfunction parseNumber(cursor: CharacterCursor): Token {\n  const position = cursor.position\n  let value = ''\n\n  // Handle negative sign\n  if (cursor() === '-') {\n    value += cursor.consume()\n  }\n\n  // Parse integer part\n  while (/[0-9]/.test(cursor())) {\n    value += cursor.consume()\n  }\n\n  // Parse decimal part if present\n  if (cursor() === '.' && /[0-9]/.test(cursor(1))) {\n    value += cursor.consume()\n    while (/[0-9]/.test(cursor())) {\n      value += cursor.consume()\n    }\n  }\n\n  return {type: 'Number', value: parseFloat(value), position}\n}\n","import {tokenize, type Token} from './tokenize'\nimport {createCursor, type Cursor} from './cursor'\n\n/**\n * The root type for all JSONMatch expression nodes.\n *\n * @public\n */\nexport type ExprNode = NumberNode | StringNode | BooleanNode | NullNode | PathNode\n\n/**\n * Represents a path expression in the JSONMatch AST.\n * This is the most common type of expression, representing navigation through an object or array.\n *\n * @public\n */\nexport type PathNode = {\n  type: 'Path'\n  base?: PathNode // the preceding context (what we apply the current segment to)\n  recursive?: boolean // true for '..' recursive descent, false/undefined for normal '.' descent\n  segment: SegmentNode // current operation to apply\n}\n\n/**\n * Represents different types of path segments in the JSONMatch AST.\n *\n * @public\n */\nexport type SegmentNode = ThisNode | IdentifierNode | WildcardNode | SubscriptNode\n\n/**\n * Represents a subscript operation (bracket notation) in the JSONMatch AST.\n * Can contain multiple elements that are combined with union (OR) semantics.\n *\n * @public\n */\nexport type SubscriptNode = {\n  type: 'Subscript'\n  elements: SubscriptElementNode[]\n}\n\n/**\n * Represents elements that can appear inside subscript brackets.\n *\n * @public\n */\nexport type SubscriptElementNode = SliceNode | ComparisonNode | ExistenceNode | ExprNode\n\n/**\n * Represents a comparison operation for filtering array/object elements.\n *\n * @public\n */\nexport type ComparisonNode = {\n  type: 'Comparison'\n  left: ExprNode\n  operator: '==' | '!=' | '>' | '<' | '>=' | '<='\n  right: ExprNode\n}\n\n/**\n * Represents an existence check (?) for filtering elements that have a specific property.\n *\n * @public\n */\nexport type ExistenceNode = {\n  type: 'Existence'\n  base: PathNode\n}\n\n/**\n * Represents an array slice operation.\n *\n * @public\n */\nexport type SliceNode = {type: 'Slice'; start?: number; end?: number}\n\n/**\n * Represents an identifier (property name) in the JSONMatch AST.\n *\n * @public\n */\nexport type IdentifierNode = {type: 'Identifier'; name: string}\n\n/**\n * Represents a string literal in the JSONMatch AST.\n *\n * @public\n */\nexport type StringNode = {type: 'String'; value: string}\n\n/**\n * Represents a numeric literal in the JSONMatch AST or an index depending on\n * execution the context.\n *\n * @public\n */\nexport type NumberNode = {type: 'Number'; value: number}\n\n/**\n * Represents a boolean literal in the JSONMatch AST.\n *\n * @public\n */\nexport type BooleanNode = {type: 'Boolean'; value: boolean}\n\n/**\n * Represents a null literal in the JSONMatch AST.\n *\n * @public\n */\nexport type NullNode = {type: 'Null'}\n\n/**\n * Represents a wildcard (*) operation in the JSONMatch AST.\n *\n * @public\n */\nexport type WildcardNode = {type: 'Wildcard'}\n\n/**\n * Represents the current context (`@`/`$`) in the JSONMatch AST.\n *\n * @public\n */\nexport type ThisNode = {type: 'This'}\n\nclass UnexpectedTokenError extends SyntaxError {\n  constructor(token: Token, expected?: string) {\n    super(\n      expected\n        ? `Expected ${expected} at position ${token.position} but got ${token.type} instead`\n        : `Unexpected token ${token.type} at position ${token.position}`,\n    )\n  }\n}\n\ninterface TokenCursor extends Cursor<Token, Token['type']> {\n  consume<TTokenType extends Token['type']>(\n    tokenType?: TTokenType,\n  ): Extract<Token, {type: TTokenType}>\n}\n\n/**\n * Parses a JSONMatch expression string into an Abstract Syntax Tree (AST).\n *\n * This is the main parsing function that converts a JSONMatch string expression\n * into a structured AST that can be evaluated by the `jsonMatch` function or\n * manipulated using the path utilities.\n *\n * @param query - The JSONMatch expression string to parse\n * @returns The parsed AST representation of the expression\n *\n * @example\n * Basic parsing:\n * ```typescript\n * import { parse } from 'jsonmatch'\n *\n * const ast = parse('users[age > 21].name')\n * console.log(ast.type) // 'Path'\n * ```\n *\n * @example\n * Parsing with complex expressions:\n * ```typescript\n * const complexAst = parse('data..items[price > 100, category == \"electronics\"].name')\n * // Returns a nested PathNode structure\n * ```\n *\n * @public\n */\nexport function parse(query: string): ExprNode {\n  const tokens = tokenize(query)\n  if (tokens.length <= 1) throw new SyntaxError('Empty expression')\n  const eof = tokens.at(-1)!\n\n  // last token will always be EOF but we'll check anyway for the type assertion\n  if (eof.type !== 'EOF') {\n    throw new UnexpectedTokenError(eof)\n  }\n\n  const cursor = createCursor({\n    values: tokens,\n    fallback: eof,\n    validator: (expectedTokenType: Token['type'], token) => {\n      if (token.type !== expectedTokenType) {\n        throw new UnexpectedTokenError(token, expectedTokenType)\n      }\n    },\n  }) as TokenCursor\n  const ast = parseExpression(cursor)\n\n  cursor.consume('EOF')\n\n  return ast\n}\n\nfunction parseExpression(cursor: TokenCursor): ExprNode {\n  switch (cursor().type) {\n    // Path openers\n    case 'This':\n    case 'Identifier':\n    case '*':\n    case '[':\n    case '.':\n    case '..': {\n      return parsePath(cursor)\n    }\n\n    case 'String': {\n      const {value} = cursor.consume('String')\n      return {type: 'String', value}\n    }\n\n    case 'Number': {\n      const {value} = cursor.consume('Number')\n      return {type: 'Number', value}\n    }\n\n    case 'Boolean': {\n      const {value} = cursor.consume('Boolean')\n      return {type: 'Boolean', value}\n    }\n\n    case 'Null': {\n      cursor.consume('Null')\n      return {type: 'Null'}\n    }\n\n    default: {\n      throw new UnexpectedTokenError(cursor())\n    }\n  }\n}\n\nfunction parsePath(cursor: TokenCursor): PathNode {\n  // build up the path node in this variable the AST includes a `base` to allow\n  // for chaining. this was done to prioritize evaluation of the AST so that the\n  // base can be evaluated first\n  let result: PathNode\n\n  // handle implicit this\n  if (cursor().type === '.' || cursor().type === '..') {\n    const recursive = cursor().type === '..'\n    cursor.consume()\n\n    // Check if there's a segment following the dot(s)\n    if (cursor().type === 'EOF' || cursor().type === ']' || cursor().type === ',') {\n      // Only bare .. is valid - treat as wildcard. Bare . should be invalid\n      if (recursive) {\n        result = {\n          type: 'Path',\n          base: {\n            type: 'Path',\n            segment: {type: 'This'},\n          },\n          recursive,\n          segment: {type: 'Wildcard'},\n        }\n      } else {\n        // Bare . is invalid\n        throw new UnexpectedTokenError(cursor(), 'Path Segment')\n      }\n    } else {\n      // For implicit root, we need to parse the next segment and combine it\n      const segment = parsePathSegment(cursor)\n      result = {\n        type: 'Path',\n        base: {\n          type: 'Path',\n          segment: {type: 'This'},\n        },\n        recursive,\n        segment,\n      }\n    }\n  } else {\n    // parse the initial segment\n    const segment = parsePathSegment(cursor)\n    result = {type: 'Path', segment}\n  }\n\n  // handle chaining: subscripts and dot notation can be mixed\n  while (true) {\n    // check for subscripts after identifiers, wildcards, or this\n    if (cursor().type === '[') {\n      const subscript = parseSubscript(cursor)\n      result = {\n        type: 'Path',\n        base: result,\n        recursive: false,\n        segment: subscript,\n      }\n      continue\n    }\n\n    // check for dot notation continuation\n    if (cursor().type === '.' || cursor().type === '..') {\n      const recursive = cursor().type === '..'\n      cursor.consume()\n      const segment = parsePathSegment(cursor)\n      result = {\n        type: 'Path',\n        base: result,\n        recursive,\n        segment,\n      }\n      continue\n    }\n\n    // no more chaining\n    break\n  }\n\n  return result\n}\n\nfunction parsePathSegment(cursor: TokenCursor): SegmentNode {\n  // PathSegment ::= This | Identifier | Wildcard | Subscript\n  const next = cursor()\n\n  if (next.type === 'This') {\n    cursor.consume()\n    return {type: 'This'}\n  }\n\n  if (next.type === 'Identifier') {\n    cursor.consume()\n    return {type: 'Identifier', name: next.value}\n  }\n\n  if (next.type === '*') {\n    cursor.consume()\n    return {type: 'Wildcard'}\n  }\n\n  if (next.type === '[') {\n    return parseSubscript(cursor)\n  }\n\n  throw new UnexpectedTokenError(next, 'Path Segment')\n}\n\nfunction parseSubscript(cursor: TokenCursor): SubscriptNode {\n  // Subscript ::= '[' SubscriptContent ']'\n  const elements: SubscriptElementNode[] = []\n\n  cursor.consume('[')\n  elements.push(parseSubscriptElement(cursor))\n  while (cursor().type === ',') {\n    cursor.consume()\n    elements.push(parseSubscriptElement(cursor))\n  }\n  cursor.consume(']')\n\n  return {type: 'Subscript', elements}\n}\n\nfunction parseSubscriptElement(cursor: TokenCursor): SubscriptElementNode {\n  if (cursor().type === ':' || cursor().type === 'Number') {\n    return parseIndexOrSlice(cursor)\n  }\n\n  const nestedExpression = parseExpression(cursor)\n\n  if (cursor().type === 'Operator') {\n    const {value: operator} = cursor.consume('Operator')\n    return {\n      type: 'Comparison',\n      left: nestedExpression,\n      operator,\n      right: parseExpression(cursor),\n    }\n  }\n\n  if (cursor().type === '?' && nestedExpression.type === 'Path') {\n    cursor.consume()\n    return {\n      type: 'Existence',\n      base: nestedExpression,\n    }\n  }\n\n  return nestedExpression\n}\n\nfunction parseIndexOrSlice(cursor: TokenCursor): SliceNode | NumberNode | PathNode {\n  if (cursor().type === 'Number') {\n    const {value: start} = cursor.consume('Number')\n\n    if (cursor().type === ':') {\n      cursor.consume()\n\n      if (cursor().type === 'Number') {\n        const {value: end} = cursor.consume('Number')\n        return {type: 'Slice', start, end}\n      }\n\n      return {type: 'Slice', start}\n    }\n\n    return {type: 'Number', value: start}\n  }\n\n  if (cursor().type === ':') {\n    cursor.consume()\n\n    if (cursor().type === 'Number') {\n      const {value: end} = cursor.consume('Number')\n      return {type: 'Slice', end}\n    }\n\n    // bare `:` is parsed as a wildcard\n    return {type: 'Path', segment: {type: 'Wildcard'}}\n  }\n\n  throw new UnexpectedTokenError(cursor(), 'Number or Slice')\n}\n","import {type ExprNode, type PathNode, type SegmentNode, type SubscriptElementNode} from './parse'\n\n/**\n * Converts a JSONMatch AST node back to its string representation.\n */\nexport function stringifyExpression(node: ExprNode): string {\n  switch (node.type) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n      return JSON.stringify(node.value)\n    case 'Path':\n      return stringifyPath(node)\n    case 'Null':\n      return 'null'\n    default:\n      throw new Error(\n        `Unknown node type: ${\n          // @ts-expect-error should be `never` type\n          node.type\n        }`,\n      )\n  }\n}\n\nfunction stringifyPath(node: PathNode | undefined): string {\n  if (!node) return ''\n\n  const base = stringifyPath(node.base)\n  const segment = stringifySegment(node.segment)\n\n  // if the node is recursive, a `..` is always required\n  if (node.recursive) return `${base}..${segment}`\n  if (!base) return segment\n\n  // if the next segment starts with a `[` then we can omit the `.`\n  if (segment.startsWith('[')) return `${base}${segment}`\n  // otherwise, we need the `.`\n  return `${base}.${segment}`\n}\n\nfunction stringifySegment(segment: SegmentNode): string {\n  switch (segment.type) {\n    case 'This':\n      return '@'\n    case 'Wildcard':\n      return '*'\n    case 'Subscript':\n      return `[${segment.elements.map(stringifySubscriptElement).join(',')}]`\n    case 'Identifier':\n      return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(segment.name)\n        ? segment.name\n        : escapeIdentifier(segment.name)\n    default:\n      throw new Error(`Unknown segment type: ${(segment as any).type}`)\n  }\n}\n\nfunction escapeIdentifier(value: string): string {\n  const jsonString = JSON.stringify(value)\n  // Remove outer double quotes and escape single quotes\n  const content = jsonString.slice(1, -1).replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"')\n  return `'${content}'`\n}\n\nfunction stringifySubscriptElement(node: SubscriptElementNode): string {\n  switch (node.type) {\n    case 'Slice':\n      return `${node.start ?? ''}:${node.end ?? ''}`\n    case 'Comparison':\n      return `${stringifyExpression(node.left)}${node.operator}${stringifyExpression(node.right)}`\n    case 'Existence':\n      return `${stringifyPath(node.base)}?`\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Null':\n    case 'Path':\n      return stringifyExpression(node)\n    default:\n      throw new Error(\n        `Unknown subscript element type: ${\n          // @ts-expect-error this should be a `never` type\n          node.type\n        }`,\n      )\n  }\n}\n","import {\n  type ComparisonNode,\n  type ExprNode,\n  type PathNode,\n  type SegmentNode,\n  type SubscriptElementNode,\n  parse,\n} from './parse'\nimport {stringifyExpression} from './stringify'\n\nconst KEY_PREFIX = 'key:'\nconst FIELD_PREFIX = 'field:'\nconst INDEX_PREFIX = 'index:'\n\ntype PathKey = `${typeof INDEX_PREFIX | typeof KEY_PREFIX | typeof FIELD_PREFIX}${string}`\ntype PathMap = Map<PathKey, PathMap | true>\n\ninterface PathSet {\n  add(path: Path): void\n  has(path: Path): boolean\n}\n\nexport function createPathSet(): PathSet {\n  const root: PathMap = new Map()\n\n  function getKey(segment: PathSegment): PathKey {\n    if (isKeyedObject(segment)) return `${KEY_PREFIX}${segment._key}`\n    if (typeof segment === 'string') return `${FIELD_PREFIX}${segment}`\n    return `${INDEX_PREFIX}${segment}`\n  }\n\n  function add(map: PathMap, [head, ...tail]: Path): void {\n    if (typeof head === 'undefined') return\n\n    const key = getKey(head)\n    if (!tail.length) {\n      map.set(key, true)\n      return\n    }\n\n    const cached = map.get(key)\n    if (typeof cached !== 'undefined') {\n      if (cached === true) return\n      add(cached, tail)\n      return\n    }\n\n    const next = new Map<PathKey, PathMap | true>()\n    map.set(key, next)\n    add(next, tail)\n  }\n\n  function has(map: PathMap, [head, ...tail]: Path): boolean {\n    if (typeof head === 'undefined') return false\n    const key = getKey(head)\n    const cached = map.get(key)\n    if (typeof cached === 'undefined') return false\n    if (!tail.length) return cached === true\n    if (cached === true) return false\n    return has(cached, tail)\n  }\n\n  return {\n    add: (path: Path) => add(root, path),\n    has: (path: Path) => has(root, path),\n  }\n}\n\nconst INDEX_CACHE = new WeakMap<unknown[], Record<string, number | undefined>>()\n\ntype IndexTuple = [number | '', number | '']\ntype KeyedSegment = {_key: string}\n\n/**\n * Represents a single segment in a path.\n *\n * @public\n */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/**\n * Represents a path as an array of segments. This is the format used internally\n * and returned by `jsonMatch` in `MatchEntry` objects.\n *\n * Each segment can be:\n * - `string`: Object property name\n * - `number`: Array index\n * - `{_key: string}`: Keyed object reference\n * - `[number | '', number | '']`: Array slices\n *\n * @example\n * ```typescript\n * const path: Path = ['users', 0, 'profile', { _key: 'email' }]\n * // Represents: users[0].profile[_key==\"email\"]\n * ```\n *\n * @public\n */\nexport type Path = PathSegment[]\n\n/**\n * Equivalent to the normal {@link Path} array but without the index tuple.\n * These paths are meant to locate only one value (no index tuple)\n * @public\n */\nexport type SingleValuePath = Exclude<PathSegment, IndexTuple>[]\n\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value)\n}\n\nexport function isKeyedObject(value: unknown): value is {_key: string} {\n  return isRecord(value) && typeof (value as any)._key === 'string'\n}\n\n/**\n * Converts various path formats to their string representation.\n *\n * This function serves as a universal converter that can handle different path formats\n * used in the Sanity ecosystem. It converts JSONMatch AST nodes and Path arrays\n * to string expressions, while returning string inputs unchanged. This is useful for\n * normalizing different path representations into a consistent string format.\n *\n * @param path - The path to stringify (string expression, Path array, or AST node)\n * @returns The path as a string expression\n *\n * @example\n * Converting AST nodes to strings:\n * ```typescript\n * import { parsePath, stringifyPath } from '@sanity/json-match'\n *\n * const ast = parsePath('users[age > 21].name')\n * const str = stringifyPath(ast) // \"users[age>21].name\"\n * ```\n *\n * @example\n *\n * Converting `Path` arrays to strings:\n *\n * ```typescript\n * const path = ['users', 0, { _key: 'profile' }, 'email']\n * const str = stringifyPath(path) // 'users[0][_key==\"profile\"].email'\n *\n * const withSlice = ['items', [1, 3], 'name']\n * const sliceStr = stringifyPath(withSlice) // \"items[1:3].name\"\n * ```\n *\n * @example\n * Identity operation on strings:\n * ```typescript\n * const existing = 'items[*].name'\n * const result = stringifyPath(existing) // \"items[*].name\" (same string)\n * ```\n *\n * @example\n * Normalizing expressions:\n * ```typescript\n * const messy = '  users  [  age  >  21  ] . name  '\n * const clean = stringifyPath(parsePath(messy)) // \"users[age>21].name\"\n * ```\n *\n * @public\n */\nexport function stringifyPath(path: ExprNode | Path | string | undefined): string {\n  if (!path) return ''\n  if (typeof path === 'string') return path\n  if (Array.isArray(path)) return stringifyPath(parsePath(path))\n  return stringifyExpression(path)\n}\n\n/**\n * Finds the array index for an object with a specific `_key` property.\n *\n * This function is optimized for Sanity's keyed arrays where objects have a special\n * `_key` property for stable references. It uses caching for performance when called\n * multiple times on the same array.\n *\n * @param input - The array to search in\n * @param key - The `_key` value to find\n * @returns The index of the object with the matching `_key`, or `undefined` if not found\n *\n * @example\n * Basic usage:\n * ```typescript\n * const items = [\n *   { _key: 'item1', name: 'First' },\n *   { _key: 'item2', name: 'Second' },\n *   { _key: 'item3', name: 'Third' }\n * ]\n *\n * const index = getIndexForKey(items, 'item2')\n * console.log(index) // 1\n * console.log(items[index]) // { _key: 'item2', name: 'Second' }\n * ```\n *\n * @example\n * Handling missing keys:\n * ```typescript\n * const index = getIndexForKey(items, 'nonexistent')\n * console.log(index) // undefined\n * ```\n *\n * @example\n * Performance with caching:\n * ```typescript\n * // First call builds cache\n * const index1 = getIndexForKey(largeArray, 'key1') // Slower\n * // Subsequent calls use cache\n * const index2 = getIndexForKey(largeArray, 'key2') // Faster\n * ```\n *\n * @public\n */\nexport function getIndexForKey(input: unknown, key: string): number | undefined {\n  if (!Array.isArray(input)) return undefined\n  const cached = INDEX_CACHE.get(input)\n  if (cached) return cached[key]\n\n  const lookup = input.reduce<Record<string, number | undefined>>((acc, next, index) => {\n    if (typeof next?._key === 'string') acc[next._key] = index\n    return acc\n  }, {})\n\n  INDEX_CACHE.set(input, lookup)\n  return lookup[key]\n}\n\n/**\n * Parses various path formats into a standardized JSONMatch AST.\n *\n * This function serves as a universal converter that can handle different path formats\n * used in the Sanity ecosystem. It converts string expressions, Path arrays,\n * and returns AST nodes unchanged. This is useful for normalizing different path\n * representations before processing.\n *\n * @param path - The path to parse (string expression, Path array, or existing AST)\n * @returns The parsed JSONMatch AST node\n *\n * @example\n * Parsing string expressions:\n * ```typescript\n * const ast = parsePath('user.profile.email')\n * // Returns a PathNode AST structure\n * ```\n *\n * @example\n * Converting Path arrays:\n * ```typescript\n * const pathArr = ['users', 0, { _key: 'profile' }, 'email']\n * const ast = parsePath(pathArr)\n * // Converts to equivalent AST: users[0][_key==\"profile\"].email\n * ```\n *\n * @example\n * Identity operation on AST:\n * ```typescript\n * const existingAst = parse('items[*].name')\n * const result = parsePath(existingAst)\n * console.log(result === existingAst) // true (same object reference)\n * ```\n *\n * @example\n * Working with different segment types:\n * ```typescript\n * const complexPath = [\n *   'data',\n *   'items',\n *   [1, 5],              // slice\n *   { _key: 'metadata' }, // keyed object\n *   'tags',\n *   0                     // array index\n * ]\n * const ast = parsePath(complexPath)\n * console.log(stringifyPath(ast)) // 'data.items[1:5][_key==\"metadata\"].tags[0]'\n * ```\n *\n * @public\n */\nexport function parsePath(path: string | Path | ExprNode): ExprNode | undefined {\n  if (Array.isArray(path)) {\n    let result: PathNode | undefined\n    for (const segment of path) {\n      result = {\n        type: 'Path',\n        base: result,\n        recursive: false,\n        segment: convertArraySegmentToSegmentNode(segment),\n      }\n    }\n\n    return result\n  }\n\n  if (typeof path === 'string') return parse(path)\n  return path\n}\n\nfunction convertArraySegmentToSegmentNode(segment: PathSegment): SegmentNode {\n  // This is an IndexTuple - create a slice subscript\n  if (Array.isArray(segment)) {\n    const [start, end] = segment\n    const element: SubscriptElementNode =\n      start === '' && end === ''\n        ? {type: 'Path', segment: {type: 'Wildcard'}}\n        : {type: 'Slice', ...(start !== '' && {start}), ...(end !== '' && {end})}\n    return {type: 'Subscript', elements: [element]}\n  }\n\n  if (typeof segment === 'string') {\n    return {type: 'Identifier', name: segment}\n  }\n\n  if (typeof segment === 'number') {\n    return {\n      type: 'Subscript',\n      elements: [{type: 'Number', value: segment}],\n    }\n  }\n\n  if (isKeyedObject(segment)) {\n    const comparisonNode: ComparisonNode = {\n      type: 'Comparison',\n      left: {type: 'Path', segment: {type: 'Identifier', name: '_key'}},\n      operator: '==',\n      right: {type: 'String', value: segment._key},\n    }\n\n    return {\n      type: 'Subscript',\n      elements: [comparisonNode],\n    }\n  }\n\n  throw new Error(`Unsupported segment type: ${typeof segment}`)\n}\n\n/**\n * Calculates the depth of a path, which is the number of segments.\n *\n * This function supports multiple path formats, including string expressions,\n * Path arrays, and AST nodes. It provides a consistent way to measure the\n * complexity or length of a path regardless of its representation.\n *\n * @param path - The path to measure (string, Path array, or AST node).\n * @returns The number of segments in the path.\n *\n * @example\n * Basic usage with different path formats:\n * ```typescript\n * import { getPathDepth } from '@sanity/json-match'\n *\n * const pathStr = 'user.profile.email'\n * console.log(getPathDepth(pathStr)) // 3\n *\n * const pathArr = ['user', 'profile', 'email']\n * console.log(getPathDepth(pathArr)) // 3\n *\n * const pathWithIndex = 'users[0].name'\n * console.log(getPathDepth(pathWithIndex)) // 3\n * ```\n *\n * @public\n */\nexport function getPathDepth(path: string | Path | ExprNode | undefined): number {\n  if (!path) return 0\n  if (Array.isArray(path)) return path.length\n  if (typeof path === 'string') return getPathDepth(parsePath(path))\n  if (path.type !== 'Path') return 0\n  const segmentDepth =\n    path.segment.type === 'Subscript' ||\n    path.segment.type === 'Wildcard' ||\n    path.segment.type === 'Identifier'\n      ? 1\n      : 0\n  return getPathDepth(path.base) + segmentDepth\n}\n\nfunction* drop<T>(values: Iterable<T>, count: number) {\n  let index = 0\n  for (const value of values) {\n    if (index >= count) yield value\n    index++\n  }\n}\n\nfunction* getSegments(node: PathNode): Generator<PathNode> {\n  if (node.base) yield* getSegments(node.base)\n  if (node.segment.type !== 'This') yield node\n}\n\n/**\n * Extracts a section of a path and returns it as a new path string.\n *\n * This function works like `Array.prototype.slice` for path segments. It supports\n * different path formats and handles both positive and negative indices for slicing.\n * This is particularly useful for tasks like getting a parent path or isolating\n * specific parts of a path.\n *\n * @param path - The path to slice (string, Path array, or AST node).\n * @param start - The zero-based index at which to begin extraction. Negative indices are counted from the end.\n * @param end - The zero-based index before which to end extraction. `slice` extracts up to but not including `end`. Negative indices are counted from the end.\n * @returns A new string containing the extracted path segments.\n *\n * @example\n * Basic slicing:\n * ```typescript\n * import { slicePath } from '@sanity/json-match'\n *\n * const path = 'a.b.c.d.e'\n * console.log(slicePath(path, 1, 4)) // \"b.c.d\"\n * console.log(slicePath(path, 2))    // \"c.d.e\"\n * ```\n *\n * @example\n * Getting the parent path:\n * ```typescript\n * import { slicePath, getPathDepth } from '@sanity/json-match'\n *\n * const fullPath = 'user.profile.settings.theme'\n *\n * // Using negative indices:\n * const parentPathNegative = slicePath(fullPath, 0, -1)\n * console.log(parentPathNegative) // \"user.profile.settings\"\n * ```\n *\n * @example\n * Getting the last segment of a path:\n * ```typescript\n * import { slicePath } from '@sanity/json-match'\n *\n * const path = 'user.profile.email'\n * const lastSegment = slicePath(path, -1)\n * console.log(lastSegment) // \"email\"\n *\n * const complexPath = 'items[0].tags[_key==\"abc\"].name'\n * const lastSegmentComplex = slicePath(complexPath, -1)\n * console.log(lastSegmentComplex) // \"name\"\n * ```\n *\n * @public\n */\nexport function slicePath(\n  path: string | Path | ExprNode | undefined,\n  start?: number,\n  end?: number,\n): string {\n  if (!path) return ''\n  if (typeof path === 'string') return slicePath(parsePath(path), start, end)\n  if (Array.isArray(path)) return slicePath(parsePath(path), start, end)\n  if (path.type !== 'Path') return ''\n\n  const depth = getPathDepth(path)\n  if (typeof start === 'undefined') start = 0\n  if (start < 0) start = start + depth\n  if (typeof end === 'undefined') end = depth\n  if (end < 0) end = end + depth\n\n  // Normalize bounds\n  start = Math.max(0, Math.min(start, depth))\n  end = Math.max(0, Math.min(end, depth))\n\n  // If slice is empty or invalid, return empty string\n  if (start >= end) return ''\n\n  // slicing the end is easy, just keep scoping in\n  if (end < depth) return slicePath(path.base, start, end)\n\n  let base\n  for (const segment of drop(getSegments(path), start)) {\n    base = {...segment, base}\n  }\n  return stringifyPath(base)\n}\n\n/**\n * Joins two path segments into a single, normalized path string.\n *\n * This function is useful for programmatically constructing paths from a base\n * and an additional segment. It handles various path formats, ensuring that\n * the resulting path is correctly formatted.\n *\n * @param base - The base path (string, Path array, or AST node).\n * @param path - The path segment to append (string, Path array, or AST node).\n * @returns A new string representing the combined path.\n *\n * @example\n * Basic joining:\n * ```typescript\n * import { joinPaths } from '@sanity/json-match'\n *\n * const basePath = 'user.profile'\n * const newSegment = 'email'\n * const fullPath = joinPaths(basePath, newSegment)\n * console.log(fullPath) // \"user.profile.email\"\n * ```\n *\n * @example\n * Replacing the last segment of a path:\n * ```typescript\n * import { joinPaths, slicePath } from '@sanity/json-match'\n *\n * const originalPath = 'user.profile.email'\n * const parentPath = slicePath(originalPath, 0, -1) // \"user.profile\"\n * const newPath = joinPaths(parentPath, 'contactInfo')\n * console.log(newPath) // \"user.profile.contactInfo\"\n * ```\n *\n * @example\n * Building paths with array-like segments:\n * ```typescript\n * import { joinPaths } from '@sanity/json-match'\n *\n * let base = 'items'\n * base = joinPaths(base, '[0]') // \"items[0]\"\n * base = joinPaths(base, '[_key==\"abc\"]') // \"items[0][_key==\"abc\"]\"\n * base = joinPaths(base, 'title') // \"items[0][_key==\"abc\"].title\"\n * console.log(base)\n * ```\n *\n * @public\n */\nexport function joinPaths(\n  base: string | Path | ExprNode | undefined,\n  path: string | Path | ExprNode | undefined,\n): string {\n  if (!base) return stringifyPath(path)\n  if (Array.isArray(base)) return joinPaths(parsePath(base), path)\n  if (typeof base === 'string') return joinPaths(parsePath(base), path)\n  if (base.type !== 'Path') return stringifyPath(path)\n  if (!path) return stringifyPath(base)\n  if (Array.isArray(path)) return joinPaths(base, parsePath(path))\n  if (typeof path === 'string') return joinPaths(base, parsePath(path))\n  if (path.type !== 'Path') return stringifyPath(base)\n\n  for (const segment of getSegments(path)) {\n    base = {...segment, base}\n  }\n  return stringifyPath(base)\n}\n","import {\n  type ComparisonNode,\n  type ExistenceNode,\n  type PathNode,\n  type SegmentNode,\n  type SubscriptNode,\n  type ExprNode,\n} from './parse'\nimport {\n  type Path,\n  type SingleValuePath,\n  isKeyedObject,\n  isRecord,\n  createPathSet,\n  parsePath,\n  getIndexForKey,\n} from './path'\n\nconst LITERAL_PATH: SingleValuePath = []\n\n/**\n * Represents a single match result from evaluating a JSONMatch expression.\n * Each entry contains the matched value and its path in the document.\n *\n * @example\n * ```typescript\n * const data = { users: [{ name: \"Alice\" }, { name: \"Bob\" }] }\n * const matches = Array.from(jsonMatch(data, \"users[*].name\"))\n * // matches = [\n * //   { value: \"Alice\", path: [\"users\", 0, \"name\"] },\n * //   { value: \"Bob\", path: [\"users\", 1, \"name\"] }\n * // ]\n * ```\n *\n * @public\n */\nexport interface MatchEntry {\n  /**\n   * The subvalue of the found within the given JSON value. This is\n   * referentially equal to the nested value in the JSON object.\n   */\n  value: unknown\n  /**\n   * An array of keys and indices representing the location of the value within\n   * the original value. Note that the evaluator will only yield paths that\n   * address a single value.\n   */\n  path: SingleValuePath\n}\n\n/**\n * Evaluates a JSONMatch expression against a JSON value and returns all matching entries.\n *\n * This is the core function of the library. It takes a JSON value and a JSONMatch expression\n * and returns a generator that yields all matching values along with their paths. The paths\n * returned are compatible with Sanity's path format and can be used for document operations.\n *\n * @param value - The JSON value to search within\n * @param expr - The JSONMatch expression (string, Path array, or parsed AST)\n * @param basePath - Optional base path to prepend to all result paths\n * @returns Generator yielding MatchEntry objects for each match\n *\n * @example\n * Basic property access:\n * ```typescript\n * const data = { user: { name: \"Alice\", age: 25 } }\n * const matches = Array.from(jsonMatch(data, \"user.name\"))\n * // [{ value: \"Alice\", path: [\"user\", \"name\"] }]\n * ```\n *\n * @example\n * Array filtering with constraints:\n * ```typescript\n * const data = {\n *   users: [\n *     { name: \"Alice\", age: 25 },\n *     { name: \"Bob\", age: 30 }\n *   ]\n * }\n * const matches = Array.from(jsonMatch(data, \"users[age > 28].name\"))\n * // [{ value: \"Bob\", path: [\"users\", 1, \"name\"] }]\n * ```\n *\n * @example\n * Using the generator for efficient processing:\n * ```typescript\n * const data = { items: Array(1000).fill(0).map((_, i) => ({ id: i, active: i % 2 === 0 })) }\n *\n * // Find first active item efficiently without processing all items\n * for (const match of jsonMatch(data, \"items[active == true]\")) {\n *   console.log(\"First active item:\", match.value)\n *   break\n * }\n * ```\n *\n * @public\n */\nexport function* jsonMatch(\n  value: unknown,\n  expr: string | Path | ExprNode,\n  basePath: SingleValuePath = [],\n): Generator<MatchEntry> {\n  const visited = createPathSet()\n\n  for (const entry of evaluateExpression({expr: parsePath(expr), value, path: basePath})) {\n    const {path} = entry\n    if (path === LITERAL_PATH) continue // skip literals\n    if (visited.has(path)) continue\n    visited.add(path)\n    yield entry as MatchEntry\n  }\n}\n\ntype EvaluatorOptions<T> = T & {value: unknown; path: SingleValuePath}\n\nconst itemEntry = (item: unknown, path: SingleValuePath, index: number): MatchEntry => ({\n  value: item,\n  path: [...path, isKeyedObject(item) ? {_key: item._key} : index],\n})\n\nfunction* evaluateExpression({\n  expr,\n  value,\n  path,\n}: EvaluatorOptions<{expr?: ExprNode}>): Generator<MatchEntry> {\n  if (!expr) return\n\n  // If a Number, String, or Boolean node is here, then it's a literal value semantically\n  // so we yield it without a path\n  switch (expr.type) {\n    case 'String':\n    case 'Number':\n    case 'Boolean': {\n      yield {value: expr.value, path: LITERAL_PATH}\n      return\n    }\n    case 'Null': {\n      yield {value: null, path: LITERAL_PATH}\n      return\n    }\n    case 'Path': {\n      yield* evaluatePath({expr, value, path})\n      return\n    }\n    default: {\n      return\n    }\n  }\n}\n\nfunction* evaluatePath({\n  expr,\n  value,\n  path,\n}: EvaluatorOptions<{expr?: PathNode}>): Generator<MatchEntry> {\n  if (!expr) {\n    yield {value, path}\n    return\n  }\n\n  for (const candidate of evaluatePath({expr: expr.base, value, path})) {\n    if (expr.recursive) {\n      yield* evaluateRecursivePath({segment: expr.segment, ...candidate})\n      continue\n    }\n\n    yield* evaluateSegment({segment: expr.segment, ...candidate})\n  }\n}\n\nfunction* evaluateRecursivePath({\n  segment,\n  value,\n  path,\n}: EvaluatorOptions<{segment: SegmentNode}>): Generator<MatchEntry> {\n  // First try to match at current level\n  yield* evaluateSegment({segment, value, path})\n\n  // Then recursively search nested values\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index++) {\n      const item = value[index]\n      yield* evaluateRecursivePath({segment, ...itemEntry(item, path, index)})\n    }\n    return\n  }\n\n  if (isRecord(value)) {\n    for (const [key, nestedValue] of Object.entries(value)) {\n      yield* evaluateRecursivePath({segment, value: nestedValue, path: [...path, key]})\n    }\n    return\n  }\n}\n\nfunction* evaluateSegment({\n  segment,\n  value,\n  path,\n}: EvaluatorOptions<{segment: SegmentNode}>): Generator<MatchEntry> {\n  switch (segment.type) {\n    case 'This': {\n      yield {value, path}\n      return\n    }\n\n    case 'Identifier': {\n      if (Array.isArray(value)) {\n        for (let index = 0; index < value.length; index++) {\n          const item = value[index]\n          yield* evaluateSegment({segment, ...itemEntry(item, path, index)})\n        }\n        return\n      }\n\n      yield {\n        value: isRecord(value) ? value[segment.name] : undefined,\n        path: [...path, segment.name],\n      }\n      return\n    }\n\n    case 'Subscript': {\n      yield* evaluateSubscript({subscript: segment, value, path})\n      return\n    }\n\n    case 'Wildcard': {\n      if (Array.isArray(value)) {\n        for (let index = 0; index < value.length; index++) {\n          const item = value[index]\n          yield itemEntry(item, path, index)\n        }\n        return\n      }\n\n      if (isRecord(value)) {\n        for (const [key, nestedValue] of Object.entries(value)) {\n          yield {value: nestedValue, path: [...path, key]}\n        }\n        return\n      }\n\n      return\n    }\n\n    default: {\n      return\n    }\n  }\n}\n\nfunction* evaluateSubscript({\n  value,\n  subscript,\n  path,\n}: EvaluatorOptions<{subscript: SubscriptNode}>): Generator<MatchEntry> {\n  // Process all subscript elements with union semantics (OR logic)\n  for (const element of subscript.elements) {\n    switch (element.type) {\n      case 'Existence': {\n        yield* evaluateExistence({existence: element, value, path})\n        continue\n      }\n\n      case 'Comparison': {\n        yield* evaluateComparison({comparison: element, value, path})\n        continue\n      }\n\n      case 'Path': {\n        yield* evaluatePath({expr: element, value, path})\n        continue\n      }\n\n      case 'Slice': {\n        if (!Array.isArray(value)) continue\n        let start = element.start ?? 0\n        let end = element.end ?? value.length\n        if (start < 0) start = value.length + start\n        if (end < 0) end = value.length + end\n\n        // Clamp bounds to valid array indices\n        start = Math.max(0, Math.min(start, value.length))\n        end = Math.max(0, Math.min(end, value.length))\n\n        for (let index = start; index < end; index++) {\n          const item = value[index]\n          yield itemEntry(item, path, index)\n        }\n        continue\n      }\n\n      // handle number nodes in subscripts as array indices\n      case 'Number': {\n        const item = Array.isArray(value) ? value.at(element.value) : undefined\n        yield itemEntry(item, path, element.value)\n        continue\n      }\n\n      // strings and booleans are always evaluated as literals\n      case 'String':\n      case 'Boolean': {\n        yield* evaluateExpression({expr: element, value, path})\n        continue\n      }\n\n      default: {\n        continue\n      }\n    }\n  }\n}\n\nfunction* evaluateExistence({\n  existence,\n  value,\n  path,\n}: EvaluatorOptions<{existence: ExistenceNode}>): Generator<MatchEntry> {\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index++) {\n      const item = value[index]\n      yield* evaluateExistence({existence, ...itemEntry(item, path, index)})\n    }\n    return\n  }\n\n  for (const candidate of evaluatePath({expr: existence.base, path, value})) {\n    if (typeof candidate.value !== 'undefined') {\n      yield {value, path}\n      return\n    }\n  }\n}\n\nfunction getKeyFromComparison({operator, left, right}: ComparisonNode) {\n  if (operator !== '==') return undefined\n  const keyPathNode = [left, right].find(isKeyPath)\n  if (!keyPathNode) return undefined\n  const other = left === keyPathNode ? right : left\n  if (other.type !== 'String') return undefined\n  return other.value\n}\n\nconst isKeyPath = (node: ExprNode): node is PathNode => {\n  if (node.type !== 'Path') return false\n  if (node.base) return false\n  if (node.recursive) return false\n  if (node.segment.type !== 'Identifier') return false\n  return node.segment.name === '_key'\n}\n\nfunction* removeUndefinedMatches(values: Iterable<MatchEntry>) {\n  for (const item of values) {\n    if (typeof item.value !== 'undefined') yield item\n  }\n}\n\nfunction* evaluateComparison({\n  comparison,\n  value,\n  path,\n}: EvaluatorOptions<{comparison: ComparisonNode}>): Generator<MatchEntry> {\n  if (Array.isArray(value)) {\n    const _key = getKeyFromComparison(comparison)\n    if (_key) {\n      const index = getIndexForKey(value, _key)\n      yield {\n        value: typeof index === 'number' ? value[index] : undefined,\n        path: [...path, {_key}],\n      }\n      return\n    }\n\n    for (let index = 0; index < value.length; index++) {\n      const item = value[index]\n      yield* evaluateComparison({comparison, ...itemEntry(item, path, index)})\n    }\n    return\n  }\n\n  const leftResult = removeUndefinedMatches(\n    evaluateExpression({expr: comparison.left, value, path}),\n  ).next()\n  const rightResult = removeUndefinedMatches(\n    evaluateExpression({expr: comparison.right, value, path}),\n  ).next()\n  // ensure left or right yielded at least one value\n  if (leftResult.done || rightResult.done) return\n  const {value: left} = leftResult.value\n  const {value: right} = rightResult.value\n\n  if (comparison.operator === '==') {\n    if (left === right) yield {value, path}\n    return\n  }\n\n  if (comparison.operator === '!=') {\n    if (left !== right) yield {value, path}\n    return\n  }\n\n  if (typeof left !== 'number' || typeof right !== 'number') return\n  if (comparison.operator === '<' && left < right) yield {value, path}\n  if (comparison.operator === '<=' && left <= right) yield {value, path}\n  if (comparison.operator === '>' && left > right) yield {value, path}\n  if (comparison.operator === '>=' && left >= right) yield {value, path}\n}\n"],"names":["parsePath","stringifyPath"],"mappings":"AAaO,SAAS,aAA2B;AAAA,EACzC;AAAA,EACA;AAAA,EACA,WAAW;AACb,GAAsD;AACpD,MAAI,WAAW;AAEf,WAAS,KAAK,SAAS,GAAG;AACxB,WAAO,OAAO,WAAW,MAAM,KAAK;AAAA,EAAA;AAGtC,WAAS,QAAQ,UAAsB;AACrC,UAAM,UAAU,KAAA;AAChB,WAAI,OAAO,WAAa,OACtB,SAAS,UAAU,SAAS,QAAQ,GAEtC,YACO;AAAA,EAAA;AAGT,WAAS,UAAU;AACjB,WAAO,WAAW,OAAO;AAAA,EAAA;AAG3B,SAAA,OAAO,eAAe,MAAM,YAAY,EAAC,KAAK,MAAM,SAAA,CAAS,GACtD,OAAO,OAAO,MAAM,EAAC,SAAS,SAAQ;AAC/C;AChBO,SAAS,SAAS,YAA6B;AACpD,SAAO;AAAA,IACL,aAAa;AAAA,MACX,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,WAAW,CAAC,UAA2B,OAAO,aAAa;AACzD,YAAI,OAAO,YAAa,YAAY,aAAa;AAC/C,gBAAM,IAAI;AAAA,YACR,cAAc,QAAQ,kBAAkB,QAAQ,GAC9C,QAAQ,cAAc,KAAK,eAAe,EAC5C;AAAA,UAAA;AAIJ,YAAI,oBAAoB,UAAU,CAAC,SAAS,KAAK,KAAK;AACpD,gBAAM,IAAI;AAAA,YACR,wBAAwB,KAAK,kBAAkB,QAAQ,aAAa,QAAQ;AAAA,UAAA;AAAA,MAC9E;AAAA,IAEJ,CACD;AAAA,EAAA;AAEL;AAEA,SAAS,uBAAuB,QAAkC;AAChE,QAAM,SAAkB,CAAA;AAExB,SAAO,OAAO,aAAW;AACvB,UAAM,OAAO,OAAA,GACP,WAAW,OAAO;AAGxB,QAAI,KAAK,KAAK,IAAI,GAAG;AACnB,aAAO,QAAA;AACP;AAAA,IAAA;AAGF,YAAQ,MAAA;AAAA,MACN,KAAK,KAAK;AACR,eAAO,KAAK,mBAAmB,MAAM,CAAC;AACtC;AAAA,MAAA;AAAA,MAGF,KAAK,KAAK;AACR,eAAO,KAAK,sBAAsB,MAAM,CAAC;AACzC;AAAA,MAAA;AAAA,MAGF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,KAAK;AACR,eAAO,QAAA,GACP,OAAO,KAAK,EAAC,MAAM,MAAM,UAAS;AAClC;AAAA,MAAA;AAAA,MAGF,KAAK;AAAA,MACL,KAAK,KAAK;AAER,YAAI,aAAa,KAAK,OAAO,CAAC,CAAC,GAAG;AAEhC,iBAAO,KAAK,gBAAgB,MAAM,CAAC;AACnC;AAAA,QAAA;AAIF,eAAO,QAAA,GACP,OAAO,KAAK,EAAC,MAAM,QAAQ,UAAS;AACpC;AAAA,MAAA;AAAA,MAGF,KAAK,KAAK;AAGR,YAFA,OAAO,QAAA,GAEH,OAAA,MAAa,KAAK;AACpB,iBAAO,QAAA,GACP,OAAO,KAAK,EAAC,MAAM,MAAM,UAAS;AAClC;AAAA,QAAA;AAGF,eAAO,KAAK,EAAC,MAAM,KAAK,UAAS;AACjC;AAAA,MAAA;AAAA,MAGF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,KAAK;AACR,eAAO,KAAK,cAAc,MAAM,CAAC;AACjC;AAAA,MAAA;AAAA,MAGF,SAAS;AACP,YAAI,QAAQ,KAAK,IAAI,KAAM,SAAS,OAAO,QAAQ,KAAK,OAAO,CAAC,CAAC,GAAI;AACnE,iBAAO,KAAK,YAAY,MAAM,CAAC;AAC/B;AAAA,QAAA;AAGF,YAAI,aAAa,KAAK,IAAI,GAAG;AAC3B,iBAAO,KAAK,yBAAyB,MAAM,CAAC;AAC5C;AAAA,QAAA;AAGF,cAAM,IAAI,MAAM,yBAAyB,IAAI,iBAAiB,QAAQ,EAAE;AAAA,MAAA;AAAA,IAC1E;AAAA,EACF;AAGF,SAAA,OAAO,KAAK,EAAC,MAAM,OAAO,UAAU,OAAO,SAAA,CAAS,GAC7C;AACT;AAEA,SAAS,mBAAmB,QAAgC;AAC1D,QAAM,WAAW,OAAO;AACxB,MAAI,QAAQ;AAGZ,OADA,OAAO,QAAQ,GAAG,GACX,OAAO,QAAA,KAAa,aAAa;AAClC,WAAA,MAAa,OACf,SAAS,oBAAoB,MAAM,IAEnC,SAAS,OAAO,QAAA;AAGpB,SAAA,OAAO,QAAQ,GAAG,GAEX,EAAC,MAAM,UAAU,OAAO,SAAA;AACjC;AAEA,SAAS,sBAAsB,QAAgC;AAC7D,QAAM,WAAW,OAAO;AACxB,MAAI,QAAQ;AAGZ,OADA,OAAO,QAAQ,GAAG,GACX,OAAO,QAAA,KAAa,aAAa;AAClC,WAAA,MAAa,OACf,SAAS,oBAAoB,MAAM,IAEnC,SAAS,OAAO,QAAA;AAGpB,SAAA,OAAO,QAAQ,GAAG,GAEX,EAAC,MAAM,cAAc,OAAO,SAAA;AACrC;AAEA,SAAS,gBAAgB,QAAgC;AACvD,QAAM,WAAW,OAAO;AACxB,MAAI,QAAQ;AAMZ,OAHA,SAAS,OAAO,QAAQ,YAAY,GAG7B,gBAAgB,KAAK,QAAQ;AAClC,aAAS,OAAO,QAAA;AAGlB,SAAO,EAAC,MAAM,cAAc,OAAO,SAAA;AACrC;AAEA,SAAS,yBAAyB,QAAgC;AAChE,QAAM,WAAW,OAAO;AACxB,MAAI,QAAQ;AAMZ,OAHA,SAAS,OAAO,QAAQ,YAAY,GAG7B,gBAAgB,KAAK,QAAQ;AAClC,aAAS,OAAO,QAAA;AAGlB,SAAI,UAAU,SACL,EAAC,MAAM,QAAQ,SAAA,IAIpB,UAAU,SACL,EAAC,MAAM,WAAW,OAAO,IAAM,SAAA,IAEpC,UAAU,UACL,EAAC,MAAM,WAAW,OAAO,IAAO,SAAA,IAGlC,EAAC,MAAM,cAAc,OAAO,SAAA;AACrC;AAEA,SAAS,oBAAoB,QAAiC;AAC5D,SAAO,QAAQ,IAAI;AACnB,QAAM,UAAU,OAAO,QAAA;AACvB,UAAQ,SAAA;AAAA,IACN,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IAET,KAAK;AACH,aAAO;AAAA,IAET,KAAK;AACH,aAAO;AAAA,IAET,KAAK;AACH,aAAO;AAAA;AAAA,IAET,KAAK;AACH,aAAO;AAAA,IAET,KAAK;AACH,aAAO;AAAA,IAET,KAAK,KAAK;AAER,UAAI,UAAU;AACd,eAAS,IAAI,GAAG,IAAI,GAAG;AACrB,mBAAW,OAAO,QAAQ,aAAa;AAGzC,aAAO,OAAO,aAAa,SAAS,SAAS,EAAE,CAAC;AAAA,IAAA;AAAA,IAElD;AACE,YAAM,IAAI,MAAM,6BAA6B,OAAO,gBAAgB,OAAO,WAAW,CAAC,EAAE;AAAA,EAAA;AAG/F;AAEA,SAAS,cAAc,QAAgC;AACrD,QAAM,WAAW,OAAO,UAClB,OAAO,UACP,OAAO,OAAO,CAAC;AAErB,MAAI,SAAS,OAAO,SAAS;AAC3B,WAAA,OAAO,WACP,OAAO,QAAA,GACA,EAAC,MAAM,YAAY,OAAO,MAAM,SAAA;AAEzC,MAAI,SAAS,OAAO,SAAS;AAC3B,WAAA,OAAO,WACP,OAAO,QAAA,GACA,EAAC,MAAM,YAAY,OAAO,MAAM,SAAA;AAEzC,MAAI,SAAS,OAAO,SAAS;AAC3B,WAAA,OAAO,WACP,OAAO,QAAA,GACA,EAAC,MAAM,YAAY,OAAO,MAAM,SAAA;AAEzC,MAAI,SAAS,OAAO,SAAS;AAC3B,WAAA,OAAO,WACP,OAAO,QAAA,GACA,EAAC,MAAM,YAAY,OAAO,MAAM,SAAA;AAEzC,MAAI,SAAS;AACX,WAAA,OAAO,WACA,EAAC,MAAM,YAAY,OAAO,KAAK,SAAA;AAExC,MAAI,SAAS;AACX,WAAA,OAAO,WACA,EAAC,MAAM,YAAY,OAAO,KAAK,SAAA;AAGxC,QAAM,IAAI,YAAY,gCAAgC,QAAQ,EAAE;AAClE;AAEA,SAAS,YAAY,QAAgC;AACnD,QAAM,WAAW,OAAO;AACxB,MAAI,QAAQ;AAQZ,OALI,OAAA,MAAa,QACf,SAAS,OAAO,YAIX,QAAQ,KAAK,QAAQ;AAC1B,aAAS,OAAO,QAAA;AAIlB,MAAI,aAAa,OAAO,QAAQ,KAAK,OAAO,CAAC,CAAC;AAE5C,SADA,SAAS,OAAO,QAAA,GACT,QAAQ,KAAK,QAAQ;AAC1B,eAAS,OAAO,QAAA;AAIpB,SAAO,EAAC,MAAM,UAAU,OAAO,WAAW,KAAK,GAAG,SAAA;AACpD;AC3LA,MAAM,6BAA6B,YAAY;AAAA,EAC7C,YAAY,OAAc,UAAmB;AAC3C;AAAA,MACE,WACI,YAAY,QAAQ,gBAAgB,MAAM,QAAQ,YAAY,MAAM,IAAI,aACxE,oBAAoB,MAAM,IAAI,gBAAgB,MAAM,QAAQ;AAAA,IAAA;AAAA,EAClE;AAEJ;AAoCO,SAAS,MAAM,OAAyB;AAC7C,QAAM,SAAS,SAAS,KAAK;AAC7B,MAAI,OAAO,UAAU,EAAG,OAAM,IAAI,YAAY,kBAAkB;AAChE,QAAM,MAAM,OAAO,GAAG,EAAE;AAGxB,MAAI,IAAI,SAAS;AACf,UAAM,IAAI,qBAAqB,GAAG;AAGpC,QAAM,SAAS,aAAa;AAAA,IAC1B,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,WAAW,CAAC,mBAAkC,UAAU;AACtD,UAAI,MAAM,SAAS;AACjB,cAAM,IAAI,qBAAqB,OAAO,iBAAiB;AAAA,IAAA;AAAA,EAE3D,CACD,GACK,MAAM,gBAAgB,MAAM;AAElC,SAAA,OAAO,QAAQ,KAAK,GAEb;AACT;AAEA,SAAS,gBAAgB,QAA+B;AACtD,UAAQ,OAAA,EAAS,MAAA;AAAA;AAAA,IAEf,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAOA,YAAU,MAAM;AAAA,IAGzB,KAAK,UAAU;AACb,YAAM,EAAC,MAAA,IAAS,OAAO,QAAQ,QAAQ;AACvC,aAAO,EAAC,MAAM,UAAU,MAAA;AAAA,IAAK;AAAA,IAG/B,KAAK,UAAU;AACb,YAAM,EAAC,MAAA,IAAS,OAAO,QAAQ,QAAQ;AACvC,aAAO,EAAC,MAAM,UAAU,MAAA;AAAA,IAAK;AAAA,IAG/B,KAAK,WAAW;AACd,YAAM,EAAC,MAAA,IAAS,OAAO,QAAQ,SAAS;AACxC,aAAO,EAAC,MAAM,WAAW,MAAA;AAAA,IAAK;AAAA,IAGhC,KAAK;AACH,aAAA,OAAO,QAAQ,MAAM,GACd,EAAC,MAAM,OAAA;AAAA,IAGhB;AACE,YAAM,IAAI,qBAAqB,QAAQ;AAAA,EAAA;AAG7C;AAEA,SAASA,YAAU,QAA+B;AAIhD,MAAI;AAGJ,MAAI,SAAS,SAAS,OAAO,OAAA,EAAS,SAAS,MAAM;AACnD,UAAM,YAAY,SAAS,SAAS;AAIpC,QAHA,OAAO,QAAA,GAGH,OAAA,EAAS,SAAS,SAAS,OAAA,EAAS,SAAS,OAAO,OAAA,EAAS,SAAS;AAExE,UAAI;AACF,iBAAS;AAAA,UACP,MAAM;AAAA,UACN,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,SAAS,EAAC,MAAM,OAAA;AAAA,UAAM;AAAA,UAExB;AAAA,UACA,SAAS,EAAC,MAAM,WAAA;AAAA,QAAU;AAAA;AAI5B,cAAM,IAAI,qBAAqB,OAAA,GAAU,cAAc;AAAA,SAEpD;AAEL,YAAM,UAAU,iBAAiB,MAAM;AACvC,eAAS;AAAA,QACP,MAAM;AAAA,QACN,MAAM;AAAA,UACJ,MAAM;AAAA,UACN,SAAS,EAAC,MAAM,OAAA;AAAA,QAAM;AAAA,QAExB;AAAA,QACA;AAAA,MAAA;AAAA,IACF;AAAA,EACF;AAIA,aAAS,EAAC,MAAM,QAAQ,SADR,iBAAiB,MAAM,EAAA;AAKzC,aAAa;AAEX,QAAI,OAAA,EAAS,SAAS,KAAK;AACzB,YAAM,YAAY,eAAe,MAAM;AACvC,eAAS;AAAA,QACP,MAAM;AAAA,QACN,MAAM;AAAA,QACN,WAAW;AAAA,QACX,SAAS;AAAA,MAAA;AAEX;AAAA,IAAA;AAIF,QAAI,SAAS,SAAS,OAAO,OAAA,EAAS,SAAS,MAAM;AACnD,YAAM,YAAY,SAAS,SAAS;AACpC,aAAO,QAAA;AACP,YAAM,UAAU,iBAAiB,MAAM;AACvC,eAAS;AAAA,QACP,MAAM;AAAA,QACN,MAAM;AAAA,QACN;AAAA,QACA;AAAA,MAAA;AAEF;AAAA,IAAA;AAIF;AAAA,EAAA;AAGF,SAAO;AACT;AAEA,SAAS,iBAAiB,QAAkC;AAE1D,QAAM,OAAO,OAAA;AAEb,MAAI,KAAK,SAAS;AAChB,WAAA,OAAO,QAAA,GACA,EAAC,MAAM,OAAA;AAGhB,MAAI,KAAK,SAAS;AAChB,WAAA,OAAO,WACA,EAAC,MAAM,cAAc,MAAM,KAAK,MAAA;AAGzC,MAAI,KAAK,SAAS;AAChB,WAAA,OAAO,QAAA,GACA,EAAC,MAAM,WAAA;AAGhB,MAAI,KAAK,SAAS;AAChB,WAAO,eAAe,MAAM;AAG9B,QAAM,IAAI,qBAAqB,MAAM,cAAc;AACrD;AAEA,SAAS,eAAe,QAAoC;AAE1D,QAAM,WAAmC,CAAA;AAIzC,OAFA,OAAO,QAAQ,GAAG,GAClB,SAAS,KAAK,sBAAsB,MAAM,CAAC,GACpC,OAAA,EAAS,SAAS;AACvB,WAAO,WACP,SAAS,KAAK,sBAAsB,MAAM,CAAC;AAE7C,SAAA,OAAO,QAAQ,GAAG,GAEX,EAAC,MAAM,aAAa,SAAA;AAC7B;AAEA,SAAS,sBAAsB,QAA2C;AACxE,MAAI,SAAS,SAAS,OAAO,OAAA,EAAS,SAAS;AAC7C,WAAO,kBAAkB,MAAM;AAGjC,QAAM,mBAAmB,gBAAgB,MAAM;AAE/C,MAAI,OAAA,EAAS,SAAS,YAAY;AAChC,UAAM,EAAC,OAAO,SAAA,IAAY,OAAO,QAAQ,UAAU;AACnD,WAAO;AAAA,MACL,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,OAAO,gBAAgB,MAAM;AAAA,IAAA;AAAA,EAC/B;AAGF,SAAI,OAAA,EAAS,SAAS,OAAO,iBAAiB,SAAS,UACrD,OAAO,WACA;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,EAAA,KAIH;AACT;AAEA,SAAS,kBAAkB,QAAwD;AACjF,MAAI,OAAA,EAAS,SAAS,UAAU;AAC9B,UAAM,EAAC,OAAO,MAAA,IAAS,OAAO,QAAQ,QAAQ;AAE9C,QAAI,OAAA,EAAS,SAAS,KAAK;AAGzB,UAFA,OAAO,QAAA,GAEH,OAAA,EAAS,SAAS,UAAU;AAC9B,cAAM,EAAC,OAAO,IAAA,IAAO,OAAO,QAAQ,QAAQ;AAC5C,eAAO,EAAC,MAAM,SAAS,OAAO,IAAA;AAAA,MAAG;AAGnC,aAAO,EAAC,MAAM,SAAS,MAAA;AAAA,IAAK;AAG9B,WAAO,EAAC,MAAM,UAAU,OAAO,MAAA;AAAA,EAAK;AAGtC,MAAI,OAAA,EAAS,SAAS,KAAK;AAGzB,QAFA,OAAO,QAAA,GAEH,OAAA,EAAS,SAAS,UAAU;AAC9B,YAAM,EAAC,OAAO,IAAA,IAAO,OAAO,QAAQ,QAAQ;AAC5C,aAAO,EAAC,MAAM,SAAS,IAAA;AAAA,IAAG;AAI5B,WAAO,EAAC,MAAM,QAAQ,SAAS,EAAC,MAAM,aAAU;AAAA,EAAC;AAGnD,QAAM,IAAI,qBAAqB,OAAA,GAAU,iBAAiB;AAC5D;AC5ZO,SAAS,oBAAoB,MAAwB;AAC1D,UAAQ,KAAK,MAAA;AAAA,IACX,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,KAAK,UAAU,KAAK,KAAK;AAAA,IAClC,KAAK;AACH,aAAOC,gBAAc,IAAI;AAAA,IAC3B,KAAK;AACH,aAAO;AAAA,IACT;AACE,YAAM,IAAI;AAAA,QACR;AAAA,QAEE,KAAK,IACP;AAAA,MAAA;AAAA,EACF;AAEN;AAEA,SAASA,gBAAc,MAAoC;AACzD,MAAI,CAAC,KAAM,QAAO;AAElB,QAAM,OAAOA,gBAAc,KAAK,IAAI,GAC9B,UAAU,iBAAiB,KAAK,OAAO;AAG7C,SAAI,KAAK,YAAkB,GAAG,IAAI,KAAK,OAAO,KACzC,OAGD,QAAQ,WAAW,GAAG,IAAU,GAAG,IAAI,GAAG,OAAO,KAE9C,GAAG,IAAI,IAAI,OAAO,KALP;AAMpB;AAEA,SAAS,iBAAiB,SAA8B;AACtD,UAAQ,QAAQ,MAAA;AAAA,IACd,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO,IAAI,QAAQ,SAAS,IAAI,yBAAyB,EAAE,KAAK,GAAG,CAAC;AAAA,IACtE,KAAK;AACH,aAAO,6BAA6B,KAAK,QAAQ,IAAI,IACjD,QAAQ,OACR,iBAAiB,QAAQ,IAAI;AAAA,IACnC;AACE,YAAM,IAAI,MAAM,yBAA0B,QAAgB,IAAI,EAAE;AAAA,EAAA;AAEtE;AAEA,SAAS,iBAAiB,OAAuB;AAI/C,SAAO,IAHY,KAAK,UAAU,KAAK,EAEZ,MAAM,GAAG,EAAE,EAAE,QAAQ,MAAM,KAAK,EAAE,QAAQ,QAAQ,GAAG,CAC9D;AACpB;AAEA,SAAS,0BAA0B,MAAoC;AACrE,UAAQ,KAAK,MAAA;AAAA,IACX,KAAK;AACH,aAAO,GAAG,KAAK,SAAS,EAAE,IAAI,KAAK,OAAO,EAAE;AAAA,IAC9C,KAAK;AACH,aAAO,GAAG,oBAAoB,KAAK,IAAI,CAAC,GAAG,KAAK,QAAQ,GAAG,oBAAoB,KAAK,KAAK,CAAC;AAAA,IAC5F,KAAK;AACH,aAAO,GAAGA,gBAAc,KAAK,IAAI,CAAC;AAAA,IACpC,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,oBAAoB,IAAI;AAAA,IACjC;AACE,YAAM,IAAI;AAAA,QACR;AAAA,QAEE,KAAK,IACP;AAAA,MAAA;AAAA,EACF;AAEN;AC7EA,MAAM,aAAa,QACb,eAAe,UACf,eAAe;AAUd,SAAS,gBAAyB;AACvC,QAAM,2BAAoB,IAAA;AAE1B,WAAS,OAAO,SAA+B;AAC7C,WAAI,cAAc,OAAO,IAAU,GAAG,UAAU,GAAG,QAAQ,IAAI,KAC3D,OAAO,WAAY,WAAiB,GAAG,YAAY,GAAG,OAAO,KAC1D,GAAG,YAAY,GAAG,OAAO;AAAA,EAAA;AAGlC,WAAS,IAAI,KAAc,CAAC,MAAM,GAAG,IAAI,GAAe;AACtD,QAAI,OAAO,OAAS,IAAa;AAEjC,UAAM,MAAM,OAAO,IAAI;AACvB,QAAI,CAAC,KAAK,QAAQ;AAChB,UAAI,IAAI,KAAK,EAAI;AACjB;AAAA,IAAA;AAGF,UAAM,SAAS,IAAI,IAAI,GAAG;AAC1B,QAAI,OAAO,SAAW,KAAa;AACjC,UAAI,WAAW,GAAM;AACrB,UAAI,QAAQ,IAAI;AAChB;AAAA,IAAA;AAGF,UAAM,2BAAW,IAAA;AACjB,QAAI,IAAI,KAAK,IAAI,GACjB,IAAI,MAAM,IAAI;AAAA,EAAA;AAGhB,WAAS,IAAI,KAAc,CAAC,MAAM,GAAG,IAAI,GAAkB;AACzD,QAAI,OAAO,OAAS,IAAa,QAAO;AACxC,UAAM,MAAM,OAAO,IAAI,GACjB,SAAS,IAAI,IAAI,GAAG;AAC1B,WAAI,OAAO,SAAW,MAAoB,KACrC,KAAK,SACN,WAAW,KAAa,KACrB,IAAI,QAAQ,IAAI,IAFE,WAAW;AAAA,EAAA;AAKtC,SAAO;AAAA,IACL,KAAK,CAAC,SAAe,IAAI,MAAM,IAAI;AAAA,IACnC,KAAK,CAAC,SAAe,IAAI,MAAM,IAAI;AAAA,EAAA;AAEvC;AAEA,MAAM,kCAAkB,QAAA;AAuCjB,SAAS,SAAS,OAAkD;AACzE,SAAO,OAAO,SAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK;AAC5E;AAEO,SAAS,cAAc,OAAyC;AACrE,SAAO,SAAS,KAAK,KAAK,OAAQ,MAAc,QAAS;AAC3D;AAkDO,SAAS,cAAc,MAAoD;AAChF,SAAK,OACD,OAAO,QAAS,WAAiB,OACjC,MAAM,QAAQ,IAAI,IAAU,cAAc,UAAU,IAAI,CAAC,IACtD,oBAAoB,IAAI,IAHb;AAIpB;AA6CO,SAAS,eAAe,OAAgB,KAAiC;AAC9E,MAAI,CAAC,MAAM,QAAQ,KAAK,EAAG;AAC3B,QAAM,SAAS,YAAY,IAAI,KAAK;AACpC,MAAI,OAAQ,QAAO,OAAO,GAAG;AAE7B,QAAM,SAAS,MAAM,OAA2C,CAAC,KAAK,MAAM,WACtE,OAAO,MAAM,QAAS,aAAU,IAAI,KAAK,IAAI,IAAI,QAC9C,MACN,EAAE;AAEL,SAAA,YAAY,IAAI,OAAO,MAAM,GACtB,OAAO,GAAG;AACnB;AAqDO,SAAS,UAAU,MAAsD;AAC9E,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,QAAI;AACJ,eAAW,WAAW;AACpB,eAAS;AAAA,QACP,MAAM;AAAA,QACN,MAAM;AAAA,QACN,WAAW;AAAA,QACX,SAAS,iCAAiC,OAAO;AAAA,MAAA;AAIrD,WAAO;AAAA,EAAA;AAGT,SAAI,OAAO,QAAS,WAAiB,MAAM,IAAI,IACxC;AACT;AAEA,SAAS,iCAAiC,SAAmC;AAE3E,MAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,UAAM,CAAC,OAAO,GAAG,IAAI;AAKrB,WAAO,EAAC,MAAM,aAAa,UAAU,CAHnC,UAAU,MAAM,QAAQ,KACpB,EAAC,MAAM,QAAQ,SAAS,EAAC,MAAM,WAAA,EAAU,IACzC,EAAC,MAAM,SAAS,GAAI,UAAU,MAAM,EAAC,MAAA,GAAS,GAAI,QAAQ,MAAM,EAAC,IAAA,EAAG,CAC7B,EAAA;AAAA,EAAC;AAGhD,MAAI,OAAO,WAAY;AACrB,WAAO,EAAC,MAAM,cAAc,MAAM,QAAA;AAGpC,MAAI,OAAO,WAAY;AACrB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,CAAC,EAAC,MAAM,UAAU,OAAO,SAAQ;AAAA,IAAA;AAI/C,MAAI,cAAc,OAAO;AAQvB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,CAT2B;AAAA,QACrC,MAAM;AAAA,QACN,MAAM,EAAC,MAAM,QAAQ,SAAS,EAAC,MAAM,cAAc,MAAM,SAAM;AAAA,QAC/D,UAAU;AAAA,QACV,OAAO,EAAC,MAAM,UAAU,OAAO,QAAQ,KAAA;AAAA,MAAI,CAKlB;AAAA,IAAA;AAI7B,QAAM,IAAI,MAAM,6BAA6B,OAAO,OAAO,EAAE;AAC/D;AA6BO,SAAS,aAAa,MAAoD;AAC/E,MAAI,CAAC,KAAM,QAAO;AAClB,MAAI,MAAM,QAAQ,IAAI,UAAU,KAAK;AACrC,MAAI,OAAO,QAAS,iBAAiB,aAAa,UAAU,IAAI,CAAC;AACjE,MAAI,KAAK,SAAS,OAAQ,QAAO;AACjC,QAAM,eACJ,KAAK,QAAQ,SAAS,eACtB,KAAK,QAAQ,SAAS,cACtB,KAAK,QAAQ,SAAS,eAClB,IACA;AACN,SAAO,aAAa,KAAK,IAAI,IAAI;AACnC;AAEA,UAAU,KAAQ,QAAqB,OAAe;AACpD,MAAI,QAAQ;AACZ,aAAW,SAAS;AACd,aAAS,UAAO,MAAM,QAC1B;AAEJ;AAEA,UAAU,YAAY,MAAqC;AACrD,OAAK,SAAM,OAAO,YAAY,KAAK,IAAI,IACvC,KAAK,QAAQ,SAAS,WAAQ,MAAM;AAC1C;AAqDO,SAAS,UACd,MACA,OACA,KACQ;AACR,MAAI,CAAC,KAAM,QAAO;AAElB,MADI,OAAO,QAAS,YAChB,MAAM,QAAQ,IAAI,EAAG,QAAO,UAAU,UAAU,IAAI,GAAG,OAAO,GAAG;AACrE,MAAI,KAAK,SAAS,OAAQ,QAAO;AAEjC,QAAM,QAAQ,aAAa,IAAI;AAW/B,MAVI,OAAO,QAAU,QAAa,QAAQ,IACtC,QAAQ,MAAG,QAAQ,QAAQ,QAC3B,OAAO,MAAQ,QAAa,MAAM,QAClC,MAAM,MAAG,MAAM,MAAM,QAGzB,QAAQ,KAAK,IAAI,GAAG,KAAK,IAAI,OAAO,KAAK,CAAC,GAC1C,MAAM,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,CAAC,GAGlC,SAAS,IAAK,QAAO;AAGzB,MAAI,MAAM,MAAO,QAAO,UAAU,KAAK,MAAM,OAAO,GAAG;AAEvD,MAAI;AACJ,aAAW,WAAW,KAAK,YAAY,IAAI,GAAG,KAAK;AACjD,WAAO,EAAC,GAAG,SAAS,KAAA;AAEtB,SAAO,cAAc,IAAI;AAC3B;AAiDO,SAAS,UACd,MACA,MACQ;AACR,MAAI,CAAC,KAAM,QAAO,cAAc,IAAI;AAEpC,MADI,MAAM,QAAQ,IAAI,KAClB,OAAO,QAAS,SAAU,QAAO,UAAU,UAAU,IAAI,GAAG,IAAI;AACpE,MAAI,KAAK,SAAS,OAAQ,QAAO,cAAc,IAAI;AACnD,MAAI,CAAC,KAAM,QAAO,cAAc,IAAI;AAEpC,MADI,MAAM,QAAQ,IAAI,KAClB,OAAO,QAAS,SAAU,QAAO,UAAU,MAAM,UAAU,IAAI,CAAC;AACpE,MAAI,KAAK,SAAS,OAAQ,QAAO,cAAc,IAAI;AAEnD,aAAW,WAAW,YAAY,IAAI;AACpC,WAAO,EAAC,GAAG,SAAS,KAAA;AAEtB,SAAO,cAAc,IAAI;AAC3B;ACxgBA,MAAM,eAAgC,CAAA;AA+E/B,UAAU,UACf,OACA,MACA,WAA4B,CAAA,GACL;AACvB,QAAM,UAAU,cAAA;AAEhB,aAAW,SAAS,mBAAmB,EAAC,MAAM,UAAU,IAAI,GAAG,OAAO,MAAM,SAAA,CAAS,GAAG;AACtF,UAAM,EAAC,SAAQ;AACX,aAAS,iBACT,QAAQ,IAAI,IAAI,MACpB,QAAQ,IAAI,IAAI,GAChB,MAAM;AAAA,EAAA;AAEV;AAIA,MAAM,YAAY,CAAC,MAAe,MAAuB,WAA+B;AAAA,EACtF,OAAO;AAAA,EACP,MAAM,CAAC,GAAG,MAAM,cAAc,IAAI,IAAI,EAAC,MAAM,KAAK,KAAA,IAAQ,KAAK;AACjE;AAEA,UAAU,mBAAmB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AACF,GAA+D;AAC7D,MAAK;AAIL,YAAQ,KAAK,MAAA;AAAA,MACX,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,WAAW;AACd,cAAM,EAAC,OAAO,KAAK,OAAO,MAAM,aAAA;AAChC;AAAA,MAAA;AAAA,MAEF,KAAK,QAAQ;AACX,cAAM,EAAC,OAAO,MAAM,MAAM,aAAA;AAC1B;AAAA,MAAA;AAAA,MAEF,KAAK,QAAQ;AACX,eAAO,aAAa,EAAC,MAAM,OAAO,MAAK;AACvC;AAAA,MAAA;AAAA,MAEF;AACE;AAAA,IAAA;AAGN;AAEA,UAAU,aAAa;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AACF,GAA+D;AAC7D,MAAI,CAAC,MAAM;AACT,UAAM,EAAC,OAAO,KAAA;AACd;AAAA,EAAA;AAGF,aAAW,aAAa,aAAa,EAAC,MAAM,KAAK,MAAM,OAAO,KAAA,CAAK,GAAG;AACpE,QAAI,KAAK,WAAW;AAClB,aAAO,sBAAsB,EAAC,SAAS,KAAK,SAAS,GAAG,WAAU;AAClE;AAAA,IAAA;AAGF,WAAO,gBAAgB,EAAC,SAAS,KAAK,SAAS,GAAG,WAAU;AAAA,EAAA;AAEhE;AAEA,UAAU,sBAAsB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF,GAAoE;AAKlE,MAHA,OAAO,gBAAgB,EAAC,SAAS,OAAO,KAAA,CAAK,GAGzC,MAAM,QAAQ,KAAK,GAAG;AACxB,aAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,YAAM,OAAO,MAAM,KAAK;AACxB,aAAO,sBAAsB,EAAC,SAAS,GAAG,UAAU,MAAM,MAAM,KAAK,GAAE;AAAA,IAAA;AAEzE;AAAA,EAAA;AAGF,MAAI,SAAS,KAAK,GAAG;AACnB,eAAW,CAAC,KAAK,WAAW,KAAK,OAAO,QAAQ,KAAK;AACnD,aAAO,sBAAsB,EAAC,SAAS,OAAO,aAAa,MAAM,CAAC,GAAG,MAAM,GAAG,GAAE;AAElF;AAAA,EAAA;AAEJ;AAEA,UAAU,gBAAgB;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AACF,GAAoE;AAClE,UAAQ,QAAQ,MAAA;AAAA,IACd,KAAK,QAAQ;AACX,YAAM,EAAC,OAAO,KAAA;AACd;AAAA,IAAA;AAAA,IAGF,KAAK,cAAc;AACjB,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,iBAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,gBAAM,OAAO,MAAM,KAAK;AACxB,iBAAO,gBAAgB,EAAC,SAAS,GAAG,UAAU,MAAM,MAAM,KAAK,GAAE;AAAA,QAAA;AAEnE;AAAA,MAAA;AAGF,YAAM;AAAA,QACJ,OAAO,SAAS,KAAK,IAAI,MAAM,QAAQ,IAAI,IAAI;AAAA,QAC/C,MAAM,CAAC,GAAG,MAAM,QAAQ,IAAI;AAAA,MAAA;AAE9B;AAAA,IAAA;AAAA,IAGF,KAAK,aAAa;AAChB,aAAO,kBAAkB,EAAC,WAAW,SAAS,OAAO,MAAK;AAC1D;AAAA,IAAA;AAAA,IAGF,KAAK,YAAY;AACf,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,iBAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,gBAAM,OAAO,MAAM,KAAK;AACxB,gBAAM,UAAU,MAAM,MAAM,KAAK;AAAA,QAAA;AAEnC;AAAA,MAAA;AAGF,UAAI,SAAS,KAAK,GAAG;AACnB,mBAAW,CAAC,KAAK,WAAW,KAAK,OAAO,QAAQ,KAAK;AACnD,gBAAM,EAAC,OAAO,aAAa,MAAM,CAAC,GAAG,MAAM,GAAG,EAAA;AAEhD;AAAA,MAAA;AAGF;AAAA,IAAA;AAAA,IAGF;AACE;AAAA,EAAA;AAGN;AAEA,UAAU,kBAAkB;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AACF,GAAwE;AAEtE,aAAW,WAAW,UAAU;AAC9B,YAAQ,QAAQ,MAAA;AAAA,MACd,KAAK,aAAa;AAChB,eAAO,kBAAkB,EAAC,WAAW,SAAS,OAAO,MAAK;AAC1D;AAAA,MAAA;AAAA,MAGF,KAAK,cAAc;AACjB,eAAO,mBAAmB,EAAC,YAAY,SAAS,OAAO,MAAK;AAC5D;AAAA,MAAA;AAAA,MAGF,KAAK,QAAQ;AACX,eAAO,aAAa,EAAC,MAAM,SAAS,OAAO,MAAK;AAChD;AAAA,MAAA;AAAA,MAGF,KAAK,SAAS;AACZ,YAAI,CAAC,MAAM,QAAQ,KAAK,EAAG;AAC3B,YAAI,QAAQ,QAAQ,SAAS,GACzB,MAAM,QAAQ,OAAO,MAAM;AAC3B,gBAAQ,MAAG,QAAQ,MAAM,SAAS,QAClC,MAAM,MAAG,MAAM,MAAM,SAAS,MAGlC,QAAQ,KAAK,IAAI,GAAG,KAAK,IAAI,OAAO,MAAM,MAAM,CAAC,GACjD,MAAM,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,MAAM,MAAM,CAAC;AAE7C,iBAAS,QAAQ,OAAO,QAAQ,KAAK,SAAS;AAC5C,gBAAM,OAAO,MAAM,KAAK;AACxB,gBAAM,UAAU,MAAM,MAAM,KAAK;AAAA,QAAA;AAEnC;AAAA,MAAA;AAAA;AAAA,MAIF,KAAK,UAAU;AACb,cAAM,OAAO,MAAM,QAAQ,KAAK,IAAI,MAAM,GAAG,QAAQ,KAAK,IAAI;AAC9D,cAAM,UAAU,MAAM,MAAM,QAAQ,KAAK;AACzC;AAAA,MAAA;AAAA;AAAA,MAIF,KAAK;AAAA,MACL,KAAK,WAAW;AACd,eAAO,mBAAmB,EAAC,MAAM,SAAS,OAAO,MAAK;AACtD;AAAA,MAAA;AAAA,MAGF;AACE;AAAA,IAAA;AAIR;AAEA,UAAU,kBAAkB;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AACF,GAAwE;AACtE,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,aAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,YAAM,OAAO,MAAM,KAAK;AACxB,aAAO,kBAAkB,EAAC,WAAW,GAAG,UAAU,MAAM,MAAM,KAAK,GAAE;AAAA,IAAA;AAEvE;AAAA,EAAA;AAGF,aAAW,aAAa,aAAa,EAAC,MAAM,UAAU,MAAM,MAAM,OAAM;AACtE,QAAI,OAAO,UAAU,QAAU,KAAa;AAC1C,YAAM,EAAC,OAAO,KAAA;AACd;AAAA,IAAA;AAGN;AAEA,SAAS,qBAAqB,EAAC,UAAU,MAAM,SAAwB;AACrE,MAAI,aAAa,KAAM;AACvB,QAAM,cAAc,CAAC,MAAM,KAAK,EAAE,KAAK,SAAS;AAChD,MAAI,CAAC,YAAa;AAClB,QAAM,QAAQ,SAAS,cAAc,QAAQ;AAC7C,MAAI,MAAM,SAAS;AACnB,WAAO,MAAM;AACf;AAEA,MAAM,YAAY,CAAC,SACb,KAAK,SAAS,UACd,KAAK,QACL,KAAK,aACL,KAAK,QAAQ,SAAS,eAAqB,KACxC,KAAK,QAAQ,SAAS;AAG/B,UAAU,uBAAuB,QAA8B;AAC7D,aAAW,QAAQ;AACb,WAAO,KAAK,QAAU,QAAa,MAAM;AAEjD;AAEA,UAAU,mBAAmB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AACF,GAA0E;AACxE,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,UAAM,OAAO,qBAAqB,UAAU;AAC5C,QAAI,MAAM;AACR,YAAM,QAAQ,eAAe,OAAO,IAAI;AACxC,YAAM;AAAA,QACJ,OAAO,OAAO,SAAU,WAAW,MAAM,KAAK,IAAI;AAAA,QAClD,MAAM,CAAC,GAAG,MAAM,EAAC,MAAK;AAAA,MAAA;AAExB;AAAA,IAAA;AAGF,aAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,YAAM,OAAO,MAAM,KAAK;AACxB,aAAO,mBAAmB,EAAC,YAAY,GAAG,UAAU,MAAM,MAAM,KAAK,GAAE;AAAA,IAAA;AAEzE;AAAA,EAAA;AAGF,QAAM,aAAa;AAAA,IACjB,mBAAmB,EAAC,MAAM,WAAW,MAAM,OAAO,MAAK;AAAA,EAAA,EACvD,KAAA,GACI,cAAc;AAAA,IAClB,mBAAmB,EAAC,MAAM,WAAW,OAAO,OAAO,MAAK;AAAA,EAAA,EACxD,KAAA;AAEF,MAAI,WAAW,QAAQ,YAAY,KAAM;AACzC,QAAM,EAAC,OAAO,KAAA,IAAQ,WAAW,OAC3B,EAAC,OAAO,UAAS,YAAY;AAEnC,MAAI,WAAW,aAAa,MAAM;AAC5B,aAAS,UAAO,MAAM,EAAC,OAAO,KAAA;AAClC;AAAA,EAAA;AAGF,MAAI,WAAW,aAAa,MAAM;AAC5B,aAAS,UAAO,MAAM,EAAC,OAAO,KAAA;AAClC;AAAA,EAAA;AAGE,SAAO,QAAS,YAAY,OAAO,SAAU,aAC7C,WAAW,aAAa,OAAO,OAAO,UAAO,MAAM,EAAC,OAAO,KAAA,IAC3D,WAAW,aAAa,QAAQ,QAAQ,UAAO,MAAM,EAAC,OAAO,KAAA,IAC7D,WAAW,aAAa,OAAO,OAAO,UAAO,MAAM,EAAC,OAAO,SAC3D,WAAW,aAAa,QAAQ,QAAQ,UAAO,MAAM,EAAC,OAAO,KAAA;AACnE;"}