{"version":3,"file":"index.js","sources":["../src/auth/authStateType.ts","../src/utils/ids.ts","../src/store/createSanityInstance.ts","../src/utils/getEnv.ts","../src/store/createStoreState.ts","../src/store/createStoreInstance.ts","../src/store/createActionBinder.ts","../src/store/createStateSourceAction.ts","../src/auth/authConstants.ts","../src/auth/refreshStampedToken.ts","../src/auth/utils.ts","../src/auth/studioModeAuth.ts","../src/auth/subscribeToStateAndFetchCurrentUser.ts","../src/auth/subscribeToStorageEventsAndSetToken.ts","../src/auth/authStore.ts","../src/project/organizationVerification.ts","../src/client/clientStore.ts","../src/utils/createFetcherStore.ts","../src/project/project.ts","../src/auth/dashboardUtils.ts","../src/auth/getOrganizationVerificationState.ts","../src/auth/handleAuthCallback.ts","../src/auth/logout.ts","../src/comlink/controller/actions/destroyController.ts","../src/comlink/controller/actions/getOrCreateChannel.ts","../src/comlink/controller/actions/getOrCreateController.ts","../src/comlink/controller/actions/releaseChannel.ts","../src/comlink/controller/comlinkControllerStore.ts","../src/comlink/node/actions/getOrCreateNode.ts","../src/comlink/node/actions/releaseNode.ts","../src/comlink/node/comlinkNodeStore.ts","../src/comlink/node/getNodeState.ts","../src/config/handles.ts","../src/datasets/datasets.ts","../src/document/actions.ts","../src/document/documentConstants.ts","../src/document/patchOperations.ts","../src/document/processMutations.ts","../src/document/listen.ts","../src/document/_synchronous-groq-js.mjs","../src/utils/MultiKeyWeakMap.ts","../src/document/permissions.ts","../src/document/processActions.ts","../src/document/reducers.ts","../src/document/events.ts","../src/document/sharedListener.ts","../src/document/documentStore.ts","../src/document/applyDocumentActions.ts","../src/favorites/favorites.ts","../src/users/usersConstants.ts","../src/users/reducers.ts","../src/users/usersStore.ts","../src/presence/bifurTransport.ts","../src/presence/presenceStore.ts","../src/utils/listenQuery.ts","../src/releases/utils/sortReleases.ts","../src/releases/releasesStore.ts","../src/releases/getPerspectiveState.ts","../src/query/queryStoreConstants.ts","../src/query/reducers.ts","../src/query/queryStore.ts","../src/utils/hashString.ts","../src/preview/previewConstants.ts","../src/preview/util.ts","../src/preview/previewQuery.ts","../src/preview/subscribeToStateAndFetchBatches.ts","../src/preview/previewStore.ts","../src/preview/getPreviewState.ts","../src/preview/resolvePreview.ts","../src/projection/projectionQuery.ts","../src/projection/util.ts","../src/projection/subscribeToStateAndFetchBatches.ts","../src/projection/projectionStore.ts","../src/projection/getProjectionState.ts","../src/projection/resolveProjection.ts","../src/projects/projects.ts","../src/utils/createGroqSearchFilter.ts","../src/utils/defineIntent.ts","../src/version.ts"],"sourcesContent":["/**\n * Represents the various states the authentication type can be in.\n *\n * @public\n */\nexport enum AuthStateType {\n  LOGGED_IN = 'logged-in',\n  LOGGING_IN = 'logging-in',\n  ERROR = 'error',\n  LOGGED_OUT = 'logged-out',\n}\n","export function getPublishedId(id: string): string {\n  const draftsPrefix = 'drafts.'\n  return id.startsWith(draftsPrefix) ? id.slice(draftsPrefix.length) : id\n}\n\nexport function getDraftId(id: string): string {\n  const draftsPrefix = 'drafts.'\n  return id.startsWith(draftsPrefix) ? id : `${draftsPrefix}${id}`\n}\n\nexport function insecureRandomId(): string {\n  return Array.from({length: 16}, () => Math.floor(Math.random() * 16).toString(16)).join('')\n}\n","import {pick} from 'lodash-es'\n\nimport {type SanityConfig} from '../config/sanityConfig'\nimport {insecureRandomId} from '../utils/ids'\n\n/**\n * Represents a Sanity.io resource instance with its own configuration and lifecycle\n * @remarks Instances form a hierarchy through parent/child relationships\n *\n * @public\n */\nexport interface SanityInstance {\n  /**\n   * Unique identifier for this instance\n   * @remarks Generated using crypto.randomUUID()\n   */\n  readonly instanceId: string\n\n  /**\n   * Resolved configuration for this instance\n   * @remarks Merges values from parent instances where appropriate\n   */\n  readonly config: SanityConfig\n\n  /**\n   * Checks if the instance has been disposed\n   * @returns true if dispose() has been called\n   */\n  isDisposed(): boolean\n\n  /**\n   * Disposes the instance and cleans up associated resources\n   * @remarks Triggers all registered onDispose callbacks\n   */\n  dispose(): void\n\n  /**\n   * Registers a callback to be invoked when the instance is disposed\n   * @param cb - Callback to execute on disposal\n   * @returns Function to unsubscribe the callback\n   */\n  onDispose(cb: () => void): () => void\n\n  /**\n   * Gets the parent instance in the hierarchy\n   * @returns Parent instance or undefined if this is the root\n   */\n  getParent(): SanityInstance | undefined\n\n  /**\n   * Creates a child instance with merged configuration\n   * @param config - Configuration to merge with parent values\n   * @remarks Child instances inherit parent configuration but can override values\n   */\n  createChild(config: SanityConfig): SanityInstance\n\n  /**\n   * Traverses the instance hierarchy to find the first instance whose configuration\n   * matches the given target config using a shallow comparison.\n   * @param targetConfig - A partial configuration object containing key-value pairs to match.\n   * @returns The first matching instance or undefined if no match is found.\n   */\n  match(targetConfig: Partial<SanityConfig>): SanityInstance | undefined\n}\n\n/**\n * Creates a new Sanity resource instance\n * @param config - Configuration for the instance (optional)\n * @returns A configured SanityInstance\n * @remarks When creating child instances, configurations are merged with parent values\n *\n * @public\n */\nexport function createSanityInstance(config: SanityConfig = {}): SanityInstance {\n  const instanceId = crypto.randomUUID()\n  const disposeListeners = new Map<string, () => void>()\n  const disposed = {current: false}\n\n  const instance: SanityInstance = {\n    instanceId,\n    config,\n    isDisposed: () => disposed.current,\n    dispose: () => {\n      if (disposed.current) return\n      disposed.current = true\n      disposeListeners.forEach((listener) => listener())\n      disposeListeners.clear()\n    },\n    onDispose: (cb) => {\n      const listenerId = insecureRandomId()\n      disposeListeners.set(listenerId, cb)\n      return () => {\n        disposeListeners.delete(listenerId)\n      }\n    },\n    getParent: () => undefined,\n    createChild: (next) =>\n      Object.assign(\n        createSanityInstance({\n          ...config,\n          ...next,\n          ...(config.auth === next.auth\n            ? config.auth\n            : config.auth && next.auth && {auth: {...config.auth, ...next.auth}}),\n        }),\n        {getParent: () => instance},\n      ),\n    match: (targetConfig) => {\n      if (\n        Object.entries(pick(targetConfig, 'auth', 'projectId', 'dataset')).every(\n          ([key, value]) => config[key as keyof SanityConfig] === value,\n        )\n      ) {\n        return instance\n      }\n\n      const parent = instance.getParent()\n      if (parent) return parent.match(targetConfig)\n      return undefined\n    },\n  }\n\n  return instance\n}\n","// Local type declaration for Remix\ntype WindowWithEnv = Window &\n  typeof globalThis & {\n    ENV?: Record<string, unknown>\n  }\n\ntype KnownEnvVar = 'DEV' | 'PKG_VERSION'\n\nexport function getEnv(key: KnownEnvVar): unknown {\n  if (typeof import.meta !== 'undefined' && import.meta.env) {\n    // Vite environment variables\n    return (import.meta.env as unknown as Record<string, unknown>)[key]\n  } else if (typeof process !== 'undefined' && process.env) {\n    // Node.js or server-side environment variables\n    return process.env[key]\n  } else if (typeof window !== 'undefined' && (window as WindowWithEnv).ENV) {\n    // Remix-style client-side environment variables\n    return (window as WindowWithEnv).ENV?.[key]\n  }\n  return undefined\n}\n","import {Observable} from 'rxjs'\nimport {devtools, type DevtoolsOptions} from 'zustand/middleware'\nimport {createStore} from 'zustand/vanilla'\n\n/**\n * Represents a reactive store state container with multiple access patterns\n */\nexport interface StoreState<TState> {\n  /**\n   * Gets the current state value\n   *\n   * @remarks\n   * This is a direct synchronous accessor that doesn't trigger subscriptions\n   */\n  get: () => TState\n\n  /**\n   * Updates the store state\n   * @param name - Action name for devtools tracking\n   * @param updatedState - New state value or updater function\n   *\n   * @remarks\n   * When providing a partial object, previous top-level keys not included in\n   * the update will be preserved.\n   */\n  set: (name: string, updatedState: Partial<TState> | ((s: TState) => Partial<TState>)) => void\n\n  /**\n   * Observable stream of state changes\n   * @remarks\n   * - Emits immediately with current state on subscription\n   * - Shares underlying subscription between observers\n   * - Only emits when state reference changes\n   * - Completes when store is disposed\n   */\n  observable: Observable<TState>\n}\n\n/**\n * Creates a reactive store state container with multiple access patterns\n * @param initialState - Initial state value for the store\n * @param devToolsOptions - Configuration for Zustand devtools integration\n * @returns StoreState instance with get/set/observable interface\n *\n * @example\n * ```typescript\n * // Create a simple counter store\n * const counterStore = createStoreState({ count: 0 });\n *\n * // Update state\n * counterStore.set('increment', { count: 1 });\n *\n * // Observe changes\n * counterStore.observable.subscribe(console.log);\n * ```\n *\n * @remarks\n * Uses Zustand for state management under the hood with RxJS for observable interface.\n * Designed to work with both imperative and reactive programming patterns.\n */\nexport function createStoreState<TState>(\n  initialState: TState,\n  devToolsOptions?: DevtoolsOptions,\n): StoreState<TState> {\n  // Create underlying Zustand store with devtools integration\n  const store = createStore<TState>()(devtools(() => initialState, devToolsOptions))\n\n  return {\n    get: store.getState,\n    set: (actionKey, updatedState) => {\n      const currentState = store.getState()\n      const nextState =\n        typeof updatedState === 'function' ? updatedState(currentState) : updatedState\n\n      // Optimization: Skip update if state reference remains the same\n      if (currentState !== nextState) {\n        store.setState(nextState, false, actionKey)\n      }\n    },\n    observable: new Observable((observer) => {\n      // Emit current state immediately on subscription\n      const emit = () => observer.next(store.getState())\n      emit()\n\n      // Subscribe to Zustand store changes\n      const unsubscribe = store.subscribe(emit)\n\n      // Cleanup when observable unsubscribed\n      return () => unsubscribe()\n    }),\n  }\n}\n","import {getEnv} from '../utils/getEnv'\nimport {type SanityInstance} from './createSanityInstance'\nimport {createStoreState, type StoreState} from './createStoreState'\nimport {type StoreDefinition} from './defineStore'\n\n/**\n * Represents a running instance of a store with its own state and lifecycle\n *\n * @remarks\n * Each StoreInstance is tied to a specific SanityInstance, manages its own state,\n * and can be independently disposed when no longer needed.\n */\nexport interface StoreInstance<TState> {\n  /**\n   * Access to the reactive state container for this store instance\n   */\n  state: StoreState<TState>\n\n  /**\n   * Checks if this store instance has been disposed\n   * @returns Boolean indicating disposed state\n   */\n  isDisposed: () => void\n\n  /**\n   * Cleans up this store instance and runs any initialization cleanup functions\n   * @remarks Triggers the cleanup function returned from the initialize method\n   */\n  dispose: () => void\n}\n\n/**\n * Creates a new instance of a store from a store definition\n *\n * @param instance - The Sanity instance this store will be associated with\n * @param storeDefinition - The store definition containing initial state and initialization logic\n * @returns A store instance with state management and lifecycle methods\n *\n * @remarks\n * The store instance maintains its own state that is scoped to the given Sanity instance.\n * If the store definition includes an initialize function, it will be called during\n * instance creation, and its cleanup function will be called during disposal.\n *\n * @example\n * ```ts\n * const counterStore = defineStore({\n *   name: 'Counter',\n *   getInitialState: () => ({ count: 0 }),\n *   initialize: ({state}) => {\n *     console.log('Counter store initialized')\n *     return () => console.log('Counter store disposed')\n *   }\n * })\n *\n * const instance = createStoreInstance(sanityInstance, counterStore)\n * // Later when done with the store:\n * instance.dispose()\n * ```\n */\nexport function createStoreInstance<TState>(\n  instance: SanityInstance,\n  {name, getInitialState, initialize}: StoreDefinition<TState>,\n): StoreInstance<TState> {\n  const state = createStoreState(getInitialState(instance), {\n    enabled: !!getEnv('DEV'),\n    name: `${name}-${instance.config.projectId}.${instance.config.dataset}`,\n  })\n  const dispose = initialize?.({state, instance})\n  const disposed = {current: false}\n\n  return {\n    state,\n    dispose: () => {\n      if (disposed.current) return\n      disposed.current = true\n      dispose?.()\n    },\n    isDisposed: () => disposed.current,\n  }\n}\n","import {type SanityConfig} from '../config/sanityConfig'\nimport {type SanityInstance} from './createSanityInstance'\nimport {createStoreInstance, type StoreInstance} from './createStoreInstance'\nimport {type StoreState} from './createStoreState'\nimport {type StoreContext, type StoreDefinition} from './defineStore'\n\n/**\n * Defines a store action that operates on a specific state type\n */\nexport type StoreAction<TState, TParams extends unknown[], TReturn> = (\n  context: StoreContext<TState>,\n  ...params: TParams\n) => TReturn\n\n/**\n * Represents a store action that has been bound to a specific store instance\n */\nexport type BoundStoreAction<_TState, TParams extends unknown[], TReturn> = (\n  instance: SanityInstance,\n  ...params: TParams\n) => TReturn\n\n/**\n * Creates an action binder function that uses the provided key function\n * to determine how store instances are shared between Sanity instances\n *\n * @param keyFn - Function that generates a key from a Sanity config\n * @returns A function that binds store actions to Sanity instances\n *\n * @remarks\n * Action binders determine how store instances are shared across multiple\n * Sanity instances. The key function determines which instances share state.\n *\n * @example\n * ```ts\n * // Create a custom binder that uses a tenant ID for isolation\n * const bindActionByTenant = createActionBinder(config => config.tenantId || 'default')\n *\n * // Use the custom binder with a store definition\n * const getTenantUsers = bindActionByTenant(\n *   userStore,\n *   ({state}) => state.get().users\n * )\n * ```\n */\nexport function createActionBinder(keyFn: (config: SanityConfig) => string) {\n  const instanceRegistry = new Map<string, Set<string>>()\n  const storeRegistry = new Map<string, StoreInstance<unknown>>()\n\n  /**\n   * Binds a store action to a store definition\n   *\n   * @param storeDefinition - The store definition\n   * @param action - The action to bind\n   * @returns A function that executes the action with a Sanity instance\n   */\n  return function bindAction<TState, TParams extends unknown[], TReturn>(\n    storeDefinition: StoreDefinition<TState>,\n    action: StoreAction<TState, TParams, TReturn>,\n  ): BoundStoreAction<TState, TParams, TReturn> {\n    return function boundAction(instance: SanityInstance, ...params: TParams) {\n      const keySuffix = keyFn(instance.config)\n      const compositeKey = storeDefinition.name + (keySuffix ? `:${keySuffix}` : '')\n\n      // Get or create instance set for this composite key\n      let instances = instanceRegistry.get(compositeKey)\n      if (!instances) {\n        instances = new Set<string>()\n        instanceRegistry.set(compositeKey, instances)\n      }\n\n      // Register instance for disposal tracking\n      if (!instances.has(instance.instanceId)) {\n        instances.add(instance.instanceId)\n        instance.onDispose(() => {\n          instances.delete(instance.instanceId)\n\n          // Clean up when last instance is disposed\n          if (instances.size === 0) {\n            storeRegistry.get(compositeKey)?.dispose()\n            storeRegistry.delete(compositeKey)\n            instanceRegistry.delete(compositeKey)\n          }\n        })\n      }\n\n      // Get or create store instance\n      let storeInstance = storeRegistry.get(compositeKey)\n      if (!storeInstance) {\n        storeInstance = createStoreInstance(instance, storeDefinition)\n        storeRegistry.set(compositeKey, storeInstance)\n      }\n\n      // Execute action with store context\n      return action({instance, state: storeInstance.state as StoreState<TState>}, ...params)\n    }\n  }\n}\n\n/**\n * Binds an action to a store that's scoped to a specific project and dataset\n *\n * @remarks\n * This creates actions that operate on state isolated to a specific projectId and dataset.\n * Different project/dataset combinations will have separate states.\n *\n * @throws Error if projectId or dataset is missing from the Sanity instance config\n *\n * @example\n * ```ts\n * // Define a store\n * const documentStore = defineStore<DocumentState>({\n *   name: 'Document',\n *   getInitialState: () => ({ documents: {} }),\n *   // ...\n * })\n *\n * // Create dataset-specific actions\n * export const fetchDocument = bindActionByDataset(\n *   documentStore,\n *   ({instance, state}, documentId) => {\n *     // This state is isolated to the specific project/dataset\n *     // ...fetch logic...\n *   }\n * )\n *\n * // Usage\n * fetchDocument(sanityInstance, 'doc123')\n * ```\n */\nexport const bindActionByDataset = createActionBinder(({projectId, dataset}) => {\n  if (!projectId || !dataset) {\n    throw new Error('This API requires a project ID and dataset configured.')\n  }\n  return `${projectId}.${dataset}`\n})\n\n/**\n * Binds an action to a global store that's shared across all Sanity instances\n *\n * @remarks\n * This creates actions that operate on state shared globally across all Sanity instances.\n * Use this for features like authentication where the state should be the same\n * regardless of which project or dataset is being used.\n *\n * @example\n * ```ts\n * // Define a store\n * const authStore = defineStore<AuthState>({\n *   name: 'Auth',\n *   getInitialState: () => ({\n *     user: null,\n *     isAuthenticated: false\n *   }),\n *   // ...\n * })\n *\n * // Create global actions\n * export const getCurrentUser = bindActionGlobally(\n *   authStore,\n *   ({state}) => state.get().user\n * )\n *\n * export const login = bindActionGlobally(\n *   authStore,\n *   ({state, instance}, credentials) => {\n *     // Login logic that affects global state\n *     // ...\n *   }\n * )\n *\n * // Usage with any instance\n * getCurrentUser(sanityInstance)\n * ```\n */\nexport const bindActionGlobally = createActionBinder(() => 'global')\n","import {distinctUntilChanged, map, Observable, share, skip} from 'rxjs'\n\nimport {type StoreAction} from './createActionBinder'\nimport {type SanityInstance} from './createSanityInstance'\nimport {type StoreContext} from './defineStore'\n\n/**\n * Represents a reactive state source that provides synchronized access to store data\n *\n * @remarks\n * Designed to work with React's useSyncExternalStore hook. Provides three ways to access data:\n * 1. `getCurrent()` for synchronous current value access\n * 2. `subscribe()` for imperative change notifications\n * 3. `observable` for reactive stream access\n *\n * @public\n */\nexport interface StateSource<T> {\n  /**\n   * Subscribes to state changes with optional callback\n   * @param onStoreChanged - Called whenever relevant state changes occur\n   * @returns Unsubscribe function to clean up the subscription\n   */\n  subscribe: (onStoreChanged?: () => void) => () => void\n\n  /**\n   * Gets the current derived state value\n   *\n   * @remarks\n   * Safe to call without subscription. Will always return the latest value\n   * based on the current store state and selector parameters.\n   */\n  getCurrent: () => T\n\n  /**\n   * Observable stream of state values\n   *\n   * @remarks\n   * Shares a single underlying subscription between all observers. Emits:\n   * - Immediately with current value on subscription\n   * - On every relevant state change\n   * - Errors if selector throws\n   */\n  observable: Observable<T>\n}\n\n/**\n * Context passed to selectors when deriving state\n *\n * @remarks\n * Provides access to both the current state value and the Sanity instance,\n * allowing selectors to use configuration values when computing derived state.\n * The context is memoized for each state object and instance combination\n * to optimize performance and prevent unnecessary recalculations.\n *\n * @example\n * ```ts\n * // Using both state and instance in a selector (psuedo example)\n * const getUserByProjectId = createStateSourceAction(\n *   ({ state, instance }: SelectorContext<UsersState>, options?: ProjectHandle) => {\n *     const allUsers = state.users\n *     const projectId = options?.projectId ?? instance.config.projectId\n *     return allUsers.filter(user => user.projectId === projectId)\n *   }\n * )\n * ```\n */\nexport interface SelectorContext<TState> {\n  /**\n   * The current state object from the store\n   */\n  state: TState\n\n  /**\n   * The Sanity instance associated with this state\n   */\n  instance: SanityInstance\n}\n\n/**\n * Function type for selecting derived state from store state and parameters\n * @public\n */\nexport type Selector<TState, TParams extends unknown[], TReturn> = (\n  context: SelectorContext<TState>,\n  ...params: TParams\n) => TReturn\n\n/**\n * Configuration options for creating a state source action\n */\ninterface StateSourceOptions<TState, TParams extends unknown[], TReturn> {\n  /**\n   * Selector function that derives the desired value from store state\n   *\n   * @remarks\n   * Will be called on every store change. Should be pure function.\n   * Thrown errors will propagate to observable subscribers.\n   */\n  selector: Selector<TState, TParams, TReturn>\n\n  /**\n   * Optional setup/cleanup handler for subscriptions\n   *\n   * @param context - Store context containing state and instance\n   * @param params - Action parameters provided during invocation\n   * @returns Optional cleanup function called when subscription ends\n   */\n  onSubscribe?: (context: StoreContext<TState>, ...params: TParams) => void | (() => void)\n\n  /**\n   * Equality function to prevent unnecessary updates\n   */\n  isEqual?: (prev: TReturn, curr: TReturn) => boolean\n}\n\n/**\n * Creates a state source action that generates StateSource instances\n *\n * @remarks\n * The returned action can be bound to a store using createActionBinder.\n * When invoked, returns a StateSource that stays synchronized with the store.\n *\n * Key performance features:\n * - Memoizes selector contexts to prevent redundant object creation\n * - Only runs selectors when the underlying state changes\n *\n * For complex data transformations, consider using memoized selectors\n * (like those from Reselect) to prevent expensive recalculations.\n *\n * @example\n * ```ts\n * // Create a simple counter source\n * const getCount = createStateSourceAction(({state}: SelectorContext<CounterState>) => state.count)\n * ```\n *\n * @example\n * ```ts\n * // Create a parameterized source with setup/cleanup\n * const getItem = createStateSourceAction({\n *   selector: ({state}, index: number) => state.items[index],\n *   onSubscribe: (context, index) => {\n *     trackItemSubscription(index)\n *     return () => untrackItem(index)\n *   }\n * })\n * ```\n *\n * @example\n * ```ts\n * // Binding a state source to a specific store\n * const documentStore = defineStore<DocumentState>({\n *   name: 'Documents',\n *   getInitialState: () => ({ documents: {} }),\n *   // ...\n * })\n *\n * const getDocument = bindActionByDataset(\n *   documentStore,\n *   createStateSourceAction(({state}, documentId: string) => state.documents[documentId])\n * )\n *\n * // Usage\n * const documentSource = getDocument(sanityInstance, 'doc123')\n * const doc = documentSource.getCurrent()\n * const subscription = documentSource.observable.subscribe(updatedDoc => {\n *   console.log('Document changed:', updatedDoc)\n * })\n * ```\n */\nexport function createStateSourceAction<TState, TParams extends unknown[], TReturn>(\n  options: Selector<TState, TParams, TReturn> | StateSourceOptions<TState, TParams, TReturn>,\n): StoreAction<TState, TParams, StateSource<TReturn>> {\n  const selector = typeof options === 'function' ? options : options.selector\n  const subscribeHandler = options && 'onSubscribe' in options ? options.onSubscribe : undefined\n  const isEqual = options && 'isEqual' in options ? (options.isEqual ?? Object.is) : Object.is\n  const selectorContextCache = new WeakMap<\n    object,\n    WeakMap<SanityInstance, SelectorContext<TState>>\n  >()\n\n  /**\n   * The state source action implementation\n   * @param context - Store context providing access to state and instance\n   * @param params - Parameters provided when invoking the bound action\n   */\n  function stateSourceAction(context: StoreContext<TState>, ...params: TParams) {\n    const {state, instance} = context\n\n    const getCurrent = () => {\n      const currentState = state.get()\n      if (typeof currentState !== 'object' || currentState === null) {\n        throw new Error(\n          `Expected store state to be an object but got \"${typeof currentState}\" instead`,\n        )\n      }\n\n      let instanceCache = selectorContextCache.get(currentState)\n      if (!instanceCache) {\n        instanceCache = new WeakMap<SanityInstance, SelectorContext<TState>>()\n        selectorContextCache.set(currentState, instanceCache)\n      }\n      let selectorContext = instanceCache.get(instance)\n      if (!selectorContext) {\n        selectorContext = {state: currentState, instance}\n        instanceCache.set(instance, selectorContext)\n      }\n      return selector(selectorContext, ...params)\n    }\n\n    // Subscription manager handles both RxJS and direct subscriptions\n    const subscribe = (onStoreChanged?: () => void) => {\n      // Run setup handler if provided\n      const cleanup = subscribeHandler?.(context, ...params)\n\n      // Set up state change subscription\n      const subscription = state.observable\n        .pipe(\n          // Derive value from current state\n          map(getCurrent),\n          // Filter unchanged values using custom equality check\n          distinctUntilChanged(isEqual),\n          // Skip initial emission since we only want changes\n          skip(1),\n        )\n        .subscribe({\n          next: () => onStoreChanged?.(),\n          // Propagate selector errors to both subscription types\n          error: () => onStoreChanged?.(),\n        })\n\n      return () => {\n        subscription.unsubscribe()\n        cleanup?.()\n      }\n    }\n\n    // Create shared observable that handles multiple subscribers efficiently\n    const observable = new Observable<TReturn>((observer) => {\n      const emitCurrent = () => {\n        try {\n          observer.next(getCurrent())\n        } catch (error) {\n          observer.error(error)\n        }\n      }\n      // Emit immediately on subscription\n      emitCurrent()\n      return subscribe(emitCurrent)\n    }).pipe(share())\n\n    return {\n      getCurrent,\n      subscribe,\n      observable,\n    }\n  }\n\n  return stateSourceAction\n}\n","export const DEFAULT_BASE = 'http://localhost'\nexport const AUTH_CODE_PARAM = 'sid'\nexport const DEFAULT_API_VERSION = '2021-06-07'\nexport const REQUEST_TAG_PREFIX = 'sanity.sdk.auth'\n","import {\n  distinctUntilChanged,\n  exhaustMap,\n  filter,\n  firstValueFrom,\n  from,\n  map,\n  Observable,\n  type Subscription,\n  switchMap,\n  takeWhile,\n  timer,\n} from 'rxjs'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {DEFAULT_API_VERSION} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {type AuthState, type AuthStoreState} from './authStore'\n\nconst REFRESH_INTERVAL = 12 * 60 * 60 * 1000 // 12 hours in milliseconds\nconst LOCK_NAME = 'sanity-token-refresh-lock'\n\n/** @internal */\nexport function getLastRefreshTime(storageArea: Storage | undefined, storageKey: string): number {\n  try {\n    const data = storageArea?.getItem(`${storageKey}_last_refresh`)\n    const parsed = data ? parseInt(data, 10) : 0\n    return isNaN(parsed) ? 0 : parsed\n  } catch {\n    return 0\n  }\n}\n\n/** @internal */\nexport function setLastRefreshTime(storageArea: Storage | undefined, storageKey: string): void {\n  try {\n    storageArea?.setItem(`${storageKey}_last_refresh`, Date.now().toString())\n  } catch {\n    // Ignore storage errors\n  }\n}\n\n/** @internal */\nexport function getNextRefreshDelay(storageArea: Storage | undefined, storageKey: string): number {\n  const lastRefresh = getLastRefreshTime(storageArea, storageKey)\n  if (!lastRefresh) return 0\n\n  const now = Date.now()\n  const nextRefreshTime = lastRefresh + REFRESH_INTERVAL\n  return Math.max(0, nextRefreshTime - now)\n}\n\nfunction createTokenRefreshStream(\n  token: string,\n  clientFactory: AuthStoreState['options']['clientFactory'],\n  apiHost: string | undefined,\n): Observable<{token: string}> {\n  return new Observable((subscriber) => {\n    const client = clientFactory({\n      apiVersion: DEFAULT_API_VERSION,\n      requestTagPrefix: 'token-refresh',\n      useProjectHostname: false,\n      useCdn: false,\n      token,\n      ignoreBrowserTokenWarning: true,\n      ...(apiHost && {apiHost}),\n    })\n\n    const subscription = client.observable\n      .request<{token: string}>({\n        uri: 'auth/refresh-token',\n        method: 'POST',\n        body: {\n          token,\n        },\n      })\n      .subscribe(subscriber)\n\n    return () => subscription.unsubscribe()\n  })\n}\n\nasync function acquireTokenRefreshLock(\n  refreshFn: () => Promise<void>,\n  storageArea: Storage | undefined,\n  storageKey: string,\n): Promise<boolean> {\n  if (!navigator.locks) {\n    // If Web Locks API is not supported, perform an immediate, uncoordinated refresh.\n    // eslint-disable-next-line no-console\n    console.warn('Web Locks API not supported. Proceeding with uncoordinated refresh.')\n    await refreshFn()\n    setLastRefreshTime(storageArea, storageKey)\n    return true // Indicate success to allow stream processing, though it won't loop.\n  }\n\n  try {\n    // Attempt to acquire an exclusive lock for token refresh coordination.\n    // The callback handles the continuous refresh cycle while the lock is held.\n    const result = await navigator.locks.request(LOCK_NAME, {mode: 'exclusive'}, async (lock) => {\n      if (!lock) return false // Lock not granted\n\n      // Problematic infinite loop - needs redesign for graceful termination.\n      // This loop continuously refreshes the token at REFRESH_INTERVAL.\n      while (true) {\n        const delay = getNextRefreshDelay(storageArea, storageKey)\n        if (delay > 0) {\n          await new Promise((resolve) => setTimeout(resolve, delay))\n        }\n        try {\n          await refreshFn()\n          setLastRefreshTime(storageArea, storageKey)\n        } catch (error) {\n          // eslint-disable-next-line no-console\n          console.error('Token refresh failed within lock:', error)\n          // Decide how to handle errors - break, retry, etc.? Currently logs and continues.\n        }\n        // Wait for the next interval\n        await new Promise((resolve) => setTimeout(resolve, REFRESH_INTERVAL))\n      }\n      // Unreachable due to while(true)\n    })\n    // The promise from navigator.locks.request resolves with the callback's return value,\n    // but only if the callback finishes. The infinite loop prevents this.\n    return result === true\n  } catch (error) {\n    // Handle potential errors during the initial lock request itself.\n    // eslint-disable-next-line no-console\n    console.error('Failed to request token refresh lock:', error)\n    return false // Indicate lock acquisition failure.\n  }\n}\n\nfunction shouldRefreshToken(lastRefresh: number | undefined): boolean {\n  if (!lastRefresh) return true\n  const timeSinceLastRefresh = Date.now() - lastRefresh\n  return timeSinceLastRefresh >= REFRESH_INTERVAL\n}\n\n/**\n * @internal\n */\nexport const refreshStampedToken = ({state}: StoreContext<AuthStoreState>): Subscription => {\n  const {clientFactory, apiHost, storageArea, storageKey} = state.get().options\n\n  const refreshToken$ = state.observable.pipe(\n    map((storeState) => ({\n      authState: storeState.authState,\n      dashboardContext: storeState.dashboardContext,\n    })),\n    filter(\n      (\n        storeState,\n      ): storeState is {\n        authState: Extract<AuthState, {type: AuthStateType.LOGGED_IN}>\n        dashboardContext: AuthStoreState['dashboardContext']\n      } => storeState.authState.type === AuthStateType.LOGGED_IN,\n    ),\n    distinctUntilChanged(\n      (prev, curr) =>\n        prev.authState.type === curr.authState.type &&\n        prev.authState.token === curr.authState.token && // Only care about token for distinctness here\n        prev.dashboardContext === curr.dashboardContext,\n    ), // Make distinctness check explicit\n    filter((storeState) => storeState.authState.token.includes('-st')), // Ensure we only try to refresh stamped tokens\n    exhaustMap((storeState) => {\n      // USE exhaustMap instead of switchMap\n      // Create a function that performs a single refresh and updates state/storage\n      const performRefresh = async () => {\n        // Read the latest token directly from state inside refresh\n        const currentState = state.get()\n        if (currentState.authState.type !== AuthStateType.LOGGED_IN) {\n          throw new Error('User logged out before refresh could complete') // Abort refresh\n        }\n        const currentToken = currentState.authState.token\n\n        const response = await firstValueFrom(\n          createTokenRefreshStream(currentToken, clientFactory, apiHost),\n        )\n\n        state.set('setRefreshStampedToken', (prev) => ({\n          authState:\n            prev.authState.type === AuthStateType.LOGGED_IN\n              ? {...prev.authState, token: response.token}\n              : prev.authState,\n        }))\n        storageArea?.setItem(storageKey, JSON.stringify({token: response.token}))\n      }\n\n      if (storeState.dashboardContext) {\n        return new Observable<{token: string}>((subscriber) => {\n          const visibilityHandler = () => {\n            const currentState = state.get()\n            if (\n              document.visibilityState === 'visible' &&\n              currentState.authState.type === AuthStateType.LOGGED_IN &&\n              shouldRefreshToken(currentState.authState.lastTokenRefresh)\n            ) {\n              createTokenRefreshStream(\n                currentState.authState.token,\n                clientFactory,\n                apiHost,\n              ).subscribe({\n                next: (response) => {\n                  state.set('setRefreshStampedToken', (prev) => ({\n                    authState:\n                      prev.authState.type === AuthStateType.LOGGED_IN\n                        ? {\n                            ...prev.authState,\n                            token: response.token,\n                            lastTokenRefresh: Date.now(),\n                          }\n                        : prev.authState,\n                  }))\n                  subscriber.next(response)\n                },\n                error: (error) => subscriber.error(error),\n              })\n            }\n          }\n\n          const timerSubscription = timer(REFRESH_INTERVAL, REFRESH_INTERVAL)\n            .pipe(\n              filter(() => document.visibilityState === 'visible'),\n              switchMap(() => {\n                const currentState = state.get().authState\n                if (currentState.type !== AuthStateType.LOGGED_IN) {\n                  throw new Error('User logged out before refresh could complete')\n                }\n                return createTokenRefreshStream(currentState.token, clientFactory, apiHost)\n              }),\n            )\n            .subscribe({\n              next: (response) => {\n                state.set('setRefreshStampedToken', (prev) => ({\n                  authState:\n                    prev.authState.type === AuthStateType.LOGGED_IN\n                      ? {\n                          ...prev.authState,\n                          token: response.token,\n                          lastTokenRefresh: Date.now(),\n                        }\n                      : prev.authState,\n                }))\n                subscriber.next(response)\n              },\n              error: (error) => subscriber.error(error),\n            })\n\n          document.addEventListener('visibilitychange', visibilityHandler)\n\n          return () => {\n            document.removeEventListener('visibilitychange', visibilityHandler)\n            timerSubscription.unsubscribe()\n          }\n        }).pipe(\n          takeWhile(() => state.get().authState.type === AuthStateType.LOGGED_IN),\n          map((response: {token: string}) => ({token: response.token})),\n        )\n      }\n\n      // If not in dashboard context, use lock-based refresh\n      return from(acquireTokenRefreshLock(performRefresh, storageArea, storageKey)).pipe(\n        filter((hasLock) => hasLock),\n        map(() => {\n          const currentState = state.get().authState\n          if (currentState.type !== AuthStateType.LOGGED_IN) {\n            throw new Error('User logged out before refresh could complete')\n          }\n          return {token: currentState.token} as const\n        }),\n      )\n    }),\n  )\n\n  return refreshToken$.subscribe({\n    next: (response: {token: string}) => {\n      state.set('setRefreshStampedToken', (prev) => ({\n        authState:\n          prev.authState.type === AuthStateType.LOGGED_IN\n            ? {\n                ...prev.authState,\n                token: response.token,\n                lastTokenRefresh: Date.now(),\n              }\n            : prev.authState,\n      }))\n      storageArea?.setItem(storageKey, JSON.stringify({token: response.token}))\n    },\n    error: (error) => {\n      state.set('setRefreshStampedTokenError', {authState: {type: AuthStateType.ERROR, error}})\n    },\n  })\n}\n","import {EMPTY, fromEvent, Observable} from 'rxjs'\n\nimport {AUTH_CODE_PARAM, DEFAULT_BASE} from './authConstants'\n\nexport function getAuthCode(callbackUrl: string | undefined, locationHref: string): string | null {\n  const loc = new URL(locationHref, DEFAULT_BASE)\n  const callbackLocation = callbackUrl ? new URL(callbackUrl, DEFAULT_BASE) : undefined\n  const callbackLocationMatches = callbackLocation\n    ? loc.pathname.toLowerCase().startsWith(callbackLocation.pathname.toLowerCase())\n    : true\n\n  // First, try getting the auth code (sid) from hash or search params directly\n  let authCode =\n    new URLSearchParams(loc.hash.slice(1)).get(AUTH_CODE_PARAM) ||\n    new URLSearchParams(loc.search).get(AUTH_CODE_PARAM)\n\n  // If not found directly, try extracting it from the _context parameter as a fallback\n  if (!authCode) {\n    const contextParam = new URLSearchParams(loc.search).get('_context')\n    if (contextParam) {\n      try {\n        const parsedContext = JSON.parse(contextParam)\n        if (\n          parsedContext &&\n          typeof parsedContext === 'object' &&\n          typeof parsedContext.sid === 'string' &&\n          parsedContext.sid // Ensure it's not an empty string\n        ) {\n          authCode = parsedContext.sid\n        }\n      } catch {\n        // Silently ignore _context JSON parsing errors; authCode remains null/empty\n      }\n    }\n  }\n\n  return authCode && callbackLocationMatches ? authCode : null\n}\n\nexport function getTokenFromLocation(locationHref: string): string | null {\n  const loc = new URL(locationHref)\n  const token = new URLSearchParams(loc.hash.slice(1)).get('token')\n  return token ? token : null\n}\n\n/**\n * Attempts to retrieve a token from the configured storage.\n * If invalid or not present, returns null.\n */\nexport function getTokenFromStorage(\n  storageArea: Storage | undefined,\n  storageKey: string,\n): string | null {\n  if (!storageArea) return null\n  const item = storageArea.getItem(storageKey)\n  if (item === null) return null\n\n  try {\n    const parsed: unknown = JSON.parse(item)\n    if (\n      typeof parsed !== 'object' ||\n      parsed === null ||\n      !('token' in parsed) ||\n      typeof parsed.token !== 'string'\n    ) {\n      throw new Error('Invalid stored auth data structure')\n    }\n    return parsed.token\n  } catch {\n    storageArea.removeItem(storageKey)\n    return null\n  }\n}\n\n/**\n * Creates an observable stream of storage events. If not in a browser environment,\n * returns an EMPTY observable.\n */\nexport function getStorageEvents(): Observable<StorageEvent> {\n  const isBrowser = typeof window !== 'undefined' && typeof window.addEventListener === 'function'\n\n  if (!isBrowser) {\n    return EMPTY\n  }\n\n  return fromEvent<StorageEvent>(window, 'storage')\n}\n\n/**\n * Returns a default storage instance (localStorage) if available.\n * If not available or an error occurs, returns undefined.\n */\nexport function getDefaultStorage(): Storage | undefined {\n  try {\n    if (typeof localStorage !== 'undefined' && typeof localStorage.getItem === 'function') {\n      return localStorage\n    }\n    return undefined\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Returns the default location to use.\n * Tries accessing `location.href`, falls back to a default base if not available or on error.\n */\nexport function getDefaultLocation(): string {\n  try {\n    if (typeof location === 'undefined') return DEFAULT_BASE\n    if (typeof location.href === 'string') return location.href\n    return DEFAULT_BASE\n  } catch {\n    return DEFAULT_BASE\n  }\n}\n\n/**\n * Cleans up the URL by removing the hash and the sid and url parameters.\n * @internal\n */\nexport function getCleanedUrl(locationUrl: string): string {\n  const loc = new URL(locationUrl)\n  loc.hash = ''\n  loc.searchParams.delete('sid')\n  loc.searchParams.delete('url')\n  return loc.toString()\n}\n","import {type ClientConfig, type SanityClient} from '@sanity/client'\n\nimport {getTokenFromStorage} from './utils'\n\n/**\n * Attempts to check for cookie auth by making a withCredentials request to the users endpoint.\n * @param projectId - The project ID to check for cookie auth.\n * @param clientFactory - A factory function that creates a Sanity client.\n * @returns True if the user is authenticated, false otherwise.\n * @internal\n */\nexport async function checkForCookieAuth(\n  projectId: string | undefined,\n  clientFactory: (config: ClientConfig) => SanityClient,\n): Promise<boolean> {\n  if (!projectId) return false\n  try {\n    const client = clientFactory({\n      projectId,\n      useCdn: false,\n    })\n    const user = await client.request({\n      uri: '/users/me',\n      withCredentials: true,\n      tag: 'users.get-current',\n    })\n    return typeof user?.id === 'string'\n  } catch {\n    return false\n  }\n}\n\n/**\n * Attempts to retrieve a studio token from local storage.\n * @param storageArea - The storage area to retrieve the token from.\n * @param projectId - The project ID to retrieve the token for.\n * @returns The studio token or null if it does not exist.\n * @internal\n */\nexport function getStudioTokenFromLocalStorage(\n  storageArea: Storage | undefined,\n  projectId: string | undefined,\n): string | null {\n  if (!storageArea || !projectId) return null\n  const studioStorageKey = `__studio_auth_token_${projectId}`\n  const token = getTokenFromStorage(storageArea, studioStorageKey)\n  if (token) {\n    return token\n  }\n  return null\n}\n","import {type CurrentUser} from '@sanity/types'\nimport {distinctUntilChanged, filter, map, type Subscription, switchMap} from 'rxjs'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {DEFAULT_API_VERSION, REQUEST_TAG_PREFIX} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {type AuthState, type AuthStoreState} from './authStore'\n\nexport const subscribeToStateAndFetchCurrentUser = ({\n  state,\n}: StoreContext<AuthStoreState>): Subscription => {\n  const {clientFactory, apiHost} = state.get().options\n\n  const currentUser$ = state.observable\n    .pipe(\n      map(({authState}) => authState),\n      filter(\n        (authState): authState is Extract<AuthState, {type: AuthStateType.LOGGED_IN}> =>\n          authState.type === AuthStateType.LOGGED_IN && !authState.currentUser,\n      ),\n      map((authState) => authState.token),\n      distinctUntilChanged(),\n    )\n    .pipe(\n      map((token) =>\n        clientFactory({\n          apiVersion: DEFAULT_API_VERSION,\n          requestTagPrefix: REQUEST_TAG_PREFIX,\n          token,\n          ignoreBrowserTokenWarning: true,\n          useProjectHostname: false,\n          useCdn: false,\n          ...(apiHost && {apiHost}),\n        }),\n      ),\n      switchMap((client) =>\n        client.observable.request<CurrentUser>({uri: '/users/me', method: 'GET'}),\n      ),\n    )\n\n  return currentUser$.subscribe({\n    next: (currentUser) => {\n      state.set('setCurrentUser', (prev) => ({\n        authState:\n          prev.authState.type === AuthStateType.LOGGED_IN\n            ? {...prev.authState, currentUser}\n            : prev.authState,\n      }))\n    },\n    error: (error) => {\n      state.set('setError', {authState: {type: AuthStateType.ERROR, error}})\n    },\n  })\n}\n","import {defer, distinctUntilChanged, filter, map, type Subscription} from 'rxjs'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {AuthStateType} from './authStateType'\nimport {type AuthStoreState} from './authStore'\nimport {getStorageEvents, getTokenFromStorage} from './utils'\n\nexport const subscribeToStorageEventsAndSetToken = ({\n  state,\n}: StoreContext<AuthStoreState>): Subscription => {\n  const {storageArea, storageKey} = state.get().options\n\n  const tokenFromStorage$ = defer(getStorageEvents).pipe(\n    filter(\n      (e): e is StorageEvent & {newValue: string} =>\n        e.storageArea === storageArea && e.key === storageKey,\n    ),\n    map(() => getTokenFromStorage(storageArea, storageKey)),\n    distinctUntilChanged(),\n  )\n\n  return tokenFromStorage$.subscribe((token) => {\n    state.set('updateTokenFromStorageEvent', {\n      authState: token\n        ? {type: AuthStateType.LOGGED_IN, token, currentUser: null}\n        : {type: AuthStateType.LOGGED_OUT, isDestroyingSession: false},\n    })\n  })\n}\n","import {type ClientConfig, createClient, type SanityClient} from '@sanity/client'\nimport {type CurrentUser} from '@sanity/types'\nimport {type Subscription} from 'rxjs'\n\nimport {type AuthConfig, type AuthProvider} from '../config/authConfig'\nimport {bindActionGlobally} from '../store/createActionBinder'\nimport {createStateSourceAction} from '../store/createStateSourceAction'\nimport {defineStore} from '../store/defineStore'\nimport {AuthStateType} from './authStateType'\nimport {refreshStampedToken} from './refreshStampedToken'\nimport {checkForCookieAuth, getStudioTokenFromLocalStorage} from './studioModeAuth'\nimport {subscribeToStateAndFetchCurrentUser} from './subscribeToStateAndFetchCurrentUser'\nimport {subscribeToStorageEventsAndSetToken} from './subscribeToStorageEventsAndSetToken'\nimport {\n  getAuthCode,\n  getCleanedUrl,\n  getDefaultLocation,\n  getDefaultStorage,\n  getTokenFromLocation,\n  getTokenFromStorage,\n} from './utils'\n\n/**\n * Represents the various states the authentication can be in.\n *\n * @public\n */\nexport type AuthState = LoggedInAuthState | LoggedOutAuthState | LoggingInAuthState | ErrorAuthState\n\n/**\n * Logged-in state from the auth state.\n * @public\n */\nexport type LoggedInAuthState = {\n  type: AuthStateType.LOGGED_IN\n  token: string\n  currentUser: CurrentUser | null\n  lastTokenRefresh?: number\n}\n\n/**\n * Logged-out state from the auth state.\n * @public\n */\nexport type LoggedOutAuthState = {type: AuthStateType.LOGGED_OUT; isDestroyingSession: boolean}\n\n/**\n * Logging-in state from the auth state.\n * @public\n */\nexport type LoggingInAuthState = {type: AuthStateType.LOGGING_IN; isExchangingToken: boolean}\n\n/**\n * Error state from the auth state.\n * @public\n */\nexport type ErrorAuthState = {type: AuthStateType.ERROR; error: unknown}\n\n/**\n * Represents the various states the authentication can be in.\n *\n * @public\n */\nexport interface DashboardContext {\n  mode?: string\n  env?: string\n  orgId?: string\n}\n\ntype AuthMethodOptions = 'localstorage' | 'cookie' | undefined\n\nlet tokenRefresherRunning = false\n\n/**\n * @public\n */\nexport interface AuthStoreState {\n  authState: AuthState\n  providers?: AuthProvider[]\n  options: {\n    initialLocationHref: string\n    clientFactory: (config: ClientConfig) => SanityClient\n    customProviders: AuthConfig['providers']\n    storageKey: string\n    storageArea: Storage | undefined\n    apiHost: string | undefined\n    loginUrl: string\n    callbackUrl: string | undefined\n    providedToken: string | undefined\n    authMethod: AuthMethodOptions\n  }\n  dashboardContext?: DashboardContext\n}\n\nexport const authStore = defineStore<AuthStoreState>({\n  name: 'Auth',\n  getInitialState(instance) {\n    const {\n      apiHost,\n      callbackUrl,\n      providers: customProviders,\n      token: providedToken,\n      clientFactory = createClient,\n      initialLocationHref = getDefaultLocation(),\n    } = instance.config.auth ?? {}\n    let storageArea = instance.config.auth?.storageArea\n\n    const storageKey = `__sanity_auth_token`\n\n    // This login URL will only be used for local development\n    let loginDomain = 'https://www.sanity.io'\n    try {\n      if (apiHost && new URL(apiHost).hostname.endsWith('.sanity.work')) {\n        loginDomain = 'https://www.sanity.work'\n      }\n    } catch {\n      /* empty */\n    }\n    const loginUrl = new URL('/login', loginDomain)\n    loginUrl.searchParams.set('origin', getCleanedUrl(initialLocationHref))\n    loginUrl.searchParams.set('type', 'stampedToken') // Token must be stamped to have an sid passed back\n    loginUrl.searchParams.set('withSid', 'true')\n\n    // Check if running in dashboard context by parsing initialLocationHref\n    let dashboardContext: DashboardContext = {}\n    let isInDashboard = false\n    try {\n      const parsedUrl = new URL(initialLocationHref)\n      const contextParam = parsedUrl.searchParams.get('_context')\n      if (contextParam) {\n        const parsedContext = JSON.parse(contextParam)\n\n        // Consider it in dashboard if context is present and an object\n        if (\n          parsedContext &&\n          typeof parsedContext === 'object' &&\n          Object.keys(parsedContext).length > 0\n        ) {\n          // Explicitly remove the 'sid' property from the parsed object *before* assigning\n          delete parsedContext.sid\n\n          // Now assign the potentially modified object to dashboardContext\n          dashboardContext = parsedContext\n          isInDashboard = true\n        }\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse dashboard context from initial location:', err)\n    }\n\n    if (!isInDashboard) {\n      // If not in dashboard, use the storage area from the config\n      storageArea = storageArea ?? getDefaultStorage()\n    }\n\n    let token: string | null\n    let authMethod: AuthMethodOptions\n    if (instance.config.studioMode?.enabled) {\n      token = getStudioTokenFromLocalStorage(storageArea, instance.config.projectId)\n      if (token) {\n        authMethod = 'localstorage'\n      } else {\n        checkForCookieAuth(instance.config.projectId, clientFactory).then((isCookieAuthEnabled) => {\n          if (isCookieAuthEnabled) {\n            authMethod = 'cookie'\n          }\n        })\n      }\n    } else {\n      token = getTokenFromStorage(storageArea, storageKey)\n      if (token) {\n        authMethod = 'localstorage'\n      }\n    }\n\n    let authState: AuthState\n    if (providedToken) {\n      authState = {type: AuthStateType.LOGGED_IN, token: providedToken, currentUser: null}\n    } else if (\n      getAuthCode(callbackUrl, initialLocationHref) ||\n      getTokenFromLocation(initialLocationHref)\n    ) {\n      authState = {type: AuthStateType.LOGGING_IN, isExchangingToken: false}\n      // Note: dashboardContext from the callback URL can be set later in handleAuthCallback too\n    } else if (token && !isInDashboard) {\n      // Only use token from storage if NOT running in dashboard\n      authState = {type: AuthStateType.LOGGED_IN, token, currentUser: null}\n    } else {\n      // Default to logged out if no provided token, not handling callback,\n      // or if token exists but we ARE in dashboard mode.\n      authState = {type: AuthStateType.LOGGED_OUT, isDestroyingSession: false}\n    }\n\n    return {\n      authState,\n      dashboardContext,\n      options: {\n        apiHost,\n        loginUrl: loginUrl.toString(),\n        callbackUrl,\n        customProviders,\n        providedToken,\n        clientFactory,\n        initialLocationHref,\n        storageKey,\n        storageArea,\n        authMethod,\n      },\n    }\n  },\n  initialize(context) {\n    const subscriptions: Subscription[] = []\n    subscriptions.push(subscribeToStateAndFetchCurrentUser(context))\n\n    if (context.state.get().options?.storageArea) {\n      subscriptions.push(subscribeToStorageEventsAndSetToken(context))\n    }\n\n    if (!tokenRefresherRunning) {\n      tokenRefresherRunning = true\n      subscriptions.push(refreshStampedToken(context))\n    }\n\n    return () => {\n      for (const subscription of subscriptions) {\n        subscription.unsubscribe()\n      }\n    }\n  },\n})\n\n/**\n * @public\n */\nexport const getCurrentUserState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {authState}}) =>\n    authState.type === AuthStateType.LOGGED_IN ? authState.currentUser : null,\n  ),\n)\n\n/**\n * @public\n */\nexport const getTokenState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {authState}}) =>\n    authState.type === AuthStateType.LOGGED_IN ? authState.token : null,\n  ),\n)\n\n/**\n * @internal\n */\nexport const getAuthMethodState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {options}}) => options.authMethod),\n)\n\n/**\n * @public\n */\nexport const getLoginUrlState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {options}}) => options.loginUrl),\n)\n\n/**\n * @public\n */\nexport const getAuthState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {authState}}) => authState),\n)\n\n/**\n * @public\n */\nexport const getDashboardOrganizationId = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {dashboardContext}}) => dashboardContext?.orgId),\n)\n\n/**\n * Returns a state source indicating if the SDK is running within a dashboard context.\n * @public\n */\nexport const getIsInDashboardState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(\n    ({state: {dashboardContext}}) =>\n      // Check if dashboardContext exists and is not empty\n      !!dashboardContext && Object.keys(dashboardContext).length > 0,\n  ),\n)\n\n/**\n * Action to explicitly set the authentication token.\n * Used internally by the Comlink token refresh.\n * @internal\n */\nexport const setAuthToken = bindActionGlobally(authStore, ({state}, token: string | null) => {\n  const currentAuthState = state.get().authState\n  if (token) {\n    // Update state only if the new token is different or currently logged out\n    if (currentAuthState.type !== AuthStateType.LOGGED_IN || currentAuthState.token !== token) {\n      // This state update structure should trigger listeners in clientStore\n      state.set('setToken', {\n        authState: {\n          type: AuthStateType.LOGGED_IN,\n          token: token,\n          // Keep existing user or set to null? Setting to null forces refetch.\n          // Keep existing user to avoid unnecessary refetches if user data is still valid.\n          currentUser:\n            currentAuthState.type === AuthStateType.LOGGED_IN ? currentAuthState.currentUser : null,\n        },\n      })\n    }\n  } else {\n    // Handle setting token to null (logging out)\n    if (currentAuthState.type !== AuthStateType.LOGGED_OUT) {\n      state.set('setToken', {\n        authState: {type: AuthStateType.LOGGED_OUT, isDestroyingSession: false},\n      })\n    }\n  }\n})\n","/**\n * Error message returned by the organization verification\n * @public\n */\nexport interface OrgVerificationResult {\n  error: string | null\n}\n\n/**\n * Compares a project's actual organization ID with the expected organization ID.\n * @public\n */\nexport function compareProjectOrganization(\n  projectId: string,\n  projectOrganizationId: string | null | undefined,\n  currentDashboardOrgId: string,\n): OrgVerificationResult {\n  if (projectOrganizationId !== currentDashboardOrgId) {\n    return {\n      error:\n        `Project ${projectId} belongs to Organization ${projectOrganizationId ?? 'unknown'}, ` +\n        `but the Dashboard has Organization ${currentDashboardOrgId} selected`,\n    }\n  }\n  return {error: null}\n}\n","import {type ClientConfig, createClient, type SanityClient} from '@sanity/client'\nimport {pick} from 'lodash-es'\n\nimport {getAuthMethodState, getTokenState} from '../auth/authStore'\nimport {bindActionGlobally} from '../store/createActionBinder'\nimport {createStateSourceAction} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\n\nconst DEFAULT_API_VERSION = '2024-11-12'\nconst DEFAULT_REQUEST_TAG_PREFIX = 'sanity.sdk'\n\ntype AllowedClientConfigKey =\n  | 'useCdn'\n  | 'token'\n  | 'perspective'\n  | 'apiHost'\n  | 'proxy'\n  | 'withCredentials'\n  | 'timeout'\n  | 'maxRetries'\n  | 'dataset'\n  | 'projectId'\n  | 'requestTagPrefix'\n  | 'useProjectHostname'\n\nconst allowedKeys = Object.keys({\n  'apiHost': null,\n  'useCdn': null,\n  'token': null,\n  'perspective': null,\n  'proxy': null,\n  'withCredentials': null,\n  'timeout': null,\n  'maxRetries': null,\n  'dataset': null,\n  'projectId': null,\n  'scope': null,\n  'apiVersion': null,\n  'requestTagPrefix': null,\n  'useProjectHostname': null,\n  '~experimental_resource': null,\n} satisfies Record<keyof ClientOptions, null>) as (keyof ClientOptions)[]\n\nconst DEFAULT_CLIENT_CONFIG: ClientConfig = {\n  apiVersion: DEFAULT_API_VERSION,\n  useCdn: false,\n  ignoreBrowserTokenWarning: true,\n  allowReconfigure: false,\n  requestTagPrefix: DEFAULT_REQUEST_TAG_PREFIX,\n}\n\n/**\n * States tracked by the client store\n * @public\n */\nexport interface ClientStoreState {\n  token: string | null\n  clients: {[TKey in string]?: SanityClient}\n  authMethod?: 'localstorage' | 'cookie'\n}\n\n/**\n * Options used when retrieving a client instance from the client store.\n *\n * This interface extends the base {@link ClientConfig} and adds:\n *\n * - **apiVersion:** A required string indicating the API version for the client.\n * - **scope:** An optional flag to choose between the project-specific client\n *   ('project') and the global client ('global'). When set to `'global'`, the\n *   global client is used.\n *\n * These options are utilized by `getClient` and `getClientState` to configure and\n * return appropriate client instances that automatically handle authentication\n * updates and configuration changes.\n *\n * @public\n */\nexport interface ClientOptions extends Pick<ClientConfig, AllowedClientConfigKey> {\n  /**\n   * An optional flag to choose between the default client (typically project-level)\n   * and the global client ('global'). When set to `'global'`, the global client\n   * is used.\n   */\n  'scope'?: 'default' | 'global'\n  /**\n   * A required string indicating the API version for the client.\n   */\n  'apiVersion': string\n  /**\n   * @internal\n   */\n  '~experimental_resource'?: ClientConfig['~experimental_resource']\n}\n\nconst clientStore = defineStore<ClientStoreState>({\n  name: 'clientStore',\n\n  getInitialState: (instance) => ({\n    clients: {},\n    token: getTokenState(instance).getCurrent(),\n  }),\n\n  initialize(context) {\n    const subscription = listenToToken(context)\n    const authMethodSubscription = listenToAuthMethod(context)\n    return () => {\n      subscription.unsubscribe()\n      authMethodSubscription.unsubscribe()\n    }\n  },\n})\n\n/**\n * Updates the client store state when a token is received.\n * @internal\n */\nconst listenToToken = ({instance, state}: StoreContext<ClientStoreState>) => {\n  return getTokenState(instance).observable.subscribe((token) => {\n    state.set('setTokenAndResetClients', {token, clients: {}})\n  })\n}\n\nconst listenToAuthMethod = ({instance, state}: StoreContext<ClientStoreState>) => {\n  return getAuthMethodState(instance).observable.subscribe((authMethod) => {\n    state.set('setAuthMethod', {authMethod})\n  })\n}\n\nconst getClientConfigKey = (options: ClientOptions) => JSON.stringify(pick(options, ...allowedKeys))\n\n/**\n * Retrieves a Sanity client instance configured with the provided options.\n *\n * This function returns a client instance configured for the project or as a\n * global client based on the options provided. It ensures efficient reuse of\n * client instances by returning the same instance for the same options.\n * For automatic handling of authentication token updates, consider using\n * `getClientState`.\n *\n * @public\n */\nexport const getClient = bindActionGlobally(\n  clientStore,\n  ({state, instance}, options: ClientOptions) => {\n    // Check for disallowed keys\n    const providedKeys = Object.keys(options) as (keyof ClientOptions)[]\n    const disallowedKeys = providedKeys.filter((key) => !allowedKeys.includes(key))\n\n    if (disallowedKeys.length > 0) {\n      const listFormatter = new Intl.ListFormat('en', {style: 'long', type: 'conjunction'})\n      throw new Error(\n        `The client options provided contains unsupported properties: ${listFormatter.format(disallowedKeys)}. ` +\n          `Allowed keys are: ${listFormatter.format(allowedKeys)}.`,\n      )\n    }\n\n    const tokenFromState = state.get().token\n    const {clients, authMethod} = state.get()\n    const projectId = options.projectId ?? instance.config.projectId\n    const dataset = options.dataset ?? instance.config.dataset\n    const apiHost = options.apiHost ?? instance.config.auth?.apiHost\n\n    const effectiveOptions: ClientOptions = {\n      ...DEFAULT_CLIENT_CONFIG,\n      ...((options.scope === 'global' || !projectId) && {useProjectHostname: false}),\n      token: authMethod === 'cookie' ? undefined : (tokenFromState ?? undefined),\n      ...options,\n      ...(projectId && {projectId}),\n      ...(dataset && {dataset}),\n      ...(apiHost && {apiHost}),\n    }\n\n    if (effectiveOptions.token === null || typeof effectiveOptions.token === 'undefined') {\n      delete effectiveOptions.token\n      if (authMethod === 'cookie') {\n        effectiveOptions.withCredentials = true\n      }\n    } else {\n      delete effectiveOptions.withCredentials\n    }\n\n    const key = getClientConfigKey(effectiveOptions)\n\n    if (clients[key]) return clients[key]\n\n    const client = createClient(effectiveOptions)\n    state.set('addClient', (prev) => ({clients: {...prev.clients, [key]: client}}))\n\n    return client\n  },\n)\n\n/**\n * Returns a state source for the Sanity client instance.\n *\n * This function provides a subscribable state source that emits updated client\n * instances whenever relevant configurations change (such as authentication tokens).\n * Use this when you need to react to client configuration changes in your application.\n *\n * @public\n */\nexport const getClientState = bindActionGlobally(\n  clientStore,\n  createStateSourceAction(({instance}, options: ClientOptions) => getClient(instance, options)),\n)\n","import {omit} from 'lodash-es'\nimport {asapScheduler, EMPTY, firstValueFrom, from, Observable} from 'rxjs'\nimport {\n  catchError,\n  delay,\n  filter,\n  first,\n  groupBy,\n  map,\n  mergeMap,\n  pairwise,\n  startWith,\n  switchMap,\n  tap,\n} from 'rxjs/operators'\n\nimport {bindActionGlobally, type BoundStoreAction} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {insecureRandomId} from '../utils/ids'\n\ninterface CreateFetcherStoreOptions<TParams extends unknown[], TData> {\n  /**\n   * A unique name for this store (for devtools)\n   */\n  name: string\n  /**\n   * A function that creates the observable that will be used to fetch the data.\n   */\n  fetcher: (instance: SanityInstance) => (...params: TParams) => Observable<TData>\n  /**\n   * The function used to convert the params into keys that state related to\n   * those params will be stored.\n   */\n  getKey: (instance: SanityInstance, ...params: TParams) => string\n  /**\n   * Delay in ms before clearing state after the last subscription is removed.\n   * This results in react components suspending again due to no previous state\n   * to show.\n   */\n  stateExpirationDelay?: number\n  /**\n   * The minimum time (ms) that must elapse since the last fetch for the same key\n   */\n  fetchThrottleInternal?: number\n}\n\ninterface StoreEntry<TParams extends unknown[], TData> {\n  params: TParams\n  instance: SanityInstance\n  key: string\n  data?: TData\n  error?: unknown\n  subscriptions: string[]\n  lastFetchInitiatedAt?: string\n}\n\n/**\n * Internal helper type\n * @public\n */\nexport interface FetcherStoreState<TParams extends unknown[], TData> {\n  stateByParams: {[TSerializedKey in string]?: StoreEntry<TParams, TData>}\n  error?: unknown\n}\n\n/**\n * Internal helper type\n * @public\n */\nexport interface FetcherStore<TParams extends unknown[], TData> {\n  getState: BoundStoreAction<\n    FetcherStoreState<TParams, TData>,\n    TParams,\n    StateSource<TData | undefined>\n  >\n  resolveState: BoundStoreAction<FetcherStoreState<TParams, TData>, TParams, Promise<TData>>\n}\n\n/**\n * Creates a store from a function that returns an observable that fetches data\n * that supports parameterized state caching.\n *\n * This function creates a resource store keyed by parameter values (using the\n * provided `getKey` function) and returns a state source (via `getState`)\n * that components can subscribe to. When a new subscription is added, and if\n * enough time has passed since the last fetch (controlled by\n * `fetchThrottleInternal`), it invokes the observable factory (via\n * `getObservable`) to fetch fresh data. The data is stored in state and can be\n * accessed reactively.\n *\n * Additionally, the store provides a `resolveState` function that returns a\n * Promise resolving with the next non-undefined value from the state source.\n *\n * State expiration is implemented: after the last subscription for a key is\n * removed, its state is cleared after `stateExpirationDelay` ms, causing\n * components to suspend until fresh data is fetched.\n */\nexport function createFetcherStore<TParams extends unknown[], TData>({\n  name,\n  fetcher: getObservable,\n  getKey,\n  fetchThrottleInternal = 1000,\n  stateExpirationDelay = 5000,\n}: CreateFetcherStoreOptions<TParams, TData>): FetcherStore<TParams, TData> {\n  const store = defineStore<FetcherStoreState<TParams, TData>>({\n    name,\n    getInitialState: () => ({\n      stateByParams: {},\n    }),\n    initialize: (context) => {\n      const subscription = subscribeToSubscriptionsAndFetch(context)\n      return () => subscription.unsubscribe()\n    },\n  })\n\n  /**\n   * For each key in state.stateByParams we set up a grouped stream.\n   * When a subscription is added (i.e. the subscriptions array length increases)\n   * and if enough time has elapsed since the last fetch, we update the timestamp\n   * and call the factory function for that key.\n   */\n  const subscribeToSubscriptionsAndFetch = ({\n    state,\n  }: StoreContext<FetcherStoreState<TParams, TData>>) => {\n    return state.observable\n      .pipe(\n        // Map the state to an array of [serialized, entry] pairs.\n        switchMap((s: FetcherStoreState<TParams, TData>) => {\n          const entries = Object.entries(s.stateByParams)\n          return entries.length > 0 ? from(entries) : EMPTY\n        }),\n        // Group by the serialized key.\n        groupBy(([key]) => key),\n        mergeMap((group$) =>\n          group$.pipe(\n            // Emit an initial value for pairwise comparisons.\n            startWith<[string, StoreEntry<TParams, TData> | undefined]>([group$.key, undefined]),\n            pairwise(),\n            // Trigger only when the subscriptions array grows.\n            filter(([[, prevEntry], [, currEntry]]) => {\n              const prevSubs = prevEntry?.subscriptions ?? []\n              const currSubs = currEntry?.subscriptions ?? []\n              return currSubs.length > prevSubs.length\n            }),\n            map(([, [, currEntry]]) => currEntry),\n\n            // Only trigger if we haven't fetched recently.\n            filter((entry) => {\n              const lastFetch = entry?.lastFetchInitiatedAt\n              if (!lastFetch) return true\n              return Date.now() - new Date(lastFetch).getTime() >= fetchThrottleInternal\n            }),\n            switchMap((entry) => {\n              // Retrieve params from the entry\n              if (!entry) return EMPTY\n\n              // Record that a fetch is being initiated.\n              state.set('setLastFetchInitiatedAt', (prev: FetcherStoreState<TParams, TData>) => ({\n                stateByParams: {\n                  ...prev.stateByParams,\n                  [entry.key]: {\n                    ...entry,\n                    ...prev.stateByParams[entry.key],\n                    lastFetchInitiatedAt: new Date().toISOString(),\n                  },\n                },\n              }))\n\n              const factoryFn = getObservable(entry.instance)\n              return factoryFn(...entry.params).pipe(\n                // the `createStateSourceAction` util requires the update\n                // to\n                delay(0, asapScheduler),\n                tap((data: TData) =>\n                  state.set('setData', (prev: FetcherStoreState<TParams, TData>) => ({\n                    stateByParams: {\n                      ...prev.stateByParams,\n                      [entry.key]: {\n                        ...omit(entry, 'error'),\n                        ...omit(prev.stateByParams[entry.key], 'error'),\n                        data,\n                      },\n                    },\n                  })),\n                ),\n                catchError((error) => {\n                  state.set('setError', (prev) => ({\n                    stateByParams: {\n                      ...prev.stateByParams,\n                      [entry.key]: {\n                        ...entry,\n                        ...prev.stateByParams[entry.key],\n                        error,\n                      },\n                    },\n                  }))\n\n                  return EMPTY\n                }),\n              )\n            }),\n          ),\n        ),\n      )\n      .subscribe({\n        error: (error) => state.set('setError', {error}),\n      })\n  }\n\n  const getState = bindActionGlobally(\n    store,\n    createStateSourceAction({\n      selector: (\n        {\n          instance,\n          state: {stateByParams, error},\n        }: SelectorContext<FetcherStoreState<TParams, TData>>,\n        ...params: TParams\n      ) => {\n        if (error) throw error\n        const key = getKey(instance, ...params)\n        const entry = stateByParams[key]\n        if (entry?.error) throw entry.error\n        return entry?.data\n      },\n      onSubscribe: ({instance, state}, ...params: TParams) => {\n        const subscriptionId = insecureRandomId()\n        const key = getKey(instance, ...params)\n\n        state.set('addSubscription', (prev: FetcherStoreState<TParams, TData>) => ({\n          stateByParams: {\n            ...prev.stateByParams,\n            [key]: {\n              ...prev.stateByParams[key],\n              instance,\n              key,\n              params: prev.stateByParams[key]?.params || params,\n              subscriptions: [...(prev.stateByParams[key]?.subscriptions || []), subscriptionId],\n            },\n          },\n        }))\n\n        return () => {\n          setTimeout(() => {\n            state.set('removeSubscription', (prev: FetcherStoreState<TParams, TData>) => {\n              const entry = prev.stateByParams[key]\n              if (!entry) return prev\n\n              const newSubs = (entry.subscriptions || []).filter((id) => id !== subscriptionId)\n              if (newSubs.length === 0) {\n                return {stateByParams: omit(prev.stateByParams, key)}\n              }\n\n              return {\n                stateByParams: {\n                  ...prev.stateByParams,\n                  [key]: {\n                    ...entry,\n                    subscriptions: newSubs,\n                  },\n                },\n              }\n            })\n          }, stateExpirationDelay)\n        }\n      },\n    }),\n  )\n\n  const resolveState = bindActionGlobally(store, ({instance}, ...params: TParams) =>\n    firstValueFrom(getState(instance, ...params).observable.pipe(first((i) => i !== undefined))),\n  )\n\n  return {getState, resolveState}\n}\n","import {switchMap} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type ProjectHandle} from '../config/sanityConfig'\nimport {createFetcherStore} from '../utils/createFetcherStore'\n\nconst API_VERSION = 'v2025-02-19'\n\nconst project = createFetcherStore({\n  name: 'Project',\n  getKey: (instance, options?: ProjectHandle) => {\n    const projectId = options?.projectId ?? instance.config.projectId\n    if (!projectId) {\n      throw new Error('A projectId is required to use the project API.')\n    }\n    return projectId\n  },\n  fetcher:\n    (instance) =>\n    (options: ProjectHandle = {}) => {\n      const projectId = options.projectId ?? instance.config.projectId\n\n      return getClientState(instance, {\n        apiVersion: API_VERSION,\n        scope: 'global',\n        projectId,\n      }).observable.pipe(\n        switchMap((client) =>\n          client.observable.projects.getById(\n            // non-null assertion is fine with the above throwing\n            (projectId ?? instance.config.projectId)!,\n          ),\n        ),\n      )\n    },\n})\n\n/** @public */\nexport const getProjectState = project.getState\n/** @public */\nexport const resolveProject = project.resolveState\n","import {bindActionGlobally} from '../store/createActionBinder'\nimport {createStateSourceAction} from '../store/createStateSourceAction'\nimport {authStore} from './authStore'\n\n/**\n * Gets the dashboard organization ID from the auth store\n * @internal\n */\nexport const getDashboardOrganizationId = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {dashboardContext}}) => dashboardContext?.orgId),\n)\n","import {combineLatest, distinctUntilChanged, map, type Observable, of, switchMap} from 'rxjs'\n\nimport {\n  compareProjectOrganization,\n  type OrgVerificationResult,\n} from '../project/organizationVerification'\nimport {getProjectState} from '../project/project'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {getDashboardOrganizationId} from './dashboardUtils'\n\n/**\n * Creates an observable that emits the organization verification state for a given instance.\n * It combines the dashboard organization ID (from auth context) with the\n * project's actual organization ID (fetched via getProjectState) and compares them.\n * @public\n */\nexport function observeOrganizationVerificationState(\n  instance: SanityInstance,\n  projectIds: string[],\n): Observable<OrgVerificationResult> {\n  // Observable for the dashboard org ID (potentially null)\n  const dashboardOrgId$ =\n    getDashboardOrganizationId(instance).observable.pipe(distinctUntilChanged())\n\n  // Create observables for each project's org ID\n  const projectOrgIdObservables = projectIds.map((id) =>\n    getProjectState(instance, {projectId: id}).observable.pipe(\n      map((project) => ({projectId: id, orgId: project?.organizationId ?? null})),\n      // Ensure we only proceed if the orgId is loaded, distinct prevents unnecessary checks\n      distinctUntilChanged((prev, curr) => prev.orgId === curr.orgId),\n    ),\n  )\n\n  // Combine observables to get all project org IDs\n  const allProjectOrgIds$ =\n    projectOrgIdObservables.length > 0 ? combineLatest(projectOrgIdObservables) : of([])\n\n  // Combine the sources\n  return combineLatest([dashboardOrgId$, allProjectOrgIds$]).pipe(\n    switchMap(([dashboardOrgId, projectOrgDataArray]) => {\n      // If no dashboard org ID is set, or no project IDs provided, verification isn't applicable/possible\n      if (!dashboardOrgId || projectOrgDataArray.length === 0) {\n        return of<OrgVerificationResult>({error: null}) // Return success (no error)\n      }\n\n      // Iterate through all projects and check organization IDs\n      for (const projectData of projectOrgDataArray) {\n        // If a project doesn't have an orgId, we can't verify, treat as non-blocking for now\n        // (Matches original logic where null projectOrgId resulted in {error: null})\n        if (!projectData.orgId) {\n          continue\n        }\n\n        // Perform the comparison for the current project\n        const result = compareProjectOrganization(\n          projectData.projectId,\n          projectData.orgId,\n          dashboardOrgId,\n        )\n\n        // If any project fails verification, immediately return the error\n        if (result.error) {\n          return of(result)\n        }\n      }\n\n      // If all projects passed verification (or had no orgId to check)\n      return of<OrgVerificationResult>({error: null})\n    }),\n    // Only emit when the overall error status actually changes\n    distinctUntilChanged((prev, curr) => prev.error === curr.error),\n  )\n}\n","import {bindActionGlobally} from '../store/createActionBinder'\nimport {DEFAULT_API_VERSION, REQUEST_TAG_PREFIX} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {authStore, type AuthStoreState, type DashboardContext} from './authStore'\nimport {getAuthCode, getCleanedUrl, getDefaultLocation, getTokenFromLocation} from './utils'\n\n/**\n * @public\n */\nexport const handleAuthCallback = bindActionGlobally(\n  authStore,\n  async ({state}, locationHref: string = getDefaultLocation()) => {\n    const {providedToken, callbackUrl, clientFactory, apiHost, storageArea, storageKey} =\n      state.get().options\n\n    // If a token is provided, no need to handle callback\n    if (providedToken) return false\n\n    // Don't handle the callback if already in flight.\n    const {authState} = state.get()\n    if (authState.type === AuthStateType.LOGGING_IN && authState.isExchangingToken) return false\n\n    // Prepare the cleaned-up URL early. It will be returned on both success and error if an authCode/token was processed.\n    const cleanedUrl = getCleanedUrl(locationHref)\n\n    // Check if there is a token in the is in the Dashboard iframe url hash\n    const tokenFromUrl = getTokenFromLocation(locationHref)\n    if (tokenFromUrl) {\n      state.set('setTokenFromUrl', {\n        authState: {type: AuthStateType.LOGGED_IN, token: tokenFromUrl, currentUser: null},\n      })\n      return cleanedUrl\n    }\n\n    // If there is no matching `authCode` then we can't handle the callback\n    const authCode = getAuthCode(callbackUrl, locationHref)\n    if (!authCode) return false\n\n    // Get the SanityOS dashboard context from the url\n    const parsedUrl = new URL(locationHref)\n    let dashboardContext: DashboardContext = {}\n    try {\n      const contextParam = parsedUrl.searchParams.get('_context')\n      if (contextParam) {\n        const parsedContext = JSON.parse(contextParam)\n        if (parsedContext && typeof parsedContext === 'object') {\n          delete parsedContext.sid\n          dashboardContext = parsedContext\n        }\n      }\n    } catch (err) {\n      // If JSON parsing fails, use empty context\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse dashboard context:', err)\n    }\n\n    // Otherwise, start the exchange\n    state.set('exchangeSessionForToken', {\n      authState: {type: AuthStateType.LOGGING_IN, isExchangingToken: true},\n      dashboardContext,\n    } as Partial<AuthStoreState>)\n\n    try {\n      const client = clientFactory({\n        apiVersion: DEFAULT_API_VERSION,\n        requestTagPrefix: REQUEST_TAG_PREFIX,\n        useProjectHostname: false,\n        useCdn: false,\n        ...(apiHost && {apiHost}),\n      })\n\n      const {token} = await client.request<{token: string; label: string}>({\n        method: 'GET',\n        uri: '/auth/fetch',\n        query: {sid: authCode},\n        tag: 'fetch-token',\n      })\n\n      storageArea?.setItem(storageKey, JSON.stringify({token}))\n      state.set('setToken', {authState: {type: AuthStateType.LOGGED_IN, token, currentUser: null}})\n\n      return cleanedUrl\n    } catch (error) {\n      state.set('exchangeSessionForTokenError', {authState: {type: AuthStateType.ERROR, error}})\n      return cleanedUrl\n    }\n  },\n)\n","import {bindActionGlobally} from '../store/createActionBinder'\nimport {DEFAULT_API_VERSION, REQUEST_TAG_PREFIX} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {authStore} from './authStore'\n\n/**\n * @public\n */\nexport const logout = bindActionGlobally(authStore, async ({state}) => {\n  const {clientFactory, apiHost, providedToken, storageArea, storageKey} = state.get().options\n\n  // If a token is statically provided, logout does nothing\n  if (providedToken) return\n\n  const {authState} = state.get()\n\n  // If we already have an inflight request, no-op\n  if (authState.type === AuthStateType.LOGGED_OUT && authState.isDestroyingSession) return\n  const token = authState.type === AuthStateType.LOGGED_IN && authState.token\n\n  try {\n    if (token) {\n      state.set('loggingOut', {\n        authState: {type: AuthStateType.LOGGED_OUT, isDestroyingSession: true},\n      })\n\n      const client = clientFactory({\n        token,\n        requestTagPrefix: REQUEST_TAG_PREFIX,\n        apiVersion: DEFAULT_API_VERSION,\n        ...(apiHost && {apiHost}),\n        useProjectHostname: false,\n        useCdn: false,\n      })\n\n      await client.request<void>({uri: '/auth/logout', method: 'POST'})\n    }\n  } finally {\n    state.set('logoutSuccess', {\n      authState: {type: AuthStateType.LOGGED_OUT, isDestroyingSession: false},\n    })\n    storageArea?.removeItem(storageKey)\n    storageArea?.removeItem(`${storageKey}_last_refresh`)\n  }\n})\n","import {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\n\n/**\n * Calls the destroy method on the controller and resets the controller state.\n * @public\n */\nexport const destroyController = ({state}: StoreContext<ComlinkControllerState>): void => {\n  const {controller} = state.get()\n\n  if (controller) {\n    controller.destroy()\n    state.set('destroyController', {\n      controller: null,\n      channels: new Map(),\n    })\n  }\n}\n","import {type ChannelInput, type ChannelInstance} from '@sanity/comlink'\nimport {isEqual} from 'lodash-es'\n\nimport {type StoreContext} from '../../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../../types'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\n\n/**\n * Retrieve or create a channel to be used for communication between\n * an application and the controller.\n * @public\n */\nexport const getOrCreateChannel = (\n  {state}: StoreContext<ComlinkControllerState>,\n  options: ChannelInput,\n): ChannelInstance<FrameMessage, WindowMessage> => {\n  const controller = state.get().controller\n\n  if (!controller) {\n    throw new Error('Controller must be initialized before using or creating channels')\n  }\n\n  const channels = state.get().channels\n  const existing = channels.get(options.name)\n\n  // limit channels to one per name\n  if (existing) {\n    if (!isEqual(existing.options, options)) {\n      throw new Error(`Channel \"${options.name}\" already exists with different options`)\n    }\n\n    state.set('incrementChannelRefCount', {\n      channels: new Map(channels).set(options.name, {\n        ...existing,\n        refCount: existing.refCount + 1,\n      }),\n    })\n    existing.channel.start()\n    return existing.channel\n  }\n\n  const channel = controller.createChannel(options)\n  channel.start()\n  state.set('createChannel', {\n    channels: new Map(channels).set(options.name, {\n      channel,\n      options,\n      refCount: 1,\n    }),\n  })\n\n  return channel\n}\n","import {type Controller, createController} from '@sanity/comlink'\n\nimport {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\nimport {destroyController} from './destroyController'\n\n/**\n * Initializes or fetches a controller to handle communication\n * between an application and iframes.\n * @public\n */\nexport const getOrCreateController = (\n  {state, instance}: StoreContext<ComlinkControllerState>,\n  targetOrigin: string,\n): Controller => {\n  const {controller, controllerOrigin} = state.get()\n  if (controller && controllerOrigin === targetOrigin) {\n    return controller\n  }\n\n  // if the target origin has changed, we'll create a new controller,\n  // but need to clean up first\n  if (controller) {\n    destroyController({state, instance})\n  }\n\n  const newController = createController({targetOrigin})\n  state.set('initializeController', {\n    controllerOrigin: targetOrigin,\n    controller: newController,\n  })\n\n  return newController\n}\n","import {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\n\n/**\n * Signals to the store that the consumer has stopped using the channel\n * @public\n */\nexport const releaseChannel = (\n  {state}: StoreContext<ComlinkControllerState>,\n  name: string,\n): void => {\n  const channels = state.get().channels\n  const channelEntry = channels.get(name)\n\n  if (channelEntry) {\n    const newRefCount = channelEntry.refCount === 0 ? 0 : channelEntry.refCount - 1\n\n    if (newRefCount === 0) {\n      channelEntry.channel.stop()\n      channels.delete(name)\n      state.set('releaseChannel', {channels: new Map(channels)})\n    } else {\n      state.set('releaseChannel', {\n        channels: new Map(channels).set(name, {\n          ...channelEntry,\n          refCount: newRefCount,\n        }),\n      })\n    }\n  }\n}\n","import {type ChannelInput, type ChannelInstance, type Controller} from '@sanity/comlink'\n\nimport {bindActionGlobally} from '../../store/createActionBinder'\nimport {defineStore} from '../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../types'\nimport {destroyController as unboundDestroyController} from './actions/destroyController'\nimport {getOrCreateChannel as unboundGetOrCreateChannel} from './actions/getOrCreateChannel'\nimport {getOrCreateController as unboundGetOrCreateController} from './actions/getOrCreateController'\nimport {releaseChannel as unboundReleaseChannel} from './actions/releaseChannel'\n\n/**\n * Individual channel with its relevant options\n * @public\n */\nexport interface ChannelEntry {\n  channel: ChannelInstance<FrameMessage, WindowMessage>\n  // we store options to ensure that channels remain as unique / consistent as possible\n  options: ChannelInput\n  // we store refCount to ensure channels remain open only as long as they are in use\n  refCount: number\n}\n\n/**\n * Internal state tracking comlink connections\n * @public\n */\nexport interface ComlinkControllerState {\n  controller: Controller | null\n  controllerOrigin: string | null\n  channels: Map<string, ChannelEntry>\n}\n\nexport const comlinkControllerStore = defineStore<ComlinkControllerState>({\n  name: 'connectionStore',\n  getInitialState: () => {\n    const initialState = {\n      controller: null,\n      controllerOrigin: null,\n      channels: new Map(),\n    }\n    return initialState\n  },\n  initialize({instance}) {\n    return () => {\n      // destroying controller also destroys channels\n      destroyController(instance)\n    }\n  },\n})\n\n/**\n * Calls the destroy method on the controller and resets the controller state.\n * @public\n */\nexport const destroyController = bindActionGlobally(\n  comlinkControllerStore,\n  unboundDestroyController,\n)\n\n/**\n * Retrieve or create a channel to be used for communication between\n * an application and the controller.\n * @public\n */\nexport const getOrCreateChannel = bindActionGlobally(\n  comlinkControllerStore,\n  unboundGetOrCreateChannel,\n)\n\n/**\n * Initializes or fetches a controller to handle communication\n * between an application and iframes.\n * @public\n */\nexport const getOrCreateController = bindActionGlobally(\n  comlinkControllerStore,\n  unboundGetOrCreateController,\n)\n\n/**\n * Signals to the store that the consumer has stopped using the channel\n * @public\n */\nexport const releaseChannel = bindActionGlobally(comlinkControllerStore, unboundReleaseChannel)\n","import {createNode, type Node, type NodeInput} from '@sanity/comlink'\nimport {isEqual} from 'lodash-es'\n\nimport {type StoreContext} from '../../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../../types'\nimport {type ComlinkNodeState} from '../comlinkNodeStore'\n\nexport const getOrCreateNode = (\n  {state}: StoreContext<ComlinkNodeState>,\n  options: NodeInput,\n): Node<WindowMessage, FrameMessage> => {\n  const nodes = state.get().nodes\n  const existing = nodes.get(options.name)\n\n  // limit nodes to one per name\n  if (existing) {\n    if (!isEqual(existing.options, options)) {\n      throw new Error(`Node \"${options.name}\" already exists with different options`)\n    }\n\n    existing.node.start()\n    return existing.node\n  }\n\n  const node: Node<WindowMessage, FrameMessage> = createNode(options)\n  node.start()\n\n  // Subscribe to status changes\n  const statusUnsub = node.onStatus((status) => {\n    const currentNodes = state.get().nodes\n    const currentEntry = currentNodes.get(options.name)\n    if (!currentEntry) return\n    const updatedEntry = {\n      ...currentEntry,\n      status,\n    }\n    state.set('updateNodeStatus', {\n      nodes: new Map(currentNodes).set(options.name, updatedEntry),\n    })\n  })\n\n  // Set up initial entry with status, error, and statusUnsub\n  const entry = {\n    node,\n    options,\n    status: 'idle' as const,\n    statusUnsub,\n  }\n\n  nodes.set(options.name, entry)\n\n  state.set('createNode', {nodes})\n\n  return node\n}\n","import {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkNodeState} from '../comlinkNodeStore'\n\nexport const releaseNode = ({state}: StoreContext<ComlinkNodeState>, name: string): void => {\n  const nodes = state.get().nodes\n  const existing = nodes.get(name)\n\n  if (existing) {\n    if (existing.statusUnsub) {\n      existing.statusUnsub()\n    }\n    existing.node.stop()\n    nodes.delete(name)\n    state.set('removeNode', {nodes})\n    return\n  }\n}\n","import {type Node, type NodeInput, type Status} from '@sanity/comlink'\n\nimport {bindActionGlobally} from '../../store/createActionBinder'\nimport {defineStore} from '../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../types'\nimport {getOrCreateNode as unboundGetOrCreateNode} from './actions/getOrCreateNode'\nimport {releaseNode as unboundReleaseNode} from './actions/releaseNode'\n\n/**\n * Individual node with its relevant options\n * @public\n */\nexport interface NodeEntry {\n  node: Node<WindowMessage, FrameMessage>\n  // we store options to ensure that channels remain as unique / consistent as possible\n  options: NodeInput\n  // status of the node connection\n  status: Status\n  statusUnsub?: () => void\n}\n\n/**\n * Internal state tracking comlink connections\n * @public\n */\nexport interface ComlinkNodeState {\n  nodes: Map<string, NodeEntry>\n  // Map of node name to set of active subscriber symbols\n  subscriptions: Map<string, Set<symbol>>\n}\n\nexport const comlinkNodeStore = defineStore<ComlinkNodeState>({\n  name: 'nodeStore',\n  getInitialState: () => ({\n    nodes: new Map(),\n    subscriptions: new Map(),\n  }),\n\n  initialize({state}) {\n    return () => {\n      state.get().nodes.forEach(({node}) => {\n        node.stop()\n      })\n    }\n  },\n})\n\n/**\n * Signals to the store that the consumer has stopped using the node\n * @public\n */\nexport const releaseNode = bindActionGlobally(comlinkNodeStore, unboundReleaseNode)\n\n/**\n * Retrieve or create a node to be used for communication between\n * an application and the controller -- specifically, a node should\n * be created within a frame / window to communicate with the controller.\n * @public\n */\nexport const getOrCreateNode = bindActionGlobally(comlinkNodeStore, unboundGetOrCreateNode)\n","import {type Node, type NodeInput, type Status} from '@sanity/comlink'\nimport {createSelector} from 'reselect'\n\nimport {bindActionGlobally} from '../../store/createActionBinder'\nimport {createStateSourceAction, type SelectorContext} from '../../store/createStateSourceAction'\nimport {type FrameMessage, type WindowMessage} from '../types'\nimport {\n  type ComlinkNodeState,\n  comlinkNodeStore,\n  getOrCreateNode,\n  releaseNode,\n} from './comlinkNodeStore'\n\nconst NODE_RELEASE_TIME = 5000\n\n// Public shape for node state\n/**\n * @public\n */\nexport interface NodeState {\n  node: Node<WindowMessage, FrameMessage>\n  status: Status | undefined\n}\nconst selectNode = (context: SelectorContext<ComlinkNodeState>, nodeInput: NodeInput) =>\n  context.state.nodes.get(nodeInput.name)\n\n/**\n * Provides a subscribable state source for a node by name\n * @param instance - The Sanity instance to get the node state for\n * @param nodeInput - The configuration for the node to get the state for\n\n * @returns A subscribable state source for the node\n * @public\n */\nexport const getNodeState = bindActionGlobally(\n  comlinkNodeStore,\n  createStateSourceAction<ComlinkNodeState, [NodeInput], NodeState | undefined>({\n    selector: createSelector([selectNode], (nodeEntry) => {\n      return nodeEntry?.status === 'connected'\n        ? {\n            node: nodeEntry.node,\n            status: nodeEntry.status,\n          }\n        : undefined\n    }),\n    onSubscribe: ({state, instance}, nodeInput) => {\n      const nodeName = nodeInput.name\n      const subscriberId = Symbol('comlink-node-subscriber')\n      getOrCreateNode(instance, nodeInput)\n\n      // Add subscriber to the set for this node\n      let subs = state.get().subscriptions.get(nodeName)\n      if (!subs) {\n        subs = new Set()\n        state.get().subscriptions.set(nodeName, subs)\n      }\n      subs.add(subscriberId)\n\n      return () => {\n        setTimeout(() => {\n          const activeSubs = state.get().subscriptions.get(nodeName)\n          if (activeSubs) {\n            activeSubs.delete(subscriberId)\n            if (activeSubs.size === 0) {\n              state.get().subscriptions.delete(nodeName)\n              releaseNode(instance, nodeName)\n            }\n          }\n        }, NODE_RELEASE_TIME)\n      }\n    },\n  }),\n)\n","import {\n  type DatasetHandle,\n  type DocumentHandle,\n  type DocumentTypeHandle,\n  type ProjectHandle,\n} from './sanityConfig'\n\n/**\n * Creates or validates a `DocumentHandle` object.\n * Ensures the provided object conforms to the `DocumentHandle` interface.\n * @param handle - The object containing document identification properties.\n * @returns The validated `DocumentHandle` object.\n * @public\n */\nexport function createDocumentHandle<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  handle: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n): DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  return handle\n}\n\n/**\n * Creates or validates a `DocumentTypeHandle` object.\n * Ensures the provided object conforms to the `DocumentTypeHandle` interface.\n * @param handle - The object containing document type identification properties.\n * @returns The validated `DocumentTypeHandle` object.\n * @public\n */\nexport function createDocumentTypeHandle<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  handle: DocumentTypeHandle<TDocumentType, TDataset, TProjectId>,\n): DocumentTypeHandle<TDocumentType, TDataset, TProjectId> {\n  return handle\n}\n\n/**\n * Creates or validates a `ProjectHandle` object.\n * Ensures the provided object conforms to the `ProjectHandle` interface.\n * @param handle - The object containing project identification properties.\n * @returns The validated `ProjectHandle` object.\n * @public\n */\nexport function createProjectHandle<TProjectId extends string = string>(\n  handle: ProjectHandle<TProjectId>,\n): ProjectHandle<TProjectId> {\n  return handle\n}\n\n/**\n * Creates or validates a `DatasetHandle` object.\n * Ensures the provided object conforms to the `DatasetHandle` interface.\n * @param handle - The object containing dataset identification properties.\n * @returns The validated `DatasetHandle` object.\n * @public\n */\nexport function createDatasetHandle<\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(handle: DatasetHandle<TDataset, TProjectId>): DatasetHandle<TDataset, TProjectId> {\n  return handle\n}\n","import {switchMap} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type ProjectHandle} from '../config/sanityConfig'\nimport {createFetcherStore} from '../utils/createFetcherStore'\n\nconst API_VERSION = 'v2025-02-19'\n\n/** @public */\nexport const datasets = createFetcherStore({\n  name: 'Datasets',\n  getKey: (instance, options?: ProjectHandle) => {\n    const projectId = options?.projectId ?? instance.config.projectId\n    if (!projectId) {\n      throw new Error('A projectId is required to use the project API.')\n    }\n    return projectId\n  },\n  fetcher: (instance) => (options?: ProjectHandle) => {\n    return getClientState(instance, {\n      apiVersion: API_VERSION,\n      // non-null assertion is fine because we check above\n      projectId: (options?.projectId ?? instance.config.projectId)!,\n      useProjectHostname: true,\n    }).observable.pipe(switchMap((client) => client.observable.datasets.list()))\n  },\n})\n\n/** @public */\nexport const getDatasetsState = datasets.getState\n\n/** @public */\nexport const resolveDatasets = datasets.resolveState\n","import {SanityEncoder} from '@sanity/mutate'\nimport {type PatchMutation as SanityMutatePatchMutation} from '@sanity/mutate/_unstable_store'\nimport {type PatchMutation, type PatchOperations} from '@sanity/types'\n\nimport {type DocumentHandle, type DocumentTypeHandle} from '../config/sanityConfig'\nimport {getPublishedId} from '../utils/ids'\n\nconst isSanityMutatePatch = (value: unknown): value is SanityMutatePatchMutation => {\n  if (typeof value !== 'object' || !value) return false\n  if (!('type' in value) || typeof value.type !== 'string' || value.type !== 'patch') return false\n  if (!('id' in value) || typeof value.id !== 'string') return false\n  if (!('patches' in value) || !Array.isArray(value.patches)) return false\n  return true\n}\n\n/**\n * Represents an action to create a new document.\n * Specifies the document type and optionally a document ID (which will be treated as the published ID).\n * @beta\n */\nexport interface CreateDocumentAction<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentTypeHandle<TDocumentType, TDataset, TProjectId> {\n  type: 'document.create'\n}\n\n/**\n * Represents an action to delete an existing document.\n * Requires the full document handle including the document ID.\n * @beta\n */\nexport interface DeleteDocumentAction<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  type: 'document.delete'\n}\n\n/**\n * Represents an action to edit an existing document using patches.\n * Requires the full document handle and an array of patch operations.\n * @beta\n */\nexport interface EditDocumentAction<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  type: 'document.edit'\n  patches?: PatchOperations[]\n}\n\n/**\n * Represents an action to publish the draft version of a document.\n * Requires the full document handle.\n * @beta\n */\nexport interface PublishDocumentAction<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  type: 'document.publish'\n}\n\n/**\n * Represents an action to unpublish a document, moving its published content to a draft.\n * Requires the full document handle.\n * @beta\n */\nexport interface UnpublishDocumentAction<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  type: 'document.unpublish'\n}\n\n/**\n * Represents an action to discard the draft changes of a document.\n * Requires the full document handle.\n * @beta\n */\nexport interface DiscardDocumentAction<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  type: 'document.discard'\n}\n\n/**\n * Union type representing all possible document actions within the SDK.\n * @beta\n */\nexport type DocumentAction<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> =\n  | CreateDocumentAction<TDocumentType, TDataset, TProjectId>\n  | DeleteDocumentAction<TDocumentType, TDataset, TProjectId>\n  | EditDocumentAction<TDocumentType, TDataset, TProjectId>\n  | PublishDocumentAction<TDocumentType, TDataset, TProjectId>\n  | UnpublishDocumentAction<TDocumentType, TDataset, TProjectId>\n  | DiscardDocumentAction<TDocumentType, TDataset, TProjectId>\n\n/**\n * Creates a `CreateDocumentAction` object.\n * @param doc - A handle identifying the document type, dataset, and project. An optional `documentId` can be provided.\n * @returns A `CreateDocumentAction` object ready for dispatch.\n * @beta\n */\nexport function createDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentTypeHandle<TDocumentType, TDataset, TProjectId>,\n): CreateDocumentAction<TDocumentType, TDataset, TProjectId> {\n  return {\n    type: 'document.create',\n    ...doc,\n    ...(doc.documentId && {documentId: getPublishedId(doc.documentId)}),\n  }\n}\n\n/**\n * Creates a `DeleteDocumentAction` object.\n * @param doc - A handle uniquely identifying the document to be deleted.\n * @returns A `DeleteDocumentAction` object ready for dispatch.\n * @beta\n */\nexport function deleteDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n): DeleteDocumentAction<TDocumentType, TDataset, TProjectId> {\n  return {\n    type: 'document.delete',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n\nfunction convertSanityMutatePatch(\n  sanityPatchMutation: SanityMutatePatchMutation,\n): EditDocumentAction['patches'] {\n  const encoded = SanityEncoder.encode(sanityPatchMutation) as PatchMutation[]\n  return encoded.map((i) => {\n    const copy: PatchOperations = {...i.patch}\n    if ('id' in copy) delete copy.id\n    return copy\n  })\n}\n\n/**\n * Creates an `EditDocumentAction` object with patches for modifying a document.\n * Accepts patches in either the standard `PatchOperations` format or as a `SanityMutatePatchMutation` from `@sanity/mutate`.\n *\n * @param doc - A handle uniquely identifying the document to be edited.\n * @param sanityMutatePatch - A patch mutation object from `@sanity/mutate`.\n * @returns An `EditDocumentAction` object ready for dispatch.\n * @beta\n */\nexport function editDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n  sanityMutatePatch: SanityMutatePatchMutation,\n): EditDocumentAction<TDocumentType, TDataset, TProjectId>\n/**\n * Creates an `EditDocumentAction` object with patches for modifying a document.\n *\n * @param doc - A handle uniquely identifying the document to be edited.\n * @param patches - A single patch operation or an array of patch operations.\n * @returns An `EditDocumentAction` object ready for dispatch.\n * @beta\n */\nexport function editDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n  patches?: PatchOperations | PatchOperations[],\n): EditDocumentAction<TDocumentType, TDataset, TProjectId>\n/**\n * Creates an `EditDocumentAction` object with patches for modifying a document.\n * This is the implementation signature and handles the different patch input types.\n *\n * @param doc - A handle uniquely identifying the document to be edited.\n * @param patches - Patches in various formats (`PatchOperations`, `PatchOperations[]`, or `SanityMutatePatchMutation`).\n * @returns An `EditDocumentAction` object ready for dispatch.\n */\nexport function editDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n  patches?: PatchOperations | PatchOperations[] | SanityMutatePatchMutation,\n): EditDocumentAction<TDocumentType, TDataset, TProjectId> {\n  if (isSanityMutatePatch(patches)) {\n    const converted = convertSanityMutatePatch(patches) ?? []\n    return {\n      ...doc,\n      type: 'document.edit',\n      documentId: getPublishedId(doc.documentId),\n      patches: converted,\n    }\n  }\n\n  return {\n    ...doc,\n    type: 'document.edit',\n    documentId: getPublishedId(doc.documentId),\n    ...(patches && {patches: Array.isArray(patches) ? patches : [patches]}),\n  }\n}\n\n/**\n * Creates a `PublishDocumentAction` object.\n * @param doc - A handle uniquely identifying the document to be published.\n * @returns A `PublishDocumentAction` object ready for dispatch.\n * @beta\n */\nexport function publishDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n): PublishDocumentAction<TDocumentType, TDataset, TProjectId> {\n  return {\n    type: 'document.publish',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n\n/**\n * Creates an `UnpublishDocumentAction` object.\n * @param doc - A handle uniquely identifying the document to be unpublished.\n * @returns An `UnpublishDocumentAction` object ready for dispatch.\n * @beta\n */\nexport function unpublishDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n): UnpublishDocumentAction<TDocumentType, TDataset, TProjectId> {\n  return {\n    type: 'document.unpublish',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n\n/**\n * Creates a `DiscardDocumentAction` object.\n * @param doc - A handle uniquely identifying the document whose draft changes are to be discarded.\n * @returns A `DiscardDocumentAction` object ready for dispatch.\n * @beta\n */\nexport function discardDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  doc: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n): DiscardDocumentAction<TDocumentType, TDataset, TProjectId> {\n  return {\n    type: 'document.discard',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n","/**\n * When a document has no more subscribers, its state is cleaned up and removed\n * from the store. A delay used to prevent re-creating resources when the last\n * subscriber is removed quickly before another one is added. This is helpful\n * when used in a frontend where components may suspend or transition to\n * different views quickly.\n */\nexport const DOCUMENT_STATE_CLEAR_DELAY = 1000\nexport const INITIAL_OUTGOING_THROTTLE_TIME = 1000\nexport const API_VERSION = 'v2025-05-06'\n","import {applyPatches, parsePatch} from '@sanity/diff-match-patch'\nimport {getIndexForKey, jsonMatch, slicePath, stringifyPath} from '@sanity/json-match'\nimport {\n  type IndexTuple,\n  type InsertPatch,\n  isKeyedObject,\n  isKeySegment,\n  type PathSegment,\n} from '@sanity/types'\n\ntype SingleValuePath = Exclude<PathSegment, IndexTuple>[]\n\ntype ToNumber<TInput extends string> = TInput extends `${infer TNumber extends number}`\n  ? TNumber\n  : TInput\n\n/**\n * Parse a single \"segment\" that may include bracket parts.\n *\n * For example, the literal\n *\n * ```\n * \"friends[0][1]\"\n * ```\n *\n * is parsed as:\n *\n * ```\n * [\"friends\", 0, 1]\n * ```\n */\ntype ParseSegment<TInput extends string> = TInput extends `${infer TProp}[${infer TRest}`\n  ? TProp extends ''\n    ? [...ParseBracket<`[${TRest}`>] // no property name before '['\n    : [TProp, ...ParseBracket<`[${TRest}`>]\n  : TInput extends ''\n    ? []\n    : [TInput]\n\n/**\n * Parse one or more bracketed parts from a segment.\n *\n * It recursively \"peels off\" a bracketed part and then continues.\n *\n * For example, given the string:\n *\n * ```\n * \"[0][foo]\"\n * ```\n *\n * it produces:\n *\n * ```\n * [ToNumber<\"0\">, \"foo\"]\n * ```\n */\ntype ParseBracket<TInput extends string> = TInput extends `[${infer TPart}]${infer TRest}`\n  ? [ToNumber<TPart>, ...ParseSegment<TRest>]\n  : [] // no leading bracket → end of this segment\n\n/**\n * Split the entire path string on dots \"outside\" of any brackets.\n *\n * For example:\n * ```\n * \"friends[0].name\"\n * ```\n *\n * becomes:\n *\n * ```\n * [...ParseSegment<\"friends[0]\">, ...ParseSegment<\"name\">]\n * ```\n *\n * (We use a simple recursion that splits on the first dot.)\n */\ntype PathParts<TPath extends string> = TPath extends `${infer Head}.${infer Tail}`\n  ? [Head, ...PathParts<Tail>]\n  : TPath extends ''\n    ? []\n    : [TPath]\n\n/**\n * Given a type T and an array of \"access keys\" Parts, recursively index into T.\n *\n * If a part is a key, it looks up that property.\n * If T is an array and the part is a number, it \"indexes\" into the element type.\n */\ntype DeepGet<TValue, TPath extends readonly (string | number)[]> = TPath extends []\n  ? TValue\n  : TPath extends readonly [infer THead, ...infer TTail]\n    ? // Handle traversing into optional properties\n      DeepGet<\n        TValue extends undefined | null\n          ? undefined // Stop traversal if current value is null/undefined\n          : THead extends keyof TValue // Access property if key exists\n            ? TValue[THead]\n            : // Handle array indexing\n              THead extends number\n              ? TValue extends readonly (infer TElement)[]\n                ? TElement | undefined // Array element or undefined if out of bounds\n                : undefined // Cannot index non-array with number\n              : undefined, // Key/index doesn't exist\n        TTail extends readonly (string | number)[] ? TTail : [] // Continue with the rest of the path\n      >\n    : never // Should be unreachable\n\n/**\n * Given a document type TDocument and a JSON Match path string TPath,\n * compute the type found at that path.\n * @beta\n */\nexport type JsonMatch<TDocument, TPath extends string> = DeepGet<TDocument, PathParts<TPath>>\n\n// this is a similar array key to the studio:\n// https://github.com/sanity-io/sanity/blob/v3.74.1/packages/sanity/src/core/form/inputs/arrays/ArrayOfObjectsInput/createProtoArrayValue.ts\nfunction generateArrayKey(length: number = 12): string {\n  // Each byte gives two hex characters, so generate enough bytes.\n  const numBytes = Math.ceil(length / 2)\n  const bytes = crypto.getRandomValues(new Uint8Array(numBytes))\n  // Convert each byte to a 2-digit hex string and join them.\n  return Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n    .slice(0, length)\n}\n\nfunction memoize<TFunction extends (input: unknown) => unknown>(fn: TFunction): TFunction {\n  const cache = new WeakMap<object, unknown>()\n  return ((input) => {\n    if (!input || typeof input !== 'object') return fn(input)\n\n    const cached = cache.get(input)\n    if (cached) return cached\n\n    const result = fn(input)\n    cache.set(input, result)\n    return result\n  }) as TFunction\n}\n\n/**\n * Recursively traverse a value. When an array is encountered, ensure that\n * each object item has a _key property. Memoized such that sub-objects that\n * have not changed aren't re-computed.\n */\nexport const ensureArrayKeysDeep = memoize(<R>(input: R): R => {\n  if (!input || typeof input !== 'object') return input\n\n  if (Array.isArray(input)) {\n    // if the array is empty then just return the input\n    if (!input.length) return input\n    const first = input[0]\n    // if the first input in the array isn't an object (null is allowed) then\n    // assume that this is an array of primitives, just return the input\n    if (typeof first !== 'object') return input\n\n    // if all the items already have a key, then return the input\n    if (input.every(isKeyedObject)) return input\n\n    // otherwise return a new object item with a new key\n    return input.map((item: unknown) => {\n      if (!item || typeof item !== 'object') return item\n      if (isKeyedObject(item)) return ensureArrayKeysDeep(item)\n      const next = ensureArrayKeysDeep(item)\n      return {...next, _key: generateArrayKey()}\n    }) as R\n  }\n\n  const entries = Object.entries(input).map(([key, value]) => [key, ensureArrayKeysDeep(value)])\n\n  if (entries.every(([key, value]) => input[key as keyof typeof input] === value)) {\n    return input\n  }\n\n  return Object.fromEntries(entries) as R\n})\n\n/**\n * Given an input object and a record of path expressions to values, this\n * function will set each match with the given value.\n *\n * ```js\n * const output = set(\n *   {name: {first: 'initial', last: 'initial'}},\n *   {'name.first': 'changed'}\n * );\n *\n * // { name: { first: 'changed', last: 'initial' } }\n * console.log(output);\n * ```\n */\nexport function set<R>(input: unknown, pathExpressionValues: Record<string, unknown>): R\nexport function set(input: unknown, pathExpressionValues: Record<string, unknown>): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, replacementValue]) =>\n      Array.from(jsonMatch(input, pathExpression)).map((matchEntry) => ({\n        ...matchEntry,\n        replacementValue,\n      })),\n    )\n    .reduce((acc, {path, replacementValue}) => setDeep(acc, path, replacementValue), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of path expressions to values, this\n * function will set each match with the given value **if the value at the current\n * path is missing** (i.e. `null` or `undefined`).\n *\n * ```js\n * const output = setIfMissing(\n *   {items: [null, 'initial']},\n *   {'items[:]': 'changed'}\n * );\n *\n * // { items: ['changed', 'initial'] }\n * console.log(output);\n * ```\n */\nexport function setIfMissing<R>(input: unknown, pathExpressionValues: Record<string, unknown>): R\nexport function setIfMissing(\n  input: unknown,\n  pathExpressionValues: Record<string, unknown>,\n): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, replacementValue]) => {\n      return Array.from(jsonMatch(input, pathExpression)).map((matchEntry) => ({\n        ...matchEntry,\n        replacementValue,\n      }))\n    })\n    .filter((matchEntry) => matchEntry.value === null || matchEntry.value === undefined)\n    .reduce((acc, {path, replacementValue}) => setDeep(acc, path, replacementValue), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and an array of path expressions, this function will\n * remove each match from the input object.\n *\n * ```js\n * const output = unset(\n *   {name: {first: 'one', last: 'two'}},\n *   ['name.last']\n * );\n *\n * // { name: { first: 'one' } }\n * console.log(output);\n * ```\n */\nexport function unset<R>(input: unknown, pathExpressions: string[]): R\nexport function unset(input: unknown, pathExpressions: string[]): unknown {\n  const result = pathExpressions\n    .flatMap((pathExpression) => Array.from(jsonMatch(input, pathExpression)))\n    // ensure that we remove in the reverse order the paths were found in\n    // this is necessary for array unsets so the indexes don't change as we unset\n    .reverse()\n    .reduce((acc, {path}) => unsetDeep(acc, path), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object, a path expression (inside the insert patch object), and an array of items,\n * this function will insert or replace the matched items.\n *\n * **Insert before:**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c']}}\n * const output = insert(\n *   input,\n *   {\n *     before: 'some.array[1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', '!', 'b', 'c'] } }\n * console.log(output);\n * ```\n *\n * **Insert before with negative index (append):**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c']}}\n * const output = insert(\n *   input,\n *   {\n *     before: 'some.array[-1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', 'b', 'c', '!'] } }\n * console.log(output);\n * ```\n *\n * **Insert after:**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c']}}\n * const output = insert(\n *   input,\n *   {\n *     after: 'some.array[1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', 'b', '!', 'c'] } }\n * console.log(output);\n * ```\n *\n * **Replace:**\n *\n * ```js\n * const output = insert(\n *   { some: { array: ['a', 'b', 'c'] } },\n *   {\n *     replace: 'some.array[1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', '!', 'c'] } }\n * console.log(output);\n * ```\n *\n * **Replace many:**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c', 'd']}}\n * const output = insert(\n *   input,\n *   {\n *     replace: 'some.array[1:3]',\n *     items: ['!', '?']\n *   }\n * );\n * // { some: { array: ['a', '!', '?', 'd'] } }\n * console.log(output);\n * ```\n */\nexport function insert<R>(input: unknown, insertPatch: InsertPatch): R\nexport function insert(input: unknown, {items, ...insertPatch}: InsertPatch): unknown {\n  let operation\n  let pathExpression\n\n  // behavior observed from content-lake when inserting:\n  // 1. if the operation is before, out of all the matches, it will use the\n  //    insert the items before the first match that appears in the array\n  // 2. if the operation is after, it will insert the items after the first\n  //    match that appears in the array\n  // 3. if the operation is replace, then insert the items before the first\n  //    match and then delete the rest\n  if ('before' in insertPatch) {\n    operation = 'before' as const\n    pathExpression = insertPatch.before\n  } else if ('after' in insertPatch) {\n    operation = 'after' as const\n    pathExpression = insertPatch.after\n  } else if ('replace' in insertPatch) {\n    operation = 'replace' as const\n    pathExpression = insertPatch.replace\n  }\n  if (!operation) return input\n  if (typeof pathExpression !== 'string') return input\n\n  // in order to do an insert patch, you need to provide at least one path segment\n  if (!pathExpression.length) return input\n\n  const arrayPath = slicePath(pathExpression, 0, -1)\n  const positionPath = slicePath(pathExpression, -1)\n\n  let result = input\n\n  for (const {path, value} of jsonMatch(input, arrayPath)) {\n    if (!Array.isArray(value)) continue\n    let arr = value\n\n    switch (operation) {\n      case 'replace': {\n        const indexesToRemove = new Set<number>()\n        let position = Infinity\n\n        for (const itemMatch of jsonMatch(arr, positionPath)) {\n          // there should only be one path segment for an insert patch, invalid otherwise\n          if (itemMatch.path.length !== 1) continue\n          const [segment] = itemMatch.path\n          if (typeof segment === 'string') continue\n\n          let index\n\n          if (typeof segment === 'number') index = segment\n          if (typeof index === 'number' && index < 0) index = arr.length + index\n          if (isKeySegment(segment)) index = getIndexForKey(arr, segment._key)\n          if (typeof index !== 'number') continue\n          if (index < 0) index = arr.length + index\n\n          indexesToRemove.add(index)\n          if (index < position) position = index\n        }\n\n        if (position === Infinity) continue\n\n        // remove all other indexes\n        arr = arr\n          .map((item, index) => ({item, index}))\n          .filter(({index}) => !indexesToRemove.has(index))\n          .map(({item}) => item)\n\n        // insert at the min index\n        arr = [...arr.slice(0, position), ...items, ...arr.slice(position, arr.length)]\n\n        break\n      }\n      case 'before': {\n        let position = Infinity\n\n        for (const itemMatch of jsonMatch(arr, positionPath)) {\n          if (itemMatch.path.length !== 1) continue\n          const [segment] = itemMatch.path\n\n          if (typeof segment === 'string') continue\n\n          let index\n\n          if (typeof segment === 'number') index = segment\n          if (typeof index === 'number' && index < 0) index = arr.length + index\n          if (isKeySegment(segment)) index = getIndexForKey(arr, segment._key)\n          if (typeof index !== 'number') continue\n          if (index < 0) index = arr.length - index\n          if (index < position) position = index\n        }\n\n        if (position === Infinity) continue\n\n        arr = [...arr.slice(0, position), ...items, ...arr.slice(position, arr.length)]\n\n        break\n      }\n      case 'after': {\n        let position = -Infinity\n\n        for (const itemMatch of jsonMatch(arr, positionPath)) {\n          if (itemMatch.path.length !== 1) continue\n          const [segment] = itemMatch.path\n\n          if (typeof segment === 'string') continue\n\n          let index\n\n          if (typeof segment === 'number') index = segment\n          if (typeof index === 'number' && index < 0) index = arr.length + index\n          if (isKeySegment(segment)) index = getIndexForKey(arr, segment._key)\n          if (typeof index !== 'number') continue\n          if (index > position) position = index\n        }\n\n        if (position === -Infinity) continue\n\n        arr = [...arr.slice(0, position + 1), ...items, ...arr.slice(position + 1, arr.length)]\n\n        break\n      }\n\n      default: {\n        continue\n      }\n    }\n\n    result = setDeep(result, path, arr)\n  }\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of path expressions to numeric values,\n * this function will increment each match with the given value.\n *\n * ```js\n * const output = inc(\n *   {foo: {first: 3, second: 4.5}},\n *   {'foo.first': 3, 'foo.second': 4}\n * );\n *\n * // { foo: { first: 6, second: 8.5 } }\n * console.log(output);\n * ```\n */\nexport function inc<R>(input: unknown, pathExpressionValues: Record<string, number>): R\nexport function inc(input: unknown, pathExpressionValues: Record<string, number>): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, valueToAdd]) =>\n      Array.from(jsonMatch(input, pathExpression)).map((matchEntry) => ({\n        ...matchEntry,\n        valueToAdd,\n      })),\n    )\n    .filter(\n      <T extends {value: unknown}>(matchEntry: T): matchEntry is T & {value: number} =>\n        typeof matchEntry.value === 'number',\n    )\n    .reduce((acc, {path, value, valueToAdd}) => setDeep(acc, path, value + valueToAdd), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of path expressions to numeric values,\n * this function will decrement each match with the given value.\n *\n * ```js\n * const output = dec(\n *   {foo: {first: 3, second: 4.5}},\n *   {'foo.first': 3, 'foo.second': 4}\n * );\n *\n * // { foo: { first: 0, second: 0.5 } }\n * console.log(output);\n * ```\n */\nexport function dec<R>(input: unknown, pathExpressionValues: Record<string, number>): R\nexport function dec(input: unknown, pathExpressionValues: Record<string, number>): unknown {\n  const result = inc(\n    input,\n    Object.fromEntries(\n      Object.entries(pathExpressionValues)\n        .filter(([, value]) => typeof value === 'number')\n        .map(([key, value]) => [key, -value]),\n    ),\n  )\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of paths to [diff match patches][0], this\n * function will apply the diff match patch for the string at each match.\n *\n * [0]: https://www.sanity.io/docs/http-patches#aTbJhlAJ\n *\n * ```js\n * const output = diffMatchPatch(\n *   {foo: 'the quick brown fox'},\n *   {'foo': '@@ -13,7 +13,7 @@\\n own \\n-fox\\n+cat\\n'}\n * );\n *\n * // { foo: 'the quick brown cat' }\n * console.log(output);\n * ```\n */\nexport function diffMatchPatch<R>(input: unknown, pathExpressionValues: Record<string, string>): R\nexport function diffMatchPatch(\n  input: unknown,\n  pathExpressionValues: Record<string, string>,\n): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, dmp]) =>\n      Array.from(jsonMatch(input, pathExpression)).map((m) => ({...m, dmp})),\n    )\n    .filter((i) => i.value !== undefined)\n    .map(({path, value, dmp}) => {\n      if (typeof value !== 'string') {\n        throw new Error(\n          `Can't diff-match-patch \\`${JSON.stringify(value)}\\` at path \\`${stringifyPath(path)}\\`, because it is not a string`,\n        )\n      }\n\n      const [nextValue] = applyPatches(parsePatch(dmp), value)\n      return {path, value: nextValue}\n    })\n    .reduce((acc, {path, value}) => setDeep(acc, path, value), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Simply checks if the given document input has a `_rev` that matches the given\n * `revisionId` and throws otherwise.\n *\n * (No code example provided.)\n */\nexport function ifRevisionID<R>(input: unknown, revisionId: string): R\nexport function ifRevisionID(input: unknown, revisionId: string): unknown {\n  const inputRev =\n    typeof input === 'object' && !!input && '_rev' in input && typeof input._rev === 'string'\n      ? input._rev\n      : undefined\n\n  if (typeof inputRev !== 'string') {\n    throw new Error(`Patch specified \\`ifRevisionID\\` but could not find document's revision ID.`)\n  }\n\n  if (revisionId !== inputRev) {\n    throw new Error(\n      `Patch's \\`ifRevisionID\\` \\`${revisionId}\\` does not match document's revision ID \\`${inputRev}\\``,\n    )\n  }\n\n  return input\n}\n\n/**\n * Gets a value deep inside of an object given a path. If the path does not\n * exist in the object, `undefined` will be returned.\n */\nexport function getDeep<R>(input: unknown, path: SingleValuePath): R\nexport function getDeep(input: unknown, path: SingleValuePath): unknown {\n  const [currentSegment, ...restOfPath] = path\n  if (currentSegment === undefined) return input\n  if (typeof input !== 'object' || input === null) return undefined\n\n  let key\n  if (isKeySegment(currentSegment)) {\n    key = getIndexForKey(input, currentSegment._key)\n  } else if (typeof currentSegment === 'string') {\n    key = currentSegment\n  } else if (typeof currentSegment === 'number') {\n    key = currentSegment\n  }\n\n  if (key === undefined) return undefined\n\n  // Use .at() to support negative indexes on arrays.\n  const nestedInput =\n    typeof key === 'number' && Array.isArray(input)\n      ? input.at(key)\n      : (input as Record<string, unknown>)[key]\n\n  return getDeep(nestedInput, restOfPath)\n}\n\n/**\n * Sets a value deep inside of an object given a path. If the path does not\n * exist in the object, it will be created.\n */\nexport function setDeep<R>(input: unknown, path: SingleValuePath, value: unknown): R\nexport function setDeep(input: unknown, path: SingleValuePath, value: unknown): unknown {\n  const [currentSegment, ...restOfPath] = path\n  if (currentSegment === undefined) return value\n\n  // If the current input is not an object, create a new container.\n  if (typeof input !== 'object' || input === null) {\n    if (typeof currentSegment === 'string') {\n      return {[currentSegment]: setDeep(null, restOfPath, value)}\n    }\n\n    let index: number | undefined\n    if (isKeySegment(currentSegment)) {\n      // When creating a new array via a keyed segment, use index 0.\n      index = 0\n    } else if (typeof currentSegment === 'number' && currentSegment >= 0) {\n      index = currentSegment\n    } else {\n      // For negative numbers in a non‐object we simply return input.\n      return input\n    }\n\n    return [\n      // fill until index\n      ...Array.from({length: index}).fill(null),\n      // then set deep here\n      setDeep(null, restOfPath, value),\n    ]\n  }\n\n  // When input is an array…\n  if (Array.isArray(input)) {\n    let index: number | undefined\n    if (isKeySegment(currentSegment)) {\n      index = getIndexForKey(input, currentSegment._key) ?? input.length\n    } else if (typeof currentSegment === 'number') {\n      // Support negative indexes by computing the proper positive index.\n      index = currentSegment < 0 ? input.length + currentSegment : currentSegment\n    }\n    if (index === undefined) return input\n\n    if (index in input) {\n      // Update the element at the resolved index.\n      return input.map((nestedInput, i) =>\n        i === index ? setDeep(nestedInput, restOfPath, value) : nestedInput,\n      )\n    }\n\n    // Expand the array if needed.\n    return [\n      ...input,\n      ...Array.from({length: index - input.length}).fill(null),\n      setDeep(null, restOfPath, value),\n    ]\n  }\n\n  // For keyed segments that aren't arrays, do nothing.\n  if (typeof currentSegment === 'object') return input\n\n  // For plain objects, update an existing property if it exists…\n  if (currentSegment in input) {\n    return Object.fromEntries(\n      Object.entries(input).map(([key, nestedInput]) =>\n        key === currentSegment\n          ? [key, setDeep(nestedInput, restOfPath, value)]\n          : [key, nestedInput],\n      ),\n    )\n  }\n\n  // ...otherwise create the new nested path.\n  return {...input, [currentSegment]: setDeep(null, restOfPath, value)}\n}\n\n/**\n * Given an object and an exact path as an array, this unsets the value at the\n * given path.\n */\nexport function unsetDeep<R>(input: unknown, path: SingleValuePath): R\nexport function unsetDeep(input: unknown, path: SingleValuePath): unknown {\n  const [currentSegment, ...restOfPath] = path\n  if (currentSegment === undefined) return input\n  if (typeof input !== 'object' || input === null) return input\n\n  let _segment: string | number | undefined\n  if (isKeySegment(currentSegment)) {\n    _segment = getIndexForKey(input, currentSegment._key)\n  } else if (typeof currentSegment === 'string' || typeof currentSegment === 'number') {\n    _segment = currentSegment\n  }\n  if (_segment === undefined) return input\n\n  // For numeric segments in arrays, compute the positive index.\n  let segment: string | number = _segment\n  if (typeof segment === 'number' && Array.isArray(input)) {\n    segment = segment < 0 ? input.length + segment : segment\n  }\n  if (!(segment in input)) return input\n\n  // If we're at the final segment, remove the property/element.\n  if (!restOfPath.length) {\n    if (Array.isArray(input)) {\n      return input.filter((_nestedInput, index) => index !== segment)\n    }\n    return Object.fromEntries(Object.entries(input).filter(([key]) => key !== segment.toString()))\n  }\n\n  // Otherwise, recurse into the nested value.\n  if (Array.isArray(input)) {\n    return input.map((nestedInput, index) =>\n      index === segment ? unsetDeep(nestedInput, restOfPath) : nestedInput,\n    )\n  }\n\n  return Object.fromEntries(\n    Object.entries(input).map(([key, value]) =>\n      key === segment ? [key, unsetDeep(value, restOfPath)] : [key, value],\n    ),\n  )\n}\n","import {\n  type Mutation,\n  type MutationSelection,\n  type PatchOperations,\n  type SanityDocument,\n} from '@sanity/types'\n\nimport {\n  dec,\n  diffMatchPatch,\n  ifRevisionID,\n  inc,\n  insert,\n  set,\n  setIfMissing,\n  unset,\n} from './patchOperations'\n\n/**\n * Represents a set of document that will go into `applyMutations`. Before\n * applying a mutation, it's expected that all relevant documents that the\n * mutations affect are included, including those that do not exist yet.\n * Documents that don't exist have a `null` value.\n */\nexport type DocumentSet<TDocument extends SanityDocument = SanityDocument> = {\n  [TDocumentId in string]?: TDocument | null\n}\n\ntype SupportedPatchOperation = Exclude<keyof PatchOperations, 'merge'>\n\n// > If multiple patches are included, then the order of execution is as follows:\n// > - set, setIfMissing, unset, inc, dec, insert.\n// > https://www.sanity.io/docs/http-mutations#5b4db1396e56\nconst patchOperations = {\n  ifRevisionID,\n  set,\n  setIfMissing,\n  unset,\n  inc,\n  dec,\n  insert,\n  diffMatchPatch,\n} satisfies {\n  [K in SupportedPatchOperation]: (\n    input: unknown,\n    pathExpressions: NonNullable<PatchOperations[K]>,\n  ) => unknown\n}\n\n/**\n * Implements ID generation:\n *\n * A create mutation creates a new document. It takes the literal document\n * content as its argument. The rules for the new document's identifier are as\n * follows:\n *\n * - If the `_id` attribute is missing, then a new, random, unique ID is\n *   generated.\n * - If the `_id` attribute is present but ends with `.`, then it is used as a\n *   prefix for a new, random, unique ID.\n * - If the _id attribute is present, it is used as-is.\n *\n * [- source](https://www.sanity.io/docs/http-mutations#c732f27330a4)\n */\nexport function getId(id?: string): string {\n  if (!id || typeof id !== 'string') return crypto.randomUUID()\n  if (id.endsWith('.')) return `${id}${crypto.randomUUID()}`\n  return id\n}\n\ninterface ProcessMutationsOptions {\n  /**\n   * The transaction ID that will become the next `_rev` for documents mutated\n   * by the given mutations.\n   */\n  transactionId: string\n  /**\n   * The input document set that the mutations will be applied to.\n   */\n  documents: DocumentSet\n  /**\n   * A list of mutations to apply to the given document set.\n   */\n  mutations: Mutation[]\n  /**\n   * An optional timestamp that will be used for `_createdAt` and `_updatedAt`\n   * timestamp when applicable.\n   */\n  timestamp?: string\n}\n\nexport function getDocumentIds(selection: MutationSelection): string[] {\n  if ('id' in selection) {\n    // NOTE: the `MutationSelection` type within `@sanity/client` (instead of\n    // `@sanity/types`) allows for the ID field to be an array of strings so we\n    // support that as well\n    const array = Array.isArray(selection.id) ? selection.id : [selection.id]\n    const ids = array.filter((id): id is string => typeof id === 'string')\n    return Array.from(new Set(ids))\n  }\n\n  if ('query' in selection) {\n    throw new Error(`'query' in mutations is not supported.`)\n  }\n\n  return []\n}\n\n/**\n * Applies the given mutation to the given document set. Note, it is expected\n * that all relevant documents that the mutations affect should be within the\n * given `document` set. If a document does not exist, it should have the value\n * `null`. If a document is deleted as a result of the mutations, it will still\n * have its document ID present in the returns documents, but it will have a\n * value of `null`.\n *\n * The given `transactionId` will be used as the resulting `_rev` for documents\n * affected by the given set of mutations.\n *\n * If a `timestamp` is given, that will be used as for the relevant `_updatedAt`\n * and `_createdAt` timestamps.\n */\nexport function processMutations({\n  documents,\n  mutations,\n  transactionId,\n  timestamp,\n}: ProcessMutationsOptions): DocumentSet {\n  // early return if there are no mutations given\n  if (!mutations.length) return documents\n\n  const dataset = {...documents}\n  const now = timestamp || new Date().toISOString()\n\n  for (const mutation of mutations) {\n    if ('create' in mutation) {\n      const id = getId(mutation.create._id)\n\n      if (dataset[id]) {\n        throw new Error(\n          `Cannot create document with \\`_id\\` \\`${id}\\` because another document with the same ID already exists.`,\n        )\n      }\n\n      const document: SanityDocument = {\n        // > `_createdAt` and `_updatedAt` may be submitted and will override\n        // > the default which is of course the current time. This can be used\n        // > to reconstruct a data-set with its timestamp structure intact.\n        // >\n        // > [- source](https://www.sanity.io/docs/http-mutations#c732f27330a4)\n        _createdAt: now,\n        _updatedAt: now,\n        ...mutation.create, // prefer the user's `_createdAt` and `_updatedAt`\n        _rev: transactionId,\n        _id: id,\n      }\n\n      dataset[id] = document\n\n      continue\n    }\n\n    if ('createOrReplace' in mutation) {\n      const id = getId(mutation.createOrReplace._id)\n      const prev = dataset[id]\n\n      const document: SanityDocument = {\n        ...mutation.createOrReplace,\n        // otherwise, if the mutation provided, a `_createdAt` time, use it,\n        // otherwise default to now\n        _createdAt:\n          // if there was an existing document, use the previous `_createdAt`\n          // since we're replacing the current document\n          prev?._createdAt ||\n          // if there was no previous document, then we're creating this\n          // document for the first time so we should use the `_createdAt` from\n          // the mutation if the user included it\n          (typeof mutation.createOrReplace['_createdAt'] === 'string' &&\n            mutation.createOrReplace['_createdAt']) ||\n          // otherwise, default to now\n          now,\n\n        _updatedAt:\n          // if there was an existing document, then set the `_updatedAt` to now\n          // since we're replacing the current document\n          prev\n            ? now\n            : // otherwise, we're creating this document for the first time,\n              // in that case, use the user's `_updatedAt` if included in the\n              // mutation\n              (typeof mutation.createOrReplace['_updatedAt'] === 'string' &&\n                mutation.createOrReplace['_updatedAt']) ||\n              // otherwise default to now\n              now,\n        _rev: transactionId,\n        _id: id,\n      }\n\n      dataset[id] = document\n\n      continue\n    }\n\n    if ('createIfNotExists' in mutation) {\n      const id = getId(mutation.createIfNotExists._id)\n      const prev = dataset[id]\n      if (prev) continue\n\n      const document: SanityDocument = {\n        // same logic as `create`:\n        // prefer the user's `_createdAt` and `_updatedAt`\n        _createdAt: now,\n        _updatedAt: now,\n        ...mutation.createIfNotExists,\n        _rev: transactionId,\n        _id: id,\n      }\n\n      dataset[id] = document\n\n      continue\n    }\n\n    if ('delete' in mutation) {\n      for (const id of getDocumentIds(mutation.delete)) {\n        dataset[id] = null\n      }\n\n      continue\n    }\n\n    if ('patch' in mutation) {\n      const {patch} = mutation\n      const ids = getDocumentIds(patch)\n\n      const patched = ids.map((id) => {\n        if (!dataset[id]) {\n          throw new Error(`Cannot patch document with ID \\`${id}\\` because it was not found.`)\n        }\n\n        type Entries<T> = {[K in keyof T]: [K, T[K]]}[keyof T][]\n        const entries = Object.entries(patchOperations) as Entries<typeof patchOperations>\n\n        return entries.reduce((acc, [type, operation]) => {\n          if (patch[type]) {\n            return operation(\n              acc,\n              // @ts-expect-error TS doesn't handle this union very well\n              patch[type],\n            )\n          }\n          return acc\n        }, dataset[id])\n      })\n\n      for (const result of patched) {\n        dataset[result._id] = {\n          ...result,\n          _rev: transactionId,\n          _updatedAt: now,\n        }\n      }\n\n      continue\n    }\n  }\n\n  return dataset\n}\n","import {type MutationEvent} from '@sanity/client'\nimport {type Mutation, type SanityDocument} from '@sanity/types'\nimport {\n  concat,\n  concatMap,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  type Observable,\n  of,\n  switchMap,\n  throwError,\n  timer,\n  withLatestFrom,\n} from 'rxjs'\nimport {mergeMap, scan} from 'rxjs/operators'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {type DocumentStoreState} from './documentStore'\nimport {processMutations} from './processMutations'\n\nconst DEFAULT_MAX_BUFFER_SIZE = 20\nconst DEFAULT_DEADLINE_MS = 30000\n\nexport interface RemoteDocument {\n  type: 'sync' | 'mutation'\n  documentId: string\n  document: SanityDocument | null\n  revision?: string\n  previousRev?: string\n  timestamp: string\n}\n\nexport interface SyncEvent {\n  type: 'sync'\n  document: SanityDocument | null\n}\n\nexport type ListenerEvent = SyncEvent | MutationEvent\n\ninterface ListenerSequenceState {\n  /**\n   * Tracks the latest revision from the server that can be applied locally\n   * Once we receive a mutation event that has a `previousRev` that equals `base.revision`\n   * we will move `base.revision` to the event's `resultRev`\n   * `base.revision` will be undefined if document doesn't exist.\n   * `base` is `undefined` until the snapshot event is received\n   */\n  base: {revision: string | undefined} | undefined\n  /**\n   * Array of events to pass on to the stream, e.g. when mutation applies to current head revision, or a chain is complete\n   */\n  emitEvents: ListenerEvent[]\n  /**\n   * Buffer to keep track of events that doesn't line up in a [previousRev, resultRev] -- [previousRev, resultRev] sequence\n   * This can happen if events arrive out of order, or if an event in the middle for some reason gets lost\n   */\n  buffer: MutationEvent[]\n}\n\nexport class OutOfSyncError extends Error {\n  /**\n   * Attach state to the error for debugging/reporting\n   */\n  state: ListenerSequenceState\n  constructor(message: string, state: ListenerSequenceState) {\n    super(message)\n    this.name = 'OutOfSyncError'\n    this.state = state\n  }\n}\n\nexport class DeadlineExceededError extends OutOfSyncError {\n  constructor(message: string, state: ListenerSequenceState) {\n    super(message, state)\n    this.name = 'DeadlineExceededError'\n  }\n}\n\nexport class MaxBufferExceededError extends OutOfSyncError {\n  constructor(message: string, state: ListenerSequenceState) {\n    super(message, state)\n    this.name = 'MaxBufferExceededError'\n  }\n}\n\ninterface SortListenerEventsOptions {\n  maxBufferSize?: number\n  resolveChainDeadline?: number\n}\n\n/**\n * Takes an input observable of listener events that might arrive out of order, and emits them in sequence\n * If we receive mutation events that doesn't line up in [previousRev, resultRev] pairs we'll put them in a buffer and\n * check if we have an unbroken chain every time we receive a new event\n *\n * If the buffer grows beyond `maxBufferSize`, or if `resolveChainDeadline` milliseconds passes before the chain resolves\n * an OutOfSyncError will be thrown on the stream\n *\n * @internal\n */\nexport function sortListenerEvents(options?: SortListenerEventsOptions) {\n  const {resolveChainDeadline = DEFAULT_DEADLINE_MS, maxBufferSize = DEFAULT_MAX_BUFFER_SIZE} =\n    options || {}\n\n  return (input$: Observable<ListenerEvent>): Observable<ListenerEvent> => {\n    return input$.pipe(\n      // Maintain state: current base revision, a buffer of pending mutation events,\n      // and a list of events to emit.\n      scan(\n        (state: ListenerSequenceState, event: ListenerEvent): ListenerSequenceState => {\n          // When a sync event is received, reset the base and clear any pending mutations.\n          if (event.type === 'sync') {\n            return {\n              base: {revision: event.document?._rev},\n              buffer: [],\n              emitEvents: [event],\n            }\n          }\n          // For mutation events we must have a base revision (from a prior sync event)\n          if (event.type === 'mutation') {\n            if (!state.base) {\n              throw new Error(\n                'Invalid state. Cannot process mutation event without a base sync event',\n              )\n            }\n            // Add the new mutation event into the buffer\n            const buffer = state.buffer.concat(event)\n            const emitEvents: MutationEvent[] = []\n            let baseRevision = state.base.revision\n            let progress = true\n\n            // Try to apply as many buffered mutations as possible.\n            while (progress) {\n              progress = false\n              // Look for a mutation whose previousRev matches the current base.\n              const idx = buffer.findIndex((e) => e.previousRev === baseRevision)\n              if (idx !== -1) {\n                // Remove the event from the buffer and “apply” it.\n                const [next] = buffer.splice(idx, 1)\n                emitEvents.push(next)\n                // If the mutation is a deletion, the new base revision is undefined.\n                baseRevision = next.transition === 'disappear' ? undefined : next.resultRev\n                progress = true\n              }\n            }\n\n            if (buffer.length >= maxBufferSize) {\n              throw new MaxBufferExceededError(\n                `Too many unchainable mutation events (${buffer.length}) waiting to resolve.`,\n                {base: {revision: baseRevision}, buffer, emitEvents},\n              )\n            }\n\n            return {\n              base: {revision: baseRevision},\n              buffer,\n              emitEvents,\n            }\n          }\n          // Any other event is simply forwarded.\n          return {...state, emitEvents: [event]}\n        },\n        {\n          base: undefined,\n          buffer: [] as MutationEvent[],\n          emitEvents: [] as ListenerEvent[],\n        },\n      ),\n      switchMap((state) => {\n        if (state.buffer.length > 0) {\n          return concat(\n            of(state),\n            timer(resolveChainDeadline).pipe(\n              mergeMap(() =>\n                throwError(\n                  () =>\n                    new DeadlineExceededError(\n                      `Did not resolve chain within a deadline of ${resolveChainDeadline}ms`,\n                      state,\n                    ),\n                ),\n              ),\n            ),\n          )\n        }\n        return of(state)\n      }),\n      // Emit all events that are ready to be applied.\n      mergeMap((state) => of(...state.emitEvents)),\n    )\n  }\n}\n\nexport const listen = (\n  {state}: StoreContext<DocumentStoreState>,\n  documentId: string,\n): Observable<RemoteDocument> => {\n  const {sharedListener, fetchDocument} = state.get()\n\n  return sharedListener.events.pipe(\n    concatMap((e) => {\n      if (e.type === 'welcome') {\n        return fetchDocument(documentId).pipe(\n          map((document): SyncEvent => ({type: 'sync', document})),\n        )\n      }\n      if (e.type === 'mutation' && e.documentId === documentId) return of(e)\n      return EMPTY\n    }),\n    sortListenerEvents(),\n    withLatestFrom(\n      state.observable.pipe(\n        map((s) => s.documentStates[documentId]),\n        filter(Boolean),\n        distinctUntilChanged(),\n      ),\n    ),\n    map(([next, documentState]): RemoteDocument => {\n      if (next.type === 'sync') {\n        return {\n          type: 'sync',\n          documentId,\n          document: next.document,\n          revision: next.document?._rev,\n          timestamp: next.document?._updatedAt ?? new Date().toISOString(),\n        }\n      }\n\n      // TODO: from manual testing, mendoza patches seem to be applying\n      // let document\n      // if (next.effects?.apply) {\n      //   document = applyPatch(omit(documentState.remote, '_rev'), next.effects?.apply)\n      // }\n\n      const [document] = Object.values(\n        processMutations({\n          documents: {[documentId]: documentState.remote},\n          mutations: next.mutations as Mutation[],\n          transactionId: next.transactionId,\n          timestamp: next.timestamp,\n        }),\n      )\n\n      const {previousRev, transactionId, timestamp} = next\n\n      return {\n        type: 'mutation',\n        documentId,\n        document: document ?? null,\n        revision: transactionId,\n        timestamp,\n        ...(previousRev && {previousRev}),\n      }\n    }),\n  )\n}\n","// NOTE: this is a stop-gap measure until sychronous groq is out\n// eslint-disable\n// prettier-ignore\nclass e{pattern;patternRe;constructor(e){this.pattern=e,this.patternRe=function(e){const t=[];for(const r of e.split(\".\"))\"*\"===r?t.push(\"[^.]+\"):\"**\"===r?t.push(\".*\"):t.push(r.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\"));return new RegExp(`^${t.join(\".\")}$`)}(e)}matches(e){return this.patternRe.test(e)}toJSON(){return this.pattern}}class t{type=\"stream\";generator;ticker;isDone;data;constructor(e){this.generator=e,this.ticker=null,this.isDone=!1,this.data=[]}isArray(){return!0}async get(){const e=[];for await(const t of this)e.push(await t.get());return e}async first(e=()=>!0){for await(const t of this)if(e(t))return t}async reduce(e,t){let r=t;for await(const t of this)r=await e(r,t);return r}async*[Symbol.asyncIterator](){let e=0;for(;;){for(;e<this.data.length;e++)yield this.data[e];if(this.isDone)return;await this._nextTick()}}_nextTick(){if(this.ticker)return this.ticker;let e;const t=()=>{this.ticker=new Promise((t=>{e=t}))},r=()=>{e(),t()};return t(),(async()=>{for await(const e of this.generator())this.data.push(e),r();this.isDone=!0,r()})(),this.ticker}}const r=/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;function n(e,t){let r=e.toString();for(;r.length<t;)r=`0${r}`;return r}class o{data;type;constructor(e,t){this.data=e,this.type=t}isArray(){return\"array\"===this.type}get(){return this.data}first(e=()=>!0){if(!this.isArray())throw new Error(\"`first` can only be called on array `StaticValue`s\");const t=this.get();for(const r of t){const t=f(r,\"sync\");if(e(t))return t}}reduce(e,t){if(!this.isArray())throw new Error(\"`reduce` can only be called on array `StaticValue`s\");const r=this.get();let n=t;for(const t of r){n=e(n,f(t,\"sync\"))}return n}[Symbol.asyncIterator](){if(Array.isArray(this.data))return function*(e){for(const t of e)yield f(t,\"async\")}(this.data);throw new Error(`Cannot iterate over: ${this.type}`)}}const i=new o(null,\"null\"),s=new o(!0,\"boolean\"),a=new o(!1,\"boolean\");class c{date;constructor(e){this.date=e}static parseToValue(e){const t=function(e){return r.test(e)?new Date(e):null}(e);return t?new o(new c(t),\"datetime\"):i}equals(e){return this.date.getTime()==e.date.getTime()}add(e){const t=new Date(this.date.getTime());return t.setTime(t.getTime()+1e3*e),new c(t)}difference(e){return(this.date.getTime()-e.date.getTime())/1e3}compareTo(e){return this.date.getTime()-e.date.getTime()}toString(){return function(e){const t=n(e.getUTCFullYear(),4),r=n(e.getUTCMonth()+1,2),o=n(e.getUTCDate(),2),i=n(e.getUTCHours(),2),s=n(e.getUTCMinutes(),2),a=n(e.getUTCSeconds(),2);let c=\"\";const u=e.getMilliseconds();return 0!=u&&(c=`.${n(u,3)}`),`${t}-${r}-${o}T${i}:${s}:${a}${c}Z`}(this.date)}toJSON(){return this.toString()}}function u(e){return Number.isFinite(e)?new o(e,\"number\"):i}function p(e){return new o(e,\"string\")}function l(e){return new o(e,\"datetime\")}function f(e,r){return(n=e)&&\"function\"==typeof n.next&&\"sync\"!==r?new t((async function*(){for await(const t of e)yield f(t,\"async\")})):null==e?i:new o(e,y(e));var n}function y(t){return null===t||typeof t>\"u\"?\"null\":Array.isArray(t)?\"array\":t instanceof e?\"path\":t instanceof c?\"datetime\":typeof t}const d=e=>\"object\"==typeof e&&!!e&&\"then\"in e&&\"function\"==typeof e.then;function h(e){const t=e(),r=t.next();if(r.done)return r.value;function n(e){const r=t.next(e);if(r.done)return r.value;const o=r.value;return o&&d(o)?o.then(n):n(o)}const o=r.value;return o&&d(o)?o.then(n):n(o)}function m(e,t){return\"string\"===e.type&&\"string\"===t.type||\"boolean\"===e.type&&\"boolean\"===t.type||\"null\"===e.type&&\"null\"===t.type||\"number\"===e.type&&\"number\"===t.type?e.data===t.data:\"datetime\"===e.type&&\"datetime\"===t.type&&e.data.equals(t.data)}const b=/([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g,g=/([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g,w=/(\\b\\.+|\\.+\\b)/g;function k(e){return e.replace(w,\"\").match(b)||[]}function v(e){return x(e).map((e=>t=>t.some((t=>e.test(t)))))}function x(e){return(e.replace(w,\"\").match(g)||[]).map((e=>new RegExp(`^${e.slice(0,1024).replace(/\\*/g,\".*\")}$`,\"i\")))}const _={datetime:1,number:2,string:3,boolean:4};function A(e,t){const r=y(e);if(r!==y(t))return null;switch(r){case\"number\":case\"boolean\":return e-t;case\"string\":return e<t?-1:e>t?1:0;case\"datetime\":return e.compareTo(t);default:return null}}function E(e,t){const r=y(e),n=y(t),o=_[r]||100,i=_[n]||100;if(o!==i)return o-i;let s=A(e,t);return null===s&&(s=0),s}const j={\"==\":function(e,t){return m(e,t)?s:a},\"!=\":function(e,t){return m(e,t)?a:s},\">\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r>0?s:a},\">=\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r>=0?s:a},\"<\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r<0?s:a},\"<=\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r<=0?s:a},in:function(e,t){return h((function*(){return\"path\"===t.type?\"string\"!==e.type?i:t.data.matches(e.data)?s:a:t.isArray()?(yield t.first((t=>m(e,t))))?s:a:i}))},match:function(e,t){return h((function*(){const r=yield e.get(),n=yield t.get();let o,i=[];if(Array.isArray(r)?i=r.filter((e=>\"string\"==typeof e)):\"string\"==typeof r&&(i=[r]),Array.isArray(n)?o=n.filter((e=>\"string\"==typeof e)):\"string\"==typeof n&&(o=[n]),!o?.length)return a;return function(e,t){return 0!==e.length&&0!==t.length&&t.every((t=>t(e)))}(i.flatMap(k),o.flatMap(v))?s:a}))},\"+\":function(e,r,n){return\"datetime\"===e.type&&\"number\"===r.type?l(e.data.add(r.data)):\"number\"===e.type&&\"number\"===r.type?u(e.data+r.data):\"string\"===e.type&&\"string\"===r.type?p(e.data+r.data):\"object\"===e.type&&\"object\"===r.type?f({...e.data,...r.data},n):\"array\"===e.type&&\"array\"===r.type?f(e.data.concat(r.data),n):e.isArray()&&r.isArray()?\"sync\"===n?h((function*(){const t=[...yield e.get(),...yield r.get()];return new o(t,\"array\")})):new t((async function*(){for await(const t of e)yield t;for await(const e of r)yield e})):i},\"-\":function(e,t){return\"datetime\"===e.type&&\"number\"===t.type?l(e.data.add(-t.data)):\"datetime\"===e.type&&\"datetime\"===t.type?u(e.data.difference(t.data)):\"number\"===e.type&&\"number\"===t.type?u(e.data-t.data):i},\"*\":S(((e,t)=>e*t)),\"/\":S(((e,t)=>e/t)),\"%\":S(((e,t)=>e%t)),\"**\":S(((e,t)=>Math.pow(e,t)))};function S(e){return function(t,r){if(\"number\"===t.type&&\"number\"===r.type){return u(e(t.data,r.data))}return i}}let O=class e{params;source;value;parent;context;isHidden=!1;constructor(e,t,r,n,o){this.params=e,this.source=t,this.value=r,this.context=n,this.parent=o}createNested(t){return this.isHidden?new e(this.params,this.source,t,this.context,this.parent):new e(this.params,this.source,t,this.context,this)}createHidden(e){const t=this.createNested(e);return t.isHidden=!0,t}};function I(e,t,r){return(0,$[e.type])(e,t,r)}const $={This:(e,t)=>t.value,Selector(){throw new Error(\"Selectors can not be evaluated\")},Everything:(e,t)=>t.source,Parameter:({name:e},t,r)=>f(t.params[e],r),Context({key:e},t){if(\"before\"===e||\"after\"===e)return t.context[e]||i;throw new Error(`unknown context key: ${e}`)},Parent({n:e},t){let r=t;for(let t=0;t<e;t++){if(!r.parent)return i;r=r.parent}return r.value},OpCall:({op:e,left:t,right:r},n,o)=>h((function*(){const i=j[e];if(!i)throw new Error(`Unknown operator: ${e}`);const s=yield I(t,n,o),a=yield I(r,n,o);return yield i(s,a,o)})),Select:({alternatives:e,fallback:t},r,n)=>h((function*(){for(const t of e){const e=yield I(t.condition,r,n);if(\"boolean\"===e.type&&!0===e.data)return yield I(t.value,r,n)}return t?yield I(t,r,n):i})),InRange:({base:e,left:t,right:r,isInclusive:n},o,c)=>h((function*(){const u=yield I(e,o,c),p=yield I(t,o,c),l=yield I(r,o,c),f=A(yield u.get(),yield p.get());if(null===f)return i;const y=A(yield u.get(),yield l.get());return null===y?i:n?f>=0&&y<=0?s:a:f>=0&&y<0?s:a})),Filter:({base:e,expr:r},n,s)=>h((function*(){const a=yield I(e,n,s);if(!a.isArray())return i;if(\"sync\"===s){const e=yield a.get(),t=[];for(const o of e){const e=f(o,s),i=n.createNested(e),a=yield I(r,i,s);\"boolean\"===a.type&&!0===a.data&&t.push(o)}return new o(t,\"array\")}return new t((async function*(){for await(const e of a){const t=n.createNested(e),o=await I(r,t,s);\"boolean\"===o.type&&!0===o.data&&(yield e)}}))})),Projection:({base:e,expr:t},r,n)=>h((function*(){const o=yield I(e,r,n);if(\"object\"!==o.type)return i;const s=r.createNested(o);return yield I(t,s,n)})),FuncCall:({func:e,args:t},r,n)=>e(t,r,n),PipeFuncCall:({func:e,base:t,args:r},n,o)=>h((function*(){const i=yield I(t,n,o);return yield e(i,r,n,o)})),AccessAttribute:({base:e,name:t},r,n)=>h((function*(){let o=r.value;return e&&(o=yield I(e,r,n)),\"object\"===o.type&&o.data.hasOwnProperty(t)?f(o.data[t],n):i})),AccessElement:({base:e,index:t},r,n)=>h((function*(){const o=yield I(e,r,n);if(!o.isArray())return i;const s=yield o.get();return f(s[t<0?t+s.length:t],n)})),Slice:({base:e,left:t,right:r,isInclusive:n},o,s)=>h((function*(){const a=yield I(e,o,s);if(!a.isArray())return i;const c=yield a.get();let u=t,p=r;return u<0&&(u=c.length+u),p<0&&(p=c.length+p),n&&p++,u<0&&(u=0),p<0&&(p=0),f(c.slice(u,p),s)})),Deref:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);if(!t.source.isArray()||\"object\"!==n.type)return i;const o=n.data._ref;if(\"string\"!=typeof o)return i;if(t.context.dereference){return f(yield t.context.dereference({_ref:o}),r)}return(yield t.source.first((e=>\"object\"===e.type&&o==e.data._id)))||i})),Value:({value:e},t,r)=>f(e,r),Group:({base:e},t,r)=>I(e,t,r),Object:({attributes:e},t,r)=>h((function*(){const n={};for(const o of e){const e=o.type;switch(o.type){case\"ObjectAttributeValue\":{const e=yield I(o.value,t,r);n[o.name]=yield e.get();break}case\"ObjectConditionalSplat\":{const e=yield I(o.condition,t,r);if(\"boolean\"!==e.type||!1===e.data)continue;const i=yield I(o.value,t,r);\"object\"===i.type&&Object.assign(n,i.data);break}case\"ObjectSplat\":{const e=yield I(o.value,t,r);\"object\"===e.type&&Object.assign(n,e.data);break}default:throw new Error(`Unknown node type: ${e}`)}}return f(n,r)})),Array:({elements:e},r,n)=>h((function*(){if(\"sync\"===n){const t=[];for(const o of e){const e=yield I(o.value,r,n);if(o.isSplat){if(e.isArray()){const r=yield e.get();t.push(...r)}}else t.push(yield e.get())}return new o(t,\"array\")}return new t((async function*(){for(const t of e){const e=await I(t.value,r,n);if(t.isSplat){if(e.isArray())for await(const t of e)yield t}else yield e}}))})),Tuple(){throw new Error(\"tuples can not be evaluated\")},Or:({left:e,right:t},r,n)=>h((function*(){const o=yield I(e,r,n),c=yield I(t,r,n);return\"boolean\"===o.type&&!0===o.data||\"boolean\"===c.type&&!0===c.data?s:\"boolean\"!==o.type||\"boolean\"!==c.type?i:a})),And:({left:e,right:t},r,n)=>h((function*(){const o=yield I(e,r,n),c=yield I(t,r,n);return\"boolean\"===o.type&&!1===o.data||\"boolean\"===c.type&&!1===c.data?a:\"boolean\"!==o.type||\"boolean\"!==c.type?i:s})),Not:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return\"boolean\"!==n.type?i:n.data?a:s})),Neg:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return\"number\"!==n.type?i:u(-n.data)})),Pos:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return\"number\"!==n.type?i:u(n.data)})),Asc:()=>i,Desc:()=>i,ArrayCoerce:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return n.isArray()?n:i})),Map:({base:e,expr:r},n,s)=>h((function*(){const a=yield I(e,n,s);if(!a.isArray())return i;if(\"sync\"===s){const e=yield a.get(),t=[];for(const o of e){const e=f(o,\"sync\"),i=n.createHidden(e),a=yield I(r,i,s);t.push(yield a.get())}return new o(t,\"array\")}return new t((async function*(){for await(const e of a){const t=n.createHidden(e);yield await I(r,t,s)}}))})),FlatMap:({base:e,expr:r},n,s)=>h((function*(){const a=yield I(e,n,s);if(!a.isArray())return i;if(\"sync\"===s){const e=yield a.get(),t=[];for(const o of e){const e=f(o,\"sync\"),i=n.createHidden(e),a=yield I(r,i,s);if(a.isArray()){const e=yield a.get();t.push(...e)}else{const e=yield a.get();t.push(e)}}return new o(t,\"array\")}return new t((async function*(){for await(const e of a){const t=n.createHidden(e),o=await I(r,t,s);if(o.isArray())for await(const e of o)yield e;else yield o}}))}))};function C(e,t={}){const r=f(t.root,\"sync\"),n=f(t.dataset,\"sync\"),o={...t.params},i=new O(o,n,r,function(e={},t){return{timestamp:e.timestamp||new Date,identity:void 0===e.identity?\"me\":e.identity,sanity:e.sanity,after:e.after?f(e.after,t):null,before:e.before?f(e.before,t):null,dereference:e.dereference}}(t,\"sync\"),null),s=I(e,i,\"sync\");if(d(s))throw new Error(\"Unexpected promise when evaluating. This expression may not support evaluateSync.\");return s}function M(e){switch(e.type){case\"Group\":return M(e.base);case\"Value\":case\"Parameter\":return!0;case\"Pos\":case\"Neg\":return M(e.base);case\"OpCall\":switch(e.op){case\"+\":case\"-\":case\"*\":case\"/\":case\"%\":case\"**\":return M(e.left)&&M(e.right);default:return!1}default:return!1}}const T=new O({},i,i,{timestamp:new Date(0),identity:\"me\",before:null,after:null},null);function P(e){return M(e)?function(e){const t=I(e,T,\"sync\");if(d(t))throw new Error(\"BUG: constant evaluate should never return a promise\");return t}(e):null}function N(e,t){return h((function*(){if(\"object\"===e.type)return V(e.data);if(e.isArray()){const r=yield U(e,t);if(r.length>0)return r.join(\"\\n\\n\")}return null}))}function U(e,t){return h((function*(){const r=[],n=yield e.get();for(const e of n){const n=f(e,t);if(\"object\"===n.type){const e=V(n.data);null!==e&&r.push(e)}else if(n.isArray()){const e=yield U(n,t);r.push(...e)}}return r}))}function V(e){if(\"string\"!=typeof e._type)return null;const t=e.children;if(!Array.isArray(t))return null;let r=\"\";for(const e of t)e&&\"object\"==typeof e&&\"string\"==typeof e._type&&\"span\"===e._type&&\"string\"==typeof e.text&&(r+=e.text);return r}const D=1.2;function F(e,t,r){return h((function*(){if(\"OpCall\"===e.type&&\"match\"===e.op){return function(e,t){return h((function*(){const r=yield e.get(),n=yield t.get();let o,i=[];if(Array.isArray(r)?i=r.filter((e=>\"string\"==typeof e)):\"string\"==typeof r&&(i=[r]),Array.isArray(n)?o=n.filter((e=>\"string\"==typeof e)):\"string\"==typeof n&&(o=[n]),!o?.length)return 0;const s=i.flatMap(k),a=o.flatMap(x);if(0===s.length||0===a.length)return 0;let c=0;for(const e of a){const t=s.reduce(((t,r)=>t+(e.test(r)?1:0)),0);c+=2.2*t/(t+D)}return c}))}(yield I(e.left,t,r),yield I(e.right,t,r))}if(\"FuncCall\"===e.type&&\"boost\"===e.name){const n=yield F(e.args[0],t,r),o=yield I(e.args[1],t,r);return\"number\"===o.type&&n>0?n+o.data:0}switch(e.type){case\"Or\":return(yield F(e.left,t,r))+(yield F(e.right,t,r));case\"And\":{const n=yield F(e.left,t,r),o=yield F(e.right,t,r);return 0===n||0===o?0:n+o}default:{const n=yield I(e,t,r);return\"boolean\"===n.type&&!0===n.data?1:0}}}))}function R(e,t){switch(y(e)){case\"array\":for(const r of e)if(R(r,t))return!0;break;case\"object\":if(e._ref)return t.has(e._ref);for(const r of Object.values(e))if(R(r,t))return!0}return!1}const q={anywhere:function(){throw new Error(\"not implemented\")}};q.anywhere.arity=1,q.coalesce=function(e,t,r){return h((function*(){for(const n of e){const e=yield I(n,t,r);if(\"null\"!==e.type)return e}return i}))},q.count=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray())return i;return u(yield n.reduce((e=>e+1),0))}))},q.count.arity=1,q.dateTime=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);return\"datetime\"===n.type?n:\"string\"!==n.type?i:c.parseToValue(n.data)}))},q.dateTime.arity=1,q.defined=function(e,t,r){return h((function*(){return\"null\"===(yield I(e[0],t,r)).type?a:s}))},q.defined.arity=1,q.identity=function(e,t){return p(t.context.identity)},q.identity.arity=0,q.length=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"string\"===n.type)return u(function(e){let t=0;for(let r=0;r<e.length;r++){const n=e.charCodeAt(r);n>=55296&&n<=56319||t++}return t}(n.data));if(n.isArray()){return u(yield n.reduce((e=>e+1),0))}return i}))},q.length.arity=1,q.path=function(t,r,n){return h((function*(){const s=yield I(t[0],r,n);return\"string\"!==s.type?i:(a=new e(s.data),new o(a,\"path\"));var a}))},q.path.arity=1,q.string=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);switch(n.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":return p(`${n.data}`);default:return i}}))},q.string.arity=1,q.references=function(e,t,r){return h((function*(){const n=new Set;for(const o of e){const e=yield I(o,t,r);if(\"string\"===e.type)n.add(e.data);else if(e.isArray()){const t=yield e.get();for(const e of t)\"string\"==typeof e&&n.add(e)}}if(0===n.size)return a;return R(yield t.value.get(),n)?s:a}))},q.references.arity=e=>e>=1,q.round=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"number\"!==n.type)return i;const o=n.data;let s=0;if(2===e.length){const n=yield I(e[1],t,r);if(\"number\"!==n.type||n.data<0||!Number.isInteger(n.data))return i;s=n.data}return u(0===s?o<0?-Math.round(-o):Math.round(o):Number(o.toFixed(s)))}))},q.round.arity=e=>e>=1&&e<=2,q.now=function(e,t){return p(t.context.timestamp.toISOString())},q.now.arity=0,q.boost=function(){throw new Error(\"unexpected boost call\")},q.boost.arity=2;const G={lower:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);return\"string\"!==n.type?i:p(n.data.toLowerCase())}))}};G.lower.arity=1,G.upper=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);return\"string\"!==n.type?i:p(n.data.toUpperCase())}))},G.upper.arity=1,G.split=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=yield I(e[1],t,r);return\"string\"!==o.type?i:0===n.data.length?f([],r):0===o.data.length?f(Array.from(n.data),r):f(n.data.split(o.data),r)}))},G.split.arity=2,q.lower=G.lower,q.upper=G.upper,G.startsWith=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=yield I(e[1],t,r);return\"string\"!==o.type?i:n.data.startsWith(o.data)?s:a}))},G.startsWith.arity=2;const H={join:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray())return i;const o=yield I(e[1],t,r);if(\"string\"!==o.type)return i;let s=\"\",a=!1;const c=yield n.get();for(const e of c){const t=f(e,r);switch(a&&(s+=o.data),t.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":s+=`${t.data}`;break;default:return i}a=!0}return f(s,r)}))}};H.join.arity=2,H.compact=function(e,r,n){return h((function*(){const o=yield I(e[0],r,n);return o.isArray()?new t((async function*(){for await(const e of o)\"null\"!==e.type&&(yield e)})):i}))},H.compact.arity=1,H.unique=function(e,r,n){return h((function*(){const s=yield I(e[0],r,n);if(!s.isArray())return i;if(\"sync\"===n){const e=yield s.get(),t=new Set,r=[];for(const n of e){const e=f(n,\"sync\");switch(e.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":t.has(n)||(t.add(n),r.push(e));break;default:r.push(e)}}return new o(r,\"array\")}return new t((async function*(){const e=new Set;for await(const t of s)switch(t.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":e.has(t.data)||(e.add(t.data),yield t);break;default:yield t}}))}))},H.unique.arity=1,H.intersects=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray())return i;const o=yield I(e[1],t,r);return o.isArray()?(yield n.first((e=>!!o.first((t=>m(e,t))))))?s:a:i}))},H.intersects.arity=2;const B={text:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r),o=yield N(n,r);return null===o?i:p(o)}))}};B.text.arity=1;const W={projectId:function(e,t){return t.context.sanity?p(t.context.sanity.projectId):i},dataset:function(e,t){return t.context.sanity?p(t.context.sanity.dataset):i},versionsOf:function(e,t,r){return h((function*(){if(!t.source.isArray())return i;const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=n.data;return f(yield t.source.reduce(((e,t)=>{if(\"object\"===y(t)){const r=t.get();r&&\"_id\"in r&&2===r._id.split(\".\").length&&r._id.endsWith(`.${o}`)&&\"_version\"in r&&\"object\"==typeof r._version&&e.push(r._id)}return e}),[]),r)}))}};W.versionsOf.arity=1,W.partOfRelease=function(e,t,r){return h((function*(){if(!t.source.isArray())return i;const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=n.data;return f(yield t.source.reduce(((e,t)=>{if(\"object\"===y(t)){const r=t.get();r&&\"_id\"in r&&2===r._id.split(\".\").length&&r._id.startsWith(`${o}.`)&&\"_version\"in r&&\"object\"==typeof r._version&&e.push(r._id)}return e}),[]),r)}))},W.partOfRelease.arity=1;const Z={order:function(e,t,r,n){return h((function*(){if(!e.isArray())return i;const o=[],s=[];let a=0;for(let e of t){let t=\"asc\";\"Desc\"===e.type?(t=\"desc\",e=e.base):\"Asc\"===e.type&&(e=e.base),o.push(e),s.push(t),a++}const c=[];let u=0;const p=yield e.get();for(const e of p){const t=f(e,n),i=r.createNested(t),s=[yield t.get(),u];for(let e=0;e<a;e++){const t=yield I(o[e],i,n);s.push(yield t.get())}c.push(s),u++}return c.sort(((e,t)=>{for(let r=0;r<a;r++){let n=E(e[r+2],t[r+2]);if(\"desc\"===s[r]&&(n=-n),0!==n)return n}return e[1]-t[1]})),f(c.map((e=>e[0])),n)}))}};Z.order.arity=e=>e>=1,Z.score=function(e,t,r,n){return h((function*(){if(!e.isArray())return i;const o=[],s=[],a=yield e.get();for(const e of a){const i=f(e,n);if(\"object\"!==i.type){o.push(yield i.get());continue}const a=r.createNested(i);let c=\"number\"==typeof i.data._score?i.data._score:0;for(const e of t)c+=(yield F(e,a,n));const u=Object.assign({},i.data,{_score:c});s.push(u)}return s.sort(((e,t)=>t._score-e._score)),f(s,n)}))},Z.score.arity=e=>e>=1;const z={operation:function(e,t){const r=null!==t.context.before,n=null!==t.context.after;return r&&n?p(\"update\"):n?p(\"create\"):r?p(\"delete\"):i},changedAny:()=>{throw new Error(\"not implemented\")}};z.changedAny.arity=1,z.changedAny.mode=\"delta\",z.changedOnly=()=>{throw new Error(\"not implemented\")},z.changedOnly.arity=1,z.changedOnly.mode=\"delta\";const J={changedAny:()=>{throw new Error(\"not implemented\")}};J.changedAny.arity=3,J.changedOnly=()=>{throw new Error(\"not implemented\")},J.changedOnly.arity=3;const Q={min:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;const o=yield n.get();let s;for(const e of o)\"number\"==typeof e&&(void 0===s||e<s)&&(s=e);return f(s,r)}))}};Q.min.arity=1,Q.max=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;const o=yield n.get();let s;for(const e of o)\"number\"==typeof e&&(void 0===s||e>s)&&(s=e);return f(s,r)}))},Q.max.arity=1,Q.sum=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;return f(yield n.reduce(((e,t)=>\"number\"!==t.type?e:e+t.data),0),r)}))},Q.sum.arity=1,Q.avg=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;const o=yield n.reduce(((e,t)=>\"number\"!==t.type?e:e+1),0),s=yield n.reduce(((e,t)=>\"number\"!==t.type?e:e+t.data),0);return 0===o?i:f(s/o,r)}))},Q.avg.arity=1;const L={now:function(e,t){return l(new c(t.context.timestamp))}};L.now.arity=0;const Y={global:q,string:G,array:H,pt:B,delta:z,diff:J,sanity:W,math:Q,dateTime:L};class K{string;marks;index;parseOptions;allowBoost=!1;constructor(e,t,r){this.string=e,this.marks=t,this.index=0,this.parseOptions=r}hasMark(e=0){return this.index+e<this.marks.length}getMark(e=0){return this.marks[this.index+e]}shift(){this.index+=1}process(e){const t=this.marks[this.index];this.shift();const r=e[t.name];if(!r)throw new Error(`Unknown handler: ${t.name}`);return r.call(e,this,t)}processString(){return this.shift(),this.processStringEnd()}processStringEnd(){const e=this.marks[this.index-1],t=this.marks[this.index];return this.shift(),this.string.slice(e.position,t.position)}slice(e){const t=this.marks[this.index].position;return this.string.slice(t,t+e)}}const X=/^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/,ee=/^\\d+/,te=/^[a-zA-Z_][a-zA-Z_0-9]*/;function re(e,t,r){let n,o=t;switch(e[t]){case\"+\":{let r=re(e,se(e,t+1),10);if(\"error\"===r.type)return r;n=[{name:\"pos\",position:o}].concat(r.marks),t=r.position;break}case\"-\":{let r=re(e,se(e,t+1),8);if(\"error\"===r.type)return r;n=[{name:\"neg\",position:o}].concat(r.marks),t=r.position;break}case\"(\":{let r=re(e,se(e,t+1),0);if(\"error\"===r.type)return r;switch(e[t=se(e,r.position)]){case\",\":for(n=[{name:\"tuple\",position:o}].concat(r.marks),t=se(e,t+1);;){if(r=re(e,t,0),\"error\"===r.type)return r;if(\",\"!==e[t=se(e,r.position)])break;t=se(e,t+1)}if(\")\"!==e[t])return{type:\"error\",position:t};t++,n.push({name:\"tuple_end\",position:t});break;case\")\":t++,n=[{name:\"group\",position:o}].concat(r.marks);break;default:return{type:\"error\",position:t}}break}case\"!\":{let r=re(e,se(e,t+1),10);if(\"error\"===r.type)return r;n=[{name:\"not\",position:o}].concat(r.marks),t=r.position;break}case\"{\":{let r=ie(e,t);if(\"error\"===r.type)return r;n=r.marks,t=r.position;break}case\"[\":if(n=[{name:\"array\",position:t}],\"]\"!==e[t=se(e,t+1)])for(;;){\"...\"===e.slice(t,t+3)&&(n.push({name:\"array_splat\",position:t}),t=se(e,t+3));let r=re(e,t,0);if(\"error\"===r.type)return r;if(n=n.concat(r.marks),\",\"!==e[t=se(e,t=r.position)]||\"]\"===e[t=se(e,t+1)])break}if(\"]\"!==e[t])return{type:\"error\",position:t};t++,n.push({name:\"array_end\",position:t});break;case\"'\":case'\"':{let r=function(e,t){let r=e[t];t+=1;const n=[{name:\"str\",position:t}];e:for(;;t++){if(t>e.length)return{type:\"error\",position:t};switch(e[t]){case r:n.push({name:\"str_end\",position:t}),t++;break e;case\"\\\\\":n.push({name:\"str_pause\",position:t}),\"u\"===e[t+1]?\"{\"===e[t+2]?(n.push({name:\"unicode_hex\",position:t+3}),t=e.indexOf(\"}\",t+3),n.push({name:\"unicode_hex_end\",position:t})):(n.push({name:\"unicode_hex\",position:t+2}),n.push({name:\"unicode_hex_end\",position:t+6}),t+=5):(n.push({name:\"single_escape\",position:t+1}),t+=1),n.push({name:\"str_start\",position:t+1})}}return{type:\"success\",marks:n,position:t}}(e,t);if(\"error\"===r.type)return r;n=r.marks,t=r.position;break}case\"^\":for(t++,n=[];\".\"===e[t]&&\"^\"===e[t+1];)n.push({name:\"dblparent\",position:o}),t+=2;n.push({name:\"parent\",position:o});break;case\"@\":n=[{name:\"this\",position:o}],t++;break;case\"*\":n=[{name:\"everything\",position:o}],t++;break;case\"$\":{let r=ae(e,t+1,te);r&&(n=[{name:\"param\",position:o},{name:\"ident\",position:o+1},{name:\"ident_end\",position:t+=1+r}]);break}default:{let r=ae(e,t,ee);if(r){let i=\"integer\";if(\".\"===e[t+=r]){let r=ae(e,t+1,ee);r&&(i=\"float\",t+=1+r)}if(\"e\"===e[t]||\"E\"===e[t]){i=\"sci\",(\"+\"===e[++t]||\"-\"===e[t])&&t++;let r=ae(e,t,ee);if(!r)return{type:\"error\",position:t};t+=r}n=[{name:i,position:o},{name:i+\"_end\",position:t}];break}let i=ae(e,t,te);if(i){switch(e[t+=i]){case\":\":case\"(\":{let r=oe(e,o,t);if(\"error\"===r.type)return r;n=r.marks,t=r.position;break}default:n=[{name:\"this_attr\",position:o},{name:\"ident\",position:o},{name:\"ident_end\",position:t}]}break}}}if(!n)return{type:\"error\",position:t};let i,s=12;e:for(;;){let a=se(e,t);if(a===e.length){t=a;break}if(i=ne(e,a),\"success\"!==i.type)switch(e[a]){case\"=\":switch(e[a+1]){case\">\":{if(r>1||s<=1)break e;let i=re(e,se(e,a+2),1);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"pair\",position:o}),t=i.position,s=1;break}case\"=\":{if(r>4||s<=4)break e;let i=re(e,se(e,a+2),5);if(\"error\"===i.type)return i;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+2}),n=n.concat(i.marks),t=i.position,s=4;break}default:break e}break;case\"+\":{if(r>6||s<6)break e;let i=re(e,se(e,a+1),7);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"add\",position:o}),t=i.position,s=6;break}case\"-\":{if(r>6||s<6)break e;let i=re(e,se(e,a+1),7);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"sub\",position:o}),t=i.position,s=6;break}case\"*\":{if(\"*\"===e[a+1]){if(r>8||s<=8)break e;let i=re(e,se(e,a+2),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"pow\",position:o}),t=i.position,s=8;break}if(r>7||s<7)break e;let i=re(e,se(e,a+1),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"mul\",position:o}),t=i.position,s=7;break}case\"/\":{if(r>7||s<7)break e;let i=re(e,se(e,a+1),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"div\",position:o}),t=i.position,s=7;break}case\"%\":{if(r>7||s<7)break e;let i=re(e,se(e,a+1),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"mod\",position:o}),t=i.position,s=7;break}case\"<\":case\">\":{if(r>4||s<=4)break e;let i=a+1;\"=\"===e[i]&&i++;let c=re(e,se(e,i),5);if(\"error\"===c.type)return c;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:i}),n=n.concat(c.marks),t=c.position,s=4;break}case\"|\":if(\"|\"===e[a+1]){if(r>2||s<2)break e;let i=re(e,se(e,a+2),3);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"or\",position:o}),t=i.position,s=2}else{if(r>11||s<11)break e;let i=se(e,a+1),c=ae(e,i,te);if(!c)return{type:\"error\",position:i};if(\"(\"===e[t=i+c]||\":\"===e[t]){let r=oe(e,i,t);if(\"error\"===r.type)return r;n=n.concat(r.marks),n.unshift({name:\"pipecall\",position:o}),t=r.position,s=11}}break;case\"&\":{if(\"&\"!=e[a+1]||r>3||s<3)break e;let i=re(e,se(e,a+2),4);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"and\",position:o}),t=i.position,s=3;break}case\"!\":{if(\"=\"!==e[a+1]||r>4||s<=4)break e;let i=re(e,se(e,a+2),5);if(\"error\"===i.type)return i;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+2}),n=n.concat(i.marks),t=i.position,s=4;break}case\"d\":if(\"desc\"!==e.slice(a,a+4)||r>4||s<4)break e;n.unshift({name:\"desc\",position:o}),t=a+4,s=4;break;case\"a\":if(\"asc\"!==e.slice(a,a+3)||r>4||s<4)break e;n.unshift({name:\"asc\",position:o}),t=a+3,s=4;break;default:switch(ce(e,a,te)){case\"in\":{if(r>4||s<=4)break e;let i=!1;\"(\"===e[t=se(e,a+2)]&&(i=!0,t=se(e,t+1));let c=t,u=re(e,t,5);if(\"error\"===u.type)return u;if(\".\"===e[t=se(e,u.position)]&&\".\"===e[t+1]){let r=\"inc_range\";\".\"===e[t+2]?(r=\"exc_range\",t=se(e,t+3)):t=se(e,t+2);let i=re(e,t,5);if(\"error\"===i.type)return i;n.unshift({name:\"in_range\",position:o}),n=n.concat({name:r,position:c},u.marks,i.marks),t=i.position}else n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+2}),n=n.concat(u.marks);if(i){if(\")\"!==e[t=se(e,t)])return{type:\"error\",position:t};t++}s=4;break}case\"match\":{if(r>4||s<=4)break e;let i=re(e,se(e,a+5),5);if(\"error\"===i.type)return i;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+5}),n=n.concat(i.marks),t=i.position,s=4;break}default:break e}}else{for(n.unshift({name:\"traverse\",position:o});\"success\"===i.type;)n=n.concat(i.marks),i=ne(e,se(e,t=i.position));n.push({name:\"traversal_end\",position:t})}}return{type:\"success\",marks:n,position:t,failPosition:\"error\"===i?.type&&i.position}}function ne(e,t){let r=t;switch(e[t]){case\".\":{let n=t=se(e,t+1),o=ae(e,t,te);return o?{type:\"success\",marks:[{name:\"attr_access\",position:r},{name:\"ident\",position:n},{name:\"ident_end\",position:t+=o}],position:t}:{type:\"error\",position:t}}case\"-\":if(\">\"!==e[t+1])return{type:\"error\",position:t};let n=[{name:\"deref\",position:r}],o=se(e,t+=2),i=ae(e,o,te);return i&&(t=o+i,n.push({name:\"deref_attr\",position:o},{name:\"ident\",position:o},{name:\"ident_end\",position:t})),{type:\"success\",marks:n,position:t};case\"[\":{if(\"]\"===e[t=se(e,t+1)])return{type:\"success\",marks:[{name:\"array_postfix\",position:r}],position:t+1};let n=t,o=re(e,t,0);if(\"error\"===o.type)return o;if(\".\"===e[t=se(e,o.position)]&&\".\"===e[t+1]){let i=\"inc_range\";\".\"===e[t+2]?(i=\"exc_range\",t+=3):t+=2;let s=re(e,t=se(e,t),0);return\"error\"===s.type?s:\"]\"!==e[t=se(e,s.position)]?{type:\"error\",position:t}:{type:\"success\",marks:[{name:\"slice\",position:r},{name:i,position:n}].concat(o.marks,s.marks),position:t+1}}return\"]\"!==e[t]?{type:\"error\",position:t}:{type:\"success\",marks:[{name:\"square_bracket\",position:r}].concat(o.marks),position:t+1}}case\"|\":if(\"{\"===e[t=se(e,t+1)]){let n=ie(e,t);return\"error\"===n.type||n.marks.unshift({name:\"projection\",position:r}),n}break;case\"{\":{let n=ie(e,t);return\"error\"===n.type||n.marks.unshift({name:\"projection\",position:r}),n}}return{type:\"error\",position:t}}function oe(e,t,r){let n=[];if(n.push({name:\"func_call\",position:t}),\":\"===e[r]&&\":\"===e[r+1]){n.push({name:\"namespace\",position:t}),n.push({name:\"ident\",position:t},{name:\"ident_end\",position:r});let o=ae(e,r=se(e,r+2),te);if(!o)return{type:\"error\",position:r};if(n.push({name:\"ident\",position:r},{name:\"ident_end\",position:r+o}),\"(\"!==e[r=se(e,r+o)])return{type:\"error\",position:r};r=se(e,++r)}else n.push({name:\"ident\",position:t},{name:\"ident_end\",position:r}),r=se(e,r+1);let o=r;if(\")\"!==e[r])for(;;){let t=re(e,r,0);if(\"error\"===t.type)return t;if(n=n.concat(t.marks),o=t.position,\",\"!==e[r=se(e,t.position)]||\")\"===e[r=se(e,r+1)])break}return\")\"!==e[r]?{type:\"error\",position:r}:(n.push({name:\"func_args_end\",position:o}),{type:\"success\",marks:n,position:r+1})}function ie(e,t){let r=[{name:\"object\",position:t}];for(t=se(e,t+1);\"}\"!==e[t];){let n=t;if(\"...\"===e.slice(t,t+3))if(\"}\"!==e[t=se(e,t+3)]&&\",\"!==e[t]){let o=re(e,t,0);if(\"error\"===o.type)return o;r.push({name:\"object_splat\",position:n}),r=r.concat(o.marks),t=o.position}else r.push({name:\"object_splat_this\",position:n});else{let o=re(e,t,0);if(\"error\"===o.type)return o;let i=se(e,o.position);if(\"str\"===o.marks[0].name&&\":\"===e[i]){let s=re(e,se(e,i+1),0);if(\"error\"===s.type)return s;r.push({name:\"object_pair\",position:n}),r=r.concat(o.marks,s.marks),t=s.position}else r=r.concat({name:\"object_expr\",position:t},o.marks),t=o.position}if(\",\"!==e[t=se(e,t)])break;t=se(e,t+1)}return\"}\"!==e[t]?{type:\"error\",position:t}:(t++,r.push({name:\"object_end\",position:t}),{type:\"success\",marks:r,position:t})}function se(e,t){return t+ae(e,t,X)}function ae(e,t,r){let n=r.exec(e.slice(t));return n?n[0].length:0}function ce(e,t,r){let n=r.exec(e.slice(t));return n?n[0]:null}function ue(e,t){return r=>t(e(r))}function pe(e){return t=>({type:\"Map\",base:t,expr:e({type:\"This\"})})}function le(e,t){if(!t)return{type:\"a-a\",build:e};switch(t.type){case\"a-a\":return{type:\"a-a\",build:ue(e,t.build)};case\"a-b\":return{type:\"a-b\",build:ue(e,t.build)};case\"b-b\":return{type:\"a-a\",build:ue(e,pe(t.build))};case\"b-a\":return{type:\"a-a\",build:ue(e,(r=t.build,e=>({type:\"FlatMap\",base:e,expr:r({type:\"This\"})})))};default:throw new Error(`unknown type: ${t.type}`)}var r}function fe(e,t){if(!t)return{type:\"b-b\",build:e};switch(t.type){case\"a-a\":case\"b-a\":return{type:\"b-a\",build:ue(e,t.build)};case\"a-b\":case\"b-b\":return{type:\"b-b\",build:ue(e,t.build)};default:throw new Error(`unknown type: ${t.type}`)}}const ye={\"'\":\"'\",'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"};function de(e){const t=parseInt(e,16);return String.fromCharCode(t)}class he extends Error{name=\"GroqQueryError\"}const me={group:e=>({type:\"Group\",base:e.process(me)}),everything:()=>({type:\"Everything\"}),this:()=>({type:\"This\"}),parent:()=>({type:\"Parent\",n:1}),dblparent:e=>({type:\"Parent\",n:e.process(me).n+1}),traverse(e){const t=e.process(me),r=[];for(;\"traversal_end\"!==e.getMark().name;)r.push(e.process(ge));e.shift();let n=null;for(let e=r.length-1;e>=0;e--)n=r[e](n);if((\"Everything\"===t.type||\"Array\"===t.type||\"PipeFuncCall\"===t.type)&&(n=le((e=>e),n)),null===n)throw new Error(\"BUG: unexpected empty traversal\");return n.build(t)},this_attr(e){const t=e.processString();return\"null\"===t?{type:\"Value\",value:null}:\"true\"===t?{type:\"Value\",value:!0}:\"false\"===t?{type:\"Value\",value:!1}:{type:\"AccessAttribute\",name:t}},neg:e=>({type:\"Neg\",base:e.process(me)}),pos:e=>({type:\"Pos\",base:e.process(me)}),add:e=>({type:\"OpCall\",op:\"+\",left:e.process(me),right:e.process(me)}),sub:e=>({type:\"OpCall\",op:\"-\",left:e.process(me),right:e.process(me)}),mul:e=>({type:\"OpCall\",op:\"*\",left:e.process(me),right:e.process(me)}),div:e=>({type:\"OpCall\",op:\"/\",left:e.process(me),right:e.process(me)}),mod:e=>({type:\"OpCall\",op:\"%\",left:e.process(me),right:e.process(me)}),pow:e=>({type:\"OpCall\",op:\"**\",left:e.process(me),right:e.process(me)}),comp(e){const t=e.process(me);return{type:\"OpCall\",op:e.processString(),left:t,right:e.process(me)}},in_range(e){const t=e.process(me),r=\"inc_range\"===e.getMark().name;e.shift();return{type:\"InRange\",base:t,left:e.process(me),right:e.process(me),isInclusive:r}},str(e){let t=\"\";e:for(;e.hasMark();){const r=e.getMark();switch(r.name){case\"str_end\":t+=e.processStringEnd();break e;case\"str_pause\":t+=e.processStringEnd();break;case\"str_start\":e.shift();break;case\"single_escape\":{const r=e.slice(1);e.shift(),t+=ye[r];break}case\"unicode_hex\":e.shift(),t+=de(e.processStringEnd());break;default:throw new Error(`unexpected mark: ${r.name}`)}}return{type:\"Value\",value:t}},integer(e){const t=e.processStringEnd();return{type:\"Value\",value:Number(t)}},float(e){const t=e.processStringEnd();return{type:\"Value\",value:Number(t)}},sci(e){const t=e.processStringEnd();return{type:\"Value\",value:Number(t)}},object(e){const t=[];for(;\"object_end\"!==e.getMark().name;)t.push(e.process(be));return e.shift(),{type:\"Object\",attributes:t}},array(e){const t=[];for(;\"array_end\"!==e.getMark().name;){let r=!1;\"array_splat\"===e.getMark().name&&(r=!0,e.shift());const n=e.process(me);t.push({type:\"ArrayElement\",value:n,isSplat:r})}return e.shift(),{type:\"Array\",elements:t}},tuple(e){const t=[];for(;\"tuple_end\"!==e.getMark().name;)t.push(e.process(me));return e.shift(),{type:\"Tuple\",members:t}},func_call(e){let t=\"global\";\"namespace\"===e.getMark().name&&(e.shift(),t=e.processString());const r=e.processString();if(\"global\"===t&&\"select\"===r){const t={type:\"Select\",alternatives:[]};for(;\"func_args_end\"!==e.getMark().name;)if(\"pair\"===e.getMark().name){if(t.fallback)throw new he(\"unexpected argument to select()\");e.shift();const r=e.process(me),n=e.process(me);t.alternatives.push({type:\"SelectAlternative\",condition:r,value:n})}else{if(t.fallback)throw new he(\"unexpected argument to select()\");const r=e.process(me);t.fallback=r}return e.shift(),t}const n=[];for(;\"func_args_end\"!==e.getMark().name;)xe(t,r,n.length)?(e.process(we),n.push({type:\"Selector\"})):n.push(e.process(me));if(e.shift(),\"global\"===t&&(\"before\"===r||\"after\"===r)&&\"delta\"===e.parseOptions.mode)return{type:\"Context\",key:r};if(\"global\"===t&&\"boost\"===r&&!e.allowBoost)throw new he(\"unexpected boost\");const o=Y[t];if(!o)throw new he(`Undefined namespace: ${t}`);const i=o[r];if(!i)throw new he(`Undefined function: ${r}`);if(void 0!==i.arity&&ve(r,i.arity,n.length),void 0!==i.mode&&i.mode!==e.parseOptions.mode)throw new he(`Undefined function: ${r}`);return{type:\"FuncCall\",func:i,namespace:t,name:r,args:n}},pipecall(e){const t=e.process(me);e.shift();let r=\"global\";if(\"namespace\"===e.getMark().name&&(e.shift(),r=e.processString()),\"global\"!==r)throw new he(`Undefined namespace: ${r}`);const n=e.processString(),o=[],i=e.allowBoost;for(\"score\"===n&&(e.allowBoost=!0);;){const t=e.getMark().name;if(\"func_args_end\"===t)break;if(\"order\"===n){if(\"asc\"===t){e.shift(),o.push({type:\"Asc\",base:e.process(me)});continue}if(\"desc\"===t){e.shift(),o.push({type:\"Desc\",base:e.process(me)});continue}}o.push(e.process(me))}e.shift(),e.allowBoost=i;const s=Z[n];if(!s)throw new he(`Undefined pipe function: ${n}`);return s.arity&&ve(n,s.arity,o.length),{type:\"PipeFuncCall\",func:s,base:t,name:n,args:o}},pair(){throw new he(\"unexpected =>\")},and:e=>({type:\"And\",left:e.process(me),right:e.process(me)}),or:e=>({type:\"Or\",left:e.process(me),right:e.process(me)}),not:e=>({type:\"Not\",base:e.process(me)}),asc(){throw new he(\"unexpected asc\")},desc(){throw new he(\"unexpected desc\")},param(e){const t=e.processString();return e.parseOptions.params&&e.parseOptions.params.hasOwnProperty(t)?{type:\"Value\",value:e.parseOptions.params[t]}:{type:\"Parameter\",name:t}}},be={object_expr(e){if(\"pair\"===e.getMark().name){e.shift();return{type:\"ObjectConditionalSplat\",condition:e.process(me),value:e.process(me)}}const t=e.process(me);return{type:\"ObjectAttributeValue\",name:ke(t),value:t}},object_pair(e){const t=e.process(me);if(\"Value\"!==t.type)throw new Error(\"name must be string\");const r=e.process(me);return{type:\"ObjectAttributeValue\",name:t.value,value:r}},object_splat:e=>({type:\"ObjectSplat\",value:e.process(me)}),object_splat_this:()=>({type:\"ObjectSplat\",value:{type:\"This\"}})},ge={square_bracket(e){const t=e.process(me),r=P(t);return r&&\"number\"===r.type?e=>function(e,t){if(!t)return{type:\"a-b\",build:e};switch(t.type){case\"a-a\":case\"b-a\":return{type:\"a-a\",build:ue(e,t.build)};case\"a-b\":case\"b-b\":return{type:\"a-b\",build:ue(e,t.build)};default:throw new Error(`unknown type: ${t.type}`)}}((e=>({type:\"AccessElement\",base:e,index:r.data})),e):r&&\"string\"===r.type?e=>fe((e=>({type:\"AccessAttribute\",base:e,name:r.data})),e):e=>le((e=>({type:\"Filter\",base:e,expr:t})),e)},slice(e){const t=\"inc_range\"===e.getMark().name;e.shift();const r=e.process(me),n=e.process(me),o=P(r),i=P(n);if(!o||!i||\"number\"!==o.type||\"number\"!==i.type)throw new he(\"slicing must use constant numbers\");return e=>le((e=>({type:\"Slice\",base:e,left:o.data,right:i.data,isInclusive:t})),e)},projection(e){const t=e.process(me);return e=>function(e,t){if(!t)return{type:\"b-b\",build:e};switch(t.type){case\"a-a\":return{type:\"a-a\",build:ue(pe(e),t.build)};case\"a-b\":return{type:\"a-b\",build:ue(pe(e),t.build)};case\"b-a\":return{type:\"b-a\",build:ue(e,t.build)};case\"b-b\":return{type:\"b-b\",build:ue(e,t.build)};default:throw new Error(`unknown type: ${t.type}`)}}((e=>({type:\"Projection\",base:e,expr:t})),e)},attr_access(e){const t=e.processString();return e=>fe((e=>({type:\"AccessAttribute\",base:e,name:t})),e)},deref(e){let t=null;\"deref_attr\"===e.getMark().name&&(e.shift(),t=e.processString());return e=>fe((e=>(e=>t?{type:\"AccessAttribute\",base:e,name:t}:e)({type:\"Deref\",base:e})),e)},array_postfix:()=>e=>le((e=>({type:\"ArrayCoerce\",base:e})),e)},we={group:e=>(e.process(we),null),everything(){throw new Error(\"Invalid selector syntax\")},this(){throw new Error(\"Invalid selector syntax\")},parent(){throw new Error(\"Invalid selector syntax\")},dblparent(){throw new Error(\"Invalid selector syntax\")},traverse(e){for(e.process(we);\"traversal_end\"!==e.getMark().name;)e.process(ge);return e.shift(),null},this_attr:e=>(e.processString(),null),neg(){throw new Error(\"Invalid selector syntax\")},pos(){throw new Error(\"Invalid selector syntax\")},add(){throw new Error(\"Invalid selector syntax\")},sub(){throw new Error(\"Invalid selector syntax\")},mul(){throw new Error(\"Invalid selector syntax\")},div(){throw new Error(\"Invalid selector syntax\")},mod(){throw new Error(\"Invalid selector syntax\")},pow(){throw new Error(\"Invalid selector syntax\")},comp(){throw new Error(\"Invalid selector syntax\")},in_range(){throw new Error(\"Invalid selector syntax\")},str(){throw new Error(\"Invalid selector syntax\")},integer(){throw new Error(\"Invalid selector syntax\")},float(){throw new Error(\"Invalid selector syntax\")},sci(){throw new Error(\"Invalid selector syntax\")},object(){throw new Error(\"Invalid selector syntax\")},array(){throw new Error(\"Invalid selector syntax\")},tuple(){throw new Error(\"Invalid selector syntax\")},func_call(e,t){const r=me.func_call(e,t);if(\"anywhere\"===r.name&&1===r.args.length)return null;throw new Error(\"Invalid selector syntax\")},pipecall(){throw new Error(\"Invalid selector syntax\")},pair(){throw new Error(\"Invalid selector syntax\")},and(){throw new Error(\"Invalid selector syntax\")},or(){throw new Error(\"Invalid selector syntax\")},not(){throw new Error(\"Invalid selector syntax\")},asc(){throw new Error(\"Invalid selector syntax\")},desc(){throw new Error(\"Invalid selector syntax\")},param(){throw new Error(\"Invalid selector syntax\")}};function ke(e){if(\"AccessAttribute\"===e.type&&!e.base)return e.name;if(\"PipeFuncCall\"===e.type||\"Deref\"===e.type||\"Map\"===e.type||\"Projection\"===e.type||\"Slice\"===e.type||\"Filter\"===e.type||\"AccessElement\"===e.type||\"ArrayCoerce\"===e.type||\"Group\"===e.type)return ke(e.base);throw new he(`Cannot determine property key for type: ${e.type}`)}function ve(e,t,r){if(\"number\"==typeof t){if(r!==t)throw new he(`Incorrect number of arguments to function ${e}(). Expected ${t}, got ${r}.`)}else if(t&&!t(r))throw new he(`Incorrect number of arguments to function ${e}().`)}function xe(e,t,r){return\"diff\"==e&&2==r&&[\"changedAny\",\"changedOnly\"].includes(t)}class _e extends Error{position;name=\"GroqSyntaxError\";constructor(e){super(`Syntax error in GROQ query at position ${e}`),this.position=e}}function Ae(e,t={}){const r=function(e){let t=0;t=se(e,t);let r=re(e,t,0);return\"error\"===r.type?r:(t=se(e,r.position),t!==e.length?(r.failPosition&&(t=r.failPosition-1),{type:\"error\",position:t}):(delete r.position,delete r.failPosition,r))}(e);if(\"error\"===r.type)throw new _e(r.position);return new K(e,r.marks,t).process(me)}export{C as evaluateSync,Ae as parse};\n","interface MultiKeyWeakMapNode {\n  value: unknown\n  next: WeakMap<object, MultiKeyWeakMapNode>\n}\n\nexport class MultiKeyWeakMap<T = unknown> {\n  // The root of our nested WeakMap structure.\n  #rootMap = new WeakMap<object, MultiKeyWeakMapNode>()\n\n  // Instead of random IDs, we use a counter for deterministic IDs.\n  static #globalIdCounter = 0\n  // Each instance keeps a cache mapping a key to its assigned ID.\n  #idCache = new WeakMap<object, number>()\n\n  /**\n   * Assigns a numeric ID to the key.\n   */\n  #assignId(key: object): number {\n    const cachedId = this.#idCache.get(key)\n    if (cachedId !== undefined) return cachedId\n\n    const id = MultiKeyWeakMap.#globalIdCounter\n    this.#idCache.set(key, id)\n    MultiKeyWeakMap.#globalIdCounter++\n    return id\n  }\n\n  /**\n   * Remove duplicate keys and arrange them in a consistent order\n   * by sorting according to their assigned IDs.\n   */\n  #arrangeKeys(keys: object[]): object[] {\n    const uniqueKeys = Array.from(new Set(keys))\n    const keyed = uniqueKeys.map((key) => [this.#assignId(key), key] as const)\n    keyed.sort((a, b) => a[0] - b[0])\n    return keyed.map(([, key]) => key)\n  }\n\n  /**\n   * Recursively search the nested WeakMap structure for the value.\n   */\n  #getDeep(keys: object[], map: WeakMap<object, MultiKeyWeakMapNode>): unknown {\n    if (keys.length === 0) return undefined\n\n    const [firstKey, ...restKeys] = keys\n    const node = map.get(firstKey)\n    if (!node) return undefined\n    if (restKeys.length === 0) return node.value\n    return this.#getDeep(restKeys, node.next)\n  }\n\n  /**\n   * Recursively create nodes along the key chain until the final key\n   * is reached, then assign the value.\n   */\n  #setDeep(keys: object[], map: WeakMap<object, MultiKeyWeakMapNode>, value: unknown): void {\n    if (keys.length === 0) return\n\n    const [firstKey, ...restKeys] = keys\n    let node = map.get(firstKey)\n    if (!node) {\n      node = {\n        value: undefined,\n        next: new WeakMap(),\n      }\n      map.set(firstKey, node)\n    }\n\n    if (restKeys.length === 0) {\n      node.value = value\n    } else {\n      this.#setDeep(restKeys, node.next, value)\n    }\n  }\n\n  /**\n   * Retrieves the value associated with the array of keys.\n   * The keys are de-duplicated and sorted so that the order does not matter.\n   */\n  get(keys: object[]): T | undefined {\n    const arrangedKeys = this.#arrangeKeys(keys)\n    return this.#getDeep(arrangedKeys, this.#rootMap) as T | undefined\n  }\n\n  /**\n   * Associates the value with the given array of keys.\n   */\n  set(keys: object[], value: T): void {\n    const arrangedKeys = this.#arrangeKeys(keys)\n    this.#setDeep(arrangedKeys, this.#rootMap, value)\n  }\n}\n","import {type SanityDocument} from '@sanity/types'\nimport {type ExprNode} from 'groq-js'\nimport {createSelector} from 'reselect'\n\nimport {type SelectorContext} from '../store/createStateSourceAction'\nimport {getDraftId, getPublishedId} from '../utils/ids'\nimport {MultiKeyWeakMap} from '../utils/MultiKeyWeakMap'\nimport {evaluateSync, parse} from './_synchronous-groq-js.mjs'\nimport {type DocumentAction} from './actions'\nimport {ActionError, PermissionActionError, processActions} from './processActions'\nimport {type DocumentSet} from './processMutations'\nimport {type SyncTransactionState} from './reducers'\n\nexport type Grant = 'read' | 'update' | 'create' | 'history'\n\nexport type DatasetAcl = {\n  filter: string\n  permissions: Grant[]\n}[]\n\nexport function createGrantsLookup(datasetAcl: DatasetAcl): Record<Grant, ExprNode> {\n  const filtersByGrant: Record<Grant, Set<string>> = {\n    create: new Set(),\n    history: new Set(),\n    read: new Set(),\n    update: new Set(),\n  }\n\n  for (const entry of datasetAcl) {\n    for (const grant of entry.permissions) {\n      const set = filtersByGrant[grant]\n      set.add(entry.filter)\n      filtersByGrant[grant] = set\n    }\n  }\n\n  return Object.fromEntries(\n    Object.entries(filtersByGrant).map(([grant, filters]) => {\n      const combinedFilter = Array.from(filters)\n        .map((i) => `(${i})`)\n        .join('||')\n\n      if (!combinedFilter) return [grant, parse('false')]\n      return [grant, parse(`$document {\"_\": ${combinedFilter}}._`)]\n    }),\n  ) as Record<Grant, ExprNode>\n}\n\n// Cache for documents based on an array of document objects.\nconst documentsCache = new MultiKeyWeakMap<DocumentSet>()\n// Use a WeakMap so that when a computed DocumentSet is no longer in use,\n// its nested cache for actions can be garbage-collected.\nconst actionsCache = new WeakMap<DocumentSet, Map<string, DocumentAction[]>>()\n\nconst nullReplacer: object = {}\n\n// Compute documents from state and actions.\n// (If the same documents are computed, the MultiKeyWeakMap will return the same instance.)\nconst documentsSelector = createSelector(\n  [\n    ({state: {documentStates}}: SelectorContext<SyncTransactionState>) => documentStates,\n    (_context: SelectorContext<SyncTransactionState>, actions: DocumentAction | DocumentAction[]) =>\n      actions,\n  ],\n  (documentStates, actions) => {\n    const documentIds = new Set(\n      (Array.isArray(actions) ? actions : [actions])\n        .map((i) => i.documentId)\n        .filter((i) => typeof i === 'string')\n        .flatMap((documentId) => [getPublishedId(documentId), getDraftId(documentId)]),\n    )\n\n    const documents: DocumentSet = {}\n\n    for (const documentId of documentIds) {\n      const local = documentStates[documentId]?.local\n\n      // early exit if we don't have all the documents yet\n      if (local === undefined) return undefined\n      documents[documentId] = local\n    }\n\n    // Create a key from the documents values (using a nullReplacer when needed).\n    const keys = Object.values(\n      // value in this record will be `undefined` because\n      // of the early return if undefined is found above\n      documents as Record<string, SanityDocument | null>,\n    ).map((doc) => (doc === null ? nullReplacer : doc))\n    const cached = documentsCache.get(keys)\n    if (cached) return cached\n\n    documentsCache.set(keys, documents)\n    return documents\n  },\n)\n\n// Cache the actions array based on a serialized version, but “attach” the cache\n// to the computed documents. That way if the computed documents object is no longer in use,\n// the cache is eligible for GC.\nconst memoizedActionsSelector = createSelector(\n  [\n    documentsSelector,\n    (_state: SelectorContext<SyncTransactionState>, actions: DocumentAction | DocumentAction[]) =>\n      actions,\n  ],\n  (documents, actions) => {\n    if (!documents) return undefined\n\n    // Get (or create) the nested Map for this computed documents.\n    let nestedCache = actionsCache.get(documents)\n    if (!nestedCache) {\n      nestedCache = new Map<string, DocumentAction[]>()\n      actionsCache.set(documents, nestedCache)\n    }\n\n    const normalizedActions = Array.isArray(actions) ? actions : [actions]\n\n    // Use JSON.stringify to get a serialized key for the actions.\n    // TODO: considering swapping thisfor a more efficient or stable hash\n    const actionsKey = JSON.stringify(normalizedActions)\n    const cached = nestedCache.get(actionsKey)\n    if (cached) return cached\n\n    nestedCache.set(actionsKey, normalizedActions)\n    return normalizedActions\n  },\n)\n\nfunction checkGrant(grantExpr: ExprNode, document: SanityDocument): boolean {\n  return evaluateSync(grantExpr, {params: {document}}).get()\n}\n\n/** @beta */\nexport interface PermissionDeniedReason {\n  type: 'precondition' | 'access'\n  message: string\n  documentId?: string\n}\n\n/** @beta */\nexport type DocumentPermissionsResult =\n  | {\n      allowed: false\n      message: string\n      reasons: PermissionDeniedReason[]\n    }\n  | {allowed: true; message?: undefined; reasons?: undefined}\n\nconst enNarrowConjunction = new Intl.ListFormat('en', {style: 'narrow', type: 'conjunction'})\n\nexport function calculatePermissions(\n  ...args: Parameters<typeof _calculatePermissions>\n): ReturnType<typeof _calculatePermissions> {\n  return _calculatePermissions(...args)\n}\n\nconst _calculatePermissions = createSelector(\n  [\n    ({state: {grants}}: SelectorContext<SyncTransactionState>) => grants,\n    documentsSelector,\n    memoizedActionsSelector,\n  ],\n  (\n    grants: Record<Grant, ExprNode> | undefined,\n    documents: DocumentSet | undefined,\n    actions: DocumentAction[] | undefined,\n  ): DocumentPermissionsResult | undefined => {\n    if (!documents) return undefined\n    if (!grants) return undefined\n    if (!actions) return undefined\n\n    const timestamp = new Date().toISOString()\n    const reasons: PermissionDeniedReason[] = []\n\n    try {\n      processActions({\n        actions,\n        transactionId: crypto.randomUUID(),\n        working: documents,\n        base: documents,\n        timestamp,\n        grants,\n      })\n    } catch (error) {\n      if (error instanceof PermissionActionError) {\n        reasons.push({\n          message: error.message,\n          documentId: error.documentId,\n          type: 'access',\n        })\n      } else if (error instanceof ActionError) {\n        reasons.push({\n          message: error.message,\n          documentId: error.documentId,\n          type: 'precondition',\n        })\n      } else {\n        throw error\n      }\n    }\n\n    for (const action of actions) {\n      // Check edit actions with no patches\n      if (action.type === 'document.edit' && !action.patches?.length) {\n        const docId = action.documentId\n        const doc = documents[getDraftId(docId)] ?? documents[getPublishedId(docId)]\n        if (!doc) {\n          reasons.push({\n            type: 'precondition',\n            message: `The document with ID \"${docId}\" could not be found. Please check that it exists before editing.`,\n            documentId: docId,\n          })\n        } else if (!checkGrant(grants.update, doc)) {\n          reasons.push({\n            type: 'access',\n            message: `You are not allowed to edit the document with ID \"${docId}\".`,\n            documentId: docId,\n          })\n        }\n      }\n    }\n\n    const allowed = reasons.length === 0\n    if (allowed) return {allowed}\n\n    const sortedReasons = reasons\n      .map((reason, index) => ({...reason, index}))\n      .sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'access' ? -1 : 1\n        return a.message.localeCompare(b.message, 'en-US')\n      })\n      .map(({index: _index, ...reason}) => reason)\n\n    return {\n      allowed,\n      reasons: sortedReasons,\n      message: enNarrowConjunction.format(sortedReasons.map((i) => i.message)),\n    }\n  },\n)\n","import {diffValue} from '@sanity/diff-patch'\nimport {\n  type Mutation,\n  type PatchOperations,\n  type Reference,\n  type SanityDocument,\n} from '@sanity/types'\nimport {type ExprNode} from 'groq-js'\nimport {isEqual} from 'lodash-es'\n\nimport {getDraftId, getPublishedId} from '../utils/ids'\nimport {evaluateSync} from './_synchronous-groq-js.mjs'\nimport {type DocumentAction} from './actions'\nimport {type Grant} from './permissions'\nimport {type DocumentSet, getId, processMutations} from './processMutations'\nimport {type HttpAction} from './reducers'\n\nfunction checkGrant(grantExpr: ExprNode, document: SanityDocument): boolean {\n  return evaluateSync(grantExpr, {params: {document}}).get()\n}\n\ninterface ProcessActionsOptions {\n  /**\n   * The ID of this transaction. This will become the resulting `_rev` for all\n   * documents affected by changes derived from the current set of actions.\n   */\n  transactionId: string\n\n  /**\n   * The actions to apply to the given documents\n   */\n  actions: DocumentAction[]\n\n  /**\n   * The set of documents these actions were intended to be applied to. These\n   * set of documents should be captured right before a queued action is\n   * applied.\n   */\n  base: DocumentSet\n\n  /**\n   * The current \"working\" set of documents. A patch will be created by applying\n   * the actions to the base. This patch will then be applied to the working\n   * set for conflict resolution. Initially, this value should match the base\n   * set.\n   */\n  working: DocumentSet\n\n  /**\n   * The timestamp to use for `_updateAt` and other similar timestamps for this\n   * transaction\n   */\n  timestamp: string\n\n  /**\n   * the lookup with pre-parsed GROQ expressions\n   */\n  grants: Record<Grant, ExprNode>\n\n  // // TODO: implement initial values from the schema?\n  // initialValues?: {[TDocumentType in string]?: {_type: string}}\n}\n\ninterface ProcessActionsResult {\n  /**\n   * The resulting document set after the actions have been applied. This is\n   * derived from the working documents.\n   */\n  working: DocumentSet\n  /**\n   * The document set before the actions have been applied. This is simply the\n   * input of the `working` document set.\n   */\n  previous: DocumentSet\n  /**\n   * The outgoing action that were collected when applying the actions. These\n   * are sent to the Actions HTTP API\n   */\n  outgoingActions: HttpAction[]\n  /**\n   * The outgoing mutations that were collected when applying the actions. These\n   * are here for debugging purposes.\n   */\n  outgoingMutations: Mutation[]\n  /**\n   * The previous revisions of the given documents before the actions were applied.\n   */\n  previousRevs: {[TDocumentId in string]?: string}\n}\n\ninterface ActionErrorOptions {\n  message: string\n  documentId: string\n  transactionId: string\n}\n\n/**\n * Thrown when a precondition for an action failed.\n */\nexport class ActionError extends Error implements ActionErrorOptions {\n  documentId!: string\n  transactionId!: string\n\n  constructor(options: ActionErrorOptions) {\n    super(options.message)\n    Object.assign(this, options)\n  }\n}\n\nexport class PermissionActionError extends ActionError {}\n\n/**\n * Applies the given set of actions to the working set of documents and converts\n * high-level actions into lower-level outgoing mutations/actions that respect\n * the current state of the working documents.\n *\n * Supports a \"base\" and \"working\" set of documents to allow actions to be\n * applied on top of a different working set of documents in a 3-way merge\n *\n * Actions are applied to the base set of documents first. The difference\n * between the base before and after is used to create a patch. This patch is\n * then applied to the working set of documents and is set as the outgoing patch\n * sent to the server.\n */\nexport function processActions({\n  actions,\n  transactionId,\n  working: initialWorking,\n  base: initialBase,\n  timestamp,\n  grants,\n}: ProcessActionsOptions): ProcessActionsResult {\n  let working: DocumentSet = {...initialWorking}\n  let base: DocumentSet = {...initialBase}\n\n  const outgoingActions: HttpAction[] = []\n  const outgoingMutations: Mutation[] = []\n\n  for (const action of actions) {\n    switch (action.type) {\n      case 'document.create': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        if (working[draftId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `A draft version of this document already exists. Please use or discard the existing draft before creating a new one.`,\n          })\n        }\n\n        // Spread the (possibly undefined) published version directly.\n        const newDocBase = {...base[publishedId], _type: action.documentType, _id: draftId}\n        const newDocWorking = {...working[publishedId], _type: action.documentType, _id: draftId}\n        const mutations: Mutation[] = [{create: newDocWorking}]\n\n        base = processMutations({\n          documents: base,\n          transactionId,\n          mutations: [{create: newDocBase}],\n          timestamp,\n        })\n        working = processMutations({\n          documents: working,\n          transactionId,\n          mutations,\n          timestamp,\n        })\n\n        if (!checkGrant(grants.create, working[draftId] as SanityDocument)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to create a draft for document \"${documentId}\".`,\n          })\n        }\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.version.create',\n          publishedId,\n          attributes: newDocWorking,\n        })\n        continue\n      }\n\n      case 'document.delete': {\n        const documentId = action.documentId\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        if (!working[publishedId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: working[draftId]\n              ? 'Cannot delete a document without a published version.'\n              : 'The document you are trying to delete does not exist.',\n          })\n        }\n\n        const cantDeleteDraft = working[draftId] && !checkGrant(grants.update, working[draftId])\n        const cantDeletePublished =\n          working[publishedId] && !checkGrant(grants.update, working[publishedId])\n\n        if (cantDeleteDraft || cantDeletePublished) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to delete this document.`,\n          })\n        }\n\n        const mutations: Mutation[] = [{delete: {id: publishedId}}, {delete: {id: draftId}}]\n        const includeDrafts = working[draftId] ? [draftId] : undefined\n\n        base = processMutations({documents: base, transactionId, mutations, timestamp})\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.delete',\n          publishedId,\n          ...(includeDrafts ? {includeDrafts} : {}),\n        })\n        continue\n      }\n\n      case 'document.discard': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const mutations: Mutation[] = [{delete: {id: draftId}}]\n\n        if (!working[draftId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `There is no draft available to discard for document \"${documentId}\".`,\n          })\n        }\n\n        if (!checkGrant(grants.update, working[draftId])) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to discard changes for document \"${documentId}\".`,\n          })\n        }\n\n        base = processMutations({documents: base, transactionId, mutations, timestamp})\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.version.discard',\n          versionId: draftId,\n        })\n        continue\n      }\n\n      case 'document.edit': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n        const userPatches = action.patches?.map((patch) => ({patch: {id: draftId, ...patch}}))\n\n        // skip this action if there are no associated patches\n        if (!userPatches?.length) continue\n\n        if (\n          (!working[draftId] && !working[publishedId]) ||\n          (!base[draftId] && !base[publishedId])\n        ) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Cannot edit document because it does not exist in draft or published form.`,\n          })\n        }\n\n        const baseMutations: Mutation[] = []\n        if (!base[draftId] && base[publishedId]) {\n          baseMutations.push({create: {...base[publishedId], _id: draftId}})\n        }\n\n        // the first if statement should make this never be null or undefined\n        const baseBefore = (base[draftId] ?? base[publishedId]) as SanityDocument\n        if (userPatches) {\n          baseMutations.push(...userPatches)\n        }\n\n        base = processMutations({\n          documents: base,\n          transactionId,\n          mutations: baseMutations,\n          timestamp,\n        })\n        // this one will always be defined because a patch mutation will never\n        // delete an input document\n        const baseAfter = base[draftId] as SanityDocument\n        const patches = diffValue(baseBefore, baseAfter)\n\n        const workingMutations: Mutation[] = []\n        if (!working[draftId] && working[publishedId]) {\n          const newDraftFromPublished = {...working[publishedId], _id: draftId}\n\n          if (!checkGrant(grants.create, newDraftFromPublished)) {\n            throw new PermissionActionError({\n              documentId,\n              transactionId,\n              message: `You do not have permission to create a draft for editing this document.`,\n            })\n          }\n\n          workingMutations.push({create: newDraftFromPublished})\n        }\n\n        // the first if statement should make this never be null or undefined\n        const workingBefore = (working[draftId] ?? working[publishedId]) as SanityDocument\n        if (!checkGrant(grants.update, workingBefore)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to edit document \"${documentId}\".`,\n          })\n        }\n        workingMutations.push(...patches.map((patch) => ({patch: {id: draftId, ...patch}})))\n\n        working = processMutations({\n          documents: working,\n          transactionId,\n          mutations: workingMutations,\n          timestamp,\n        })\n\n        outgoingMutations.push(...workingMutations)\n        outgoingActions.push(\n          ...patches.map(\n            (patch): HttpAction => ({\n              actionType: 'sanity.action.document.edit',\n              draftId,\n              publishedId,\n              patch: patch as PatchOperations,\n            }),\n          ),\n        )\n\n        continue\n      }\n\n      case 'document.publish': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        const workingDraft = working[draftId]\n        const baseDraft = base[draftId]\n        if (!workingDraft || !baseDraft) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Cannot publish because no draft version was found for document \"${documentId}\".`,\n          })\n        }\n\n        // Before proceeding, verify that the working draft is identical to the base draft.\n        // TODO: is it enough just to check for the _rev or nah?\n        if (!isEqual(workingDraft, baseDraft)) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Publish aborted: The document has changed elsewhere. Please try again.`,\n          })\n        }\n\n        const newPublishedFromDraft = {...strengthenOnPublish(workingDraft), _id: publishedId}\n\n        const mutations: Mutation[] = [\n          {delete: {id: draftId}},\n          {createOrReplace: newPublishedFromDraft},\n        ]\n\n        if (working[draftId] && !checkGrant(grants.update, working[draftId])) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `Publish failed: You do not have permission to update the draft for \"${documentId}\".`,\n          })\n        }\n\n        if (working[publishedId] && !checkGrant(grants.update, newPublishedFromDraft)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `Publish failed: You do not have permission to update the published version of \"${documentId}\".`,\n          })\n        } else if (!working[publishedId] && !checkGrant(grants.create, newPublishedFromDraft)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `Publish failed: You do not have permission to publish a new version of \"${documentId}\".`,\n          })\n        }\n\n        base = processMutations({documents: base, transactionId, mutations, timestamp})\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.publish',\n          draftId,\n          publishedId,\n        })\n        continue\n      }\n\n      case 'document.unpublish': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        if (!working[publishedId] && !base[publishedId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Cannot unpublish because the document \"${documentId}\" is not currently published.`,\n          })\n        }\n\n        const sourceDoc = working[publishedId] ?? (base[publishedId] as SanityDocument)\n        const newDraftFromPublished = {...sourceDoc, _id: draftId}\n        const mutations: Mutation[] = [\n          {delete: {id: publishedId}},\n          {createIfNotExists: newDraftFromPublished},\n        ]\n\n        if (!checkGrant(grants.update, sourceDoc)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to unpublish the document \"${documentId}\".`,\n          })\n        }\n\n        if (!working[draftId] && !checkGrant(grants.create, newDraftFromPublished)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to create a draft from the published version of \"${documentId}\".`,\n          })\n        }\n\n        base = processMutations({\n          documents: base,\n          transactionId,\n          mutations: [\n            {delete: {id: publishedId}},\n            {createIfNotExists: {...(base[publishedId] ?? sourceDoc), _id: draftId}},\n          ],\n          timestamp,\n        })\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.unpublish',\n          draftId,\n          publishedId,\n        })\n        continue\n      }\n\n      default: {\n        throw new Error(\n          `Unknown action type: \"${\n            // @ts-expect-error invalid input\n            action.type\n          }\". Please contact support if this issue persists.`,\n        )\n      }\n    }\n  }\n\n  const previousRevs = Object.fromEntries(\n    Object.entries(initialWorking).map(([id, doc]) => [id, doc?._rev]),\n  )\n\n  return {\n    working,\n    outgoingActions,\n    outgoingMutations,\n    previous: initialWorking,\n    previousRevs,\n  }\n}\n\nfunction strengthenOnPublish(draft: SanityDocument): SanityDocument {\n  const isStrengthenReference = (\n    value: object,\n  ): value is Reference & Required<Pick<Reference, '_strengthenOnPublish'>> =>\n    '_strengthenOnPublish' in value\n\n  function strengthen(value: unknown): unknown {\n    if (typeof value !== 'object' || !value) return value\n\n    if (isStrengthenReference(value)) {\n      const {_strengthenOnPublish, _weak, ...rest} = value\n      return {\n        ...rest,\n        ...(_strengthenOnPublish.weak && {_weak: true}),\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(strengthen)\n    }\n\n    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, strengthen(v)]))\n  }\n\n  return strengthen(draft) as SanityDocument\n}\n","import {getPublishedId} from '@sanity/client/csm'\nimport {type Mutation, type PatchOperations, type SanityDocumentLike} from '@sanity/types'\nimport {omit} from 'lodash-es'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {getDraftId, insecureRandomId} from '../utils/ids'\nimport {type DocumentAction} from './actions'\nimport {DOCUMENT_STATE_CLEAR_DELAY} from './documentConstants'\nimport {type DocumentState, type DocumentStoreState} from './documentStore'\nimport {type RemoteDocument} from './listen'\nimport {ActionError, processActions} from './processActions'\nimport {type DocumentSet} from './processMutations'\n\nconst EMPTY_REVISIONS: NonNullable<Required<DocumentState['unverifiedRevisions']>> = {}\n\nexport type SyncTransactionState = Pick<\n  DocumentStoreState,\n  'queued' | 'applied' | 'documentStates' | 'outgoing' | 'grants'\n>\n\ntype ActionMap = {\n  create: 'sanity.action.document.version.create'\n  discard: 'sanity.action.document.version.discard'\n  unpublish: 'sanity.action.document.unpublish'\n  delete: 'sanity.action.document.delete'\n  edit: 'sanity.action.document.edit'\n  publish: 'sanity.action.document.publish'\n}\n\ntype OptimisticLock = {\n  ifDraftRevisionId?: string\n  ifPublishedRevisionId?: string\n}\n\nexport type HttpAction =\n  | {actionType: ActionMap['create']; publishedId: string; attributes: SanityDocumentLike}\n  | {actionType: ActionMap['discard']; versionId: string; purge?: boolean}\n  | {actionType: ActionMap['unpublish']; draftId: string; publishedId: string}\n  | {actionType: ActionMap['delete']; publishedId: string; includeDrafts?: string[]}\n  | {actionType: ActionMap['edit']; draftId: string; publishedId: string; patch: PatchOperations}\n  | ({actionType: ActionMap['publish']; draftId: string; publishedId: string} & OptimisticLock)\n\n/**\n * Represents a transaction that is queued to be applied but has not yet been\n * applied. A transaction will remain in a queued state until all required\n * documents for the transactions are available locally.\n */\nexport interface QueuedTransaction {\n  /**\n   * the ID of this transaction. this is generated client-side.\n   */\n  transactionId: string\n  /**\n   * the high-level actions associated with this transaction. note that these\n   * actions don't mention draft IDs and is meant to abstract away the draft\n   * model from users.\n   */\n  actions: DocumentAction[]\n  /**\n   * An optional flag set to disable this transaction from being batched with\n   * other transactions.\n   */\n  disableBatching?: boolean\n}\n\n/**\n * Represents a transaction that has been applied locally but has not been\n * committed/transitioned-to-outgoing. These transactions are visible to the\n * user but may be rebased upon a new working document set. Applied transactions\n * also contain the resulting `outgoingActions` that will be submitted to\n * Content Lake. These `outgoingActions` depend on the state of the working\n * documents so they are recomputed on rebase and are only relevant to applied\n * actions (we cannot compute `outgoingActions` for queued transactions because\n * we haven't resolved the set of documents the actions are dependent on yet).\n *\n * In order to support better conflict resolution, the original `previous` set\n * is saved as the `base` set.\n */\nexport interface AppliedTransaction extends QueuedTransaction {\n  /**\n   * the resulting set of documents after the actions have been applied\n   */\n  working: DocumentSet\n\n  /**\n   * the previous set of documents before the action was applied\n   */\n  previous: DocumentSet\n\n  /**\n   * the original `previous` document set captured when this action was\n   * originally applied. this is used as a reference point to do a 3-way merge\n   * if this applied transaction ever needs to be reapplied on a different\n   * set of documents.\n   */\n  base: DocumentSet\n\n  /**\n   * the `_rev`s from `previous` document set\n   */\n  previousRevs: {[TDocumentId in string]?: string}\n\n  /**\n   * a timestamp for when this transaction was applied locally\n   */\n  timestamp: string\n\n  /**\n   * the resulting HTTP actions derived from the state of the `working` document\n   * set. these are sent to Content Lake as-is when this transaction is batched\n   * and transitioned into an outgoing transaction.\n   */\n  outgoingActions: HttpAction[]\n\n  /**\n   * similar to `outgoingActions` but comprised of mutations instead of action.\n   * this left here for debugging purposes but could be used to send mutations\n   * to Content Lake instead of actions.\n   */\n  outgoingMutations: Mutation[]\n}\n\n/**\n * Represents a set of applied transactions batched into a single outgoing\n * transaction. An outgoing transaction is the result of batching many applied\n * actions. An outgoing transaction may be reverted locally if the server\n * does not accept it.\n */\nexport interface OutgoingTransaction extends AppliedTransaction {\n  disableBatching: boolean\n  batchedTransactionIds: string[]\n}\n\nexport interface UnverifiedDocumentRevision {\n  transactionId: string\n  documentId: string\n  previousRev: string | undefined\n  timestamp: string\n}\n\nexport function queueTransaction(\n  prev: SyncTransactionState,\n  transaction: QueuedTransaction,\n): SyncTransactionState {\n  const {transactionId, actions} = transaction\n  const prevWithSubscriptionIds = getDocumentIdsFromActions(actions).reduce(\n    (acc, id) => addSubscriptionIdToDocument(acc, id, transactionId),\n    prev,\n  )\n\n  return {\n    ...prevWithSubscriptionIds,\n    queued: [...prev.queued, transaction],\n  }\n}\n\nexport function removeQueuedTransaction(\n  prev: SyncTransactionState,\n  transactionId: string,\n): SyncTransactionState {\n  const transaction = prev.queued.find((t) => t.transactionId === transactionId)\n  if (!transaction) return prev\n\n  const prevWithSubscriptionIds = getDocumentIdsFromActions(transaction.actions).reduce(\n    (acc, id) => removeSubscriptionIdFromDocument(acc, id, transactionId),\n    prev,\n  )\n\n  return {\n    ...prevWithSubscriptionIds,\n    queued: prev.queued.filter((t) => transactionId !== t.transactionId),\n  }\n}\n\nexport function applyFirstQueuedTransaction(prev: SyncTransactionState): SyncTransactionState {\n  const queued = prev.queued.at(0)\n  if (!queued) return prev\n  if (!prev.grants) return prev\n\n  const ids = getDocumentIdsFromActions(queued.actions)\n  // the local value is only ever `undefined` if it has not been loaded yet\n  // we can't get the next applied state unless all relevant documents are ready\n  if (ids.some((id) => prev.documentStates[id]?.local === undefined)) return prev\n\n  const working = ids.reduce<DocumentSet>((acc, id) => {\n    acc[id] = prev.documentStates[id]?.local\n    return acc\n  }, {})\n\n  const timestamp = new Date().toISOString()\n\n  const result = processActions({\n    ...queued,\n    working,\n    base: working,\n    timestamp,\n    grants: prev.grants,\n  })\n  const applied: AppliedTransaction = {\n    ...queued,\n    ...result,\n    base: result.previous,\n    timestamp,\n  }\n\n  return {\n    ...prev,\n    applied: [...prev.applied, applied],\n    queued: prev.queued.filter((t) => t.transactionId !== queued.transactionId),\n    documentStates: Object.entries(result.working).reduce(\n      (acc, [id, next]) => {\n        const prevDoc = acc[id]\n        if (!prevDoc) return acc\n        acc[id] = {...prevDoc, local: next}\n        return acc\n      },\n      {...prev.documentStates},\n    ),\n  }\n}\n\nexport function batchAppliedTransactions([curr, ...rest]: AppliedTransaction[]):\n  | OutgoingTransaction\n  | undefined {\n  // No transactions? Nothing to batch.\n  if (!curr) return undefined\n\n  // Skip transactions with no actions.\n  if (!curr.actions.length) return batchAppliedTransactions(rest)\n\n  // If there are multiple actions, we cannot batch further.\n  if (curr.actions.length > 1) {\n    return {\n      ...curr,\n      disableBatching: true,\n      batchedTransactionIds: [curr.transactionId],\n    }\n  }\n\n  const [action] = curr.actions\n\n  // If the single action isn't a document.edit or batching is disabled,\n  // mark this transaction as non-batchable.\n  if (action.type !== 'document.edit' || curr.disableBatching) {\n    return {\n      ...curr,\n      disableBatching: true,\n      batchedTransactionIds: [curr.transactionId],\n    }\n  }\n\n  // Create an outgoing transaction for the single edit action.\n  // At this point, batching is allowed.\n  const editAction: OutgoingTransaction = {\n    ...curr,\n    actions: [action],\n    disableBatching: false,\n    batchedTransactionIds: [curr.transactionId],\n  }\n  if (!rest.length) return editAction\n\n  const next = batchAppliedTransactions(rest)\n  if (!next) return undefined\n  if (next.disableBatching) return editAction\n\n  return {\n    disableBatching: false,\n    // Use the transactionId from the later (next) transaction.\n    transactionId: next.transactionId,\n    // Accumulate actions: current action first, then later ones.\n    actions: [action, ...next.actions],\n    // Merge outgoingActions in order.\n    outgoingActions: [...curr.outgoingActions, ...next.outgoingActions],\n    // Batched transaction IDs: preserve order by placing curr first.\n    batchedTransactionIds: [curr.transactionId, ...next.batchedTransactionIds],\n    // Merge outgoingMutations in order.\n    outgoingMutations: [...curr.outgoingMutations, ...next.outgoingMutations],\n    // Working state reflects the latest optimistic changes: later transactions override earlier.\n    working: {...curr.working, ...next.working},\n    // Base state (base, previous, previousRevs) must reflect the original state.\n    // Use curr values (the earliest transaction) to override later ones.\n    previousRevs: {...next.previousRevs, ...curr.previousRevs},\n    previous: {...next.previous, ...curr.previous},\n    base: {...next.base, ...curr.base},\n    // Use the earliest timestamp from curr.\n    timestamp: curr.timestamp ?? next.timestamp,\n  }\n}\n\nexport function transitionAppliedTransactionsToOutgoing(\n  prev: SyncTransactionState,\n): SyncTransactionState {\n  if (prev.outgoing) return prev\n\n  const transaction = batchAppliedTransactions(prev.applied)\n  if (!transaction) return prev\n\n  const {\n    transactionId,\n    previousRevs,\n    working,\n    batchedTransactionIds: consumedTransactions,\n  } = transaction\n  const timestamp = new Date().toISOString()\n\n  return {\n    ...prev,\n    outgoing: transaction,\n    applied: prev.applied.filter((i) => !consumedTransactions.includes(i.transactionId)),\n    documentStates: Object.entries(previousRevs).reduce(\n      (acc, [documentId, previousRev]) => {\n        if (working[documentId]?._rev === previousRev) return acc\n\n        const documentState = prev.documentStates[documentId]\n        if (!documentState) return acc\n\n        acc[documentId] = {\n          ...documentState,\n          unverifiedRevisions: {\n            ...documentState.unverifiedRevisions,\n            // add unverified revision\n            [transactionId]: {documentId, previousRev, transactionId, timestamp},\n          },\n        }\n\n        return acc\n      },\n      {...prev.documentStates},\n    ),\n  }\n}\n\nexport function cleanupOutgoingTransaction(prev: SyncTransactionState): SyncTransactionState {\n  const {outgoing} = prev\n  if (!outgoing) return prev\n\n  let next = prev\n  const ids = getDocumentIdsFromActions(outgoing.actions)\n  for (const transactionId of outgoing.batchedTransactionIds) {\n    for (const documentId of ids) {\n      next = removeSubscriptionIdFromDocument(next, documentId, transactionId)\n    }\n  }\n\n  return {...next, outgoing: undefined}\n}\n\nexport function revertOutgoingTransaction(prev: SyncTransactionState): SyncTransactionState {\n  if (!prev.grants) return prev\n  let working = Object.fromEntries(\n    Object.entries(prev.documentStates).map(([documentId, documentState]) => [\n      documentId,\n      documentState?.remote,\n    ]),\n  )\n  const nextApplied: AppliedTransaction[] = []\n\n  for (const t of prev.applied) {\n    try {\n      const next = processActions({...t, working, grants: prev.grants})\n      working = next.working\n      nextApplied.push({...t, ...next})\n    } catch (error) {\n      // if we're already reverting a transaction, skip any applied actions if\n      // they throw while we rebuild the state\n      if (error instanceof ActionError) continue\n      throw error\n    }\n  }\n\n  return {\n    ...prev,\n    applied: nextApplied,\n    outgoing: undefined,\n    documentStates: Object.fromEntries(\n      Object.entries(prev.documentStates)\n        .filter((e): e is [string, DocumentState] => !!e[1])\n        .map(([documentId, {unverifiedRevisions = {}, local, ...documentState}]) => {\n          const next: DocumentState = {\n            ...documentState,\n            local: documentId in working ? working[documentId] : local,\n            unverifiedRevisions:\n              prev.outgoing && prev.outgoing.transactionId in unverifiedRevisions\n                ? omit(unverifiedRevisions, prev.outgoing.transactionId)\n                : unverifiedRevisions,\n          }\n          return [documentId, next] as const\n        }),\n    ),\n  }\n}\n\nexport function applyRemoteDocument(\n  prev: SyncTransactionState,\n  {document, documentId, previousRev, revision, timestamp, type}: RemoteDocument,\n  events: DocumentStoreState['events'],\n): SyncTransactionState {\n  if (!prev.grants) return prev\n  const prevDocState = prev.documentStates[documentId]\n\n  // document state is deleted when there are no more subscribers so we can\n  // simply skip if there is no state\n  if (!prevDocState) return prev\n\n  // we send out transactions with IDs generated client-side to identify them\n  // when they are observed through the listener. here we can check if this\n  // incoming remote document is the result of one of our transactions\n  const prevUnverifiedRevisions = prevDocState.unverifiedRevisions\n  const revisionToVerify = revision ? prevUnverifiedRevisions?.[revision] : undefined\n  let unverifiedRevisions = prevUnverifiedRevisions ?? EMPTY_REVISIONS\n  if (revision && revisionToVerify) {\n    unverifiedRevisions = omit(prevUnverifiedRevisions, revision)\n  }\n\n  // if this remote document is from a `'sync'` event (meaning that the whole\n  // thing was just fetched and not re-created from mutations)\n  if (type === 'sync') {\n    // then remove unverified revisions that are older than our sync time. we\n    // don't need to verify them for a rebase any more because we synced and\n    // grabbed the latest document\n    unverifiedRevisions = Object.fromEntries(\n      Object.entries(unverifiedRevisions).filter(([, unverifiedRevision]) => {\n        if (!unverifiedRevision) return false\n        return new Date(timestamp).getTime() <= new Date(unverifiedRevision.timestamp).getTime()\n      }),\n    )\n  }\n\n  // if there is a revision to verify and the previous revision from remote\n  // matches the previous revision we expected, we can \"fast-forward\" and skip\n  // rebasing local changes on top of this new base\n  if (revisionToVerify && revisionToVerify.previousRev === previousRev) {\n    return {\n      ...prev,\n      documentStates: {\n        ...prev.documentStates,\n        [documentId]: {\n          ...prevDocState,\n          remote: document,\n          remoteRev: revision,\n          unverifiedRevisions,\n        },\n      },\n    }\n  }\n\n  // if we got this far, this means that we could not fast-forward this revision\n  // for this document. now we can rebase our local changes (if any) on top of\n  // this new base from remote. in order to do that we grab the set of documents\n  // captured before the earliest local transaction\n  const previous = prev.applied.at(0)?.previous\n  // our initial working set now is the state of the documents before any of our\n  // local transactions plus the newly updated document from remote\n  let working = {...previous, [documentId]: document}\n  const nextApplied: AppliedTransaction[] = []\n\n  // now we can iterate through our applied (but not yet committed) transactions\n  // starting with the updated working set and re-apply each transaction in\n  // order creating a new set of applied transactions as we go.\n  //\n  // NOTE: we don't want to rebase over the outgoing transaction because that\n  // transaction is already on its way to the server. if an outgoing transaction\n  // needs to be rebased, then it eventually will be when we see that\n  // transaction again through the listener and this same flow will run then\n  for (const curr of prev.applied) {\n    try {\n      const next = processActions({...curr, working, grants: prev.grants})\n      working = next.working\n      // next includes an updated `previous` set and `working` set and updates\n      // the `outgoingAction` and `outgoingMutations`. the `base` set from the\n      // original applied transaction gets put back into the updated transaction\n      // as-is to preserve the intended base for a 3-way merge\n      nextApplied.push({...curr, ...next})\n    } catch (error) {\n      // if processing the action ever throws a related error, we can skip this\n      // local transaction and report the error to the user\n      if (error instanceof ActionError) {\n        events.next({\n          type: 'rebase-error',\n          transactionId: error.transactionId,\n          documentId: error.documentId,\n          message: error.message,\n          error,\n        })\n        continue\n      }\n      throw error\n    }\n  }\n\n  return {\n    ...prev,\n    applied: nextApplied,\n    documentStates: {\n      ...prev.documentStates,\n      [documentId]: {\n        ...prevDocState,\n        remote: document,\n        remoteRev: revision,\n        local: working[documentId],\n        unverifiedRevisions,\n      },\n    },\n  }\n}\n\nexport function addSubscriptionIdToDocument(\n  prev: SyncTransactionState,\n  documentId: string,\n  subscriptionId: string,\n): SyncTransactionState {\n  const prevDocState = prev.documentStates?.[documentId]\n  const prevSubscriptions = prevDocState?.subscriptions ?? []\n\n  return {\n    ...prev,\n    documentStates: {\n      ...prev.documentStates,\n      [documentId]: {\n        ...prevDocState,\n        id: documentId,\n        subscriptions: [...prevSubscriptions, subscriptionId],\n      },\n    },\n  }\n}\n\nexport function removeSubscriptionIdFromDocument(\n  prev: SyncTransactionState,\n  documentId: string,\n  subscriptionId: string,\n): SyncTransactionState {\n  const prevDocState = prev.documentStates?.[documentId]\n  const prevSubscriptions = prevDocState?.subscriptions ?? []\n  const subscriptions = prevSubscriptions.filter((id) => id !== subscriptionId)\n\n  if (!prevDocState) return prev\n  if (!subscriptions.length) {\n    return {...prev, documentStates: omit(prev.documentStates, documentId)}\n  }\n  return {\n    ...prev,\n    documentStates: {\n      ...prev.documentStates,\n      [documentId]: {...prevDocState, subscriptions: subscriptions},\n    },\n  }\n}\n\nexport function manageSubscriberIds(\n  {state}: StoreContext<SyncTransactionState>,\n  documentId: string | string[],\n): () => void {\n  const documentIds = Array.from(\n    new Set(\n      (Array.isArray(documentId) ? documentId : [documentId]).flatMap((id) => [\n        getPublishedId(id),\n        getDraftId(id),\n      ]),\n    ),\n  )\n  const subscriptionId = insecureRandomId()\n  state.set('addSubscribers', (prev) =>\n    documentIds.reduce(\n      (acc, id) => addSubscriptionIdToDocument(acc, id, subscriptionId),\n      prev as SyncTransactionState,\n    ),\n  )\n\n  return () => {\n    setTimeout(() => {\n      state.set('removeSubscribers', (prev) =>\n        documentIds.reduce(\n          (acc, id) => removeSubscriptionIdFromDocument(acc, id, subscriptionId),\n          prev as SyncTransactionState,\n        ),\n      )\n    }, DOCUMENT_STATE_CLEAR_DELAY)\n  }\n}\n\nexport function getDocumentIdsFromActions(action: DocumentAction | DocumentAction[]): string[] {\n  const actions = Array.isArray(action) ? action : [action]\n  return Array.from(\n    new Set(\n      actions\n        .map((i) => i.documentId)\n        .filter((i) => typeof i === 'string')\n        .flatMap((documentId) => [getPublishedId(documentId), getDraftId(documentId)]),\n    ),\n  )\n}\n","import {type SanityClient} from '@sanity/client'\n\nimport {type DocumentAction} from './actions'\nimport {type OutgoingTransaction} from './reducers'\n\n/** @beta */\nexport type DocumentEvent =\n  | ActionErrorEvent\n  | TransactionRevertedEvent\n  | TransactionAcceptedEvent\n  | DocumentRebaseErrorEvent\n  | DocumentEditedEvent\n  | DocumentCreatedEvent\n  | DocumentDeletedEvent\n  | DocumentPublishedEvent\n  | DocumentUnpublishedEvent\n  | DocumentDiscardedEvent\n\n/**\n * @beta\n * Event emitted when a precondition to applying an action fails.\n * (For example: when trying to edit a document that no longer exists.)\n */\nexport interface ActionErrorEvent {\n  type: 'error'\n  documentId: string\n  transactionId: string\n  message: string\n  error: unknown\n}\n/**\n * @beta\n * Event emitted when a transaction is accepted.\n */\nexport interface TransactionAcceptedEvent {\n  type: 'accepted'\n  outgoing: OutgoingTransaction\n  result: Awaited<ReturnType<SanityClient['action']>>\n}\n/**\n * @beta\n * Event emitted when a transaction is reverted.\n */\nexport interface TransactionRevertedEvent {\n  type: 'reverted'\n  message: string\n  error: unknown\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when an attempt to apply local changes to a modified remote document fails.\n */\nexport interface DocumentRebaseErrorEvent {\n  type: 'rebase-error'\n  documentId: string\n  transactionId: string\n  message: string\n  error: unknown\n}\n/**\n * @beta\n * Event emitted when a document is edited.\n */\nexport interface DocumentEditedEvent {\n  type: 'edited'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is created.\n */\nexport interface DocumentCreatedEvent {\n  type: 'created'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is deleted.\n */\nexport interface DocumentDeletedEvent {\n  type: 'deleted'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is published.\n */\nexport interface DocumentPublishedEvent {\n  type: 'published'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is unpublished.\n */\nexport interface DocumentUnpublishedEvent {\n  type: 'unpublished'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document version is discarded.\n */\nexport interface DocumentDiscardedEvent {\n  type: 'discarded'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n\nexport function getDocumentEvents(outgoing: OutgoingTransaction): DocumentEvent[] {\n  const documentIdsByAction = Object.entries(\n    outgoing.actions.reduce(\n      (acc, {type, documentId}) => {\n        const ids = acc[type] || new Set()\n        if (documentId) ids.add(documentId)\n        acc[type] = ids\n        return acc\n      },\n      {} as Record<DocumentAction['type'], Set<string>>,\n    ),\n  ) as [DocumentAction['type'], Set<string>][]\n\n  const actionMap = {\n    'document.create': 'created',\n    'document.delete': 'deleted',\n    'document.discard': 'discarded',\n    'document.edit': 'edited',\n    'document.publish': 'published',\n    'document.unpublish': 'unpublished',\n  } satisfies Record<DocumentAction['type'], DocumentEvent['type']>\n\n  return documentIdsByAction.flatMap(([actionType, documentIds]) =>\n    Array.from(documentIds).map(\n      (documentId): DocumentEvent => ({type: actionMap[actionType], documentId, outgoing}),\n    ),\n  )\n}\n","import {type ListenEvent, type SanityDocument} from '@sanity/client'\nimport {createDocumentLoaderFromClient} from '@sanity/mutate/_unstable_store'\nimport {\n  first,\n  map,\n  merge,\n  Observable,\n  partition,\n  share,\n  shareReplay,\n  Subject,\n  switchMap,\n  takeUntil,\n} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type SanityInstance} from '../store/createSanityInstance'\n\nconst API_VERSION = 'v2025-05-06'\n\nexport interface SharedListener {\n  events: Observable<ListenEvent<SanityDocument>>\n  dispose: () => void\n}\n\nexport function createSharedListener(instance: SanityInstance): SharedListener {\n  const dispose$ = new Subject<void>()\n  const events$ = getClientState(instance, {\n    apiVersion: API_VERSION,\n  }).observable.pipe(\n    switchMap((client) =>\n      // TODO: it seems like the client.listen method is not emitting disconnected\n      // events. this is important to ensure we have an up to date version of the\n      // doc. probably should introduce our own events for when the user goes offline\n      client.listen(\n        '*',\n        {},\n        {\n          events: ['mutation', 'welcome', 'reconnect'],\n          includeResult: false,\n          tag: 'document-listener',\n          // // from manual testing, it seems like mendoza patches may be\n          // // causing some ambiguity/wonkiness\n          // includeMutations: false,\n          // effectFormat: 'mendoza',\n        },\n      ),\n    ),\n    takeUntil(dispose$),\n    share(),\n  )\n\n  const [welcome$, mutation$] = partition(events$, (e) => e.type === 'welcome')\n\n  return {\n    events: merge(\n      // we replay the welcome event because that event kicks off fetching the document\n      welcome$.pipe(shareReplay(1)),\n      mutation$,\n    ),\n    dispose: () => dispose$.next(),\n  }\n}\n\nexport function createFetchDocument(instance: SanityInstance) {\n  return function (documentId: string): Observable<SanityDocument | null> {\n    return getClientState(instance, {apiVersion: API_VERSION}).observable.pipe(\n      switchMap((client) => {\n        // TODO: remove this once the client is updated to v7 the new type is available in @sanity/mutate/_unstable_store\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const loadDocument = createDocumentLoaderFromClient(client as any)\n        return loadDocument(documentId)\n      }),\n      map((result) => {\n        if (!result.accessible) {\n          if (result.reason === 'existence') return null\n          throw new Error(`Document with ID \\`${documentId}\\` is inaccessible due to permissions.`)\n        }\n        return result.document as SanityDocument\n      }),\n      first(),\n    )\n  }\n}\n","import {type Action} from '@sanity/client'\nimport {getPublishedId} from '@sanity/client/csm'\nimport {jsonMatch} from '@sanity/json-match'\nimport {type SanityDocument} from 'groq'\nimport {type ExprNode} from 'groq-js'\nimport {\n  catchError,\n  concatMap,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  groupBy,\n  map,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  Subject,\n  switchMap,\n  tap,\n  throttle,\n  timer,\n  withLatestFrom,\n} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset, type StoreAction} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {createStateSourceAction, type StateSource} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {getDraftId} from '../utils/ids'\nimport {type DocumentAction} from './actions'\nimport {API_VERSION, INITIAL_OUTGOING_THROTTLE_TIME} from './documentConstants'\nimport {type DocumentEvent, getDocumentEvents} from './events'\nimport {listen, OutOfSyncError} from './listen'\nimport {type JsonMatch} from './patchOperations'\nimport {calculatePermissions, createGrantsLookup, type DatasetAcl, type Grant} from './permissions'\nimport {ActionError} from './processActions'\nimport {\n  type AppliedTransaction,\n  applyFirstQueuedTransaction,\n  applyRemoteDocument,\n  cleanupOutgoingTransaction,\n  getDocumentIdsFromActions,\n  manageSubscriberIds,\n  type OutgoingTransaction,\n  type QueuedTransaction,\n  removeQueuedTransaction,\n  revertOutgoingTransaction,\n  transitionAppliedTransactionsToOutgoing,\n  type UnverifiedDocumentRevision,\n} from './reducers'\nimport {createFetchDocument, createSharedListener, type SharedListener} from './sharedListener'\n\nexport interface DocumentStoreState {\n  documentStates: {[TDocumentId in string]?: DocumentState}\n  queued: QueuedTransaction[]\n  applied: AppliedTransaction[]\n  outgoing?: OutgoingTransaction\n  grants?: Record<Grant, ExprNode>\n  error?: unknown\n  sharedListener: SharedListener\n  fetchDocument: (documentId: string) => Observable<SanityDocument | null>\n  events: Subject<DocumentEvent>\n}\n\nexport interface DocumentState {\n  id: string\n  /**\n   * the \"remote\" local copy that matches the server. represents the last known\n   * server state. this gets updated every time we confirm remote patches\n   */\n  remote?: SanityDocument | null\n  /**\n   * the current ephemeral working copy that includes local optimistic changes\n   * that have not yet been confirmed by the server\n   */\n  local?: SanityDocument | null\n  /**\n   * the revision that our remote document is at\n   */\n  remoteRev?: string | null\n  /**\n   * Array of subscription IDs. This document state will be deleted if there are\n   * no subscribers.\n   */\n  subscriptions: string[]\n  /**\n   * An object keyed by transaction ID of revisions sent out but that have not\n   * yet been verified yet. When an applied transaction is transitioned to an\n   * outgoing transaction, it also adds unverified revisions for each document\n   * that is part of that outgoing transaction. Transactions are submitted to\n   * the server with a locally generated transaction ID. This way we can observe\n   * when our transaction comes back through the shared listener. Each listener\n   * event that comes back contains a `previousRev`. If we see our own\n   * transaction with a different `previousRev` than expected, we can rebase our\n   * local transactions on top of this new remote.\n   */\n  unverifiedRevisions?: {[TTransactionId in string]?: UnverifiedDocumentRevision}\n}\n\nexport const documentStore = defineStore<DocumentStoreState>({\n  name: 'Document',\n  getInitialState: (instance) => ({\n    documentStates: {},\n    // these can be emptied on refetch\n    queued: [],\n    applied: [],\n    sharedListener: createSharedListener(instance),\n    fetchDocument: createFetchDocument(instance),\n    events: new Subject(),\n  }),\n  initialize(context) {\n    const {sharedListener} = context.state.get()\n    const subscriptions = [\n      subscribeToQueuedAndApplyNextTransaction(context),\n      subscribeToSubscriptionsAndListenToDocuments(context),\n      subscribeToAppliedAndSubmitNextTransaction(context),\n      subscribeToClientAndFetchDatasetAcl(context),\n    ]\n\n    return () => {\n      sharedListener.dispose()\n      subscriptions.forEach((subscription) => subscription.unsubscribe())\n    }\n  },\n})\n\n/**\n * @beta\n * Options for specifying a document and optionally a path within it.\n */\nexport interface DocumentOptions<\n  TPath extends string | undefined = undefined,\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  path?: TPath\n}\n\n/** @beta */\nexport function getDocumentState<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  options: DocumentOptions<undefined, TDocumentType, TDataset, TProjectId>,\n): StateSource<SanityDocument<TDocumentType, `${TProjectId}.${TDataset}`> | undefined | null>\n\n/** @beta */\nexport function getDocumentState<\n  TPath extends string = string,\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  options: DocumentOptions<TPath, TDocumentType, TDataset, TProjectId>,\n): StateSource<\n  JsonMatch<SanityDocument<TDocumentType, `${TProjectId}.${TDataset}`>, TPath> | undefined\n>\n\n/** @beta */\nexport function getDocumentState<TData>(\n  instance: SanityInstance,\n  options: DocumentOptions<string | undefined>,\n): StateSource<TData | undefined | null>\n\n/** @beta */\nexport function getDocumentState(\n  ...args: Parameters<typeof _getDocumentState>\n): StateSource<unknown> {\n  return _getDocumentState(...args)\n}\n\nconst _getDocumentState = bindActionByDataset(\n  documentStore,\n  createStateSourceAction({\n    selector: ({state: {error, documentStates}}, options: DocumentOptions<string | undefined>) => {\n      const {documentId, path} = options\n      if (error) throw error\n      const draftId = getDraftId(documentId)\n      const publishedId = getPublishedId(documentId)\n      const draft = documentStates[draftId]?.local\n      const published = documentStates[publishedId]?.local\n\n      // wait for draft and published to be loaded before returning a value\n      if (draft === undefined || published === undefined) return undefined\n      const document = draft ?? published\n      if (!path) return document\n      const result = jsonMatch(document, path).next()\n      if (result.done) return undefined\n      const {value} = result.value\n      return value\n    },\n    onSubscribe: (context, options: DocumentOptions<string | undefined>) =>\n      manageSubscriberIds(context, options.documentId),\n  }),\n)\n\n/** @beta */\nexport function resolveDocument<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  docHandle: DocumentHandle<TDocumentType, TDataset, TProjectId>,\n): Promise<SanityDocument<TDocumentType, `${TProjectId}.${TDataset}`> | null>\n/** @beta */\nexport function resolveDocument<TData extends SanityDocument>(\n  instance: SanityInstance,\n  docHandle: DocumentHandle<string, string, string>,\n): Promise<TData | null>\n/** @beta */\nexport function resolveDocument(\n  ...args: Parameters<typeof _resolveDocument>\n): Promise<SanityDocument | null> {\n  return _resolveDocument(...args)\n}\nconst _resolveDocument = bindActionByDataset(\n  documentStore,\n  ({instance}, docHandle: DocumentHandle<string, string, string>) => {\n    return firstValueFrom(\n      getDocumentState(instance, {\n        ...docHandle,\n        path: undefined,\n      }).observable.pipe(filter((i) => i !== undefined)),\n    ) as Promise<SanityDocument | null>\n  },\n)\n\n/** @beta */\nexport const getDocumentSyncStatus = bindActionByDataset(\n  documentStore,\n  createStateSourceAction({\n    selector: (\n      {state: {error, documentStates: documents, outgoing, applied, queued}},\n      doc: DocumentHandle,\n    ) => {\n      const documentId = typeof doc === 'string' ? doc : doc.documentId\n      if (error) throw error\n      const draftId = getDraftId(documentId)\n      const publishedId = getPublishedId(documentId)\n\n      const draft = documents[draftId]\n      const published = documents[publishedId]\n\n      if (draft === undefined || published === undefined) return undefined\n      return !queued.length && !applied.length && !outgoing\n    },\n    onSubscribe: (context, doc: DocumentHandle) => manageSubscriberIds(context, doc.documentId),\n  }),\n)\n\n/** @beta */\nexport const getPermissionsState = bindActionByDataset(\n  documentStore,\n  createStateSourceAction({\n    selector: calculatePermissions,\n    onSubscribe: (context, actions) =>\n      manageSubscriberIds(context, getDocumentIdsFromActions(actions)),\n  }) as StoreAction<\n    DocumentStoreState,\n    [DocumentAction | DocumentAction[]],\n    StateSource<ReturnType<typeof calculatePermissions>>\n  >,\n)\n\n/** @beta */\nexport const resolvePermissions = bindActionByDataset(\n  documentStore,\n  ({instance}, actions: DocumentAction | DocumentAction[]) => {\n    return firstValueFrom(\n      getPermissionsState(instance, actions).observable.pipe(filter((i) => i !== undefined)),\n    )\n  },\n)\n\n/** @beta */\nexport const subscribeDocumentEvents = bindActionByDataset(\n  documentStore,\n  ({state}, eventHandler: (e: DocumentEvent) => void) => {\n    const {events} = state.get()\n    const subscription = events.subscribe(eventHandler)\n    return () => subscription.unsubscribe()\n  },\n)\n\nconst subscribeToQueuedAndApplyNextTransaction = ({state}: StoreContext<DocumentStoreState>) => {\n  const {events} = state.get()\n  return state.observable\n    .pipe(\n      map(applyFirstQueuedTransaction),\n      distinctUntilChanged(),\n      tap((next) => state.set('applyFirstQueuedTransaction', next)),\n      catchError((error, caught) => {\n        if (error instanceof ActionError) {\n          state.set('removeQueuedTransaction', (prev) =>\n            removeQueuedTransaction(prev, error.transactionId),\n          )\n          events.next({\n            type: 'error',\n            message: error.message,\n            documentId: error.documentId,\n            transactionId: error.transactionId,\n            error,\n          })\n          return caught\n        }\n\n        throw error\n      }),\n    )\n    .subscribe({error: (error) => state.set('setError', {error})})\n}\n\nconst subscribeToAppliedAndSubmitNextTransaction = ({\n  state,\n  instance,\n}: StoreContext<DocumentStoreState>) => {\n  const {events} = state.get()\n\n  return state.observable\n    .pipe(\n      throttle(\n        (s) =>\n          // if there is no outgoing transaction, we can throttle by the\n          // initial outgoing throttle time…\n          !s.outgoing\n            ? timer(INITIAL_OUTGOING_THROTTLE_TIME)\n            : // …otherwise, wait until the outgoing has been cleared\n              state.observable.pipe(first(({outgoing}) => !outgoing)),\n        {leading: false, trailing: true},\n      ),\n      map(transitionAppliedTransactionsToOutgoing),\n      distinctUntilChanged((a, b) => a.outgoing?.transactionId === b.outgoing?.transactionId),\n      tap((next) => state.set('transitionAppliedTransactionsToOutgoing', next)),\n      map((s) => s.outgoing),\n      distinctUntilChanged(),\n      withLatestFrom(getClientState(instance, {apiVersion: API_VERSION}).observable),\n      concatMap(([outgoing, client]) => {\n        if (!outgoing) return EMPTY\n        return client.observable\n          .action(outgoing.outgoingActions as Action[], {\n            transactionId: outgoing.transactionId,\n            skipCrossDatasetReferenceValidation: true,\n          })\n          .pipe(\n            catchError((error) => {\n              state.set('revertOutgoingTransaction', revertOutgoingTransaction)\n              events.next({type: 'reverted', message: error.message, outgoing, error})\n              return EMPTY\n            }),\n            map((result) => ({result, outgoing})),\n          )\n      }),\n      tap(({outgoing, result}) => {\n        state.set('cleanupOutgoingTransaction', cleanupOutgoingTransaction)\n        for (const e of getDocumentEvents(outgoing)) events.next(e)\n        events.next({type: 'accepted', outgoing, result})\n      }),\n    )\n    .subscribe({error: (error) => state.set('setError', {error})})\n}\n\nconst subscribeToSubscriptionsAndListenToDocuments = (\n  context: StoreContext<DocumentStoreState>,\n) => {\n  const {state} = context\n  const {events} = state.get()\n\n  return state.observable\n    .pipe(\n      filter((s) => !!s.grants),\n      map((s) => Object.keys(s.documentStates)),\n      distinctUntilChanged((curr, next) => {\n        if (curr.length !== next.length) return false\n        const currSet = new Set(curr)\n        return next.every((i) => currSet.has(i))\n      }),\n      startWith(new Set<string>()),\n      pairwise(),\n      switchMap((pair) => {\n        const [curr, next] = pair.map((ids) => new Set(ids))\n        const added = Array.from(next).filter((i) => !curr.has(i))\n        const removed = Array.from(curr).filter((i) => !next.has(i))\n\n        // NOTE: the order of which these go out is somewhat important\n        // because that determines the order `applyRemoteDocument` is called\n        // which in turn determines which document version get populated\n        // first. because we prefer drafts, it's better to have those go out\n        // first so that the published document doesn't flash for a frame\n        const changes = [\n          ...added.map((id) => ({id, add: true})),\n          ...removed.map((id) => ({id, add: false})),\n        ].sort((a, b) => {\n          const aIsDraft = a.id === getDraftId(a.id)\n          const bIsDraft = b.id === getDraftId(b.id)\n\n          if (aIsDraft && bIsDraft) return a.id.localeCompare(b.id, 'en-US')\n          if (aIsDraft) return -1\n          if (bIsDraft) return 1\n          return a.id.localeCompare(b.id, 'en-US')\n        })\n\n        return of<{id: string; add: boolean}[]>(...changes)\n      }),\n      groupBy((i) => i.id),\n      mergeMap((group) =>\n        group.pipe(\n          switchMap((e) => {\n            if (!e.add) return EMPTY\n            return listen(context, e.id).pipe(\n              catchError((error) => {\n                // retry on `OutOfSyncError`\n                if (error instanceof OutOfSyncError) listen(context, e.id)\n                throw error\n              }),\n              tap((remote) =>\n                state.set('applyRemoteDocument', (prev) =>\n                  applyRemoteDocument(prev, remote, events),\n                ),\n              ),\n            )\n          }),\n        ),\n      ),\n    )\n    .subscribe({error: (error) => state.set('setError', {error})})\n}\n\nconst subscribeToClientAndFetchDatasetAcl = ({\n  instance,\n  state,\n}: StoreContext<DocumentStoreState>) => {\n  const {projectId, dataset} = instance.config\n  return getClientState(instance, {apiVersion: API_VERSION})\n    .observable.pipe(\n      switchMap((client) =>\n        client.observable.request<DatasetAcl>({\n          uri: `/projects/${projectId}/datasets/${dataset}/acl`,\n          tag: 'acl.get',\n          withCredentials: true,\n        }),\n      ),\n      tap((datasetAcl) => state.set('setGrants', {grants: createGrantsLookup(datasetAcl)})),\n    )\n    .subscribe({\n      error: (error) => state.set('setError', {error}),\n    })\n}\n","import {type SanityClient} from '@sanity/client'\nimport {type SanityDocument} from 'groq'\nimport {distinctUntilChanged, filter, first, firstValueFrom, map, race} from 'rxjs'\n\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {type StoreContext} from '../store/defineStore'\nimport {type DocumentAction} from './actions'\nimport {documentStore, type DocumentStoreState} from './documentStore'\nimport {type DocumentSet} from './processMutations'\nimport {type AppliedTransaction, type QueuedTransaction, queueTransaction} from './reducers'\n\n/** @beta */\nexport interface ActionsResult<TDocument extends SanityDocument = SanityDocument> {\n  transactionId: string\n  documents: DocumentSet<TDocument>\n  previous: DocumentSet<TDocument>\n  previousRevs: {[documentId: string]: string | undefined}\n  appeared: string[]\n  updated: string[]\n  disappeared: string[]\n  submitted: () => ReturnType<SanityClient['action']>\n}\n\n/** @beta */\nexport interface ApplyDocumentActionsOptions {\n  /**\n   * Optionally provide an ID to be used as this transaction ID\n   */\n  transactionId?: string\n  /**\n   * Set this to true to prevent this action from being batched with others.\n   */\n  disableBatching?: boolean\n}\n\n/** @beta */\nexport function applyDocumentActions<\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  action:\n    | DocumentAction<TDocumentType, TDataset, TProjectId>\n    | DocumentAction<TDocumentType, TDataset, TProjectId>[],\n  options?: ApplyDocumentActionsOptions,\n): Promise<ActionsResult<SanityDocument<TDocumentType, `${TProjectId}.${TDataset}`>>>\n/** @beta */\nexport function applyDocumentActions(\n  instance: SanityInstance,\n  action: DocumentAction | DocumentAction[],\n  options?: ApplyDocumentActionsOptions,\n): Promise<ActionsResult>\n\n/** @beta */\nexport function applyDocumentActions(\n  ...args: Parameters<typeof boundApplyDocumentActions>\n): ReturnType<typeof boundApplyDocumentActions> {\n  return boundApplyDocumentActions(...args)\n}\n\nconst boundApplyDocumentActions = bindActionByDataset(documentStore, _applyDocumentActions)\n\n/** @internal */\nasync function _applyDocumentActions(\n  {instance, state}: StoreContext<DocumentStoreState>,\n  actionOrActions: DocumentAction | DocumentAction[],\n  {transactionId = crypto.randomUUID(), disableBatching}: ApplyDocumentActionsOptions = {},\n): Promise<ActionsResult> {\n  const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]\n\n  let projectId\n  let dataset\n  for (const action of actions) {\n    if (action.projectId) {\n      if (!projectId) projectId = action.projectId\n      if (action.projectId !== projectId) {\n        throw new Error(\n          `Mismatched project IDs found in actions. All actions must belong to the same project. Found \"${action.projectId}\" but expected \"${projectId}\".`,\n        )\n      }\n\n      if (action.dataset) {\n        if (!dataset) dataset = action.dataset\n        if (action.dataset !== dataset) {\n          throw new Error(\n            `Mismatched datasets found in actions. All actions must belong to the same dataset. Found \"${action.dataset}\" but expected \"${dataset}\".`,\n          )\n        }\n      }\n    }\n  }\n\n  if (\n    (projectId && projectId !== instance.config.projectId) ||\n    (dataset && dataset !== instance.config.dataset)\n  ) {\n    const matchedInstance = instance.match({projectId, dataset})\n    if (!matchedInstance) {\n      throw new Error(\n        `Could not find a matching instance for projectId: \"${projectId}\" and dataset: \"${dataset}\"`,\n      )\n    }\n    return boundApplyDocumentActions(matchedInstance, actionOrActions, {\n      disableBatching,\n      transactionId,\n    })\n  }\n\n  const {events} = state.get()\n\n  const transaction: QueuedTransaction = {\n    transactionId,\n    actions,\n    ...(disableBatching && {disableBatching}),\n  }\n\n  const fatalError$ = state.observable.pipe(\n    map((s) => s.error),\n    first(Boolean),\n    map((error) => ({type: 'error', error}) as const),\n  )\n\n  const transactionError$ = events.pipe(\n    filter((e) => e.type === 'error'),\n    first((e) => e.transactionId === transactionId),\n  )\n\n  const appliedTransaction$ = state.observable.pipe(\n    map((s) => s.applied),\n    distinctUntilChanged(),\n    map((applied) => applied.find((t) => t.transactionId === transactionId)),\n    first(Boolean),\n  )\n\n  const successfulTransaction$ = events.pipe(\n    filter((e) => e.type === 'accepted'),\n    first((e) => e.outgoing.batchedTransactionIds.includes(transactionId)),\n  )\n\n  const rejectedTransaction$ = events.pipe(\n    filter((e) => e.type === 'reverted'),\n    first((e) => e.outgoing.batchedTransactionIds.includes(transactionId)),\n  )\n\n  const appliedTransactionOrError = firstValueFrom(\n    race([fatalError$, transactionError$, appliedTransaction$]),\n  )\n  const acceptedOrRejectedTransaction = firstValueFrom(\n    race([successfulTransaction$, rejectedTransaction$, transactionError$]),\n  )\n\n  state.set('queueTransaction', (prev) => queueTransaction(prev, transaction))\n\n  const result = await appliedTransactionOrError\n  if ('type' in result && result.type === 'error') throw result.error\n\n  const {working: documents, previous, previousRevs} = result as AppliedTransaction\n  const existingIds = new Set(\n    Object.entries(previous)\n      .filter(([, value]) => !!value)\n      .map(([key]) => key),\n  )\n  const resultingIds = new Set(\n    Object.entries(documents)\n      .filter(([, value]) => !!value)\n      .map(([key]) => key),\n  )\n  const allIds = new Set([...existingIds, ...resultingIds])\n\n  const updated: string[] = []\n  const appeared: string[] = []\n  const disappeared: string[] = []\n\n  for (const id of allIds) {\n    if (existingIds.has(id) && resultingIds.has(id)) {\n      updated.push(id)\n    } else if (!existingIds.has(id) && resultingIds.has(id)) {\n      appeared.push(id)\n    } else if (!resultingIds.has(id) && existingIds.has(id)) {\n      disappeared.push(id)\n    }\n  }\n\n  async function submitted() {\n    const raceResult = await acceptedOrRejectedTransaction\n    if (raceResult.type !== 'accepted') throw raceResult.error\n    return raceResult.result\n  }\n\n  return {\n    transactionId,\n    documents,\n    previous,\n    previousRevs,\n    appeared,\n    updated,\n    disappeared,\n    submitted,\n  }\n}\n","import {\n  type CanvasResource,\n  type MediaResource,\n  SDK_CHANNEL_NAME,\n  SDK_NODE_NAME,\n  type StudioResource,\n} from '@sanity/message-protocol'\nimport {catchError, filter, from, map, Observable, of, shareReplay, switchMap} from 'rxjs'\n\nimport {getNodeState} from '../comlink/node/getNodeState'\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {createFetcherStore} from '../utils/createFetcherStore'\n\n/**\n * @public\n */\nexport interface FavoriteStatusResponse {\n  isFavorited: boolean\n}\n\n/**\n * @public\n */\ninterface FavoriteDocumentContext extends DocumentHandle {\n  resourceId: string\n  resourceType: StudioResource['type'] | MediaResource['type'] | CanvasResource['type']\n  schemaName?: string\n}\n\n// Helper to create a stable key for the store\nfunction createFavoriteKey(context: FavoriteDocumentContext): string {\n  return `${context.documentId}:${context.documentType}:${context.resourceId}:${context.resourceType}${\n    context.schemaName ? `:${context.schemaName}` : ''\n  }`\n}\n\nconst favorites = createFetcherStore<[FavoriteDocumentContext], FavoriteStatusResponse>({\n  name: 'Favorites',\n  getKey: (_instance: SanityInstance, context: FavoriteDocumentContext) => {\n    return createFavoriteKey(context)\n  },\n  fetcher: (instance: SanityInstance) => {\n    return (context: FavoriteDocumentContext): Observable<FavoriteStatusResponse> => {\n      const nodeStateSource = getNodeState(instance, {\n        name: SDK_NODE_NAME,\n        connectTo: SDK_CHANNEL_NAME,\n      })\n      const payload = {\n        document: {\n          id: context.documentId,\n          type: context.documentType,\n          resource: {\n            id: context.resourceId,\n            type: context.resourceType,\n            schemaName: context.schemaName,\n          },\n        },\n      }\n\n      return nodeStateSource.observable.pipe(\n        filter((nodeState) => !!nodeState), // Only proceed when connected\n        shareReplay(1),\n        switchMap((nodeState) => {\n          const node = nodeState!.node\n          return from(\n            node.fetch(\n              // @ts-expect-error -- getOrCreateNode should be refactored to take type arguments\n              'dashboard/v1/events/favorite/query',\n              payload,\n            ) as Promise<FavoriteStatusResponse>,\n          ).pipe(\n            map((response) => ({isFavorited: response.isFavorited})),\n            catchError((err) => {\n              // eslint-disable-next-line no-console\n              console.error('Favorites service connection error', err)\n              return of({isFavorited: false})\n            }),\n          )\n        }),\n      )\n    }\n  },\n})\n\n/**\n * Gets a StateSource for the favorite status of a document.\n * @param instance - The Sanity instance.\n * @param context - The document context including ID, type, and resource information.\n * @returns A StateSource emitting `{ isFavorited: boolean }`.\n * @public\n */\nexport const getFavoritesState = favorites.getState\n\n/**\n * Resolves the favorite status for a document.\n * @param instance - The Sanity instance.\n * @param context - The document context including ID, type, and resource information.\n * @returns A Promise resolving to `{ isFavorited: boolean }`.\n * @public\n */\nexport const resolveFavoritesState = favorites.resolveState\n","// NOTE: currently this API is only available on vX\nexport const API_VERSION = 'vX'\nexport const PROJECT_API_VERSION = '2025-07-18'\nexport const USERS_STATE_CLEAR_DELAY = 5000\nexport const DEFAULT_USERS_BATCH_SIZE = 100\n","import {omit} from 'lodash-es'\n\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {type GetUsersOptions, type SanityUserResponse, type UsersStoreState} from './types'\nimport {DEFAULT_USERS_BATCH_SIZE} from './usersConstants'\n\n/** @internal */\nexport const getUsersKey = (\n  instance: SanityInstance,\n  {\n    resourceType,\n    organizationId,\n    batchSize = DEFAULT_USERS_BATCH_SIZE,\n    projectId = instance.config.projectId,\n    userId,\n  }: GetUsersOptions = {},\n): string =>\n  JSON.stringify({\n    resourceType,\n    organizationId,\n    batchSize,\n    projectId,\n    userId,\n  } satisfies ReturnType<typeof parseUsersKey>)\n\n/** @internal */\nexport const parseUsersKey = (\n  key: string,\n): {\n  batchSize: number\n  resourceType?: 'organization' | 'project'\n  projectId?: string\n  organizationId?: string\n  userId?: string\n} => JSON.parse(key)\n\nexport const addSubscription =\n  (subscriptionId: string, key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    const subscriptions = [...(group?.subscriptions ?? []), subscriptionId]\n    return {...prev, users: {...prev.users, [key]: {...group, subscriptions}}}\n  }\n\nexport const removeSubscription =\n  (subscriptionId: string, key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    const subscriptions = group.subscriptions.filter((id) => id !== subscriptionId)\n    if (!subscriptions.length) return {...prev, users: omit(prev.users, key)}\n    return {...prev, users: {...prev.users, [key]: {...group, subscriptions}}}\n  }\n\nexport const setUsersData =\n  (key: string, {data, nextCursor, totalCount}: SanityUserResponse) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    const users = [...(group.users ?? []), ...data]\n    return {...prev, users: {...prev.users, [key]: {...group, users, totalCount, nextCursor}}}\n  }\n\nexport const updateLastLoadMoreRequest =\n  (timestamp: string, key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    return {...prev, users: {...prev.users, [key]: {...group, lastLoadMoreRequest: timestamp}}}\n  }\n\nexport const setUsersError =\n  (key: string, error: unknown) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    return {...prev, users: {...prev.users, [key]: {...group, error}}}\n  }\n\nexport const cancelRequest =\n  (key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    if (group.subscriptions.length) return prev\n    return {...prev, users: omit(prev.users, key)}\n  }\n\nexport const initializeRequest =\n  (key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    if (prev.users[key]) return prev\n    return {...prev, users: {...prev.users, [key]: {subscriptions: []}}}\n  }\n","import {type SanityUser as SanityUserFromClient} from '@sanity/client'\nimport {createSelector} from 'reselect'\nimport {\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  groupBy,\n  map,\n  mergeMap,\n  NEVER,\n  Observable,\n  of,\n  pairwise,\n  race,\n  skip,\n  startWith,\n  switchMap,\n  tap,\n  throwError,\n  withLatestFrom,\n} from 'rxjs'\n\nimport {getDashboardOrganizationId} from '../auth/authStore'\nimport {getClient, getClientState} from '../client/clientStore'\nimport {bindActionGlobally} from '../store/createActionBinder'\nimport {createStateSourceAction, type SelectorContext} from '../store/createStateSourceAction'\nimport {type StoreState} from '../store/createStoreState'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {insecureRandomId} from '../utils/ids'\nimport {\n  addSubscription,\n  cancelRequest,\n  getUsersKey,\n  initializeRequest,\n  parseUsersKey,\n  removeSubscription,\n  setUsersData,\n  setUsersError,\n  updateLastLoadMoreRequest,\n} from './reducers'\nimport {\n  type GetUserOptions,\n  type GetUsersOptions,\n  type ResolveUserOptions,\n  type ResolveUsersOptions,\n  type SanityUser,\n  type SanityUserResponse,\n  type UsersStoreState,\n} from './types'\nimport {API_VERSION, PROJECT_API_VERSION, USERS_STATE_CLEAR_DELAY} from './usersConstants'\n\n/** @internal */\nexport type PatchedSanityUserFromClient = Omit<SanityUserFromClient, 'id'> & {\n  id: string\n  sanityUserId: string\n  email: string\n  provider: string\n}\n\n/**\n * The users store resource that manages user data fetching and state.\n *\n * This store handles fetching, caching, and managing user data. It provides functionality for\n * retrieving users associated with specific resources and supports pagination through the\n * `loadMoreUsers` action.\n *\n * @internal\n */\nconst usersStore = defineStore<UsersStoreState>({\n  name: 'UsersStore',\n  getInitialState: () => ({users: {}}),\n  initialize: (context) => {\n    const subscription = listenForLoadMoreAndFetch(context)\n    return () => subscription.unsubscribe()\n  },\n})\n\nconst errorHandler =\n  (state: StoreState<{error?: unknown}>) =>\n  (error: unknown): void =>\n    state.set('setError', {error})\n\n/**\n * Internal action that listens for new user subscriptions and load more requests.\n * Fetches user data when new subscriptions are added or when loadMoreUsers is called.\n */\nconst listenForLoadMoreAndFetch = ({state, instance}: StoreContext<UsersStoreState>) => {\n  return state.observable\n    .pipe(\n      map((s) => new Set(Object.keys(s.users))),\n      distinctUntilChanged((curr, next) => {\n        if (curr.size !== next.size) return false\n        return Array.from(next).every((i) => curr.has(i))\n      }),\n      startWith(new Set<string>()),\n      pairwise(),\n      mergeMap(([curr, next]) => {\n        const added = Array.from(next).filter((i) => !curr.has(i))\n        const removed = Array.from(curr).filter((i) => !next.has(i))\n\n        return [\n          ...added.map((key) => ({key, added: true})),\n          ...removed.map((key) => ({key, added: false})),\n        ]\n      }),\n      groupBy((i) => i.key),\n      mergeMap((group$) =>\n        group$.pipe(\n          switchMap((e) => {\n            if (!e.added) return EMPTY\n            const {userId, batchSize, ...options} = parseUsersKey(group$.key)\n\n            if (userId) {\n              // In the future we will be able to fetch a user from the global API using the resourceUserId,\n              // but for now we need to use the project subdomain to fetch a user if the userId is a project user (starts with \"p\")\n              if (userId.startsWith('p')) {\n                const client = getClient(instance, {\n                  apiVersion: PROJECT_API_VERSION,\n                  // this is a global store, so we need to use the projectId from the options when we're fetching\n                  // users from a project subdomain\n                  projectId: options.projectId,\n                  useProjectHostname: true,\n                })\n\n                return client.observable\n                  .request<PatchedSanityUserFromClient>({\n                    method: 'GET',\n                    uri: `/users/${userId}`,\n                  })\n                  .pipe(\n                    map((user) => {\n                      // We need to convert the user to the format we expect\n                      const convertedUser: SanityUser = {\n                        sanityUserId: user.sanityUserId,\n                        profile: {\n                          id: user.id,\n                          displayName: user.displayName,\n                          familyName: user.familyName ?? undefined,\n                          givenName: user.givenName ?? undefined,\n                          middleName: user.middleName ?? undefined,\n                          imageUrl: user.imageUrl ?? undefined,\n                          createdAt: user.createdAt,\n                          updatedAt: user.updatedAt,\n                          isCurrentUser: user.isCurrentUser,\n                          email: user.email,\n                          provider: user.provider,\n                        },\n                        memberships: [],\n                      }\n                      return {\n                        data: [convertedUser],\n                        totalCount: 1,\n                        nextCursor: null,\n                      }\n                    }),\n                    catchError((error) => {\n                      state.set('setUsersError', setUsersError(group$.key, error))\n                      return EMPTY\n                    }),\n                    tap((response) =>\n                      state.set('setUsersData', setUsersData(group$.key, response)),\n                    ),\n                  )\n              }\n\n              // Fetch the user from the global API\n              const scope = userId.startsWith('g') ? 'global' : undefined\n              const client = getClient(instance, {\n                scope,\n                apiVersion: API_VERSION,\n              })\n              const resourceType = options.resourceType || 'project'\n              const resourceId =\n                resourceType === 'organization' ? options.organizationId : options.projectId\n              if (!resourceId) {\n                return throwError(() => new Error('An organizationId or a projectId is required'))\n              }\n              return client.observable\n                .request<SanityUser | SanityUserResponse>({\n                  method: 'GET',\n                  uri: `access/${resourceType}/${resourceId}/users/${userId}`,\n                })\n                .pipe(\n                  map((response) => {\n                    // If the response is a single user object (has sanityUserId), wrap it in the expected format\n                    if ('sanityUserId' in response) {\n                      return {\n                        data: [response],\n                        totalCount: 1,\n                        nextCursor: null,\n                      } as SanityUserResponse\n                    }\n                    return response as SanityUserResponse\n                  }),\n                  catchError((error) => {\n                    state.set('setUsersError', setUsersError(group$.key, error))\n                    return EMPTY\n                  }),\n                  tap((response) => state.set('setUsersData', setUsersData(group$.key, response))),\n                )\n            }\n            const projectId = options.projectId\n\n            // the resource type this request will use\n            // If resourceType is explicitly provided, use it\n            // Otherwise, infer from context: organization if organizationId exists,\n            // project if projectId exists, or default to organization\n            const resourceType =\n              options.resourceType ??\n              (options.organizationId ? 'organization' : projectId ? 'project' : 'organization')\n\n            const organizationId$ = options.organizationId\n              ? of(options.organizationId)\n              : getDashboardOrganizationId(instance).observable.pipe(\n                  filter((i) => typeof i === 'string'),\n                )\n\n            const resource$: Observable<{\n              type: 'project' | 'organization'\n              id: string\n            }> =\n              resourceType === 'project'\n                ? projectId\n                  ? of({type: 'project', id: projectId})\n                  : throwError(() => new Error('Project ID required for this API.'))\n                : organizationId$.pipe(map((id) => ({type: 'organization', id})))\n\n            const client$ = getClientState(instance, {\n              scope: 'global',\n              apiVersion: API_VERSION,\n            }).observable\n\n            const loadMore$ = state.observable.pipe(\n              map((s) => s.users[group$.key]?.lastLoadMoreRequest),\n              distinctUntilChanged(),\n            )\n\n            const cursor$ = state.observable.pipe(\n              map((s) => s.users[group$.key]?.nextCursor),\n              distinctUntilChanged(),\n              filter((cursor) => cursor !== null),\n            )\n\n            return combineLatest([resource$, client$, loadMore$]).pipe(\n              withLatestFrom(cursor$),\n              switchMap(([[resource, client], cursor]) =>\n                client.observable.request<SanityUserResponse>({\n                  method: 'GET',\n                  uri: `access/${resource.type}/${resource.id}/users`,\n                  query: cursor\n                    ? {nextCursor: cursor, limit: batchSize.toString()}\n                    : {limit: batchSize.toString()},\n                }),\n              ),\n              catchError((error) => {\n                state.set('setUsersError', setUsersError(group$.key, error))\n                return EMPTY\n              }),\n              tap((response) => state.set('setUsersData', setUsersData(group$.key, response))),\n            )\n          }),\n        ),\n      ),\n    )\n    .subscribe({error: errorHandler(state)})\n}\n\n/**\n * Returns the state source for users associated with a specific resource.\n *\n * This function returns a state source that represents the current list of users for a given\n * resource. Subscribing to the state source will instruct the SDK to fetch the users (if not\n * already fetched) and will load more from this state source as well. When the last subscriber is\n * removed, the users state is automatically cleaned up from the store after a delay.\n *\n * Note: This functionality is for advanced users who want to build their own framework\n * integrations. Our SDK also provides a React integration for convenient usage.\n *\n * @beta\n */\nexport const getUsersState = bindActionGlobally(\n  usersStore,\n  createStateSourceAction({\n    selector: createSelector(\n      [\n        ({instance, state}: SelectorContext<UsersStoreState>, options?: GetUsersOptions) =>\n          state.error ?? state.users[getUsersKey(instance, options)]?.error,\n        ({instance, state}: SelectorContext<UsersStoreState>, options: GetUsersOptions) =>\n          state.users[getUsersKey(instance, options)]?.users,\n        ({instance, state}: SelectorContext<UsersStoreState>, options: GetUsersOptions) =>\n          state.users[getUsersKey(instance, options)]?.totalCount,\n        ({instance, state}: SelectorContext<UsersStoreState>, options: GetUsersOptions) =>\n          state.users[getUsersKey(instance, options)]?.nextCursor,\n      ],\n      (error, data, totalCount, nextCursor) => {\n        if (error) throw error\n        if (data === undefined || totalCount === undefined || nextCursor === undefined) {\n          return undefined\n        }\n\n        return {data, totalCount, hasMore: nextCursor !== null}\n      },\n    ),\n    onSubscribe: ({instance, state}, options?: GetUsersOptions) => {\n      const subscriptionId = insecureRandomId()\n      const key = getUsersKey(instance, options)\n      state.set('addSubscription', addSubscription(subscriptionId, key))\n      return () => {\n        setTimeout(\n          () => state.set('removeSubscription', removeSubscription(subscriptionId, key)),\n          USERS_STATE_CLEAR_DELAY,\n        )\n      }\n    },\n  }),\n)\n\n/**\n * Resolves the users for a specific resource without registering a lasting subscriber.\n *\n * This function fetches the users for a given resource and returns a promise that resolves with\n * the users result. Unlike `getUsersState`, which registers subscribers to keep the data live and\n * performs automatic cleanup, `resolveUsers` does not track subscribers. This makes it ideal for\n * use with React Suspense, where the returned promise is thrown to delay rendering until the users\n * result becomes available. Once the promise resolves, it is expected that a real subscriber will\n * be added via `getUsersState` to manage ongoing updates.\n *\n * Additionally, an optional AbortSignal can be provided to cancel the request and immediately\n * clear the associated state if there are no active subscribers.\n *\n * @beta\n */\nexport const resolveUsers = bindActionGlobally(\n  usersStore,\n  async ({state, instance}, {signal, ...options}: ResolveUsersOptions) => {\n    const key = getUsersKey(instance, options)\n    const {getCurrent} = getUsersState(instance, options)\n\n    const aborted$ = signal\n      ? new Observable<never>((observer) => {\n          const cleanup = () => {\n            signal.removeEventListener('abort', listener)\n          }\n\n          const listener = () => {\n            observer.error(new DOMException('The operation was aborted.', 'AbortError'))\n            observer.complete()\n            cleanup()\n          }\n          signal.addEventListener('abort', listener)\n\n          return cleanup\n        }).pipe(\n          catchError((error) => {\n            if (error instanceof Error && error.name === 'AbortError') {\n              state.set('cancelRequest', cancelRequest(key))\n            }\n            throw error\n          }),\n        )\n      : NEVER\n\n    state.set('initializeRequest', initializeRequest(key))\n\n    const resolved$ = state.observable.pipe(\n      map(getCurrent),\n      first((i) => i !== undefined),\n    )\n\n    return firstValueFrom(race([resolved$, aborted$]))\n  },\n)\n\n/**\n * Loads more users for a specific resource.\n *\n * This function triggers a request to fetch the next page of users for a given resource. It\n * requires that users have already been loaded for the resource (via `resolveUsers` or\n * `getUsersState`), and that there are more users available to load (as indicated by the `hasMore`\n * property).\n *\n * The function returns a promise that resolves when the next page of users has been loaded.\n *\n * @beta\n */\nexport const loadMoreUsers = bindActionGlobally(\n  usersStore,\n  async ({state, instance}, options?: GetUsersOptions) => {\n    const key = getUsersKey(instance, options)\n    const users = getUsersState(instance, options)\n    const usersState = users.getCurrent()\n    if (!usersState) {\n      throw new Error('Users not loaded for specified resource. Please call resolveUsers first.')\n    }\n\n    if (!usersState.hasMore) {\n      throw new Error('No more users available to load for this resource.')\n    }\n\n    const promise = firstValueFrom(\n      users.observable.pipe(\n        filter((i) => i !== undefined),\n        skip(1),\n      ),\n    )\n\n    const timestamp = new Date().toISOString()\n    state.set('updateLastLoadMoreRequest', updateLastLoadMoreRequest(timestamp, key))\n\n    return await promise\n  },\n)\n\n/**\n * @beta\n */\nexport const getUserState = bindActionGlobally(\n  usersStore,\n  ({instance}, {userId, ...options}: GetUserOptions) => {\n    return getUsersState(instance, {userId, ...options}).observable.pipe(\n      map((res) => res?.data[0]),\n      distinctUntilChanged((a, b) => a?.profile.updatedAt === b?.profile.updatedAt),\n    )\n  },\n)\n\n/**\n * @beta\n */\nexport const resolveUser = bindActionGlobally(\n  usersStore,\n  async ({instance}, {signal, ...options}: ResolveUserOptions) => {\n    const result = await resolveUsers(instance, {\n      signal,\n      ...options,\n    })\n    return result?.data[0]\n  },\n)\n","import {type BifurClient, fromUrl} from '@sanity/bifur-client'\nimport {type SanityClient} from '@sanity/client'\nimport {EMPTY, fromEvent, type Observable} from 'rxjs'\nimport {map, share, switchMap} from 'rxjs/operators'\n\nimport {\n  type BifurTransportOptions,\n  type PresenceLocation,\n  type PresenceTransport,\n  type TransportEvent,\n  type TransportMessage,\n} from './types'\n\ntype BifurStateMessage = {\n  type: 'state'\n  i: string\n  m: {\n    sessionId: string\n    locations: PresenceLocation[]\n  }\n}\n\ntype BifurDisconnectMessage = {\n  type: 'disconnect'\n  i: string\n  m: {session: string}\n}\n\ntype RollCallEvent = {\n  type: 'rollCall'\n  i: string\n  session: string\n}\n\ntype IncomingBifurEvent = RollCallEvent | BifurStateMessage | BifurDisconnectMessage\n\nfunction getBifurClient(client: SanityClient, token$: Observable<string | null>): BifurClient {\n  const bifurVersionedClient = client.withConfig({apiVersion: '2022-06-30'})\n  const {dataset, url: baseUrl, requestTagPrefix = 'sanity.studio'} = bifurVersionedClient.config()\n  const url = `${baseUrl.replace(/\\/+$/, '')}/socket/${dataset}`.replace(/^http/, 'ws')\n  const urlWithTag = `${url}?tag=${requestTagPrefix}`\n\n  return fromUrl(urlWithTag, {token$})\n}\n\nconst handleIncomingMessage = (event: IncomingBifurEvent): TransportEvent => {\n  switch (event.type) {\n    case 'rollCall':\n      return {\n        type: 'rollCall',\n        userId: event.i,\n        sessionId: event.session,\n      }\n    case 'state': {\n      const {sessionId, locations} = event.m\n      return {\n        type: 'state',\n        userId: event.i,\n        sessionId,\n        timestamp: new Date().toISOString(),\n        locations,\n      }\n    }\n    case 'disconnect':\n      return {\n        type: 'disconnect',\n        userId: event.i,\n        sessionId: event.m.session,\n        timestamp: new Date().toISOString(),\n      }\n    default: {\n      throw new Error(`Got unknown presence event: ${JSON.stringify(event)}`)\n    }\n  }\n}\n\nexport const createBifurTransport = (options: BifurTransportOptions): PresenceTransport => {\n  const {client, token$, sessionId} = options\n  const bifur = getBifurClient(client, token$)\n\n  const incomingEvents$: Observable<TransportEvent> = bifur\n    .listen<IncomingBifurEvent>('presence')\n    .pipe(map(handleIncomingMessage))\n\n  const dispatchMessage = (message: TransportMessage): Observable<void> => {\n    switch (message.type) {\n      case 'rollCall':\n        return bifur.request('presence_rollcall', {session: sessionId})\n      case 'state':\n        return bifur.request('presence_announce', {\n          data: {locations: message.locations, sessionId},\n        })\n      case 'disconnect':\n        return bifur.request('presence_disconnect', {session: sessionId})\n      default: {\n        return EMPTY\n      }\n    }\n  }\n\n  if (typeof window !== 'undefined') {\n    fromEvent(window, 'beforeunload')\n      .pipe(switchMap(() => dispatchMessage({type: 'disconnect'})))\n      .subscribe()\n  }\n\n  return [incomingEvents$.pipe(share()), dispatchMessage]\n}\n","import {type SanityClient} from '@sanity/client'\nimport {createSelector} from 'reselect'\nimport {combineLatest, distinctUntilChanged, filter, map, of, Subscription, switchMap} from 'rxjs'\n\nimport {getTokenState} from '../auth/authStore'\nimport {getClient} from '../client/clientStore'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {createStateSourceAction, type SelectorContext} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {type SanityUser} from '../users/types'\nimport {getUserState} from '../users/usersStore'\nimport {createBifurTransport} from './bifurTransport'\nimport {type PresenceLocation, type TransportEvent, type UserPresence} from './types'\n\ntype PresenceStoreState = {\n  locations: Map<string, {userId: string; locations: PresenceLocation[]}>\n  users: Record<string, SanityUser | undefined>\n}\n\nconst getInitialState = (): PresenceStoreState => ({\n  locations: new Map<string, {userId: string; locations: PresenceLocation[]}>(),\n  users: {},\n})\n\n/** @public */\nexport const presenceStore = defineStore<PresenceStoreState>({\n  name: 'presence',\n  getInitialState,\n  initialize: (context: StoreContext<PresenceStoreState>) => {\n    const {instance, state} = context\n    const sessionId = crypto.randomUUID()\n\n    const client = getClient(instance, {\n      apiVersion: '2022-06-30',\n    })\n\n    const token$ = getTokenState(instance).observable.pipe(distinctUntilChanged())\n\n    const [incomingEvents$, dispatch] = createBifurTransport({\n      client: client as SanityClient,\n      token$,\n      sessionId,\n    })\n\n    const subscription = new Subscription()\n\n    subscription.add(\n      incomingEvents$.subscribe((event: TransportEvent) => {\n        if ('sessionId' in event && event.sessionId === sessionId) {\n          return\n        }\n\n        if (event.type === 'state') {\n          state.set('presence/state', (prevState: PresenceStoreState) => {\n            const newLocations = new Map(prevState.locations)\n            newLocations.set(event.sessionId, {\n              userId: event.userId,\n              locations: event.locations,\n            })\n\n            return {\n              ...prevState,\n              locations: newLocations,\n            }\n          })\n        } else if (event.type === 'disconnect') {\n          state.set('presence/disconnect', (prevState: PresenceStoreState) => {\n            const newLocations = new Map(prevState.locations)\n            newLocations.delete(event.sessionId)\n            return {...prevState, locations: newLocations}\n          })\n        }\n      }),\n    )\n\n    dispatch({type: 'rollCall'}).subscribe()\n\n    return () => {\n      dispatch({type: 'disconnect'}).subscribe()\n      subscription.unsubscribe()\n    }\n  },\n})\n\nconst selectLocations = (state: PresenceStoreState) => state.locations\nconst selectUsers = (state: PresenceStoreState) => state.users\n\nconst selectPresence = createSelector(\n  selectLocations,\n  selectUsers,\n  (locations, users): UserPresence[] => {\n    return Array.from(locations.entries()).map(([sessionId, {userId, locations: locs}]) => {\n      const user = users[userId]\n\n      return {\n        user:\n          user ||\n          ({\n            id: userId,\n            displayName: 'Unknown user',\n            name: 'Unknown user',\n            email: '',\n          } as unknown as SanityUser),\n        sessionId,\n        locations: locs,\n      }\n    })\n  },\n)\n\n/** @public */\nexport const getPresence = bindActionByDataset(\n  presenceStore,\n  createStateSourceAction({\n    selector: (context: SelectorContext<PresenceStoreState>): UserPresence[] =>\n      selectPresence(context.state),\n    onSubscribe: (context) => {\n      const userIds$ = context.state.observable.pipe(\n        map((state) =>\n          Array.from(state.locations.values())\n            .map((l) => l.userId)\n            .filter((id): id is string => !!id),\n        ),\n        distinctUntilChanged((a, b) => a.length === b.length && a.every((v, i) => v === b[i])),\n      )\n\n      const subscription = userIds$\n        .pipe(\n          switchMap((userIds) => {\n            if (userIds.length === 0) {\n              return of([])\n            }\n            const userObservables = userIds.map((userId) =>\n              getUserState(context.instance, {\n                userId,\n                resourceType: 'project',\n                projectId: context.instance.config.projectId,\n              }).pipe(filter((v): v is NonNullable<typeof v> => !!v)),\n            )\n            return combineLatest(userObservables)\n          }),\n        )\n        .subscribe((users) => {\n          if (!users) {\n            return\n          }\n          context.state.set('presence/users', (prevState) => ({\n            ...prevState,\n            users: {\n              ...prevState.users,\n              ...users.reduce<Record<string, SanityUser>>((acc, user) => {\n                if (user) {\n                  acc[user.profile.id] = user\n                }\n                return acc\n              }, {}),\n            },\n          }))\n        })\n      return () => subscription.unsubscribe()\n    },\n  }),\n)\n","import {type SanityClient} from '@sanity/client'\nimport {defer, merge, Observable, of, partition, switchMap, throwError} from 'rxjs'\nimport {debounceTime, filter, mergeMap, share, take} from 'rxjs/operators'\n\ninterface ListenEvent {\n  type: 'welcome' | 'mutation' | 'reconnect'\n  documentId?: string\n  transition?: 'update' | 'appear' | 'disappear'\n}\n\ntype ListenQueryParams = Record<string, string | number | boolean | string[]>\n\n/**\n * Options for configuring a listening query\n * @beta\n */\nexport interface ListenQueryOptions {\n  /** Optional tag for the query for debugging/tracing */\n  tag?: string\n  /** Time to throttle subsequent fetches after mutations (ms) */\n  throttleTime?: number\n  /** Filter which mutation transitions to respond to */\n  transitions?: ('update' | 'appear' | 'disappear')[]\n}\n\n/**\n * Fetches data using the provided query and parameters\n * @internal\n */\nconst fetch = (\n  client: SanityClient,\n  query: string,\n  params: ListenQueryParams,\n  options: ListenQueryOptions,\n) =>\n  defer(() =>\n    client.observable.fetch(query, params, {\n      tag: options.tag,\n      filterResponse: true,\n    }),\n  )\n\n/**\n * Sets up a listener for real-time events\n * @internal\n */\nconst listen = (\n  client: SanityClient,\n  query: string,\n  params: ListenQueryParams,\n  options: ListenQueryOptions,\n) =>\n  defer(() =>\n    client.listen(query, params, {\n      events: ['welcome', 'mutation', 'reconnect'],\n      includeResult: false,\n      visibility: 'query',\n      tag: options.tag,\n    }),\n  ) as Observable<ListenEvent>\n\n/**\n * Type guard for welcome events\n * @internal\n */\nfunction isWelcomeEvent(event: ListenEvent): boolean {\n  return event.type === 'welcome'\n}\n\n/**\n * Be cautious before using this utility.\n *\n * In general, you should reach for `useQueryState` when listening for changes to\n * Sanity documents. This utility is useful for system documents that are currently\n * not supported by `useQueryState`, such as documents of type `system.release`.\n *\n * Creates an observable that listens to a query and emits results when changes occur.\n * @beta\n */\nexport const listenQuery = <T = unknown>(\n  client: SanityClient,\n  query: string | {fetch: string; listen: string},\n  params: ListenQueryParams = {},\n  options: ListenQueryOptions = {},\n): Observable<T> => {\n  const fetchQuery = typeof query === 'string' ? query : query.fetch\n  const listenerQuery = typeof query === 'string' ? query : query.listen\n\n  const fetchOnce$ = fetch(client, fetchQuery, params, options)\n\n  const events$ = listen(client, listenerQuery, params, options).pipe(\n    mergeMap((ev, i) => {\n      const isFirst = i === 0\n      if (isFirst && !isWelcomeEvent(ev)) {\n        return throwError(\n          () =>\n            new Error(\n              ev.type === 'reconnect'\n                ? 'Could not establish EventSource connection'\n                : `Received unexpected type of first event \"${ev.type}\"`,\n            ),\n        )\n      }\n      return of(ev)\n    }),\n    share(),\n  )\n\n  const [welcome$, mutationAndReconnect$] = partition(events$, isWelcomeEvent)\n  const isRelevantEvent = (event: ListenEvent): boolean => {\n    // If no transitions are specified, or if this is not a mutation event (e.g. reconnect),\n    // consider it relevant. For mutation events, we'll check the transition type below.\n    if (!options.transitions || event.type !== 'mutation') {\n      return true\n    }\n\n    return options.transitions.includes(event.transition!)\n  }\n\n  return merge(\n    welcome$.pipe(take(1)),\n    mutationAndReconnect$.pipe(filter(isRelevantEvent), debounceTime(options.throttleTime || 1000)),\n  ).pipe(\n    // will cancel any in-flight request when a new one comes in\n    // but ensures we always get the latest data\n    switchMap(() => fetchOnce$),\n  )\n}\n","import {type ReleaseDocument} from '../releasesStore'\n\n// mirrors the order of the releases in the releases list in Studio\n// https://github.com/sanity-io/sanity/blob/main/packages/sanity/src/core/releases/hooks/utils.ts\nexport function sortReleases(releases: ReleaseDocument[] = []): ReleaseDocument[] {\n  // The order should always be:\n  // [undecided (sortByCreatedAt), scheduled(sortBy publishAt || metadata.intendedPublishAt), asap(sortByCreatedAt)]\n  return [...releases].sort((a, b) => {\n    // undecided are always first, then by createdAt descending\n    if (a.metadata.releaseType === 'undecided' && b.metadata.releaseType !== 'undecided') {\n      return -1\n    }\n    if (a.metadata.releaseType !== 'undecided' && b.metadata.releaseType === 'undecided') {\n      return 1\n    }\n    if (a.metadata.releaseType === 'undecided' && b.metadata.releaseType === 'undecided') {\n      // Sort by createdAt\n      return new Date(b._createdAt).getTime() - new Date(a._createdAt).getTime()\n    }\n\n    // Scheduled are always at the middle, then by publishAt descending\n    if (a.metadata.releaseType === 'scheduled' && b.metadata.releaseType === 'scheduled') {\n      const aPublishAt = a['publishAt'] || a.metadata['intendedPublishAt']\n      if (!aPublishAt) {\n        return 1\n      }\n      const bPublishAt = b['publishAt'] || b.metadata['intendedPublishAt']\n      if (!bPublishAt) {\n        return -1\n      }\n      return new Date(bPublishAt).getTime() - new Date(aPublishAt).getTime()\n    }\n\n    // ASAP are always last, then by createdAt descending\n    if (a.metadata.releaseType === 'asap' && b.metadata.releaseType !== 'asap') {\n      return 1\n    }\n    if (a.metadata.releaseType !== 'asap' && b.metadata.releaseType === 'asap') {\n      return -1\n    }\n    if (a.metadata.releaseType === 'asap' && b.metadata.releaseType === 'asap') {\n      // Sort by createdAt\n      return new Date(b._createdAt).getTime() - new Date(a._createdAt).getTime()\n    }\n\n    return 0\n  })\n}\n","import {type SanityClient} from '@sanity/client'\nimport {type SanityDocument} from '@sanity/types'\nimport {catchError, EMPTY, retry, switchMap, timer} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {createStateSourceAction} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {listenQuery} from '../utils/listenQuery'\nimport {sortReleases} from './utils/sortReleases'\n\nconst ARCHIVED_RELEASE_STATES = ['archived', 'published']\n\n/**\n * Represents a document in a Sanity dataset that represents release options.\n * @internal\n */\nexport type ReleaseDocument = SanityDocument & {\n  name: string\n  publishAt?: string\n  state: 'active' | 'scheduled'\n  metadata: {\n    title: string\n    releaseType: 'asap' | 'scheduled' | 'undecided'\n    intendedPublishAt?: string\n    description?: string\n  }\n}\n\nexport interface ReleasesStoreState {\n  activeReleases?: ReleaseDocument[]\n  error?: unknown\n}\n\nexport const releasesStore = defineStore<ReleasesStoreState>({\n  name: 'Releases',\n  getInitialState: (): ReleasesStoreState => ({\n    activeReleases: undefined,\n  }),\n  initialize: (context) => {\n    const subscription = subscribeToReleases(context)\n    return () => subscription.unsubscribe()\n  },\n})\n\n/**\n * Get the active releases from the store.\n * @internal\n */\nexport const getActiveReleasesState = bindActionByDataset(\n  releasesStore,\n  createStateSourceAction({\n    selector: ({state}) => state.activeReleases,\n  }),\n)\n\nconst RELEASES_QUERY = 'releases::all()'\nconst QUERY_PARAMS = {}\n\nconst subscribeToReleases = ({instance, state}: StoreContext<ReleasesStoreState>) => {\n  return getClientState(instance, {\n    apiVersion: '2025-04-10',\n    perspective: 'raw',\n  })\n    .observable.pipe(\n      switchMap((client: SanityClient) =>\n        // releases are system documents, and are not supported by useQueryState\n        listenQuery<ReleaseDocument[]>(client, RELEASES_QUERY, QUERY_PARAMS, {\n          tag: 'releases-listener',\n          throttleTime: 1000,\n          transitions: ['update', 'appear', 'disappear'],\n        }).pipe(\n          retry({\n            count: 3,\n            delay: (error, retryCount) => {\n              // eslint-disable-next-line no-console\n              console.error('[releases] Error in subscription:', error, 'Retry count:', retryCount)\n              return timer(Math.min(1000 * Math.pow(2, retryCount), 10000))\n            },\n          }),\n          catchError((error) => {\n            state.set('setError', {error})\n            return EMPTY\n          }),\n        ),\n      ),\n    )\n    .subscribe({\n      next: (releases) => {\n        // logic here mirrors that of studio:\n        // https://github.com/sanity-io/sanity/blob/156e8fa482703d99219f08da7bacb384517f1513/packages/sanity/src/core/releases/store/useActiveReleases.ts#L29\n        state.set('setActiveReleases', {\n          activeReleases: sortReleases(releases ?? [])\n            .filter((release) => !ARCHIVED_RELEASE_STATES.includes(release.state))\n            .reverse(),\n        })\n      },\n    })\n}\n","import {createSelector} from 'reselect'\n\nimport {type PerspectiveHandle, type ReleasePerspective} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {createStateSourceAction, type SelectorContext} from '../store/createStateSourceAction'\nimport {releasesStore, type ReleasesStoreState} from './releasesStore'\nimport {sortReleases} from './utils/sortReleases'\n\nfunction isReleasePerspective(\n  perspective: PerspectiveHandle['perspective'],\n): perspective is ReleasePerspective {\n  return typeof perspective === 'object' && perspective !== null && 'releaseName' in perspective\n}\n\nconst DEFAULT_PERSPECTIVE = 'drafts'\n\n// Cache for options\nconst optionsCache = new Map<string, Map<string, PerspectiveHandle>>()\n\nconst selectInstancePerspective = (context: SelectorContext<ReleasesStoreState>) =>\n  context.instance.config.perspective\nconst selectActiveReleases = (context: SelectorContext<ReleasesStoreState>) =>\n  context.state.activeReleases\nconst selectOptions = (\n  _context: SelectorContext<ReleasesStoreState>,\n  options?: PerspectiveHandle,\n) => options\n\nconst memoizedOptionsSelector = createSelector(\n  [selectActiveReleases, selectOptions],\n  (activeReleases, options) => {\n    if (!options || !activeReleases) return options\n\n    // Use release document IDs as the cache key\n    const releaseIds = activeReleases.map((release) => release._id).join(',')\n    let nestedCache = optionsCache.get(releaseIds)\n    if (!nestedCache) {\n      nestedCache = new Map<string, PerspectiveHandle>()\n      optionsCache.set(releaseIds, nestedCache)\n    }\n\n    const optionsKey = JSON.stringify(options)\n    let cachedOptions = nestedCache.get(optionsKey)\n\n    if (!cachedOptions) {\n      cachedOptions = options\n      nestedCache.set(optionsKey, cachedOptions)\n    }\n    return cachedOptions\n  },\n)\n\n/**\n * Provides a subscribable state source for a \"perspective\" for the Sanity client,\n * which is used to fetch documents as though certain Content Releases are active.\n *\n * @param instance - The Sanity instance to get the perspective for\n * @param options - The options for the perspective -- usually a release name\n *\n * @returns A subscribable perspective value, usually a list of applicable release names,\n * or a single release name / default perspective (such as 'drafts').\n *\n * @public\n */\nexport const getPerspectiveState = bindActionByDataset(\n  releasesStore,\n  createStateSourceAction({\n    selector: createSelector(\n      [selectInstancePerspective, selectActiveReleases, memoizedOptionsSelector],\n      (instancePerspective, activeReleases, memoizedOptions) => {\n        const perspective =\n          memoizedOptions?.perspective ?? instancePerspective ?? DEFAULT_PERSPECTIVE\n\n        if (!isReleasePerspective(perspective)) return perspective\n\n        // if there are no active releases we can't compute the release perspective\n        if (!activeReleases || activeReleases.length === 0) return undefined\n\n        const releaseNames = sortReleases(activeReleases).map((release) => release.name)\n        const index = releaseNames.findIndex((name) => name === perspective.releaseName)\n\n        if (index < 0) {\n          throw new Error(`Release \"${perspective.releaseName}\" not found in active releases`)\n        }\n\n        const filteredReleases = releaseNames.slice(0, index + 1) // Include the release itself\n\n        return ['drafts', ...filteredReleases].filter(\n          (name) => !perspective.excludedPerspectives?.includes(name),\n        )\n      },\n    ),\n  }),\n)\n","/**\n * When a query has no more subscribers, its state is cleaned up and removed\n * from the store. A delay used to prevent re-creating resources when the last\n * subscriber is removed quickly before another one is added. This is helpful\n * when used in a frontend where components may suspend or transition to\n * different views quickly.\n */\nexport const QUERY_STATE_CLEAR_DELAY = 1000\nexport const QUERY_STORE_API_VERSION = 'v2025-05-06'\n","import {omit} from 'lodash-es'\n\ninterface QueryState {\n  syncTags?: string[]\n  result?: unknown\n  error?: unknown\n  lastLiveEventId?: string\n  subscribers: string[]\n}\n\nexport interface QueryStoreState {\n  queries: {[key: string]: QueryState | undefined}\n  error?: unknown\n}\n\nexport const setQueryError =\n  (key: string, error: unknown) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, error}}}\n  }\n\nexport const setQueryData =\n  (key: string, result: unknown, syncTags?: string[]) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    return {\n      ...prev,\n      queries: {...prev.queries, [key]: {...prevQuery, result: result ?? null, syncTags}},\n    }\n  }\n\nexport const setLastLiveEventId =\n  (key: string, lastLiveEventId: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, lastLiveEventId}}}\n  }\n\nexport const addSubscriber =\n  (key: string, subscriptionId: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    const subscribers = [...(prevQuery?.subscribers ?? []), subscriptionId]\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, subscribers}}}\n  }\n\nexport const removeSubscriber =\n  (key: string, subscriptionId: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    const subscribers = prevQuery.subscribers.filter((id) => id !== subscriptionId)\n    if (!subscribers.length) return {...prev, queries: omit(prev.queries, key)}\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, subscribers}}}\n  }\n\nexport const cancelQuery =\n  (key: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    if (prevQuery.subscribers.length) return prev\n    return {...prev, queries: omit(prev.queries, key)}\n  }\n\nexport const initializeQuery =\n  (key: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    if (prev.queries[key]) return prev\n    return {...prev, queries: {...prev.queries, [key]: {subscribers: []}}}\n  }\n","import {type ResponseQueryOptions} from '@sanity/client'\nimport {type SanityQueryResult} from 'groq'\nimport {\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  groupBy,\n  map,\n  mergeMap,\n  NEVER,\n  Observable,\n  pairwise,\n  race,\n  share,\n  startWith,\n  switchMap,\n  tap,\n} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type DatasetHandle} from '../config/sanityConfig'\nimport {getPerspectiveState} from '../releases/getPerspectiveState'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {type StoreState} from '../store/createStoreState'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {insecureRandomId} from '../utils/ids'\nimport {QUERY_STATE_CLEAR_DELAY, QUERY_STORE_API_VERSION} from './queryStoreConstants'\nimport {\n  addSubscriber,\n  cancelQuery,\n  initializeQuery,\n  type QueryStoreState,\n  removeSubscriber,\n  setLastLiveEventId,\n  setQueryData,\n  setQueryError,\n} from './reducers'\n\n/**\n * @beta\n */\nexport interface QueryOptions<\n  TQuery extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends Pick<ResponseQueryOptions, 'useCdn' | 'cache' | 'next' | 'cacheMode' | 'tag'>,\n    DatasetHandle<TDataset, TProjectId> {\n  query: TQuery\n  params?: Record<string, unknown>\n}\n\n/**\n * @beta\n */\nexport interface ResolveQueryOptions<\n  TQuery extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends QueryOptions<TQuery, TDataset, TProjectId> {\n  signal?: AbortSignal\n}\n\nconst EMPTY_ARRAY: never[] = []\n\n/** @beta */\nexport const getQueryKey = (options: QueryOptions): string => JSON.stringify(options)\n/** @beta */\nexport const parseQueryKey = (key: string): QueryOptions => JSON.parse(key)\n\nconst queryStore = defineStore<QueryStoreState>({\n  name: 'QueryStore',\n  getInitialState: () => ({queries: {}}),\n  initialize(context) {\n    const subscriptions = [\n      listenForNewSubscribersAndFetch(context),\n      listenToLiveClientAndSetLastLiveEventIds(context),\n    ]\n\n    return () => {\n      for (const subscription of subscriptions) {\n        subscription.unsubscribe()\n      }\n    }\n  },\n})\n\nconst errorHandler = (state: StoreState<{error?: unknown}>) => {\n  return (error: unknown): void => state.set('setError', {error})\n}\n\nconst listenForNewSubscribersAndFetch = ({state, instance}: StoreContext<QueryStoreState>) => {\n  return state.observable\n    .pipe(\n      map((s) => new Set(Object.keys(s.queries))),\n      distinctUntilChanged((curr, next) => {\n        if (curr.size !== next.size) return false\n        return Array.from(next).every((i) => curr.has(i))\n      }),\n      startWith(new Set<string>()),\n      pairwise(),\n      mergeMap(([curr, next]) => {\n        const added = Array.from(next).filter((i) => !curr.has(i))\n        const removed = Array.from(curr).filter((i) => !next.has(i))\n\n        return [\n          ...added.map((key) => ({key, added: true})),\n          ...removed.map((key) => ({key, added: false})),\n        ]\n      }),\n      groupBy((i) => i.key),\n      mergeMap((group$) =>\n        group$.pipe(\n          switchMap((e) => {\n            if (!e.added) return EMPTY\n\n            const lastLiveEventId$ = state.observable.pipe(\n              map((s) => s.queries[group$.key]?.lastLiveEventId),\n              distinctUntilChanged(),\n            )\n            const {\n              query,\n              params,\n              projectId,\n              dataset,\n              tag,\n              perspective: perspectiveFromOptions,\n              ...restOptions\n            } = parseQueryKey(group$.key)\n\n            const perspective$ = getPerspectiveState(instance, {\n              perspective: perspectiveFromOptions,\n            }).observable.pipe(filter(Boolean))\n\n            const client$ = getClientState(instance, {\n              apiVersion: QUERY_STORE_API_VERSION,\n              projectId,\n              dataset,\n            }).observable\n\n            return combineLatest([lastLiveEventId$, client$, perspective$]).pipe(\n              switchMap(([lastLiveEventId, client, perspective]) =>\n                client.observable.fetch(query, params, {\n                  ...restOptions,\n                  perspective,\n                  filterResponse: false,\n                  returnQuery: false,\n                  lastLiveEventId,\n                  tag,\n                }),\n              ),\n            )\n          }),\n          catchError((error) => {\n            state.set('setQueryError', setQueryError(group$.key, error))\n            return EMPTY\n          }),\n          tap(({result, syncTags}) => {\n            state.set('setQueryData', setQueryData(group$.key, result, syncTags))\n          }),\n        ),\n      ),\n    )\n    .subscribe({error: errorHandler(state)})\n}\n\nconst listenToLiveClientAndSetLastLiveEventIds = ({\n  state,\n  instance,\n}: StoreContext<QueryStoreState>) => {\n  const liveMessages$ = getClientState(instance, {\n    apiVersion: QUERY_STORE_API_VERSION,\n  }).observable.pipe(\n    switchMap((client) =>\n      client.live.events({includeDrafts: !!client.config().token, tag: 'query-store'}),\n    ),\n    share(),\n    filter((e) => e.type === 'message'),\n  )\n\n  return state.observable\n    .pipe(\n      mergeMap((s) => Object.entries(s.queries)),\n      groupBy(([key]) => key),\n      mergeMap((group$) => {\n        const syncTags$ = group$.pipe(\n          map(([, queryState]) => queryState),\n          map((i) => i?.syncTags ?? EMPTY_ARRAY),\n          distinctUntilChanged(),\n        )\n\n        return combineLatest([liveMessages$, syncTags$]).pipe(\n          filter(([message, syncTags]) => message.tags.some((tag) => syncTags.includes(tag))),\n          tap(([message]) => {\n            state.set('setLastLiveEventId', setLastLiveEventId(group$.key, message.id))\n          }),\n        )\n      }),\n    )\n    .subscribe({error: errorHandler(state)})\n}\n\n/**\n * Returns the state source for a query.\n *\n * This function returns a state source that represents the current result of a GROQ query.\n * Subscribing to the state source will instruct the SDK to fetch the query (if not already fetched)\n * and will keep the query live using the Live content API (considering sync tags) to provide up-to-date results.\n * When the last subscriber is removed, the query state is automatically cleaned up from the store.\n *\n * Note: This functionality is for advanced users who want to build their own framework integrations.\n * Our SDK also provides a React integration (useQuery hook) for convenient usage.\n *\n * Note: Automatic cleanup can interfere with React Suspense because if a component suspends while being the only subscriber,\n * cleanup might occur unexpectedly. In such cases, consider using `resolveQuery` instead.\n *\n * @beta\n */\nexport function getQueryState<\n  TQuery extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  queryOptions: QueryOptions<TQuery, TDataset, TProjectId>,\n): StateSource<SanityQueryResult<TQuery, `${TProjectId}.${TDataset}`> | undefined>\n\n/** @beta */\nexport function getQueryState<TData>(\n  instance: SanityInstance,\n  queryOptions: QueryOptions,\n): StateSource<TData | undefined>\n\n/** @beta */\nexport function getQueryState(\n  instance: SanityInstance,\n  queryOptions: QueryOptions,\n): StateSource<unknown>\n\n/** @beta */\nexport function getQueryState(\n  ...args: Parameters<typeof _getQueryState>\n): ReturnType<typeof _getQueryState> {\n  return _getQueryState(...args)\n}\nconst _getQueryState = bindActionByDataset(\n  queryStore,\n  createStateSourceAction({\n    selector: ({state}: SelectorContext<QueryStoreState>, options: QueryOptions) => {\n      if (state.error) throw state.error\n      const key = getQueryKey(options)\n      const queryState = state.queries[key]\n      if (queryState?.error) throw queryState.error\n      return queryState?.result\n    },\n    onSubscribe: ({state}, options: QueryOptions) => {\n      const subscriptionId = insecureRandomId()\n      const key = getQueryKey(options)\n\n      state.set('addSubscriber', addSubscriber(key, subscriptionId))\n\n      return () => {\n        // this runs on unsubscribe\n        setTimeout(\n          () => state.set('removeSubscriber', removeSubscriber(key, subscriptionId)),\n          QUERY_STATE_CLEAR_DELAY,\n        )\n      }\n    },\n  }),\n)\n\n/**\n * Resolves the result of a query without registering a lasting subscriber.\n *\n * This function fetches the result of a GROQ query and returns a promise that resolves with the query result.\n * Unlike `getQueryState`, which registers subscribers to keep the query live and performs automatic cleanup,\n * `resolveQuery` does not track subscribers. This makes it ideal for use with React Suspense, where the returned\n * promise is thrown to delay rendering until the query result becomes available.\n * Once the promise resolves, it is expected that a real subscriber will be added via `getQueryState` to manage ongoing updates.\n *\n * Additionally, an optional AbortSignal can be provided to cancel the query and immediately clear the associated state\n * if there are no active subscribers.\n *\n * @beta\n */\nexport function resolveQuery<\n  TQuery extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  queryOptions: ResolveQueryOptions<TQuery, TDataset, TProjectId>,\n): Promise<SanityQueryResult<TQuery, `${TProjectId}.${TDataset}`>>\n\n/** @beta */\nexport function resolveQuery<TData>(\n  instance: SanityInstance,\n  queryOptions: ResolveQueryOptions,\n): Promise<TData>\n/** @beta */\nexport function resolveQuery(...args: Parameters<typeof _resolveQuery>): Promise<unknown> {\n  return _resolveQuery(...args)\n}\nconst _resolveQuery = bindActionByDataset(\n  queryStore,\n  ({state, instance}, {signal, ...options}: ResolveQueryOptions) => {\n    const {getCurrent} = getQueryState(instance, options)\n    const key = getQueryKey(options)\n\n    const aborted$ = signal\n      ? new Observable<void>((observer) => {\n          const cleanup = () => {\n            signal.removeEventListener('abort', listener)\n          }\n\n          const listener = () => {\n            observer.error(new DOMException('The operation was aborted.', 'AbortError'))\n            observer.complete()\n            cleanup()\n          }\n          signal.addEventListener('abort', listener)\n\n          return cleanup\n        }).pipe(\n          catchError((error) => {\n            if (error instanceof Error && error.name === 'AbortError') {\n              state.set('cancelQuery', cancelQuery(key))\n            }\n            throw error\n          }),\n        )\n      : NEVER\n\n    state.set('initializeQuery', initializeQuery(key))\n\n    const resolved$ = state.observable.pipe(\n      map(getCurrent),\n      first((i) => i !== undefined),\n    )\n\n    return firstValueFrom(race([resolved$, aborted$]))\n  },\n)\n","export function hashString(str: string): string {\n  // Using a large prime number for the hash\n  const PRIME = 31\n  // Using a max 32-bit integer to prevent overflow\n  const MOD = 2147483647\n\n  let hash = 0\n\n  // Process chunks of the string to reduce complexity\n  for (let i = 0; i < str.length; i++) {\n    // Rolling hash computation\n    hash = (hash * PRIME + str.charCodeAt(i)) % MOD\n  }\n\n  // Ensure we return a positive hash\n  return Math.abs(hash).toString(16).padStart(8, '0')\n}\n","/**\n * The fields to check for a title.\n * The order of the items in the array defines the priority.\n *\n * @internal\n */\nexport const TITLE_CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption']\n\n/**\n * The fields to check for a subtitle.\n * The order of the items in the array defines the priority.\n *\n * @internal\n */\nexport const SUBTITLE_CANDIDATES = ['description', 'subtitle', ...TITLE_CANDIDATES]\n\n/**\n * Generates a GROQ projection for preview data without requiring a schema.\n * Uses common field names to make educated guesses about which fields to use.\n *\n * @internal\n */\nexport const PREVIEW_PROJECTION = `{\n  // Get all potential title fields\n  \"titleCandidates\": {\n    ${TITLE_CANDIDATES.map((field) => `\"${field}\": ${field}`).join(',\\n      ')}\n  },\n  // Get all potential subtitle fields\n  \"subtitleCandidates\": {\n    ${SUBTITLE_CANDIDATES.map((field) => `\"${field}\": ${field}`).join(',\\n      ')}\n  },\n  \"media\": coalesce(\n    select(\n      defined(asset) => {\"type\": \"image-asset\", \"_ref\": asset._ref},\n      defined(image.asset) => {\"type\": \"image-asset\", \"_ref\": image.asset._ref},\n      defined(mainImage.asset) => {\"type\": \"image-asset\", \"_ref\": mainImage.asset._ref},\n      null\n    )\n  ),\n  _type,\n  _id,\n  _updatedAt\n}`\n","import {getEnv} from '../utils/getEnv'\nimport {type PreviewValue, type ValuePending} from './previewStore'\n\nexport const PREVIEW_TAG = 'preview'\nexport const PREVIEW_PERSPECTIVE = 'raw'\nexport const STABLE_EMPTY_PREVIEW: ValuePending<PreviewValue> = {data: null, isPending: false}\nexport const STABLE_ERROR_PREVIEW: ValuePending<PreviewValue> = {\n  data: {\n    title: 'Preview Error',\n    ...(!!getEnv('DEV') && {subtitle: 'Check the console for more details'}),\n  },\n  isPending: false,\n}\n","import {isObject} from 'lodash-es'\n\nimport {hashString} from '../utils/hashString'\nimport {getDraftId, getPublishedId} from '../utils/ids'\nimport {PREVIEW_PROJECTION, SUBTITLE_CANDIDATES, TITLE_CANDIDATES} from './previewConstants'\nimport {\n  type PreviewQueryResult,\n  type PreviewStoreState,\n  type PreviewValue,\n  type ValuePending,\n} from './previewStore'\nimport {STABLE_EMPTY_PREVIEW, STABLE_ERROR_PREVIEW} from './util'\n\ninterface ProcessPreviewQueryOptions {\n  projectId: string\n  dataset: string\n  ids: Set<string>\n  results: PreviewQueryResult[]\n}\n\n/**\n * Converts an asset ID to a URL.\n *\n * @internal\n */\nfunction assetIdToUrl(assetId: string, projectId: string, dataset: string) {\n  const pattern = /^image-(?<assetName>[A-Za-z0-9]+)-(?<dimensions>\\d+x\\d+)-(?<format>[a-z]+)$/\n  const match = assetId.match(pattern)\n  if (!match?.groups) {\n    throw new Error(\n      `Invalid asset ID \\`${assetId}\\`. Expected: image-{assetName}-{width}x{height}-{format}`,\n    )\n  }\n\n  const {assetName, dimensions, format} = match.groups\n  return `https://cdn.sanity.io/images/${projectId}/${dataset}/${assetName}-${dimensions}.${format}`\n}\n\n/**\n * Checks if the provided value has `_ref` property that is a string and starts with `image-`\n */\nfunction hasImageRef<T>(value: unknown): value is T & {_ref: string} {\n  return isObject(value) && '_ref' in value && typeof (value as {_ref: unknown})._ref === 'string'\n}\n\n/**\n * Normalizes a media asset to a preview value.\n * Adds a url to a media asset reference.\n *\n * @internal\n */\nexport function normalizeMedia(\n  media: unknown,\n  projectId: string,\n  dataset: string,\n): PreviewValue['media'] {\n  if (!media) return null\n  if (!hasImageRef(media)) return null\n  return {\n    type: 'image-asset',\n    _ref: media._ref,\n    url: assetIdToUrl(media._ref, projectId, dataset),\n  }\n}\n\n/**\n * Finds a single field value from a set of candidates based on a priority list of field names.\n * Returns the first non-empty string value found from the candidates matching the priority list order.\n *\n * @internal\n */\nfunction findFirstDefined(\n  fieldsToSearch: string[],\n  candidates: Record<string, unknown>,\n  exclude?: unknown,\n): string | undefined {\n  if (!candidates) return undefined\n\n  for (const field of fieldsToSearch) {\n    const value = candidates[field]\n    if (typeof value === 'string' && value.trim() !== '' && value !== exclude) {\n      return value\n    }\n  }\n\n  return undefined\n}\n\nexport function processPreviewQuery({\n  projectId,\n  dataset,\n  ids,\n  results,\n}: ProcessPreviewQueryOptions): PreviewStoreState['values'] {\n  const resultMap = results.reduce<{[TDocumentId in string]?: PreviewQueryResult}>((acc, next) => {\n    acc[next._id] = next\n    return acc\n  }, {})\n\n  return Object.fromEntries(\n    Array.from(ids).map((id): [string, ValuePending<PreviewValue>] => {\n      const publishedId = getPublishedId(id)\n      const draftId = getDraftId(id)\n\n      const draftResult = resultMap[draftId]\n      const publishedResult = resultMap[publishedId]\n\n      if (!draftResult && !publishedResult) return [id, STABLE_EMPTY_PREVIEW]\n\n      try {\n        const result = draftResult || publishedResult\n        if (!result) return [id, STABLE_EMPTY_PREVIEW]\n        const title = findFirstDefined(TITLE_CANDIDATES, result.titleCandidates)\n        const subtitle = findFirstDefined(SUBTITLE_CANDIDATES, result.subtitleCandidates, title)\n        const preview: Omit<PreviewValue, 'status'> = {\n          title: String(title || `${result._type}: ${result._id}`),\n          subtitle: subtitle || undefined,\n          media: normalizeMedia(result.media, projectId, dataset),\n        }\n\n        const _status: PreviewValue['_status'] = {\n          ...(draftResult?._updatedAt && {lastEditedDraftAt: draftResult._updatedAt}),\n          ...(publishedResult?._updatedAt && {lastEditedPublishedAt: publishedResult._updatedAt}),\n        }\n\n        return [id, {data: {...preview, _status}, isPending: false}]\n      } catch (e) {\n        // TODO: replace this with bubbling the error\n        // eslint-disable-next-line no-console\n        console.warn(e)\n        return [id, STABLE_ERROR_PREVIEW]\n      }\n    }),\n  )\n}\n\ninterface CreatePreviewQueryResult {\n  query: string\n  params: Record<string, string[]>\n}\n\nexport function createPreviewQuery(documentIds: Set<string>): CreatePreviewQueryResult {\n  // Create arrays of draft and published IDs\n  const allIds = Array.from(documentIds).flatMap((id) => [getPublishedId(id), getDraftId(id)])\n  const queryHash = hashString(PREVIEW_PROJECTION)\n\n  return {\n    query: `*[_id in $__ids_${queryHash}]${PREVIEW_PROJECTION}`,\n    params: {\n      [`__ids_${queryHash}`]: allIds,\n    },\n  }\n}\n","import {\n  debounceTime,\n  defer,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  from,\n  map,\n  Observable,\n  pairwise,\n  startWith,\n  Subscription,\n  switchMap,\n  tap,\n} from 'rxjs'\n\nimport {getQueryState, resolveQuery} from '../query/queryStore'\nimport {type StoreContext} from '../store/defineStore'\nimport {createPreviewQuery, processPreviewQuery} from './previewQuery'\nimport {type PreviewQueryResult, type PreviewStoreState} from './previewStore'\nimport {PREVIEW_PERSPECTIVE, PREVIEW_TAG} from './util'\n\nconst BATCH_DEBOUNCE_TIME = 50\n\nconst isSetEqual = <T>(a: Set<T>, b: Set<T>) =>\n  a.size === b.size && Array.from(a).every((i) => b.has(i))\n\nexport const subscribeToStateAndFetchBatches = ({\n  state,\n  instance,\n}: StoreContext<PreviewStoreState>): Subscription => {\n  const newSubscriberIds$ = state.observable.pipe(\n    map(({subscriptions}) => new Set(Object.keys(subscriptions))),\n    distinctUntilChanged(isSetEqual),\n    debounceTime(BATCH_DEBOUNCE_TIME),\n    startWith(new Set<string>()),\n    pairwise(),\n    tap(([prevIds, currIds]) => {\n      // for all new subscriptions, set their values to pending\n      const newIds = [...currIds].filter((element) => !prevIds.has(element))\n      state.set('updatingPending', (prev) => {\n        const pendingValues = newIds.reduce<PreviewStoreState['values']>((acc, id) => {\n          const prevValue = prev.values[id]\n          const value = prevValue?.data ? prevValue.data : null\n          acc[id] = {data: value, isPending: true}\n          return acc\n        }, {})\n        return {values: {...prev.values, ...pendingValues}}\n      })\n    }),\n    map(([, ids]) => ids),\n    distinctUntilChanged(isSetEqual),\n  )\n\n  return newSubscriberIds$\n    .pipe(\n      switchMap((ids) => {\n        if (!ids.size) return EMPTY\n        const {query, params} = createPreviewQuery(ids)\n        const controller = new AbortController()\n        return new Observable<PreviewQueryResult[]>((observer) => {\n          const {getCurrent, observable} = getQueryState<PreviewQueryResult[]>(instance, {\n            query,\n            params,\n            tag: PREVIEW_TAG,\n            perspective: PREVIEW_PERSPECTIVE,\n          })\n          const source$ = defer(() => {\n            if (getCurrent() === undefined) {\n              return from(\n                resolveQuery<PreviewQueryResult[]>(instance, {\n                  query,\n                  params,\n                  tag: PREVIEW_TAG,\n                  perspective: PREVIEW_PERSPECTIVE,\n                  signal: controller.signal,\n                }),\n              ).pipe(switchMap(() => observable))\n            }\n            return observable\n          }).pipe(filter((result) => result !== undefined))\n          const subscription = source$.subscribe(observer)\n          return () => {\n            if (!controller.signal.aborted) {\n              controller.abort()\n            }\n\n            subscription.unsubscribe()\n          }\n        }).pipe(map((data) => ({data, ids})))\n      }),\n      map(({ids, data}) => ({\n        values: processPreviewQuery({\n          projectId: instance.config.projectId!,\n          dataset: instance.config.dataset!,\n          ids,\n          results: data,\n        }),\n      })),\n    )\n    .subscribe({\n      next: ({values}) => {\n        state.set('updateResult', (prev) => ({values: {...prev.values, ...values}}))\n      },\n    })\n}\n","import {defineStore} from '../store/defineStore'\nimport {subscribeToStateAndFetchBatches} from './subscribeToStateAndFetchBatches'\n\nexport interface PreviewQueryResult {\n  _id: string\n  _type: string\n  _updatedAt: string\n  titleCandidates: Record<string, unknown>\n  subtitleCandidates: Record<string, unknown>\n  media?: PreviewMedia | null\n}\n\n/**\n * Represents a media asset in a preview.\n *\n * @public\n */\nexport interface PreviewMedia {\n  type: 'image-asset'\n  _ref: string\n  url: string\n}\n\n/**\n * Represents the set of values displayed as a preview for a given Sanity document.\n * This includes a primary title, a secondary subtitle, an optional piece of media associated\n * with the document, and the document's status.\n *\n * @public\n */\nexport interface PreviewValue {\n  /**\n   * The primary text displayed for the document preview.\n   */\n  title: string\n\n  /**\n   * A secondary line of text providing additional context about the document.\n   */\n  subtitle?: string\n\n  /**\n   * An optional piece of media representing the document within its preview.\n   * Currently, only image assets are available.\n   */\n  media?: PreviewMedia | null\n\n  /**\n   * The status of the document.\n   */\n  _status?: {\n    /** The date of the last published edit */\n    lastEditedPublishedAt?: string\n    /** The date of the last draft edit */\n    lastEditedDraftAt?: string\n  }\n}\n\n/**\n * Represents the current state of a preview value along with a flag indicating whether\n * the preview data is still being fetched or is fully resolved.\n *\n * The tuple contains a preview value or null, and a boolean indicating if the data is\n * pending. A `true` value means a fetch is ongoing; `false` indicates that the\n * currently provided preview value is up-to-date.\n *\n * @public\n */\nexport type ValuePending<T> = {\n  data: T | null\n  isPending: boolean\n}\n\n/**\n * @public\n */\nexport interface PreviewStoreState {\n  values: {[TDocumentId in string]?: ValuePending<PreviewValue>}\n  subscriptions: {[TDocumentId in string]?: {[TSubscriptionId in string]?: true}}\n}\n\nexport const previewStore = defineStore<PreviewStoreState>({\n  name: 'Preview',\n  getInitialState() {\n    return {\n      subscriptions: {},\n      values: {},\n    }\n  },\n  initialize: (context) => {\n    const subscription = subscribeToStateAndFetchBatches(context)\n    return () => subscription.unsubscribe\n  },\n})\n","import {omit} from 'lodash-es'\n\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {getPublishedId, insecureRandomId} from '../utils/ids'\nimport {\n  previewStore,\n  type PreviewStoreState,\n  type PreviewValue,\n  type ValuePending,\n} from './previewStore'\nimport {STABLE_EMPTY_PREVIEW} from './util'\n\n/**\n * @beta\n */\nexport type GetPreviewStateOptions = DocumentHandle\n\n/**\n * @beta\n */\nexport function getPreviewState<TResult extends object>(\n  instance: SanityInstance,\n  options: GetPreviewStateOptions,\n): StateSource<ValuePending<TResult>>\n/**\n * @beta\n */\nexport function getPreviewState(\n  instance: SanityInstance,\n  options: GetPreviewStateOptions,\n): StateSource<ValuePending<PreviewValue>>\n/**\n * @beta\n */\nexport function getPreviewState(\n  ...args: Parameters<typeof _getPreviewState>\n): StateSource<ValuePending<object>> {\n  return _getPreviewState(...args)\n}\n\n/**\n * @beta\n */\nexport const _getPreviewState = bindActionByDataset(\n  previewStore,\n  createStateSourceAction({\n    selector: (\n      {state}: SelectorContext<PreviewStoreState>,\n      docHandle: GetPreviewStateOptions,\n    ): ValuePending<object> => state.values[docHandle.documentId] ?? STABLE_EMPTY_PREVIEW,\n    onSubscribe: ({state}, docHandle: GetPreviewStateOptions) => {\n      const subscriptionId = insecureRandomId()\n      const documentId = getPublishedId(docHandle.documentId)\n\n      state.set('addSubscription', (prev) => ({\n        subscriptions: {\n          ...prev.subscriptions,\n          [documentId]: {\n            ...prev.subscriptions[documentId],\n            [subscriptionId]: true,\n          },\n        },\n      }))\n\n      return () => {\n        state.set('removeSubscription', (prev): Partial<PreviewStoreState> => {\n          const documentSubscriptions = omit(prev.subscriptions[documentId], subscriptionId)\n          const hasSubscribers = !!Object.keys(documentSubscriptions).length\n          const prevValue = prev.values[documentId]\n          const previewValue = prevValue?.data ? prevValue.data : null\n\n          return {\n            subscriptions: hasSubscribers\n              ? {...prev.subscriptions, [documentId]: documentSubscriptions}\n              : omit(prev.subscriptions, documentId),\n            values: hasSubscribers\n              ? prev.values\n              : {...prev.values, [documentId]: {data: previewValue, isPending: false}},\n          }\n        })\n      }\n    },\n  }),\n)\n","import {filter, firstValueFrom} from 'rxjs'\n\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {getPreviewState} from './getPreviewState'\nimport {previewStore} from './previewStore'\n\n/**\n * @beta\n */\nexport type ResolvePreviewOptions = DocumentHandle\n\n/**\n * @beta\n */\nexport const resolvePreview = bindActionByDataset(\n  previewStore,\n  ({instance}, docHandle: ResolvePreviewOptions) =>\n    firstValueFrom(getPreviewState(instance, docHandle).observable.pipe(filter((i) => !!i.data))),\n)\n","import {getDraftId, getPublishedId} from '../utils/ids'\nimport {\n  type DocumentProjections,\n  type DocumentProjectionValues,\n  type ValidProjection,\n} from './types'\n\nexport type ProjectionQueryResult = {\n  _id: string\n  _type: string\n  _updatedAt: string\n  result: Record<string, unknown>\n  __projectionHash: string\n}\n\ninterface CreateProjectionQueryResult {\n  query: string\n  params: Record<string, unknown>\n}\n\ntype ProjectionMap = Record<string, {projection: ValidProjection; documentIds: Set<string>}>\n\nexport function createProjectionQuery(\n  documentIds: Set<string>,\n  documentProjections: {[TDocumentId in string]?: DocumentProjections},\n): CreateProjectionQueryResult {\n  const projections = Array.from(documentIds)\n    .flatMap((id) => {\n      const projectionsForDoc = documentProjections[id]\n      if (!projectionsForDoc) return []\n\n      return Object.entries(projectionsForDoc).map(([projectionHash, projection]) => ({\n        documentId: id,\n        projection,\n        projectionHash,\n      }))\n    })\n    .reduce<ProjectionMap>((acc, {documentId, projection, projectionHash}) => {\n      const obj = acc[projectionHash] ?? {documentIds: new Set(), projection}\n      obj.documentIds.add(documentId)\n\n      acc[projectionHash] = obj\n      return acc\n    }, {})\n\n  const query = `[${Object.entries(projections)\n    .map(([projectionHash, {projection}]) => {\n      return `...*[_id in $__ids_${projectionHash}]{_id,_type,_updatedAt,\"__projectionHash\":\"${projectionHash}\",\"result\":{...${projection}}}`\n    })\n    .join(',')}]`\n\n  const params = Object.fromEntries(\n    Object.entries(projections).map(([projectionHash, value]) => {\n      const idsInProjection = Array.from(value.documentIds).flatMap((id) => [\n        getPublishedId(id),\n        getDraftId(id),\n      ])\n\n      return [`__ids_${projectionHash}`, Array.from(idsInProjection)]\n    }),\n  )\n\n  return {query, params}\n}\n\ninterface ProcessProjectionQueryOptions {\n  projectId: string\n  dataset: string\n  ids: Set<string>\n  results: ProjectionQueryResult[]\n}\n\nexport function processProjectionQuery({ids, results}: ProcessProjectionQueryOptions): {\n  [TDocumentId in string]?: DocumentProjectionValues<Record<string, unknown>>\n} {\n  const groupedResults: {\n    [docId: string]: {\n      [hash: string]: {\n        draft?: ProjectionQueryResult\n        published?: ProjectionQueryResult\n      }\n    }\n  } = {}\n\n  for (const result of results) {\n    const originalId = getPublishedId(result._id)\n    const hash = result.__projectionHash\n    const isDraft = result._id.startsWith('drafts.')\n\n    if (!ids.has(originalId)) continue\n\n    if (!groupedResults[originalId]) {\n      groupedResults[originalId] = {}\n    }\n    if (!groupedResults[originalId][hash]) {\n      groupedResults[originalId][hash] = {}\n    }\n\n    if (isDraft) {\n      groupedResults[originalId][hash].draft = result\n    } else {\n      groupedResults[originalId][hash].published = result\n    }\n  }\n\n  const finalValues: {\n    [docId: string]: DocumentProjectionValues<Record<string, unknown>>\n  } = {}\n\n  for (const originalId of ids) {\n    finalValues[originalId] = {}\n\n    const projectionsForDoc = groupedResults[originalId]\n    if (!projectionsForDoc) continue\n\n    for (const hash in projectionsForDoc) {\n      const {draft, published} = projectionsForDoc[hash]\n\n      const projectionResultData = draft?.result ?? published?.result\n\n      if (!projectionResultData) {\n        finalValues[originalId][hash] = {data: null, isPending: false}\n        continue\n      }\n\n      const _status = {\n        ...(draft?._updatedAt && {lastEditedDraftAt: draft._updatedAt}),\n        ...(published?._updatedAt && {lastEditedPublishedAt: published._updatedAt}),\n      }\n\n      finalValues[originalId][hash] = {\n        data: {...projectionResultData, _status},\n        isPending: false,\n      }\n    }\n  }\n\n  return finalValues\n}\n","import {type ValidProjection} from './types'\n\nexport const PROJECTION_TAG = 'projection'\nexport const PROJECTION_PERSPECTIVE = 'raw'\nexport const PROJECTION_STATE_CLEAR_DELAY = 1000\n\nexport const STABLE_EMPTY_PROJECTION = {\n  data: null,\n  isPending: false,\n}\n\nexport function validateProjection(projection: string): ValidProjection {\n  if (!projection.startsWith('{') || !projection.endsWith('}')) {\n    throw new Error(\n      `Invalid projection format: \"${projection}\". Projections must be enclosed in curly braces, e.g. \"{title, 'author': author.name}\"`,\n    )\n  }\n  return projection as ValidProjection\n}\n","import {isEqual} from 'lodash-es'\nimport {\n  combineLatest,\n  debounceTime,\n  defer,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  from,\n  map,\n  Observable,\n  pairwise,\n  startWith,\n  Subscription,\n  switchMap,\n  tap,\n} from 'rxjs'\n\nimport {getQueryState, resolveQuery} from '../query/queryStore'\nimport {type StoreContext} from '../store/defineStore'\nimport {\n  createProjectionQuery,\n  processProjectionQuery,\n  type ProjectionQueryResult,\n} from './projectionQuery'\nimport {type ProjectionStoreState} from './types'\nimport {PROJECTION_PERSPECTIVE, PROJECTION_TAG} from './util'\n\nconst BATCH_DEBOUNCE_TIME = 50\n\nconst isSetEqual = <T>(a: Set<T>, b: Set<T>) =>\n  a.size === b.size && Array.from(a).every((i) => b.has(i))\n\nexport const subscribeToStateAndFetchBatches = ({\n  state,\n  instance,\n}: StoreContext<ProjectionStoreState>): Subscription => {\n  const documentProjections$ = state.observable.pipe(\n    map((s) => s.documentProjections),\n    distinctUntilChanged(isEqual),\n  )\n\n  const activeDocumentIds$ = state.observable.pipe(\n    map(({subscriptions}) => new Set(Object.keys(subscriptions))),\n    distinctUntilChanged(isSetEqual),\n  )\n\n  const pendingUpdateSubscription = activeDocumentIds$\n    .pipe(\n      debounceTime(BATCH_DEBOUNCE_TIME),\n      startWith(new Set<string>()),\n      pairwise(),\n      tap(([prevIds, currIds]) => {\n        const newIds = [...currIds].filter((id) => !prevIds.has(id))\n        if (newIds.length === 0) return\n\n        state.set('updatingPending', (prev) => {\n          const nextValues = {...prev.values}\n          for (const id of newIds) {\n            const projectionsForDoc = prev.documentProjections[id]\n            if (!projectionsForDoc) continue\n\n            const currentValuesForDoc = prev.values[id] ?? {}\n            const updatedValuesForDoc = {...currentValuesForDoc}\n\n            for (const hash in projectionsForDoc) {\n              const currentValue = updatedValuesForDoc[hash]\n              updatedValuesForDoc[hash] = {\n                data: currentValue?.data ?? null,\n                isPending: true,\n              }\n            }\n            nextValues[id] = updatedValuesForDoc\n          }\n          return {values: nextValues}\n        })\n      }),\n    )\n    .subscribe()\n\n  const queryTrigger$ = combineLatest([activeDocumentIds$, documentProjections$]).pipe(\n    debounceTime(BATCH_DEBOUNCE_TIME),\n    distinctUntilChanged(isEqual),\n  )\n\n  const queryExecutionSubscription = queryTrigger$\n    .pipe(\n      switchMap(([ids, documentProjections]) => {\n        if (!ids.size) return EMPTY\n        const {query, params} = createProjectionQuery(ids, documentProjections)\n        const controller = new AbortController()\n\n        return new Observable<ProjectionQueryResult[]>((observer) => {\n          const {getCurrent, observable} = getQueryState<ProjectionQueryResult[]>(instance, {\n            query,\n            params,\n            tag: PROJECTION_TAG,\n            perspective: PROJECTION_PERSPECTIVE,\n          })\n\n          const source$ = defer(() => {\n            if (getCurrent() === undefined) {\n              return from(\n                resolveQuery<ProjectionQueryResult[]>(instance, {\n                  query,\n                  params,\n                  tag: PROJECTION_TAG,\n                  perspective: PROJECTION_PERSPECTIVE,\n                  signal: controller.signal,\n                }),\n              ).pipe(switchMap(() => observable))\n            }\n            return observable\n          }).pipe(filter((result): result is ProjectionQueryResult[] => result !== undefined))\n\n          const subscription = source$.subscribe(observer)\n\n          return () => {\n            if (!controller.signal.aborted) {\n              controller.abort()\n            }\n            subscription.unsubscribe()\n          }\n        }).pipe(map((data) => ({data, ids})))\n      }),\n      map(({ids, data}) =>\n        processProjectionQuery({\n          projectId: instance.config.projectId!,\n          dataset: instance.config.dataset!,\n          ids,\n          results: data,\n        }),\n      ),\n    )\n    .subscribe({\n      next: (processedValues) => {\n        state.set('updateResult', (prev) => {\n          const nextValues = {...prev.values}\n          for (const docId in processedValues) {\n            if (processedValues[docId]) {\n              nextValues[docId] = {\n                ...(prev.values[docId] ?? {}),\n                ...processedValues[docId],\n              }\n            }\n          }\n          return {values: nextValues}\n        })\n      },\n      error: (err) => {\n        // eslint-disable-next-line no-console\n        console.error('Error fetching projection batches:', err)\n        // TODO: Potentially update state to reflect error state for affected projections?\n      },\n    })\n\n  return new Subscription(() => {\n    pendingUpdateSubscription.unsubscribe()\n    queryExecutionSubscription.unsubscribe()\n  })\n}\n","import {defineStore} from '../store/defineStore'\nimport {subscribeToStateAndFetchBatches} from './subscribeToStateAndFetchBatches'\nimport {type ProjectionStoreState} from './types'\n\nexport const projectionStore = defineStore<ProjectionStoreState>({\n  name: 'Projection',\n  getInitialState() {\n    return {\n      values: {},\n      documentProjections: {},\n      subscriptions: {},\n    }\n  },\n  initialize(context) {\n    const batchSubscription = subscribeToStateAndFetchBatches(context)\n    return () => batchSubscription.unsubscribe()\n  },\n})\n","import {type SanityProjectionResult} from 'groq'\nimport {omit} from 'lodash-es'\n\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {hashString} from '../utils/hashString'\nimport {getPublishedId, insecureRandomId} from '../utils/ids'\nimport {projectionStore} from './projectionStore'\nimport {type ProjectionStoreState, type ProjectionValuePending, type ValidProjection} from './types'\nimport {PROJECTION_STATE_CLEAR_DELAY, STABLE_EMPTY_PROJECTION, validateProjection} from './util'\n\nexport interface ProjectionOptions<\n  TProjection extends ValidProjection = ValidProjection,\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n> extends DocumentHandle<TDocumentType, TDataset, TProjectId> {\n  projection: TProjection\n}\n\n/**\n * @beta\n */\nexport function getProjectionState<\n  TProjection extends ValidProjection = ValidProjection,\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  options: ProjectionOptions<TProjection, TDocumentType, TDataset, TProjectId>,\n): StateSource<\n  | ProjectionValuePending<\n      SanityProjectionResult<TProjection, TDocumentType, `${TProjectId}.${TDataset}`>\n    >\n  | undefined\n>\n\n/**\n * @beta\n */\nexport function getProjectionState<TData extends object>(\n  instance: SanityInstance,\n  options: ProjectionOptions,\n): StateSource<ProjectionValuePending<TData> | undefined>\n\n/**\n * @beta\n */\nexport function getProjectionState(\n  instance: SanityInstance,\n  options: ProjectionOptions,\n): StateSource<ProjectionValuePending<Record<string, unknown>> | undefined>\n\n/**\n * @beta\n */\nexport function getProjectionState(\n  ...args: Parameters<typeof _getProjectionState>\n): ReturnType<typeof _getProjectionState> {\n  return _getProjectionState(...args)\n}\n\n/**\n * @beta\n */\nexport const _getProjectionState = bindActionByDataset(\n  projectionStore,\n  createStateSourceAction({\n    selector: (\n      {state}: SelectorContext<ProjectionStoreState>,\n      options: ProjectionOptions<ValidProjection, string, string, string>,\n    ): ProjectionValuePending<object> | undefined => {\n      const documentId = getPublishedId(options.documentId)\n      const projectionHash = hashString(options.projection)\n      return state.values[documentId]?.[projectionHash] ?? STABLE_EMPTY_PROJECTION\n    },\n    onSubscribe: ({state}, options: ProjectionOptions<ValidProjection, string, string, string>) => {\n      const {projection, ...docHandle} = options\n      const subscriptionId = insecureRandomId()\n      const documentId = getPublishedId(docHandle.documentId)\n      const validProjection = validateProjection(projection)\n      const projectionHash = hashString(validProjection)\n\n      state.set('addSubscription', (prev) => ({\n        documentProjections: {\n          ...prev.documentProjections,\n          [documentId]: {\n            ...prev.documentProjections[documentId],\n            [projectionHash]: validProjection,\n          },\n        },\n        subscriptions: {\n          ...prev.subscriptions,\n          [documentId]: {\n            ...prev.subscriptions[documentId],\n            [projectionHash]: {\n              ...prev.subscriptions[documentId]?.[projectionHash],\n              [subscriptionId]: true,\n            },\n          },\n        },\n      }))\n\n      return () => {\n        setTimeout(() => {\n          state.set('removeSubscription', (prev): Partial<ProjectionStoreState> => {\n            const documentSubscriptionsForHash = omit(\n              prev.subscriptions[documentId]?.[projectionHash],\n              subscriptionId,\n            )\n            const hasSubscribersForProjection = !!Object.keys(documentSubscriptionsForHash).length\n\n            const nextSubscriptions = {...prev.subscriptions}\n            const nextDocumentProjections = {...prev.documentProjections}\n            const nextValues = {...prev.values}\n\n            // clean up the subscription and documentProjection if there are no subscribers\n            if (!hasSubscribersForProjection) {\n              delete nextSubscriptions[documentId]![projectionHash]\n              delete nextDocumentProjections[documentId]![projectionHash]\n\n              const currentProjectionValue = prev.values[documentId]?.[projectionHash]\n              if (currentProjectionValue && nextValues[documentId]) {\n                nextValues[documentId]![projectionHash] = {\n                  data: currentProjectionValue.data,\n                  isPending: false,\n                }\n              }\n            } else {\n              if (nextSubscriptions[documentId]) {\n                nextSubscriptions[documentId]![projectionHash] = documentSubscriptionsForHash\n              }\n            }\n\n            const hasAnySubscribersForDocument = Object.values(\n              nextSubscriptions[documentId] ?? {},\n            ).some((subs) => Object.keys(subs).length > 0)\n\n            if (!hasAnySubscribersForDocument) {\n              delete nextSubscriptions[documentId]\n              delete nextDocumentProjections[documentId]\n              // Keep nextValues[documentId] as cache\n            }\n\n            return {\n              subscriptions: nextSubscriptions,\n              documentProjections: nextDocumentProjections,\n              values: nextValues,\n            }\n          })\n        }, PROJECTION_STATE_CLEAR_DELAY)\n      }\n    },\n  }),\n)\n","import {type SanityProjectionResult} from 'groq'\nimport {filter, firstValueFrom} from 'rxjs'\n\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {getProjectionState, type ProjectionOptions} from './getProjectionState'\nimport {projectionStore} from './projectionStore'\nimport {type ProjectionValuePending, type ValidProjection} from './types'\n\n/** @beta */\nexport function resolveProjection<\n  TProjection extends ValidProjection = ValidProjection,\n  TDocumentType extends string = string,\n  TDataset extends string = string,\n  TProjectId extends string = string,\n>(\n  instance: SanityInstance,\n  options: ProjectionOptions<TProjection, TDocumentType, TDataset, TProjectId>,\n): Promise<\n  ProjectionValuePending<\n    SanityProjectionResult<TProjection, TDocumentType, `${TProjectId}.${TDataset}`>\n  >\n>\n\n/** @beta */\nexport function resolveProjection<TData extends object>(\n  instance: SanityInstance,\n  options: ProjectionOptions,\n): Promise<ProjectionValuePending<TData>>\n\n/** @beta */\nexport function resolveProjection(\n  ...args: Parameters<typeof _resolveProjection>\n): ReturnType<typeof _resolveProjection> {\n  return _resolveProjection(...args)\n}\n\n/**\n * @beta\n */\nconst _resolveProjection = bindActionByDataset(\n  projectionStore,\n  (\n    {instance}: {instance: SanityInstance},\n    options: ProjectionOptions,\n  ): Promise<ProjectionValuePending<Record<string, unknown>>> =>\n    firstValueFrom(\n      getProjectionState<Record<string, unknown>>(instance, options).observable.pipe(\n        filter((state): state is ProjectionValuePending<Record<string, unknown>> => !!state?.data),\n      ),\n    ),\n)\n","import {switchMap} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {createFetcherStore} from '../utils/createFetcherStore'\n\nconst API_VERSION = 'v2025-02-19'\n\nconst projects = createFetcherStore({\n  name: 'Projects',\n  getKey: () => 'projects',\n  fetcher: (instance) => () =>\n    getClientState(instance, {\n      apiVersion: API_VERSION,\n      scope: 'global',\n    }).observable.pipe(\n      switchMap((client) => client.observable.projects.list({includeMembers: false})),\n    ),\n})\n\n/** @public */\nexport const getProjectsState = projects.getState\n/** @public */\nexport const resolveProjects = projects.resolveState\n","const WILDCARD_TOKEN = '*'\nconst NEGATION_TOKEN = '-'\n// This regex handles simple cases including quoted phrases.\n// More complex query syntaxes might need a more robust parser.\nconst TOKEN_REGEX = /(?:[^\\s\"]+|\"[^\"]*\")+/g\n\n/**\n * @internal\n * Checks if a token starts with the negation character.\n */\nfunction isNegationToken(token: string | undefined): boolean {\n  return typeof token !== 'undefined' && token.trim().startsWith(NEGATION_TOKEN)\n}\n\n/**\n * @internal\n * Checks if a token ends with the wildcard character.\n */\nfunction isPrefixToken(token: string | undefined): boolean {\n  return typeof token !== 'undefined' && token.trim().endsWith(WILDCARD_TOKEN)\n}\n\n/**\n * @internal\n * Checks if a token is enclosed in double quotes.\n */\nfunction isExactMatchToken(token: string | undefined): boolean {\n  // Ensure the token exists, has at least 2 characters, and starts/ends with \"\n  return !!token && token.length >= 2 && token.startsWith('\"') && token.endsWith('\"')\n}\n\n/**\n * Creates a GROQ search filter string (`[@] match text::query(\"...\")`)\n * from a raw search query string.\n *\n * It applies wildcard ('*') logic to the last eligible token and escapes\n * double quotes within the search term.\n *\n * If the input query is empty or only whitespace, it returns an empty string.\n *\n * @param query - The raw input search string.\n * @returns The GROQ search filter string, or an empty string.\n * @internal\n */\nexport function createGroqSearchFilter(query: string): string {\n  // Trim leading/trailing whitespace from the overall query first\n  const trimmedQuery = query.trim()\n  if (!trimmedQuery) {\n    return '' // Return empty if query is empty or just whitespace\n  }\n\n  // Extract tokens using the regex\n  const tokens = trimmedQuery.match(TOKEN_REGEX) ?? []\n\n  // Find the index of the last token eligible for wildcard appending\n  const reversedTokens = [...tokens].reverse()\n  const reversedIndex = reversedTokens.findIndex(\n    (token: string) => !isNegationToken(token) && !isExactMatchToken(token),\n  )\n  const finalIncrementalTokenIndex = reversedIndex === -1 ? -1 : tokens.length - 1 - reversedIndex\n\n  // Get the actual token based on the found index\n  const finalIncrementalToken = tokens[finalIncrementalTokenIndex]\n\n  const processedTokens = [...tokens]\n  // If a suitable token was found and it doesn't already end with a wildcard,\n  // apply the wildcard.\n  if (finalIncrementalToken !== undefined && !isPrefixToken(finalIncrementalToken)) {\n    // Replace the identified token with its wildcarded version\n    processedTokens.splice(\n      finalIncrementalTokenIndex,\n      1,\n      `${finalIncrementalToken}${WILDCARD_TOKEN}`,\n    )\n  }\n\n  // Join the tokens back into a space-separated string\n  const wildcardSearch = processedTokens.join(' ')\n\n  // Escape double quotes within the final search term for the GROQ query\n  const escapedSearch = wildcardSearch.replace(/\"/g, '\\\\\"')\n\n  // Construct the final GROQ filter clause\n  return `[@] match text::query(\"${escapedSearch}\")`\n}\n","/**\n * Filter criteria for intent matching. Can be combined to create more specific intents.\n *\n * @example\n * ```typescript\n * // matches only geopoints in the travel-project project, production dataset\n * const filter: IntentFilter = {\n *   projectId: 'travel-project',\n *   dataset: 'production',\n *   types: ['geopoint']\n * }\n *\n * // matches all documents in the travel-project project\n * const filter: IntentFilter = {\n *   projectId: 'travel-project',\n *   types: ['*']\n * }\n *\n * // matches geopoints in the travel-project production dataset and map pins in all projects in the org\n * const filters: IntentFilter[] = [\n *  {\n *    projectId: 'travel-project',\n *    dataset: 'production',\n *    types: ['geopoint']\n *  },\n *  {\n *    types: ['map-pin']\n *  }\n * ]\n * ```\n * @public\n */\nexport interface IntentFilter {\n  /**\n   * Project ID to match against\n   * @remarks When specified, the intent will only match for the specified project.\n   */\n  projectId?: string\n\n  /**\n   * Dataset to match against\n   * @remarks When specified, the intent will only match for the specified dataset. Requires projectId to be specified.\n   */\n  dataset?: string\n\n  /**\n   * Document types that this intent can handle\n   * @remarks This is required for all filters. Use ['*'] to match all document types.\n   */\n  types: string[]\n}\n\n/**\n * Intent definition structure for registering user intents\n * @public\n */\nexport interface Intent {\n  /**\n   * Unique identifier for this intent\n   * @remarks Should be unique across all registered intents in an org for proper matching\n   */\n  id: string\n\n  /**\n   * The action that this intent performs\n   * @remarks Examples: \"view\", \"edit\", \"create\", \"delete\"\n   */\n  action: 'view' | 'edit' | 'create' | 'delete'\n\n  /**\n   * Human-readable title for this intent\n   * @remarks Used for display purposes in UI or logs\n   */\n  title: string\n\n  /**\n   * Detailed description of what this intent does\n   * @remarks Helps users understand the purpose and behavior of the intent\n   */\n  description?: string\n\n  /**\n   * Array of filter criteria for intent matching\n   * @remarks At least one filter is required. Use `{types: ['*']}` to match everything\n   */\n  filters: IntentFilter[]\n}\n\n/**\n * Creates a properly typed intent definition for registration with the backend.\n *\n * This utility function provides TypeScript support and validation for intent declarations.\n * It is also used in the CLI if intents are declared as bare objects in an intents file.\n *\n * @param intent - The intent definition object\n * @returns The same intent object with proper typing\n *\n * @example\n * ```typescript\n * // Specific filter for a document type\n * const viewGeopointInMapApp = defineIntent({\n *   id: 'viewGeopointInMapApp',\n *   action: 'view',\n *   title: 'View a geopoint in the map app',\n *   description: 'This lets you view a geopoint in the map app',\n *   filters: [\n *     {\n *       projectId: 'travel-project',\n *       dataset: 'production',\n *       types: ['geopoint']\n *     }\n *   ]\n * })\n *\n * export default viewGeopointInMapApp\n * ```\n *\n * If your intent is asynchronous, resolve the promise before defining / returning the intent\n * ```typescript\n * async function createAsyncIntent() {\n *   const currentProject = await asyncProjectFunction()\n *   const currentDataset = await asyncDatasetFunction()\n *\n *   return defineIntent({\n *     id: 'dynamicIntent',\n *     action: 'view',\n *     title: 'Dynamic Intent',\n *     description: 'Intent with dynamically resolved values',\n *     filters: [\n *       {\n *         projectId: currentProject,  // Resolved value\n *         dataset: currentDataset,    // Resolved value\n *         types: ['document']\n *       }\n *     ]\n *   })\n * }\n *\n * const intent = await createAsyncIntent()\n * export default intent\n * ```\n *\n * @public\n */\nexport function defineIntent(intent: Intent): Intent {\n  // Validate required fields\n  if (!intent.id) {\n    throw new Error('Intent must have an id')\n  }\n  if (!intent.action) {\n    throw new Error('Intent must have an action')\n  }\n  if (!intent.title) {\n    throw new Error('Intent must have a title')\n  }\n  if (!Array.isArray(intent.filters)) {\n    throw new Error('Intent must have a filters array')\n  }\n  if (intent.filters.length === 0) {\n    throw new Error(\n      \"Intent must have at least one filter. If you want to match everything, use {types: ['*']}\",\n    )\n  }\n\n  // Validate each filter\n  intent.filters.forEach((filter, index) => {\n    validateFilter(filter, index)\n  })\n\n  // Return the intent as-is, providing type safety and runtime validation\n  return intent\n}\n\n/**\n * Validates an individual filter object\n * @param filter - The filter to validate\n * @param index - The filter's index in the array (for error messages)\n * @internal\n */\nfunction validateFilter(filter: IntentFilter, index: number): void {\n  const filterContext = `Filter at index ${index}`\n\n  // Check that filter is an object\n  if (!filter || typeof filter !== 'object') {\n    throw new Error(`${filterContext} must be an object`)\n  }\n\n  // Check that types is required\n  if (filter.types === undefined) {\n    throw new Error(\n      `${filterContext} must have a types property. Use ['*'] to match all document types.`,\n    )\n  }\n\n  // Validate projectId\n  if (filter.projectId !== undefined) {\n    if (typeof filter.projectId !== 'string') {\n      throw new Error(`${filterContext}: projectId must be a string`)\n    }\n    if (filter.projectId.trim() === '') {\n      throw new Error(`${filterContext}: projectId cannot be empty`)\n    }\n  }\n\n  // Validate dataset\n  if (filter.dataset !== undefined) {\n    if (typeof filter.dataset !== 'string') {\n      throw new Error(`${filterContext}: dataset must be a string`)\n    }\n    if (filter.dataset.trim() === '') {\n      throw new Error(`${filterContext}: dataset cannot be empty`)\n    }\n    // Dataset requires projectId to be specified\n    if (filter.projectId === undefined) {\n      throw new Error(`${filterContext}: dataset cannot be specified without projectId`)\n    }\n  }\n\n  // Validate types (now required)\n  if (!Array.isArray(filter.types)) {\n    throw new Error(`${filterContext}: types must be an array`)\n  }\n  if (filter.types.length === 0) {\n    throw new Error(`${filterContext}: types array cannot be empty`)\n  }\n\n  // Validate each type\n  filter.types.forEach((type, typeIndex) => {\n    if (typeof type !== 'string') {\n      throw new Error(`${filterContext}: types[${typeIndex}] must be a string`)\n    }\n    if (type.trim() === '') {\n      throw new Error(`${filterContext}: types[${typeIndex}] cannot be empty`)\n    }\n  })\n\n  // Check for wildcard exclusivity\n  const hasWildcard = filter.types.includes('*')\n  if (hasWildcard && filter.types.length > 1) {\n    throw new Error(\n      `${filterContext}: when using wildcard '*', it must be the only type in the array`,\n    )\n  }\n}\n","import {version} from '../package.json'\nimport {getEnv} from './utils/getEnv'\n\n/**\n * This version is provided by pkg-utils at build time\n * @internal\n */\nexport const CORE_SDK_VERSION = getEnv('PKG_VERSION') || `${version}-development`\n"],"names":["AuthStateType","getInitialState","isEqual","DEFAULT_API_VERSION","delay","e","getDashboardOrganizationId","key","switchMap","s","filter","map","i","API_VERSION","project","destroyController","getOrCreateChannel","getOrCreateController","releaseChannel","unboundDestroyController","unboundGetOrCreateChannel","unboundGetOrCreateController","unboundReleaseChannel","getOrCreateNode","releaseNode","unboundReleaseNode","unboundGetOrCreateNode","m","document","listen","t","r","n","o","a","c","u","p","l","f","y","b","set","parse","checkGrant","evaluateSync","k","v","getPublishedId","first","tap","catchError","startWith","pairwise","groupBy","mergeMap","errorHandler","resourceType","share","BATCH_DEBOUNCE_TIME","isSetEqual","subscribeToStateAndFetchBatches","debounceTime"],"mappings":"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"}