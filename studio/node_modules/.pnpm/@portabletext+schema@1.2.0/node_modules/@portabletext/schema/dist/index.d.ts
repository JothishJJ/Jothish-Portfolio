/**
 * @public
 */
type Schema = {
  block: {
    name: string;
    fields?: ReadonlyArray<FieldDefinition>;
  };
  span: {
    name: string;
  };
  styles: ReadonlyArray<StyleSchemaType>;
  lists: ReadonlyArray<ListSchemaType>;
  decorators: ReadonlyArray<DecoratorSchemaType>;
  annotations: ReadonlyArray<AnnotationSchemaType>;
  blockObjects: ReadonlyArray<BlockObjectSchemaType>;
  inlineObjects: ReadonlyArray<InlineObjectSchemaType>;
};
/**
 * @public
 */
type StyleSchemaType = BaseDefinition & {
  /**
   * @deprecated
   * Use `name` instead
   */
  value: string;
};
/**
 * @public
 */
type ListSchemaType = BaseDefinition & {
  /**
   * @deprecated
   * Use `name` instead
   */
  value: string;
};
/**
 * @public
 */
type DecoratorSchemaType = BaseDefinition & {
  /**
   * @deprecated
   * Use `name` instead
   */
  value: string;
};
/**
 * @public
 */
type AnnotationSchemaType = BaseDefinition & {
  fields: ReadonlyArray<FieldDefinition>;
};
/**
 * @public
 */
type BlockObjectSchemaType = BaseDefinition & {
  fields: ReadonlyArray<FieldDefinition>;
};
/**
 * @public
 */
type InlineObjectSchemaType = BaseDefinition & {
  fields: ReadonlyArray<FieldDefinition>;
};
/**
 * @public
 */
type FieldDefinition = BaseDefinition & {
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
};
/**
 * @public
 */
type BaseDefinition = {
  name: string;
  title?: string;
};
/**
 * @public
 */
type SchemaDefinition = {
  block?: {
    name?: string;
    fields?: ReadonlyArray<FieldDefinition>;
  };
  styles?: ReadonlyArray<StyleDefinition>;
  lists?: ReadonlyArray<ListDefinition>;
  decorators?: ReadonlyArray<DecoratorDefinition>;
  annotations?: ReadonlyArray<AnnotationDefinition>;
  blockObjects?: ReadonlyArray<BlockObjectDefinition>;
  inlineObjects?: ReadonlyArray<InlineObjectDefinition>;
};
/**
 * @public
 * A helper wrapper that adds editor support, such as autocomplete and type checking, for a schema definition.
 * @example
 * ```ts
 * import { defineSchema } from '@portabletext/editor'
 *
 * const schemaDefinition = defineSchema({
 *  decorators: [{name: 'strong'}, {name: 'em'}, {name: 'underline'}],
 *  annotations: [{name: 'link'}],
 *  styles: [
 *    {name: 'normal'},
 *    {name: 'h1'},
 *    {name: 'h2'},
 *    {name: 'h3'},
 *    {name: 'blockquote'},
 *  ],
 *  lists: [],
 *  inlineObjects: [],
 *  blockObjects: [],
 * }
 * ```
 */
declare function defineSchema<const TSchemaDefinition extends SchemaDefinition>(definition: TSchemaDefinition): TSchemaDefinition;
/**
 * @public
 */
type StyleDefinition<TBaseDefinition extends BaseDefinition = BaseDefinition> = TBaseDefinition;
/**
 * @public
 */
type ListDefinition<TBaseDefinition extends BaseDefinition = BaseDefinition> = TBaseDefinition;
/**
 * @public
 */
type DecoratorDefinition<TBaseDefinition extends BaseDefinition = BaseDefinition> = TBaseDefinition;
/**
 * @public
 */
type AnnotationDefinition<TBaseDefinition extends BaseDefinition = BaseDefinition> = TBaseDefinition & {
  fields?: ReadonlyArray<FieldDefinition>;
};
/**
 * @public
 */
type BlockObjectDefinition<TBaseDefinition extends BaseDefinition = BaseDefinition> = TBaseDefinition & {
  fields?: ReadonlyArray<FieldDefinition>;
};
/**
 * @public
 */
type InlineObjectDefinition<TBaseDefinition extends BaseDefinition = BaseDefinition> = TBaseDefinition & {
  fields?: ReadonlyArray<FieldDefinition>;
};
/**
 * @public
 */
declare function compileSchema(definition: SchemaDefinition): Schema;
/**
 * @public
 */
interface TypedObject {
  [key: string]: unknown;
  _type: string;
}
/**
 * @public
 */
declare function isTypedObject(object: unknown): object is TypedObject;
/**
 * @public
 */
type PortableTextBlock = PortableTextTextBlock | PortableTextObject;
/**
 * @public
 */
interface PortableTextTextBlock<TChild = PortableTextSpan | PortableTextObject> {
  _type: string;
  _key: string;
  children: TChild[];
  markDefs?: PortableTextObject[];
  listItem?: string;
  style?: string;
  level?: number;
}
/**
 * @public
 */
declare function isTextBlock(context: {
  schema: Schema;
}, block: unknown): block is PortableTextTextBlock;
/**
 * @public
 */
interface PortableTextSpan {
  _key: string;
  _type: 'span';
  text: string;
  marks?: string[];
}
/**
 * @public
 */
declare function isSpan(context: {
  schema: Schema;
}, child: unknown): child is PortableTextSpan;
/**
 * @public
 */
interface PortableTextObject {
  _type: string;
  _key: string;
  [other: string]: unknown;
}
export { type AnnotationDefinition, type AnnotationSchemaType, type BaseDefinition, type BlockObjectDefinition, type BlockObjectSchemaType, type DecoratorDefinition, type DecoratorSchemaType, type FieldDefinition, type InlineObjectDefinition, type InlineObjectSchemaType, type ListDefinition, type ListSchemaType, type PortableTextBlock, type PortableTextObject, type PortableTextSpan, type PortableTextTextBlock, type Schema, type SchemaDefinition, type StyleDefinition, type StyleSchemaType, type TypedObject, compileSchema, defineSchema, isSpan, isTextBlock, isTypedObject };