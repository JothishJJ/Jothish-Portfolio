"use strict";
var jsxRuntime = require("react/jsx-runtime"), reactCompilerRuntime = require("react-compiler-runtime"), sanity = require("sanity"), ui = require("@sanity/ui"), react = require("react"), reactSplitPane = require("@rexxars/react-split-pane"), icons = require("@sanity/icons"), isHotkeyEsm = require("is-hotkey-esm"), useEffectEvent = require("use-effect-event"), CodeMirror = require("@uiw/react-codemirror"), autocomplete = require("@codemirror/autocomplete"), commands = require("@codemirror/commands"), langJavascript = require("@codemirror/lang-javascript"), language = require("@codemirror/language"), search = require("@codemirror/search"), view = require("@codemirror/view"), highlight = require("@lezer/highlight"), color = require("@sanity/color"), styledComponents = require("styled-components"), index = require("./index.js"), debounce = require("lodash/debounce.js"), JSON5 = require("json5"), isEqual = require("lodash/isEqual.js"), uuid = require("@sanity/uuid"), operators = require("rxjs/operators"), json2Csv = require("json-2-csv"), reactJsonInspector = require("@rexxars/react-json-inspector"), LRU = require("quick-lru"), router = require("sanity/router"), reactRx = require("react-rx"), rxjs = require("rxjs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var CodeMirror__default = /* @__PURE__ */ _interopDefaultCompat(CodeMirror), debounce__default = /* @__PURE__ */ _interopDefaultCompat(debounce), JSON5__default = /* @__PURE__ */ _interopDefaultCompat(JSON5), isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual), LRU__default = /* @__PURE__ */ _interopDefaultCompat(LRU);
const API_VERSIONS = ["v1", "vX", "v2021-03-25", "v2021-10-21", "v2022-03-07", "v2025-02-19", `v${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`], [DEFAULT_API_VERSION] = API_VERSIONS.slice(-1);
function DelayedSpinner(props) {
  const $ = reactCompilerRuntime.c(5), [show, setShow] = react.useState(!1);
  let t0, t1;
  $[0] !== props.delay ? (t0 = () => {
    const timer = setTimeout(() => setShow(!0), props.delay || 500);
    return () => clearTimeout(timer);
  }, t1 = [props.delay], $[0] = props.delay, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), react.useEffect(t0, t1);
  let t2;
  return $[3] !== show ? (t2 = show ? /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0, size: 4 }) : null, $[3] = show, $[4] = t2) : t2 = $[4], t2;
}
const codemirrorExtensions = [[langJavascript.javascriptLanguage], view.lineNumbers(), view.highlightActiveLine(), view.highlightActiveLineGutter(), search.highlightSelectionMatches(), view.highlightSpecialChars(), language.indentOnInput(), language.bracketMatching(), autocomplete.closeBrackets(), commands.history(), view.drawSelection(), language.syntaxHighlighting(language.defaultHighlightStyle, {
  fallback: !0
}), view.keymap.of([
  // Override the default keymap for Mod-Enter to not insert a new line, we have a custom event handler for executing queries
  {
    key: "Mod-Enter",
    run: () => !0
  },
  // Add the default keymap and history keymap
  commands.defaultKeymap,
  commands.historyKeymap
].flat().filter(Boolean))];
function useCodemirrorTheme(theme) {
  const $ = reactCompilerRuntime.c(7);
  let t0;
  $[0] !== theme ? (t0 = createTheme(theme), $[0] = theme, $[1] = t0) : t0 = $[1];
  const cmTheme = t0;
  let t1;
  $[2] !== theme ? (t1 = language.syntaxHighlighting(createHighlight(theme)), $[2] = theme, $[3] = t1) : t1 = $[3];
  const cmHighlight = t1;
  let t2;
  return $[4] !== cmHighlight || $[5] !== cmTheme ? (t2 = [cmTheme, cmHighlight], $[4] = cmHighlight, $[5] = cmTheme, $[6] = t2) : t2 = $[6], t2;
}
function createTheme(theme) {
  const {
    color: color$1,
    fonts
  } = theme.sanity, card = color$1.card.enabled, cursor = color.hues.blue[color$1.dark ? 400 : 500].hex, selection = color.hues.gray[theme.sanity.color.dark ? 900 : 100].hex;
  return view.EditorView.theme({
    "&": {
      color: card.fg,
      backgroundColor: card.bg
    },
    ".cm-content": {
      caretColor: cursor
    },
    ".cm-editor": {
      fontFamily: fonts.code.family,
      fontSize: ui.rem(fonts.code.sizes[1].fontSize),
      lineHeight: "inherit"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: cursor
    },
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
      backgroundColor: selection
    },
    ".cm-panels": {
      backgroundColor: card.bg,
      color: card.fg
    },
    ".cm-panels.cm-panels-top": {
      borderBottom: `2px solid ${card.border}`
    },
    ".cm-panels.cm-panels-bottom": {
      borderTop: `2px solid ${card.border}`
    }
  }, {
    dark: color$1.dark
  });
}
function createHighlight(theme) {
  const c = theme.sanity.color.base, s = theme.sanity.color.syntax;
  return language.HighlightStyle.define([{
    tag: highlight.tags.keyword,
    color: s.keyword
  }, {
    tag: [highlight.tags.propertyName, highlight.tags.name, highlight.tags.deleted, highlight.tags.character, highlight.tags.macroName],
    color: s.property
  }, {
    tag: [highlight.tags.function(highlight.tags.variableName), highlight.tags.labelName],
    color: s.function
  }, {
    tag: [highlight.tags.color, highlight.tags.constant(highlight.tags.name), highlight.tags.standard(highlight.tags.name)],
    color: s.variable
  }, {
    tag: [highlight.tags.definition(highlight.tags.name), highlight.tags.separator],
    color: s.constant
  }, {
    tag: [highlight.tags.typeName, highlight.tags.className, highlight.tags.number, highlight.tags.changed, highlight.tags.annotation, highlight.tags.modifier, highlight.tags.self, highlight.tags.namespace],
    color: s.number
  }, {
    tag: [highlight.tags.operator, highlight.tags.operatorKeyword, highlight.tags.url, highlight.tags.escape, highlight.tags.regexp, highlight.tags.link, highlight.tags.special(highlight.tags.string)],
    color: s.operator
  }, {
    tag: [highlight.tags.meta, highlight.tags.comment],
    color: s.comment
  }, {
    tag: highlight.tags.strong,
    fontWeight: "bold"
  }, {
    tag: highlight.tags.emphasis,
    fontStyle: "italic"
  }, {
    tag: highlight.tags.strikethrough,
    textDecoration: "line-through"
  }, {
    tag: highlight.tags.heading,
    fontWeight: "bold",
    color: s.property
  }, {
    tag: [highlight.tags.atom, highlight.tags.bool, highlight.tags.special(highlight.tags.variableName)],
    color: s.boolean
  }, {
    tag: [highlight.tags.processingInstruction, highlight.tags.string, highlight.tags.inserted],
    color: s.string
  }, {
    tag: highlight.tags.invalid,
    color: c.fg
  }]);
}
const EditorRoot = styledComponents.styled.div`
  width: 100%;
  box-sizing: border-box;
  height: 100%;
  overflow: hidden;
  overflow: clip;
  position: relative;
  display: flex;

  & .cm-theme {
    width: 100%;
  }

  & .cm-editor {
    height: 100%;

    font-size: 16px;
    line-height: 21px;
  }

  & .cm-line {
    padding-left: ${({
  theme
}) => ui.rem(theme.sanity.space[3])};
  }

  & .cm-content {
    border-right-width: ${({
  theme
}) => ui.rem(theme.sanity.space[4])} !important;
    padding-top: ${({
  theme
}) => ui.rem(theme.sanity.space[5])};
  }
`, VisionCodeMirror = react.forwardRef((props, ref) => {
  const $ = reactCompilerRuntime.c(7), [initialValue] = react.useState(props.initialValue), sanityTheme = ui.useTheme(), theme = useCodemirrorTheme(sanityTheme), codeMirrorRef = react.useRef(null);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = (newContent) => {
    const editorView = codeMirrorRef.current?.view;
    if (!editorView)
      return;
    const currentDoc = editorView.state.doc.toString();
    newContent !== currentDoc && editorView.dispatch({
      changes: {
        from: 0,
        to: currentDoc.length,
        insert: newContent
      },
      selection: CodeMirror.EditorSelection.cursor(newContent.length)
    });
  }, $[0] = t0) : t0 = $[0];
  const resetEditorContent = t0;
  let t1, t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => ({
    resetEditorContent
  }), t2 = [resetEditorContent], $[1] = t1, $[2] = t2) : (t1 = $[1], t2 = $[2]), react.useImperativeHandle(ref, t1, t2);
  let t3;
  return $[3] !== initialValue || $[4] !== props.onChange || $[5] !== theme ? (t3 = /* @__PURE__ */ jsxRuntime.jsx(EditorRoot, { children: /* @__PURE__ */ jsxRuntime.jsx(CodeMirror__default.default, { ref: codeMirrorRef, basicSetup: !1, theme, extensions: codemirrorExtensions, value: initialValue, onChange: props.onChange }) }), $[3] = initialValue, $[4] = props.onChange, $[5] = theme, $[6] = t3) : t3 = $[6], t3;
});
VisionCodeMirror.displayName = "VisionCodeMirror";
const SUPPORTED_PERSPECTIVES = ["pinnedRelease", "raw", "published", "drafts"], VIRTUAL_PERSPECTIVES = ["pinnedRelease"];
function isSupportedPerspective(p) {
  return SUPPORTED_PERSPECTIVES.includes(p);
}
function isVirtualPerspective(maybeVirtualPerspective) {
  return typeof maybeVirtualPerspective == "string" && VIRTUAL_PERSPECTIVES.includes(maybeVirtualPerspective);
}
function hasPinnedPerspective({
  selectedPerspectiveName
}) {
  return typeof selectedPerspectiveName < "u";
}
function getActivePerspective({
  visionPerspective,
  perspectiveStack
}) {
  return visionPerspective !== "pinnedRelease" ? visionPerspective : perspectiveStack;
}
function encodeQueryString(query, params = {}, options = {}) {
  const searchParams = new URLSearchParams();
  searchParams.set("query", query);
  for (const [key, value] of Object.entries(params))
    searchParams.set(`$${key}`, JSON.stringify(value));
  for (const [key, value] of Object.entries(options))
    value && searchParams.set(key, `${value}`);
  return `?${searchParams}`;
}
function isPlainObject(obj) {
  return !!obj && typeof obj == "object" && Object.prototype.toString.call(obj) === "[object Object]";
}
const hasLocalStorage = supportsLocalStorage(), keyPrefix = "sanityVision:";
function clearLocalStorage() {
  if (hasLocalStorage)
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      key?.startsWith(keyPrefix) && localStorage.removeItem(key);
    }
}
function getLocalStorage(namespace) {
  const storageKey = `${keyPrefix}${namespace}`;
  let loadedState = null;
  return {
    get,
    set,
    merge
  };
  function get(key, defaultVal) {
    const state = ensureState();
    return typeof state[key] > "u" ? defaultVal : state[key];
  }
  function set(key, value) {
    const state = ensureState();
    return state[key] = value, localStorage.setItem(storageKey, JSON.stringify(loadedState)), value;
  }
  function merge(props) {
    const state = {
      ...ensureState(),
      ...props
    };
    return localStorage.setItem(storageKey, JSON.stringify(state)), state;
  }
  function ensureState() {
    return loadedState === null && (loadedState = loadState()), loadedState;
  }
  function loadState() {
    if (!hasLocalStorage)
      return {};
    try {
      const stored = JSON.parse(localStorage.getItem(storageKey) || "{}");
      return isPlainObject(stored) ? stored : {};
    } catch {
      return {};
    }
  }
}
function supportsLocalStorage() {
  const mod = "lsCheck";
  try {
    return localStorage.setItem(mod, mod), localStorage.removeItem(mod), !0;
  } catch {
    return !1;
  }
}
function parseApiQueryString(qs) {
  const params = {}, options = {};
  for (const [key, value] of qs.entries()) {
    if (key[0] === "$") {
      params[key.slice(1)] = JSON.parse(value);
      continue;
    }
    if (key === "perspective") {
      options[key] = value;
      continue;
    }
  }
  return {
    query: qs.get("query") || "",
    params,
    options
  };
}
function prefixApiVersion(version) {
  return version[0] !== "v" && version !== "other" ? `v${version}` : version;
}
function validateApiVersion(apiVersion) {
  const parseableApiVersion = apiVersion.replace(/^v/, "").trim().toUpperCase();
  return parseableApiVersion.length > 0 && (parseableApiVersion === "X" || parseableApiVersion === "1" || /^\d{4}-\d{2}-\d{2}$/.test(parseableApiVersion) && !isNaN(Date.parse(parseableApiVersion)));
}
function tryParseParams(val, t) {
  try {
    const parsed = val ? JSON5__default.default.parse(val) : {};
    return typeof parsed == "object" && parsed && !Array.isArray(parsed) ? parsed : {};
  } catch (err) {
    return err.message = `${t("params.error.params-invalid-json")}:

${err.message.replace("JSON5:", "")}`, err;
  }
}
const Root = styledComponents.styled(ui.Flex)`
  .sidebarPanes .Pane {
    overflow-y: auto;
    overflow-x: hidden;
  }

  & .Resizer {
    background: var(--card-border-color);
    opacity: 1;
    z-index: 1;
    box-sizing: border-box;
    background-clip: padding-box;
    border: solid transparent;
  }

  & .Resizer:hover {
    border-color: var(--card-shadow-ambient-color);
  }

  & .Resizer.horizontal {
    height: 11px;
    margin: -5px 0;
    border-width: 5px 0;
    cursor: row-resize;
    width: 100%;
    z-index: 4;
  }

  & .Resizer.vertical {
    width: 11px;
    margin: 0 -5px;
    border-width: 0 5px;
    cursor: col-resize;
    z-index: 2; /* To prevent the resizer from being hidden behind CodeMirror scroll area */
  }

  .Resizer.disabled {
    cursor: not-allowed;
  }

  .Resizer.disabled:hover {
    border-color: transparent;
  }
`;
Root.displayName = "Root";
const Header = styledComponents.styled(ui.Card)`
  border-bottom: 1px solid var(--card-border-color);
`, StyledLabel = styledComponents.styled(ui.Label)`
  flex: 1;
`, SplitpaneContainer = styledComponents.styled(ui.Box)`
  position: relative;
`, QueryCopyLink = styledComponents.styled.a`
  cursor: pointer;
  margin-right: auto;
`, InputBackgroundContainer = styledComponents.styled(ui.Box)`
  position: absolute;
  top: 1rem;
  left: 0;
  padding: 0;
  margin: 0;
  z-index: 10;
  right: 0;

  ${StyledLabel} {
    user-select: none;
  }
`, InputBackgroundContainerLeft = styledComponents.styled(InputBackgroundContainer)`
  // This is so its aligned with the gutters of CodeMirror
  left: 33px;
`, InputContainer = styledComponents.styled(ui.Card)`
  width: 100%;
  height: 100%;
  position: relative;
  flex-direction: column;
`, ResultOuterContainer = styledComponents.styled(ui.Flex)`
  height: 100%;
`, ResultInnerContainer = styledComponents.styled(ui.Box)`
  position: relative;
`, ResultContainer = styledComponents.styled(ui.Card)`
  height: 100%;
  width: 100%;
  position: absolute;
  max-width: 100%;

  ${({
  $isInvalid
}) => $isInvalid && styledComponents.css`
      &:after {
        background-color: var(--card-bg-color);
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 100%;
      }
    `}
`, Result = styledComponents.styled(ui.Box)`
  position: relative;
  width: 100%;
  height: 100%;
  z-index: 20;
`, ResultFooter = styledComponents.styled(ui.Flex)`
  border-top: 1px solid var(--card-border-color);
`, TimingsCard = styledComponents.styled(ui.Card)`
  position: relative;
`;
styledComponents.styled(ui.Box)`
  width: 100%;
  height: 100%;
`;
const TimingsTextContainer = styledComponents.styled(ui.Flex)`
  height: 100%;
  min-height: ${({
  theme
}) => ui.rem(theme.sanity.space[3] * 2 + theme.sanity.fonts.text.sizes[2].lineHeight - theme.sanity.fonts.text.sizes[2].ascenderHeight - theme.sanity.fonts.text.sizes[2].descenderHeight)};
`, DownloadsCard = styledComponents.styled(ui.Card)`
  position: relative;
`, SaveResultLabel = styledComponents.styled(ui.Text)`
  transform: initial;
  &:before,
  &:after {
    content: none;
  }
  > span {
    display: flex !important;
    gap: ${({
  theme
}) => ui.rem(theme.sanity.space[3])};
    align-items: center;
  }
`, ControlsContainer = styledComponents.styled(ui.Box)`
  border-top: 1px solid var(--card-border-color);
`, defaultValue$1 = `{
  
}`;
function ParamsEditor(props) {
  const $ = reactCompilerRuntime.c(21), {
    onChange,
    paramsError,
    hasValidParams,
    editorRef
  } = props, {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace);
  let t0;
  $[0] !== onChange ? (t0 = (newValue) => {
    onChange(newValue);
  }, $[0] = onChange, $[1] = t0) : t0 = $[1];
  const handleChangeRaw = t0;
  let t1;
  $[2] !== handleChangeRaw ? (t1 = debounce__default.default(handleChangeRaw, 333), $[2] = handleChangeRaw, $[3] = t1) : t1 = $[3];
  const handleChange = t1, t2 = hasValidParams ? "default" : "critical";
  let t3;
  $[4] !== t ? (t3 = t("params.label"), $[4] = t, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== t3 ? (t4 = /* @__PURE__ */ jsxRuntime.jsx(StyledLabel, { muted: !0, children: t3 }), $[6] = t3, $[7] = t4) : t4 = $[7];
  let t5;
  $[8] !== paramsError ? (t5 = paramsError && /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { animate: !0, placement: "top", portal: !0, content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: paramsError }), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, marginX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }) }) }), $[8] = paramsError, $[9] = t5) : t5 = $[9];
  let t6;
  $[10] !== t4 || $[11] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(InputBackgroundContainerLeft, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    t4,
    t5
  ] }) }), $[10] = t4, $[11] = t5, $[12] = t6) : t6 = $[12];
  const t7 = props.value || defaultValue$1;
  let t8;
  $[13] !== editorRef || $[14] !== handleChange || $[15] !== t7 ? (t8 = /* @__PURE__ */ jsxRuntime.jsx(VisionCodeMirror, { ref: editorRef, initialValue: t7, onChange: handleChange }), $[13] = editorRef, $[14] = handleChange, $[15] = t7, $[16] = t8) : t8 = $[16];
  let t9;
  return $[17] !== t2 || $[18] !== t6 || $[19] !== t8 ? (t9 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { flex: 1, tone: t2, "data-testid": "params-editor", children: [
    t6,
    t8
  ] }), $[17] = t2, $[18] = t6, $[19] = t8, $[20] = t9) : t9 = $[20], t9;
}
function parseParams(value, t) {
  const parsedParams = tryParseParams(value, t), params = parsedParams instanceof Error ? {} : parsedParams, validationError = parsedParams instanceof Error ? parsedParams.message : void 0;
  return {
    parsed: params,
    raw: value,
    valid: !validationError,
    error: validationError
  };
}
const STORED_QUERIES_NAMESPACE = "studio.vision-tool.saved-queries", defaultValue = {
  queries: []
}, keyValueStoreKey = STORED_QUERIES_NAMESPACE;
function useSavedQueries() {
  const keyValueStore = sanity.useKeyValueStore(), [value, setValue] = react.useState(defaultValue), [saving, setSaving] = react.useState(!1), [deleting, setDeleting] = react.useState([]), [saveQueryError, setSaveQueryError] = react.useState(), [deleteQueryError, setDeleteQueryError] = react.useState(), [error, setError] = react.useState(), queries = react.useMemo(() => keyValueStore.getKey(keyValueStoreKey), [keyValueStore]);
  react.useEffect(() => {
    const sub = queries.pipe(operators.startWith(defaultValue), operators.map((data) => data || defaultValue)).subscribe({
      next: setValue,
      error: (err) => setError(err)
    });
    return () => sub?.unsubscribe();
  }, [queries, keyValueStore]);
  const saveQuery = react.useCallback((query) => {
    setSaving(!0), setSaveQueryError(void 0);
    try {
      const newQueries = [{
        ...query,
        _key: uuid.uuid()
      }, ...value.queries];
      setValue({
        queries: newQueries
      }), keyValueStore.setKey(keyValueStoreKey, {
        queries: newQueries
      });
    } catch (err_0) {
      setSaveQueryError(err_0);
    } finally {
      setSaving(!1);
    }
  }, [keyValueStore, value.queries]), updateQuery = react.useCallback((query_0) => {
    setSaving(!0), setSaveQueryError(void 0);
    try {
      const updatedQueries = value.queries.map((q) => q._key === query_0._key ? {
        ...q,
        ...query_0
      } : q);
      setValue({
        queries: updatedQueries
      }), keyValueStore.setKey(keyValueStoreKey, {
        queries: updatedQueries
      });
    } catch (err_1) {
      setSaveQueryError(err_1);
    } finally {
      setSaving(!1);
    }
  }, [keyValueStore, value.queries]), deleteQuery = react.useCallback((key) => {
    setDeleting((prev) => [...prev, key]), setDeleteQueryError(void 0);
    try {
      const filteredQueries = value.queries.filter((q_0) => q_0._key !== key);
      setValue({
        queries: filteredQueries
      }), keyValueStore.setKey(keyValueStoreKey, {
        queries: filteredQueries
      });
    } catch (err_2) {
      setDeleteQueryError(err_2);
    } finally {
      setDeleting((prev) => prev.filter((k) => k !== key));
    }
  }, [keyValueStore, value.queries]);
  return {
    queries: value.queries,
    saveQuery,
    updateQuery,
    deleteQuery,
    saving,
    deleting,
    saveQueryError,
    deleteQueryError,
    error
  };
}
const FixedHeader = styledComponents.styled(ui.Stack)`
  position: sticky;
  top: 0;
  background: ${({
  theme
}) => theme.sanity.color.base.bg};
  z-index: 1;
`, ScrollContainer = styledComponents.styled(ui.Box)`
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;

  &::-webkit-scrollbar {
    width: 8px;
  }

  &::-webkit-scrollbar-track {
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    background: ${({
  theme
}) => theme.sanity.color.base.border};
    border-radius: 4px;
  }
`;
function QueryRecall(t0) {
  const $ = reactCompilerRuntime.c(80), {
    url,
    getStateFromUrl,
    setStateFromParsedUrl,
    currentQuery,
    currentParams,
    generateUrl
  } = t0, toast = ui.useToast(), {
    saveQuery,
    updateQuery,
    queries,
    deleteQuery,
    saving,
    saveQueryError
  } = useSavedQueries(), {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace);
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    month: "short",
    day: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
    hour12: !0
  }, $[0] = t1) : t1 = $[0];
  const formatDate = sanity.useDateTimeFormat(t1), [editingKey, setEditingKey] = react.useState(null), [editingTitle, setEditingTitle] = react.useState("");
  let t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {}, $[1] = t2) : t2 = $[1];
  const [optimisticTitles, setOptimisticTitles] = react.useState(t2), [searchQuery, setSearchQuery] = react.useState(""), [selectedUrl, setSelectedUrl] = react.useState(url);
  let t3;
  $[2] !== currentParams || $[3] !== currentQuery || $[4] !== formatDate || $[5] !== generateUrl || $[6] !== getStateFromUrl || $[7] !== queries || $[8] !== saveQuery || $[9] !== saveQueryError || $[10] !== t || $[11] !== toast ? (t3 = async () => {
    const newUrl = generateUrl(currentQuery, currentParams);
    if (queries?.some((q) => {
      const savedQueryObj = getStateFromUrl(q.url);
      return savedQueryObj && savedQueryObj.query === currentQuery && isEqual__default.default(savedQueryObj.params, currentParams);
    })) {
      const duplicateQuery = queries?.find((q_0) => {
        const savedQueryObj_0 = getStateFromUrl(q_0.url);
        return savedQueryObj_0 && savedQueryObj_0.query === currentQuery && isEqual__default.default(savedQueryObj_0.params, currentParams);
      });
      toast.push({
        closable: !0,
        status: "warning",
        title: t("save-query.already-saved"),
        description: `${duplicateQuery?.title} - ${formatDate.format(new Date(duplicateQuery?.savedAt || ""))}`
      });
      return;
    }
    newUrl && (await saveQuery({
      url: newUrl,
      savedAt: (/* @__PURE__ */ new Date()).toISOString(),
      title: "Untitled"
    }), setSelectedUrl(newUrl)), saveQueryError ? toast.push({
      closable: !0,
      status: "error",
      title: t("save-query.error"),
      description: saveQueryError.message
    }) : toast.push({
      closable: !0,
      status: "success",
      title: t("save-query.success")
    });
  }, $[2] = currentParams, $[3] = currentQuery, $[4] = formatDate, $[5] = generateUrl, $[6] = getStateFromUrl, $[7] = queries, $[8] = saveQuery, $[9] = saveQueryError, $[10] = t, $[11] = toast, $[12] = t3) : t3 = $[12];
  const handleSave = t3;
  let t4;
  $[13] !== t || $[14] !== toast || $[15] !== updateQuery ? (t4 = async (query, newTitle) => {
    setEditingKey(null), setOptimisticTitles((prev) => ({
      ...prev,
      [query._key]: newTitle
    }));
    try {
      await updateQuery({
        ...query,
        title: newTitle
      }), setOptimisticTitles((prev_1) => {
        const next_0 = {
          ...prev_1
        };
        return delete next_0[query._key], next_0;
      });
    } catch (t52) {
      const err = t52;
      setOptimisticTitles((prev_0) => {
        const next = {
          ...prev_0
        };
        return delete next[query._key], next;
      }), toast.push({
        closable: !0,
        status: "error",
        title: t("save-query.error"),
        description: err.message
      });
    }
  }, $[13] = t, $[14] = toast, $[15] = updateQuery, $[16] = t4) : t4 = $[16];
  const handleTitleSave = t4;
  let t5;
  $[17] !== currentParams || $[18] !== currentQuery || $[19] !== formatDate || $[20] !== generateUrl || $[21] !== getStateFromUrl || $[22] !== queries || $[23] !== t || $[24] !== toast || $[25] !== updateQuery ? (t5 = async (query_0) => {
    const newUrl_0 = generateUrl(currentQuery, currentParams);
    if (queries?.some((q_1) => {
      if (q_1._key === query_0._key)
        return !1;
      const savedQueryObj_1 = getStateFromUrl(q_1.url);
      return savedQueryObj_1 && savedQueryObj_1.query === currentQuery && isEqual__default.default(savedQueryObj_1.params, currentParams);
    })) {
      const duplicateQuery_0 = queries?.find((q_2) => {
        if (q_2._key === query_0._key)
          return !1;
        const savedQueryObj_2 = getStateFromUrl(q_2.url);
        return savedQueryObj_2 && savedQueryObj_2.query === currentQuery && isEqual__default.default(savedQueryObj_2.params, currentParams);
      });
      toast.push({
        closable: !0,
        status: "warning",
        title: t("save-query.already-saved"),
        description: `${duplicateQuery_0?.title} - ${formatDate.format(new Date(duplicateQuery_0?.savedAt || ""))}`
      });
      return;
    }
    try {
      await updateQuery({
        ...query_0,
        url: newUrl_0,
        savedAt: (/* @__PURE__ */ new Date()).toISOString()
      }), setSelectedUrl(newUrl_0), toast.push({
        closable: !0,
        status: "success",
        title: t("save-query.success")
      });
    } catch (t62) {
      const err_0 = t62;
      toast.push({
        closable: !0,
        status: "error",
        title: t("save-query.error"),
        description: err_0.message
      });
    }
  }, $[17] = currentParams, $[18] = currentQuery, $[19] = formatDate, $[20] = generateUrl, $[21] = getStateFromUrl, $[22] = queries, $[23] = t, $[24] = toast, $[25] = updateQuery, $[26] = t5) : t5 = $[26];
  const handleUpdate = t5;
  let T0, T1, t6, t7, t8;
  if ($[27] !== currentParams || $[28] !== currentQuery || $[29] !== deleteQuery || $[30] !== editingKey || $[31] !== editingTitle || $[32] !== formatDate || $[33] !== getStateFromUrl || $[34] !== handleSave || $[35] !== handleTitleSave || $[36] !== handleUpdate || $[37] !== optimisticTitles || $[38] !== queries || $[39] !== saving || $[40] !== searchQuery || $[41] !== selectedUrl || $[42] !== setStateFromParsedUrl || $[43] !== t) {
    const filteredQueries = queries?.filter((q_3) => q_3?.title?.toLowerCase().includes(searchQuery.toLowerCase()));
    T1 = ScrollContainer;
    let t92;
    $[49] === Symbol.for("react.memo_cache_sentinel") ? (t92 = {
      textTransform: "capitalize"
    }, $[49] = t92) : t92 = $[49];
    let t102;
    $[50] !== t ? (t102 = t("label.saved-queries"), $[50] = t, $[51] = t102) : t102 = $[51];
    let t11;
    $[52] !== t102 ? (t11 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "semibold", style: t92, size: 4, children: t102 }), $[52] = t102, $[53] = t11) : t11 = $[53];
    let t12;
    $[54] !== t ? (t12 = t("action.save-query"), $[54] = t, $[55] = t12) : t12 = $[55];
    let t13;
    $[56] !== handleSave || $[57] !== saving || $[58] !== t12 ? (t13 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { label: t12, icon: icons.AddIcon, disabled: saving, onClick: handleSave, mode: "bleed" }), $[56] = handleSave, $[57] = saving, $[58] = t12, $[59] = t13) : t13 = $[59];
    let t14;
    $[60] !== t11 || $[61] !== t13 ? (t14 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 3, paddingTop: 4, paddingBottom: 0, justify: "space-between", align: "center", children: [
      t11,
      t13
    ] }), $[60] = t11, $[61] = t13, $[62] = t14) : t14 = $[62];
    let t15;
    $[63] !== t ? (t15 = t("label.search-queries"), $[63] = t, $[64] = t15) : t15 = $[64];
    let t16;
    $[65] === Symbol.for("react.memo_cache_sentinel") ? (t16 = (event) => setSearchQuery(event.currentTarget.value), $[65] = t16) : t16 = $[65];
    let t17;
    $[66] !== searchQuery || $[67] !== t15 ? (t17 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, paddingTop: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { placeholder: t15, icon: icons.SearchIcon, value: searchQuery, onChange: t16 }) }), $[66] = searchQuery, $[67] = t15, $[68] = t17) : t17 = $[68], $[69] !== t14 || $[70] !== t17 ? (t8 = /* @__PURE__ */ jsxRuntime.jsxs(FixedHeader, { space: 3, children: [
      t14,
      t17
    ] }), $[69] = t14, $[70] = t17, $[71] = t8) : t8 = $[71], T0 = ui.Stack, t6 = 3, t7 = filteredQueries?.map((q_4) => {
      const queryObj = getStateFromUrl(q_4.url), isSelected = selectedUrl === q_4.url, areQueriesEqual = queryObj && currentQuery === queryObj.query && isEqual__default.default(currentParams, queryObj.params), isEdited = isSelected && !areQueriesEqual;
      return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { width: "fill", padding: 4, border: !0, tone: isSelected ? "positive" : "default", onClick: () => {
        setSelectedUrl(q_4.url);
        const parsedUrl = getStateFromUrl(q_4.url);
        parsedUrl && setStateFromParsedUrl(parsedUrl);
      }, style: {
        position: "relative"
      }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "space-between", align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, paddingRight: 1, children: [
            editingKey === q_4._key ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { value: editingTitle, onChange: (event_0) => setEditingTitle(event_0.currentTarget.value), onKeyDown: (event_1) => {
              event_1.key === "Enter" ? handleTitleSave(q_4, editingTitle) : event_1.key === "Escape" && setEditingKey(null);
            }, onBlur: () => handleTitleSave(q_4, editingTitle), autoFocus: !0, style: {
              maxWidth: "170px",
              height: "24px"
            } }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "bold", size: 3, textOverflow: "ellipsis", style: {
              maxWidth: "170px",
              cursor: "pointer",
              padding: "4px 0"
            }, title: optimisticTitles[q_4._key] || q_4.title || q_4._key.slice(q_4._key.length - 5, q_4._key.length), onClick: () => {
              setEditingKey(q_4._key), setEditingTitle(q_4.title || q_4._key.slice(0, 5));
            }, children: optimisticTitles[q_4._key] || q_4.title || q_4._key.slice(q_4._key.length - 5, q_4._key.length) }),
            isEdited && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: {
              width: "6px",
              height: "6px",
              borderRadius: "50%",
              backgroundColor: "var(--card-focus-ring-color)"
            } })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuButton, { button: /* @__PURE__ */ jsxRuntime.jsx(sanity.ContextMenuButton, {}), id: `${q_4._key}-menu`, menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { tone: "critical", padding: 3, icon: icons.TrashIcon, text: t("action.delete"), onClick: (event_2) => {
            event_2.stopPropagation(), deleteQuery(q_4._key);
          } }) }), popover: {
            portal: !0,
            placement: "bottom-end",
            tone: "default"
          } })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { muted: !0, children: queryObj?.query.split("{")[0] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formatDate.format(new Date(q_4.savedAt || "")) }) }),
        isEdited && /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { mode: "ghost", tone: "default", size: 1, padding: 2, style: {
          height: "24px",
          position: "absolute",
          right: "16px",
          bottom: "16px",
          fontSize: "12px"
        }, text: t("action.update"), onClick: (e) => {
          e.stopPropagation(), handleUpdate(q_4);
        } })
      ] }) }, q_4._key);
    }), $[27] = currentParams, $[28] = currentQuery, $[29] = deleteQuery, $[30] = editingKey, $[31] = editingTitle, $[32] = formatDate, $[33] = getStateFromUrl, $[34] = handleSave, $[35] = handleTitleSave, $[36] = handleUpdate, $[37] = optimisticTitles, $[38] = queries, $[39] = saving, $[40] = searchQuery, $[41] = selectedUrl, $[42] = setStateFromParsedUrl, $[43] = t, $[44] = T0, $[45] = T1, $[46] = t6, $[47] = t7, $[48] = t8;
  } else
    T0 = $[44], T1 = $[45], t6 = $[46], t7 = $[47], t8 = $[48];
  let t9;
  $[72] !== T0 || $[73] !== t6 || $[74] !== t7 ? (t9 = /* @__PURE__ */ jsxRuntime.jsx(T0, { paddingY: t6, children: t7 }), $[72] = T0, $[73] = t6, $[74] = t7, $[75] = t9) : t9 = $[75];
  let t10;
  return $[76] !== T1 || $[77] !== t8 || $[78] !== t9 ? (t10 = /* @__PURE__ */ jsxRuntime.jsxs(T1, { children: [
    t8,
    t9
  ] }), $[76] = T1, $[77] = t8, $[78] = t9, $[79] = t10) : t10 = $[79], t10;
}
function narrowBreakpoint() {
  return typeof window < "u" && window.innerWidth > 600;
}
function calculatePaneSizeOptions(height) {
  let rootHeight = height;
  return rootHeight || (rootHeight = typeof window < "u" && typeof document < "u" ? document.body.getBoundingClientRect().height - 60 : 0), {
    defaultSize: rootHeight / (narrowBreakpoint() ? 2 : 1),
    size: rootHeight > 550 ? void 0 : rootHeight * 0.4,
    allowResize: rootHeight > 550,
    minSize: Math.min(170, Math.max(170, rootHeight / 2)),
    maxSize: rootHeight > 650 ? rootHeight * 0.7 : rootHeight * 0.6
  };
}
function usePaneSize(t0) {
  const $ = reactCompilerRuntime.c(6), {
    visionRootRef
  } = t0, [isNarrowBreakpoint, setIsNarrowBreakpoint] = react.useState(_temp$3), [paneSizeOptions, setPaneSizeOptions] = react.useState(_temp2$2);
  let t1, t2;
  $[0] !== visionRootRef ? (t1 = () => {
    if (!visionRootRef.current)
      return;
    const handleResize = (entries) => {
      setIsNarrowBreakpoint(narrowBreakpoint());
      const entry = entries?.[0];
      entry && setPaneSizeOptions(calculatePaneSizeOptions(entry.contentRect.height));
    }, resizeObserver = new ResizeObserver(handleResize);
    return resizeObserver.observe(visionRootRef.current), () => {
      resizeObserver.disconnect();
    };
  }, t2 = [visionRootRef], $[0] = visionRootRef, $[1] = t1, $[2] = t2) : (t1 = $[1], t2 = $[2]), react.useEffect(t1, t2);
  let t3;
  return $[3] !== isNarrowBreakpoint || $[4] !== paneSizeOptions ? (t3 = {
    paneSizeOptions,
    isNarrowBreakpoint
  }, $[3] = isNarrowBreakpoint, $[4] = paneSizeOptions, $[5] = t3) : t3 = $[5], t3;
}
function _temp2$2() {
  return calculatePaneSizeOptions(void 0);
}
function _temp$3() {
  return narrowBreakpoint();
}
function VisionGuiControls(t0) {
  const $ = reactCompilerRuntime.c(30), {
    hasValidParams,
    listenInProgress,
    queryInProgress,
    onQueryExecution,
    onListenExecution
  } = t0, {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace);
  let t1;
  $[0] !== t ? (t1 = t("params.error.params-invalid-json"), $[0] = t, $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== t1 ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t1 }) }), $[2] = t1, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] === Symbol.for("react.memo_cache_sentinel") ? (t3 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Hotkeys, { keys: ["Ctrl", "Enter"] }) }), $[4] = t3) : t3 = $[4];
  const t4 = queryInProgress ? icons.StopIcon : icons.PlayIcon, t5 = listenInProgress || !hasValidParams, t6 = queryInProgress ? "positive" : "primary";
  let t7;
  $[5] !== queryInProgress || $[6] !== t ? (t7 = t(queryInProgress ? "action.query-cancel" : "action.query-execute"), $[5] = queryInProgress, $[6] = t, $[7] = t7) : t7 = $[7];
  let t8;
  $[8] !== onQueryExecution || $[9] !== t4 || $[10] !== t5 || $[11] !== t6 || $[12] !== t7 ? (t8 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { content: t3, placement: "top", portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { width: "fill", onClick: onQueryExecution, type: "button", icon: t4, disabled: t5, tone: t6, text: t7 }) }) }), $[8] = onQueryExecution, $[9] = t4, $[10] = t5, $[11] = t6, $[12] = t7, $[13] = t8) : t8 = $[13];
  const t9 = listenInProgress ? icons.StopIcon : icons.PlayIcon;
  let t10;
  $[14] !== listenInProgress || $[15] !== t ? (t10 = t(listenInProgress ? "action.listen-cancel" : "action.listen-execute"), $[14] = listenInProgress, $[15] = t, $[16] = t10) : t10 = $[16];
  const t11 = !hasValidParams, t12 = listenInProgress ? "positive" : "default";
  let t13;
  $[17] !== onListenExecution || $[18] !== t10 || $[19] !== t11 || $[20] !== t12 || $[21] !== t9 ? (t13 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { width: "fill", onClick: onListenExecution, type: "button", icon: t9, text: t10, mode: "ghost", disabled: t11, tone: t12 }) }), $[17] = onListenExecution, $[18] = t10, $[19] = t11, $[20] = t12, $[21] = t9, $[22] = t13) : t13 = $[22];
  let t14;
  $[23] !== t13 || $[24] !== t8 ? (t14 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "space-evenly", children: [
    t8,
    t13
  ] }), $[23] = t13, $[24] = t8, $[25] = t14) : t14 = $[25];
  let t15;
  return $[26] !== hasValidParams || $[27] !== t14 || $[28] !== t2 ? (t15 = /* @__PURE__ */ jsxRuntime.jsx(ControlsContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, paddingX: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { content: t2, placement: "top", disabled: hasValidParams, portal: !0, children: t14 }) }) }), $[26] = hasValidParams, $[27] = t14, $[28] = t2, $[29] = t15) : t15 = $[29], t15;
}
const PerspectivePopoverContent = styledComponents.styled(ui.Box)`
  /* This limits the width of the popover content */
  max-width: 240px;
`, PerspectivePopoverLink = styledComponents.styled.a`
  cursor: pointer;
  margin-right: auto;
`, Dot = styledComponents.styled.div`
  width: 4px;
  height: 4px;
  border-radius: 3px;
  box-shadow: 0 0 0 1px var(--card-bg-color);
  background-color: ${({
  $tone
}) => `var(--card-badge-${$tone}-dot-color)`};
`;
function PerspectivePopover() {
  const $ = reactCompilerRuntime.c(39), [open, setOpen] = react.useState(!1), buttonRef = react.useRef(null), popoverRef = react.useRef(null);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => setOpen(_temp$2), $[0] = t0) : t0 = $[0];
  const handleClick = t0, {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace);
  let t1, t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => setOpen(!1), t2 = () => [buttonRef.current, popoverRef.current], $[1] = t1, $[2] = t2) : (t1 = $[1], t2 = $[2]), ui.useClickOutsideEvent(t1, t2);
  let t3;
  $[3] !== t ? (t3 = t("settings.perspectives.title"), $[3] = t, $[4] = t3) : t3 = $[4];
  let t4;
  $[5] !== t3 ? (t4 = /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: t3 }) }), $[5] = t3, $[6] = t4) : t4 = $[6];
  let t5;
  $[7] !== t ? (t5 = t("settings.perspectives.description"), $[7] = t, $[8] = t5) : t5 = $[8];
  let t6;
  $[9] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: t5 }) }), $[9] = t5, $[10] = t6) : t6 = $[10];
  let t7;
  $[11] !== t ? (t7 = t("label.new"), $[11] = t, $[12] = t7) : t7 = $[12];
  let t8;
  $[13] !== t7 ? (t8 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { tone: "primary", children: t7 }) }), $[13] = t7, $[14] = t8) : t8 = $[14];
  let t9;
  $[15] !== t ? (t9 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.Translate, { t, i18nKey: "settings.perspective.preview-drafts-renamed-to-drafts.description" }) }), $[15] = t, $[16] = t9) : t9 = $[16];
  let t10;
  $[17] !== t8 || $[18] !== t9 ? (t10 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    t8,
    t9
  ] }) }), $[17] = t8, $[18] = t9, $[19] = t10) : t10 = $[19];
  let t11;
  $[20] !== t ? (t11 = null, $[20] = t, $[21] = t11) : t11 = $[21];
  let t12;
  $[22] !== t ? (t12 = t("settings.perspectives.action.docs-link"), $[22] = t, $[23] = t12) : t12 = $[23];
  let t13;
  $[24] !== t12 ? (t13 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsxs(PerspectivePopoverLink, { href: "https://sanity.io/docs/perspectives", target: "_blank", children: [
    t12,
    " \u2192"
  ] }) }) }), $[24] = t12, $[25] = t13) : t13 = $[25];
  let t14;
  $[26] !== t10 || $[27] !== t11 || $[28] !== t13 || $[29] !== t4 || $[30] !== t6 ? (t14 = /* @__PURE__ */ jsxRuntime.jsx(PerspectivePopoverContent, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    t4,
    t6,
    t10,
    t11,
    t13
  ] }) }), $[26] = t10, $[27] = t11, $[28] = t13, $[29] = t4, $[30] = t6, $[31] = t14) : t14 = $[31];
  let t15;
  $[32] === Symbol.for("react.memo_cache_sentinel") ? (t15 = /* @__PURE__ */ jsxRuntime.jsx(Dot, { $tone: "primary" }), $[32] = t15) : t15 = $[32];
  let t16;
  $[33] !== open ? (t16 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { icon: icons.HelpCircleIcon, mode: "bleed", padding: 2, paddingRight: 1, tone: "primary", fontSize: 1, ref: buttonRef, onClick: handleClick, selected: open, children: t15 }), $[33] = open, $[34] = t16) : t16 = $[34];
  let t17;
  return $[35] !== open || $[36] !== t14 || $[37] !== t16 ? (t17 = /* @__PURE__ */ jsxRuntime.jsx(ui.Popover, { content: t14, placement: "bottom-start", portal: !0, padding: 3, ref: popoverRef, open, children: t16 }), $[35] = open, $[36] = t14, $[37] = t16, $[38] = t17) : t17 = $[38], t17;
}
function _temp$2(o) {
  return !o;
}
const PinnedReleasePerspectiveOption = (t0) => {
  const $ = reactCompilerRuntime.c(9), {
    pinnedPerspective,
    t
  } = t0, name = typeof pinnedPerspective.selectedPerspective == "object" ? pinnedPerspective.selectedPerspective.metadata.title : pinnedPerspective.selectedPerspectiveName;
  let t1;
  $[0] !== pinnedPerspective || $[1] !== t ? (t1 = hasPinnedPerspective(pinnedPerspective) ? `(${t("settings.perspectives.pinned-release-label")})` : t("settings.perspectives.pinned-release-label"), $[0] = pinnedPerspective, $[1] = t, $[2] = t1) : t1 = $[2];
  const label = t1;
  let t2;
  $[3] !== label || $[4] !== name ? (t2 = [name, label].filter(_temp$1), $[3] = label, $[4] = name, $[5] = t2) : t2 = $[5];
  const text = t2.join(" "), t3 = !hasPinnedPerspective(pinnedPerspective);
  let t4;
  return $[6] !== t3 || $[7] !== text ? (t4 = /* @__PURE__ */ jsxRuntime.jsx("option", { value: "pinnedRelease", disabled: t3, children: text }), $[6] = t3, $[7] = text, $[8] = t4) : t4 = $[8], t4;
};
function VisionGuiHeader(t0) {
  const $ = reactCompilerRuntime.c(64), {
    onChangeDataset,
    dataset,
    customApiVersion,
    apiVersion,
    onChangeApiVersion,
    datasets,
    customApiVersionElementRef,
    onCustomApiVersionChange,
    isValidApiVersion,
    onChangePerspective,
    url,
    perspective
  } = t0, pinnedPerspective = sanity.usePerspective(), {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace), operationUrlElement = react.useRef(null);
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => {
    const el = operationUrlElement.current;
    if (el)
      try {
        el.select(), document.execCommand("copy");
      } catch {
        console.error("Unable to copy to clipboard :(");
      }
  }, $[0] = t1) : t1 = $[0];
  const handleCopyUrl = t1;
  let t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [1, 4, 8, 12], $[1] = t2) : t2 = $[1];
  let t3;
  $[2] !== t ? (t3 = t("settings.dataset-label"), $[2] = t, $[3] = t3) : t3 = $[3];
  let t4;
  $[4] !== t3 ? (t4 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(StyledLabel, { children: t3 }) }), $[4] = t3, $[5] = t4) : t4 = $[5];
  let t5;
  $[6] !== datasets ? (t5 = datasets.map(_temp2$1), $[6] = datasets, $[7] = t5) : t5 = $[7];
  let t6;
  $[8] !== dataset || $[9] !== onChangeDataset || $[10] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(ui.Select, { value: dataset, onChange: onChangeDataset, children: t5 }), $[8] = dataset, $[9] = onChangeDataset, $[10] = t5, $[11] = t6) : t6 = $[11];
  let t7;
  $[12] !== t4 || $[13] !== t6 ? (t7 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
    t4,
    t6
  ] }) }), $[12] = t4, $[13] = t6, $[14] = t7) : t7 = $[14];
  let t8;
  $[15] !== t ? (t8 = t("settings.api-version-label"), $[15] = t, $[16] = t8) : t8 = $[16];
  let t9;
  $[17] !== t8 ? (t9 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(StyledLabel, { children: t8 }) }), $[17] = t8, $[18] = t9) : t9 = $[18];
  const t10 = customApiVersion === !1 ? apiVersion : "other";
  let t11;
  $[19] === Symbol.for("react.memo_cache_sentinel") ? (t11 = API_VERSIONS.map(_temp3$1), $[19] = t11) : t11 = $[19];
  let t12;
  $[20] !== t ? (t12 = t("settings.other-api-version-label"), $[20] = t, $[21] = t12) : t12 = $[21];
  let t13;
  $[22] !== t12 ? (t13 = /* @__PURE__ */ jsxRuntime.jsx("option", { value: "other", children: t12 }, "other"), $[22] = t12, $[23] = t13) : t13 = $[23];
  let t14;
  $[24] !== onChangeApiVersion || $[25] !== t10 || $[26] !== t13 ? (t14 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Select, { "data-testid": "api-version-selector", value: t10, onChange: onChangeApiVersion, children: [
    t11,
    t13
  ] }), $[24] = onChangeApiVersion, $[25] = t10, $[26] = t13, $[27] = t14) : t14 = $[27];
  let t15;
  $[28] !== t14 || $[29] !== t9 ? (t15 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
    t9,
    t14
  ] }) }), $[28] = t14, $[29] = t9, $[30] = t15) : t15 = $[30];
  let t16;
  $[31] !== customApiVersion || $[32] !== customApiVersionElementRef || $[33] !== isValidApiVersion || $[34] !== onCustomApiVersionChange || $[35] !== t ? (t16 = customApiVersion !== !1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(StyledLabel, { textOverflow: "ellipsis", children: t("settings.custom-api-version-label") }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ref: customApiVersionElementRef, value: customApiVersion, onChange: onCustomApiVersionChange, customValidity: isValidApiVersion ? void 0 : t("settings.error.invalid-api-version"), maxLength: 11 })
  ] }) }), $[31] = customApiVersion, $[32] = customApiVersionElementRef, $[33] = isValidApiVersion, $[34] = onCustomApiVersionChange, $[35] = t, $[36] = t16) : t16 = $[36];
  let t17;
  $[37] !== t ? (t17 = t("settings.perspective-label"), $[37] = t, $[38] = t17) : t17 = $[38];
  let t18;
  $[39] !== t17 ? (t18 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(StyledLabel, { children: t17 }) }), $[39] = t17, $[40] = t18) : t18 = $[40];
  let t19;
  $[41] === Symbol.for("react.memo_cache_sentinel") ? (t19 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(PerspectivePopover, {}) }), $[41] = t19) : t19 = $[41];
  let t20;
  $[42] !== t18 ? (t20 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 1, children: [
    t18,
    t19
  ] }) }), $[42] = t18, $[43] = t20) : t20 = $[43];
  const t21 = perspective || "default";
  let t22;
  $[44] !== pinnedPerspective || $[45] !== t ? (t22 = SUPPORTED_PERSPECTIVES.map((perspectiveName) => perspectiveName === "pinnedRelease" ? /* @__PURE__ */ jsxRuntime.jsxs(react.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(PinnedReleasePerspectiveOption, { pinnedPerspective, t }),
    /* @__PURE__ */ jsxRuntime.jsx("option", { value: "default", children: t("settings.perspectives.default") }, "default"),
    /* @__PURE__ */ jsxRuntime.jsx("hr", {})
  ] }, "pinnedRelease") : /* @__PURE__ */ jsxRuntime.jsx("option", { children: perspectiveName }, perspectiveName)), $[44] = pinnedPerspective, $[45] = t, $[46] = t22) : t22 = $[46];
  let t23;
  $[47] !== onChangePerspective || $[48] !== t21 || $[49] !== t22 ? (t23 = /* @__PURE__ */ jsxRuntime.jsx(ui.Select, { value: t21, onChange: onChangePerspective, children: t22 }), $[47] = onChangePerspective, $[48] = t21, $[49] = t22, $[50] = t23) : t23 = $[50];
  let t24;
  $[51] !== t20 || $[52] !== t23 ? (t24 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
    t20,
    t23
  ] }) }), $[51] = t20, $[52] = t23, $[53] = t24) : t24 = $[53];
  let t25;
  $[54] !== customApiVersion || $[55] !== t || $[56] !== url ? (t25 = typeof url == "string" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, flex: 1, column: customApiVersion === !1 ? 6 : 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(StyledLabel, { children: [
      t("query.url"),
      "\xA0",
      /* @__PURE__ */ jsxRuntime.jsxs(QueryCopyLink, { onClick: handleCopyUrl, children: [
        "[",
        t("action.copy-url-to-clipboard"),
        "]"
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, gap: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { readOnly: !0, type: "url", ref: operationUrlElement, value: url }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { content: t("action.copy-url-to-clipboard"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { "aria-label": t("action.copy-url-to-clipboard"), type: "button", mode: "ghost", icon: icons.CopyIcon, onClick: handleCopyUrl }) })
    ] })
  ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1 }), $[54] = customApiVersion, $[55] = t, $[56] = url, $[57] = t25) : t25 = $[57];
  let t26;
  return $[58] !== t15 || $[59] !== t16 || $[60] !== t24 || $[61] !== t25 || $[62] !== t7 ? (t26 = /* @__PURE__ */ jsxRuntime.jsx(Header, { paddingX: 3, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: t2, children: [
    t7,
    t15,
    t16,
    t24,
    t25
  ] }) }), $[58] = t15, $[59] = t16, $[60] = t24, $[61] = t25, $[62] = t7, $[63] = t26) : t26 = $[63], t26;
}
function _temp3$1(version) {
  return /* @__PURE__ */ jsxRuntime.jsx("option", { children: version }, version);
}
function _temp2$1(ds) {
  return /* @__PURE__ */ jsxRuntime.jsx("option", { children: ds }, ds);
}
function _temp$1(value) {
  return typeof value < "u";
}
function getBlobUrl(content, mimeType) {
  return URL.createObjectURL(new Blob([content], {
    type: mimeType
  }));
}
function getMemoizedBlobUrlResolver(mimeType, stringEncoder) {
  return /* @__PURE__ */ (() => {
    let prevResult = "", prevContent = "";
    return (input) => {
      const content = stringEncoder(input);
      if (!(typeof content != "string" || content === ""))
        return content === prevContent || (prevContent = content, prevResult && URL.revokeObjectURL(prevResult), prevResult = getBlobUrl(content, mimeType)), prevResult;
    };
  })();
}
const getJsonBlobUrl = getMemoizedBlobUrlResolver("application/json", (input) => JSON.stringify(input, null, 2)), getCsvBlobUrl = getMemoizedBlobUrlResolver("text/csv", (input) => json2Csv.json2csv(Array.isArray(input) ? input : [input]).trim()), ErrorCode = styledComponents.styled(ui.Code)`
  color: ${({
  theme
}) => theme.sanity.color.muted.critical.enabled.fg};
`;
function QueryErrorDetails(t0) {
  const $ = reactCompilerRuntime.c(7), {
    error
  } = t0, {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace);
  if (!("details" in error))
    return null;
  const details = {
    ...error.details,
    ...mapToLegacyDetails(error.details)
  };
  if (!details.line)
    return null;
  const t1 = `${details.line}
${dashLine(details.column, details.columnEnd)}`;
  let t2;
  $[0] !== t1 ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(ErrorCode, { size: 1, children: t1 }), $[0] = t1, $[1] = t2) : t2 = $[1];
  const t3 = `${t("query.error.line")}:   ${details.lineNumber}
${t("query.error.column")}: ${details.column}`;
  let t4;
  $[2] !== t3 ? (t4 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ErrorCode, { size: 1, children: t3 }) }), $[2] = t3, $[3] = t4) : t4 = $[3];
  let t5;
  return $[4] !== t2 || $[5] !== t4 ? (t5 = /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
    t2,
    t4
  ] }), $[4] = t2, $[5] = t4, $[6] = t5) : t5 = $[6], t5;
}
function mapToLegacyDetails(details) {
  if (!details || typeof details.query != "string" || typeof details.start != "number")
    return {};
  const {
    query,
    start,
    end
  } = details, lineStart = query.slice(0, start).lastIndexOf(`
`) + 1, lineNumber = (query.slice(0, lineStart).match(/\n/g) || []).length, line = query.slice(lineStart, query.indexOf(`
`, lineStart)), column = start - lineStart, columnEnd = typeof end == "number" ? end - lineStart : void 0;
  return {
    line,
    lineNumber,
    column,
    columnEnd
  };
}
function dashLine(column, columnEnd) {
  const line = "-".repeat(column), hats = "^".repeat(columnEnd ? columnEnd - column : 1);
  return `${line}${hats}`;
}
function QueryErrorDialog(props) {
  const $ = reactCompilerRuntime.c(7);
  let t0;
  $[0] !== props.error.message ? (t0 = /* @__PURE__ */ jsxRuntime.jsx(ErrorCode, { size: 1, children: props.error.message }), $[0] = props.error.message, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== props.error ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(QueryErrorDetails, { error: props.error }), $[2] = props.error, $[3] = t1) : t1 = $[3];
  let t2;
  return $[4] !== t0 || $[5] !== t1 ? (t2 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, marginTop: 2, children: [
    t0,
    t1
  ] }), $[4] = t0, $[5] = t1, $[6] = t2) : t2 = $[6], t2;
}
const ResultViewWrapper = styledComponents.styled.div(({
  theme
}) => {
  const {
    color: color2,
    fonts,
    space
  } = theme.sanity;
  return styledComponents.css`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[2].fontSize}px;
      line-height: ${fonts.code.sizes[2].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${ui.rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${ui.rem(space[0])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: '▸ ';
      margin-left: calc(0px - ${ui.rem(space[4])});
      font-size: ${fonts.code.sizes[2].fontSize}px;
      line-height: ${fonts.code.sizes[2].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: '▾ ';
      font-size: ${fonts.code.sizes[2].fontSize}px;
      line-height: ${fonts.code.sizes[2].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${ui.rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color2.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color2.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${ui.rem(space[2])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color2.syntax.string};
      word-break: break-word;
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color2.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color2.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: '↔';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
}), lru = new LRU__default.default({
  maxSize: 5e4
});
function ResultView(props) {
  const $ = reactCompilerRuntime.c(7), {
    data,
    datasetName
  } = props, workspaceDataset = sanity.useDataset();
  if (isRecord(data) || Array.isArray(data)) {
    const t02 = workspaceDataset === datasetName ? DocumentEditLabel : void 0;
    let t12;
    return $[0] !== data || $[1] !== t02 ? (t12 = /* @__PURE__ */ jsxRuntime.jsx(ResultViewWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(reactJsonInspector.JsonInspector, { data, search: !1, isExpanded, onClick: toggleExpanded, interactiveLabel: t02 }) }), $[0] = data, $[1] = t02, $[2] = t12) : t12 = $[2], t12;
  }
  let t0;
  $[3] !== data ? (t0 = JSON.stringify(data), $[3] = data, $[4] = t0) : t0 = $[4];
  let t1;
  return $[5] !== t0 ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", children: t0 }), $[5] = t0, $[6] = t1) : t1 = $[6], t1;
}
function DocumentEditLabel(props) {
  const $ = reactCompilerRuntime.c(5);
  if (props.isKey || !props.keypath.endsWith("_id") && !props.keypath.endsWith("_ref"))
    return null;
  let t0;
  $[0] !== props.value ? (t0 = {
    id: props.value
  }, $[0] = props.value, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(icons.LinkIcon, {}), $[2] = t1) : t1 = $[2];
  let t2;
  return $[3] !== t0 ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(router.IntentLink, { intent: "edit", params: t0, children: t1 }), $[3] = t0, $[4] = t2) : t2 = $[4], t2;
}
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  if (typeof cached == "boolean")
    return cached;
  const segments = keyPath.split(".", 4);
  return segments.length === 4 ? !1 : Array.isArray(value) ? !0 : isRecord(value) && !segments.some((key) => isArrayKeyOverLimit(key));
}
function toggleExpanded(event) {
  const {
    path
  } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function isRecord(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
const numeric = /^\d+$/;
function isArrayKeyOverLimit(segment, limit = 10) {
  return numeric.test(segment) && parseInt(segment, 10) > limit;
}
function preventSave(evt) {
  return evt.preventDefault();
}
function SaveCsvButton(t0) {
  const $ = reactCompilerRuntime.c(9), {
    blobUrl
  } = t0, {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace), isDisabled = !blobUrl, t1 = isDisabled ? void 0 : "query-result.csv", t2 = isDisabled ? preventSave : void 0;
  let t3;
  $[0] !== blobUrl || $[1] !== isDisabled || $[2] !== t1 || $[3] !== t2 ? (t3 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { as: "a", disabled: isDisabled, download: t1, href: blobUrl, icon: icons.DocumentSheetIcon, mode: "ghost", onClick: t2, text: "CSV", tone: "default" }), $[0] = blobUrl, $[1] = isDisabled, $[2] = t1, $[3] = t2, $[4] = t3) : t3 = $[4];
  const button = t3;
  let t4;
  return $[5] !== button || $[6] !== isDisabled || $[7] !== t ? (t4 = isDisabled ? /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { content: t("result.save-result-as-csv.not-csv-encodable"), placement: "top", children: button }) : button, $[5] = button, $[6] = isDisabled, $[7] = t, $[8] = t4) : t4 = $[8], t4;
}
function SaveJsonButton(t0) {
  const $ = reactCompilerRuntime.c(2), {
    blobUrl
  } = t0;
  let t1;
  return $[0] !== blobUrl ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { as: "a", download: "query-result.json", href: blobUrl, icon: icons.DocumentSheetIcon, mode: "ghost", text: "JSON", tone: "default" }), $[0] = blobUrl, $[1] = t1) : t1 = $[1], t1;
}
function VisionGuiResult(t0) {
  const $ = reactCompilerRuntime.c(67), {
    error,
    queryInProgress,
    queryResult,
    listenInProgress,
    listenMutations,
    dataset,
    queryTime,
    e2eTime
  } = t0, {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace), hasResult = !error && !queryInProgress && typeof queryResult < "u";
  let t1;
  $[0] !== hasResult || $[1] !== queryResult ? (t1 = hasResult ? getJsonBlobUrl(queryResult) : "", $[0] = hasResult, $[1] = queryResult, $[2] = t1) : t1 = $[2];
  const jsonUrl = t1;
  let t2;
  $[3] !== hasResult || $[4] !== queryResult ? (t2 = hasResult ? getCsvBlobUrl(queryResult) : "", $[3] = hasResult, $[4] = queryResult, $[5] = t2) : t2 = $[5];
  const csvUrl = t2, t3 = error ? "critical" : "default", t4 = !!error;
  let t5;
  $[6] !== t ? (t5 = t("result.label"), $[6] = t, $[7] = t5) : t5 = $[7];
  let t6;
  $[8] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(InputBackgroundContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsx(StyledLabel, { muted: !0, children: t5 }) }) }), $[8] = t5, $[9] = t6) : t6 = $[9];
  let t7;
  $[10] !== listenInProgress || $[11] !== listenMutations || $[12] !== queryInProgress ? (t7 = (queryInProgress || listenInProgress && listenMutations.length === 0) && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(DelayedSpinner, {}) }), $[10] = listenInProgress, $[11] = listenMutations, $[12] = queryInProgress, $[13] = t7) : t7 = $[13];
  let t8;
  $[14] !== error ? (t8 = error && /* @__PURE__ */ jsxRuntime.jsx(QueryErrorDialog, { error }), $[14] = error, $[15] = t8) : t8 = $[15];
  let t9;
  $[16] !== dataset || $[17] !== hasResult || $[18] !== queryResult ? (t9 = hasResult && /* @__PURE__ */ jsxRuntime.jsx(ResultView, { data: queryResult, datasetName: dataset }), $[16] = dataset, $[17] = hasResult, $[18] = queryResult, $[19] = t9) : t9 = $[19];
  let t10;
  $[20] !== dataset || $[21] !== listenInProgress || $[22] !== listenMutations ? (t10 = listenInProgress && listenMutations.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ResultView, { data: listenMutations, datasetName: dataset }), $[20] = dataset, $[21] = listenInProgress, $[22] = listenMutations, $[23] = t10) : t10 = $[23];
  let t11;
  $[24] !== t10 || $[25] !== t7 || $[26] !== t8 || $[27] !== t9 ? (t11 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 3, paddingTop: 5, children: [
    t7,
    t8,
    t9,
    t10
  ] }), $[24] = t10, $[25] = t7, $[26] = t8, $[27] = t9, $[28] = t11) : t11 = $[28];
  let t12;
  $[29] !== t11 || $[30] !== t6 ? (t12 = /* @__PURE__ */ jsxRuntime.jsxs(Result, { overflow: "auto", children: [
    t6,
    t11
  ] }), $[29] = t11, $[30] = t6, $[31] = t12) : t12 = $[31];
  let t13;
  $[32] !== t12 || $[33] !== t3 || $[34] !== t4 ? (t13 = /* @__PURE__ */ jsxRuntime.jsx(ResultInnerContainer, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ResultContainer, { flex: 1, overflow: "hidden", tone: t3, $isInvalid: t4, children: t12 }) }), $[32] = t12, $[33] = t3, $[34] = t4, $[35] = t13) : t13 = $[35];
  let t14;
  $[36] === Symbol.for("react.memo_cache_sentinel") ? (t14 = ["column", "column", "row"], $[36] = t14) : t14 = $[36];
  let t15;
  $[37] !== t ? (t15 = t("result.execution-time-label"), $[37] = t, $[38] = t15) : t15 = $[38];
  let t16;
  $[39] !== queryTime || $[40] !== t ? (t16 = typeof queryTime == "number" ? `${queryTime}ms` : t("result.timing-not-applicable"), $[39] = queryTime, $[40] = t, $[41] = t16) : t16 = $[41];
  let t17;
  $[42] !== t15 || $[43] !== t16 ? (t17 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, children: [
    t15,
    ":",
    " ",
    t16
  ] }) }), $[42] = t15, $[43] = t16, $[44] = t17) : t17 = $[44];
  let t18;
  $[45] !== t ? (t18 = t("result.end-to-end-time-label"), $[45] = t, $[46] = t18) : t18 = $[46];
  let t19;
  $[47] !== e2eTime || $[48] !== t ? (t19 = typeof e2eTime == "number" ? `${e2eTime}ms` : t("result.timing-not-applicable"), $[47] = e2eTime, $[48] = t, $[49] = t19) : t19 = $[49];
  let t20;
  $[50] !== t18 || $[51] !== t19 ? (t20 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, children: [
    t18,
    ":",
    " ",
    t19
  ] }) }), $[50] = t18, $[51] = t19, $[52] = t20) : t20 = $[52];
  let t21;
  $[53] !== t17 || $[54] !== t20 ? (t21 = /* @__PURE__ */ jsxRuntime.jsx(TimingsCard, { paddingX: 4, paddingY: 3, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsxs(TimingsTextContainer, { align: "center", children: [
    t17,
    t20
  ] }) }), $[53] = t17, $[54] = t20, $[55] = t21) : t21 = $[55];
  let t22;
  $[56] !== csvUrl || $[57] !== hasResult || $[58] !== jsonUrl || $[59] !== t ? (t22 = hasResult && /* @__PURE__ */ jsxRuntime.jsx(DownloadsCard, { paddingX: 4, paddingY: 3, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(SaveResultLabel, { muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.Translate, { components: {
    SaveResultButtons: () => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(SaveJsonButton, { blobUrl: jsonUrl }),
      /* @__PURE__ */ jsxRuntime.jsx(SaveCsvButton, { blobUrl: csvUrl })
    ] })
  }, i18nKey: "result.save-result-as-format", t }) }) }), $[56] = csvUrl, $[57] = hasResult, $[58] = jsonUrl, $[59] = t, $[60] = t22) : t22 = $[60];
  let t23;
  $[61] !== t21 || $[62] !== t22 ? (t23 = /* @__PURE__ */ jsxRuntime.jsxs(ResultFooter, { justify: "space-between", direction: t14, children: [
    t21,
    t22
  ] }), $[61] = t21, $[62] = t22, $[63] = t23) : t23 = $[63];
  let t24;
  return $[64] !== t13 || $[65] !== t23 ? (t24 = /* @__PURE__ */ jsxRuntime.jsxs(ResultOuterContainer, { direction: "column", "data-testid": "vision-result", children: [
    t13,
    t23
  ] }), $[64] = t13, $[65] = t23, $[66] = t24) : t24 = $[66], t24;
}
function nodeContains(node, other) {
  return !node || !other ? !1 : node === other || !!(node.compareDocumentPosition(other) & 16);
}
const sanityUrl = /\.(?:api|apicdn)\.sanity\.(?:io|work)\/(vX|v1|v\d{4}-\d\d-\d\d)\/.*?(?:query|listen)\/(.*?)\?(.*)/, isRunHotkey = (event) => isHotkeyEsm.isHotkey("ctrl+enter", event) || isHotkeyEsm.isHotkey("mod+enter", event);
function VisionGui(props) {
  const $ = reactCompilerRuntime.c(199), {
    datasets,
    config,
    projectId,
    defaultDataset
  } = props, toast = ui.useToast(), {
    t
  } = sanity.useTranslation(index.visionLocaleNamespace), {
    perspectiveStack
  } = sanity.usePerspective(), editorQueryRef = react.useRef(null), editorParamsRef = react.useRef(null), visionRootRef = react.useRef(null), customApiVersionElementRef = react.useRef(null), querySubscriptionRef = react.useRef(void 0), listenSubscriptionRef = react.useRef(void 0);
  let t0;
  $[0] !== projectId ? (t0 = () => getLocalStorage(projectId || "default"), $[0] = projectId, $[1] = t0) : t0 = $[1];
  const [localStorage2] = react.useState(t0);
  let t1;
  $[2] !== defaultDataset || $[3] !== localStorage2 ? (t1 = localStorage2.get("dataset", defaultDataset), $[2] = defaultDataset, $[3] = localStorage2, $[4] = t1) : t1 = $[4];
  const storedDataset = t1;
  let t2;
  $[5] !== config.defaultApiVersion || $[6] !== localStorage2 ? (t2 = localStorage2.get("apiVersion", prefixApiVersion(`${config.defaultApiVersion}`)), $[5] = config.defaultApiVersion, $[6] = localStorage2, $[7] = t2) : t2 = $[7];
  const storedApiVersion = t2;
  let t3;
  $[8] !== localStorage2 ? (t3 = localStorage2.get("query", ""), $[8] = localStorage2, $[9] = t3) : t3 = $[9];
  const storedQuery = t3;
  let t4;
  $[10] !== localStorage2 ? (t4 = localStorage2.get("params", `{
  
}`), $[10] = localStorage2, $[11] = t4) : t4 = $[11];
  const storedParams = t4;
  let t5;
  $[12] !== localStorage2 ? (t5 = localStorage2.get("perspective", void 0), $[12] = localStorage2, $[13] = t5) : t5 = $[13];
  const storedPerspective = t5;
  let t6;
  $[14] !== datasets || $[15] !== defaultDataset || $[16] !== storedDataset ? (t6 = () => datasets.includes(storedDataset) ? storedDataset : datasets.includes(defaultDataset) ? defaultDataset : datasets[0], $[14] = datasets, $[15] = defaultDataset, $[16] = storedDataset, $[17] = t6) : t6 = $[17];
  const [dataset, setDataset] = react.useState(t6);
  let t7;
  $[18] !== storedApiVersion ? (t7 = () => API_VERSIONS.includes(storedApiVersion) ? storedApiVersion : DEFAULT_API_VERSION, $[18] = storedApiVersion, $[19] = t7) : t7 = $[19];
  const [apiVersion, setApiVersion] = react.useState(t7);
  let t8;
  $[20] !== storedApiVersion ? (t8 = () => API_VERSIONS.includes(storedApiVersion) ? !1 : storedApiVersion, $[20] = storedApiVersion, $[21] = t8) : t8 = $[21];
  const [customApiVersion, setCustomApiVersion] = react.useState(t8), [perspective, setPerspectiveState] = react.useState(storedPerspective || "raw");
  let t9;
  $[22] !== customApiVersion ? (t9 = customApiVersion ? validateApiVersion(customApiVersion) : !0, $[22] = customApiVersion, $[23] = t9) : t9 = $[23];
  const isValidApiVersion = t9, [url, setUrl] = react.useState(void 0);
  let t10;
  $[24] !== storedQuery ? (t10 = () => typeof storedQuery == "string" ? storedQuery : "", $[24] = storedQuery, $[25] = t10) : t10 = $[25];
  const [query, setQuery] = react.useState(t10), [rawParams, setRawParams] = react.useState(storedParams);
  let t11;
  $[26] !== rawParams || $[27] !== t ? (t11 = parseParams(rawParams, t), $[26] = rawParams, $[27] = t, $[28] = t11) : t11 = $[28];
  const params = t11, [queryResult, setQueryResult] = react.useState(void 0);
  let t12;
  $[29] === Symbol.for("react.memo_cache_sentinel") ? (t12 = [], $[29] = t12) : t12 = $[29];
  const [listenMutations, setListenMutations] = react.useState(t12), [error, setError] = react.useState(void 0), [queryTime, setQueryTime] = react.useState(void 0), [e2eTime, setE2eTime] = react.useState(void 0), [queryInProgress, setQueryInProgress] = react.useState(!1), [listenInProgress, setListenInProgress] = react.useState(!1), [isQueryRecallCollapsed, setIsQueryRecallCollapsed] = react.useState(!1);
  let t13;
  $[30] === Symbol.for("react.memo_cache_sentinel") ? (t13 = {
    visionRootRef
  }, $[30] = t13) : t13 = $[30];
  const {
    paneSizeOptions,
    isNarrowBreakpoint
  } = usePaneSize(t13), t14 = isValidApiVersion && customApiVersion ? customApiVersion : apiVersion;
  let t15;
  $[31] !== t14 ? (t15 = {
    apiVersion: t14
  }, $[31] = t14, $[32] = t15) : t15 = $[32];
  const _client = sanity.useClient(t15);
  let t16;
  $[33] !== _client || $[34] !== apiVersion || $[35] !== customApiVersion || $[36] !== dataset || $[37] !== isValidApiVersion || $[38] !== perspective || $[39] !== perspectiveStack ? (t16 = _client.withConfig({
    apiVersion: isValidApiVersion && customApiVersion ? customApiVersion : apiVersion,
    perspective: getActivePerspective({
      visionPerspective: perspective,
      perspectiveStack
    }),
    dataset,
    allowReconfigure: !0
  }), $[33] = _client, $[34] = apiVersion, $[35] = customApiVersion, $[36] = dataset, $[37] = isValidApiVersion, $[38] = perspective, $[39] = perspectiveStack, $[40] = t16) : t16 = $[40];
  const client = t16;
  let t17;
  $[41] === Symbol.for("react.memo_cache_sentinel") ? (t17 = () => {
    querySubscriptionRef.current && (querySubscriptionRef.current.unsubscribe(), querySubscriptionRef.current = void 0);
  }, $[41] = t17) : t17 = $[41];
  const cancelQuerySubscription = t17;
  let t18;
  $[42] === Symbol.for("react.memo_cache_sentinel") ? (t18 = () => {
    listenSubscriptionRef.current && (listenSubscriptionRef.current.unsubscribe(), listenSubscriptionRef.current = void 0);
  }, $[42] = t18) : t18 = $[42];
  const cancelListenerSubscription = t18;
  let t19;
  $[43] !== apiVersion || $[44] !== client || $[45] !== customApiVersion || $[46] !== dataset || $[47] !== isValidApiVersion || $[48] !== localStorage2 || $[49] !== params.parsed || $[50] !== perspective || $[51] !== perspectiveStack || $[52] !== query || $[53] !== queryInProgress || $[54] !== t ? (t19 = (options) => {
    if (queryInProgress) {
      cancelQuerySubscription(), cancelListenerSubscription(), setQueryInProgress(!1);
      return;
    }
    const context = {
      query: options?.query || query,
      dataset: options?.dataset || dataset,
      params: parseParams(JSON.stringify(options?.params || params.parsed, null, 2), t),
      perspective: getActivePerspective({
        visionPerspective: options?.perspective || perspective,
        perspectiveStack
      }),
      apiVersion: options?.apiVersion || (customApiVersion && isValidApiVersion ? customApiVersion : apiVersion)
    };
    if (localStorage2.set("query", context.query), localStorage2.set("params", context.params.raw), cancelListenerSubscription(), setQueryInProgress(!context.params.error && !!context.query), setListenInProgress(!1), setListenMutations([]), setError(context.params.error ? new Error(context.params.error) : void 0), setQueryResult(void 0), setQueryTime(void 0), setE2eTime(void 0), context.params.error)
      return;
    const urlQueryOpts = {
      perspective: context.perspective ?? []
    }, ctxClient = client.withConfig({
      apiVersion: context.apiVersion,
      dataset: context.dataset,
      perspective: context.perspective
    }), newUrl = ctxClient.getUrl(ctxClient.getDataUrl("query", encodeQueryString(context.query, context.params.parsed, urlQueryOpts)));
    setUrl(newUrl);
    const queryStart = Date.now();
    querySubscriptionRef.current = ctxClient.observable.fetch(context.query, context.params.parsed, {
      filterResponse: !1,
      tag: "vision"
    }).subscribe({
      next: (res) => {
        setQueryTime(res.ms), setE2eTime(Date.now() - queryStart), setQueryResult(res.result), setQueryInProgress(!1), setError(void 0);
      },
      error: (err) => {
        setError(err), setQueryInProgress(!1);
      }
    });
  }, $[43] = apiVersion, $[44] = client, $[45] = customApiVersion, $[46] = dataset, $[47] = isValidApiVersion, $[48] = localStorage2, $[49] = params.parsed, $[50] = perspective, $[51] = perspectiveStack, $[52] = query, $[53] = queryInProgress, $[54] = t, $[55] = t19) : t19 = $[55];
  const handleQueryExecution = t19;
  let t20;
  $[56] !== handleQueryExecution || $[57] !== localStorage2 ? (t20 = (newPerspective) => {
    newPerspective !== void 0 && !isSupportedPerspective(newPerspective) || (setPerspectiveState(newPerspective), localStorage2.set("perspective", newPerspective), handleQueryExecution({
      perspective: newPerspective
    }));
  }, $[56] = handleQueryExecution, $[57] = localStorage2, $[58] = t20) : t20 = $[58];
  const setPerspective = t20;
  let t21;
  $[59] !== handleQueryExecution || $[60] !== localStorage2 ? (t21 = (evt) => {
    const newDataset = evt.target.value;
    localStorage2.set("dataset", newDataset), setDataset(newDataset), handleQueryExecution({
      dataset: newDataset
    });
  }, $[59] = handleQueryExecution, $[60] = localStorage2, $[61] = t21) : t21 = $[61];
  const handleChangeDataset = t21;
  let t22;
  $[62] !== handleQueryExecution || $[63] !== localStorage2 ? (t22 = (evt_0) => {
    const newApiVersion = evt_0.target.value;
    if (newApiVersion?.toLowerCase() === "other") {
      setCustomApiVersion("v"), customApiVersionElementRef.current?.focus();
      return;
    }
    setApiVersion(newApiVersion), setCustomApiVersion(!1), localStorage2.set("apiVersion", newApiVersion), handleQueryExecution({
      apiVersion: newApiVersion
    });
  }, $[62] = handleQueryExecution, $[63] = localStorage2, $[64] = t22) : t22 = $[64];
  const handleChangeApiVersion = t22;
  let t23;
  $[65] !== handleQueryExecution || $[66] !== localStorage2 ? (t23 = (evt_1) => {
    const newCustomApiVersion = evt_1.target.value || "";
    setCustomApiVersion(newCustomApiVersion || "v"), validateApiVersion(newCustomApiVersion) && (setApiVersion(newCustomApiVersion), localStorage2.set("apiVersion", newCustomApiVersion), handleQueryExecution({
      apiVersion: newCustomApiVersion
    }));
  }, $[65] = handleQueryExecution, $[66] = localStorage2, $[67] = t23) : t23 = $[67];
  const handleCustomApiVersionChange = t23;
  let t24;
  $[68] !== setPerspective ? (t24 = (evt_2) => {
    const newPerspective_0 = evt_2.target.value;
    setPerspective(newPerspective_0 === "default" ? void 0 : newPerspective_0);
  }, $[68] = setPerspective, $[69] = t24) : t24 = $[69];
  const handleChangePerspective = t24;
  let t25;
  $[70] === Symbol.for("react.memo_cache_sentinel") ? (t25 = (evt_3) => {
    evt_3.type === "mutation" && setListenMutations((prevMutations) => prevMutations.length === 50 ? [evt_3, ...prevMutations.slice(0, 49)] : [evt_3, ...prevMutations]);
  }, $[70] = t25) : t25 = $[70];
  const handleListenerEvent = t25;
  let t26;
  $[71] !== client || $[72] !== listenInProgress || $[73] !== localStorage2 || $[74] !== params.error || $[75] !== params.parsed || $[76] !== params.raw || $[77] !== query ? (t26 = () => {
    if (listenInProgress) {
      cancelListenerSubscription(), setListenInProgress(!1);
      return;
    }
    const newUrl_0 = client.getDataUrl("listen", encodeQueryString(query, params.parsed, {})), shouldExecute = !params.error && query.trim().length > 0;
    localStorage2.set("query", query), localStorage2.set("params", params.raw), cancelQuerySubscription(), setUrl(newUrl_0), setListenMutations([]), setQueryInProgress(!1), setQueryResult(void 0), setListenInProgress(shouldExecute), setError(params.error ? new Error(params.error) : void 0), setQueryTime(void 0), setE2eTime(void 0), shouldExecute && (listenSubscriptionRef.current = client.listen(query, params.parsed, {
      events: ["mutation", "welcome"],
      includeAllVersions: !0
    }).subscribe({
      next: handleListenerEvent,
      error: (err_0) => {
        setError(err_0), setListenInProgress(!1);
      }
    }));
  }, $[71] = client, $[72] = listenInProgress, $[73] = localStorage2, $[74] = params.error, $[75] = params.parsed, $[76] = params.raw, $[77] = query, $[78] = t26) : t26 = $[78];
  const handleListenExecution = t26;
  let t27;
  $[79] !== localStorage2 ? (t27 = (value) => {
    setRawParams(value), localStorage2.set("params", value);
  }, $[79] = localStorage2, $[80] = t27) : t27 = $[80];
  const handleParamsChange = t27;
  let t28;
  $[81] !== apiVersion || $[82] !== dataset || $[83] !== datasets || $[84] !== perspective || $[85] !== toast ? (t28 = (data) => {
    const match = data.match(sanityUrl);
    if (!match)
      return null;
    const [, usedApiVersion, usedDataset, urlQuery] = match, qs = new URLSearchParams(urlQuery), parts = parseApiQueryString(qs);
    if (!parts)
      return null;
    let newApiVersion_0, newCustomApiVersion_0;
    validateApiVersion(usedApiVersion) && (API_VERSIONS.includes(usedApiVersion) ? (newApiVersion_0 = usedApiVersion, newCustomApiVersion_0 = !1) : newCustomApiVersion_0 = usedApiVersion);
    const newPerspective_1 = isSupportedPerspective(parts.options.perspective) && !isVirtualPerspective(parts.options.perspective) ? parts.options.perspective : void 0;
    return newPerspective_1 && (!isSupportedPerspective(parts.options.perspective) || isVirtualPerspective(parts.options.perspective)) && toast.push({
      closable: !0,
      id: "vision-paste-unsupported-perspective",
      status: "warning",
      title: 'Perspective in pasted url is currently not supported. Falling back to "raw"'
    }), {
      query: parts.query,
      params: parts.params,
      rawParams: JSON.stringify(parts.params, null, 2),
      dataset: datasets.includes(usedDataset) ? usedDataset : dataset,
      apiVersion: newApiVersion_0 || apiVersion,
      customApiVersion: newCustomApiVersion_0,
      perspective: newPerspective_1 || perspective,
      url: data
    };
  }, $[81] = apiVersion, $[82] = dataset, $[83] = datasets, $[84] = perspective, $[85] = toast, $[86] = t28) : t28 = $[86];
  const getStateFromUrl = t28;
  let t29;
  $[87] !== handleQueryExecution || $[88] !== localStorage2 ? (t29 = (parsedUrlObj) => {
    setDataset(parsedUrlObj.dataset), setQuery(parsedUrlObj.query), setRawParams(parsedUrlObj.rawParams), setApiVersion(parsedUrlObj.apiVersion), parsedUrlObj.customApiVersion && setCustomApiVersion(parsedUrlObj.customApiVersion), setPerspectiveState(parsedUrlObj.perspective), setUrl(parsedUrlObj.url), editorQueryRef.current?.resetEditorContent(parsedUrlObj.query), editorParamsRef.current?.resetEditorContent(parsedUrlObj.rawParams), localStorage2.merge({
      query: parsedUrlObj.query,
      params: parsedUrlObj.rawParams,
      dataset: parsedUrlObj.dataset,
      apiVersion: parsedUrlObj.customApiVersion || parsedUrlObj.apiVersion,
      perspective: parsedUrlObj.perspective
    }), handleQueryExecution(parsedUrlObj);
  }, $[87] = handleQueryExecution, $[88] = localStorage2, $[89] = t29) : t29 = $[89];
  const setStateFromParsedUrl = t29;
  let t30;
  $[90] !== getStateFromUrl || $[91] !== setStateFromParsedUrl || $[92] !== toast ? (t30 = (evt_4) => {
    if (!evt_4.clipboardData)
      return;
    const data_0 = evt_4.clipboardData.getData("text/plain");
    evt_4.preventDefault();
    const urlState = getStateFromUrl(data_0);
    urlState && (setStateFromParsedUrl(urlState), toast.push({
      closable: !0,
      id: "vision-paste",
      status: "info",
      title: "Parsed URL to query"
    }));
  }, $[90] = getStateFromUrl, $[91] = setStateFromParsedUrl, $[92] = toast, $[93] = t30) : t30 = $[93];
  const handlePaste = t30;
  let t31;
  $[94] !== handleQueryExecution || $[95] !== params.valid ? (t31 = (event) => {
    const isWithinRoot = visionRootRef.current && nodeContains(visionRootRef.current, event.target);
    isRunHotkey(event) && isWithinRoot && params.valid && (handleQueryExecution(), event.preventDefault(), event.stopPropagation());
  }, $[94] = handleQueryExecution, $[95] = params.valid, $[96] = t31) : t31 = $[96];
  const handleKeyDown = t31;
  let t32, t33;
  $[97] !== handleKeyDown || $[98] !== handlePaste ? (t32 = () => (window.document.addEventListener("paste", handlePaste), window.document.addEventListener("keydown", handleKeyDown), () => {
    window.document.removeEventListener("paste", handlePaste), window.document.removeEventListener("keydown", handleKeyDown);
  }), t33 = [handleKeyDown, handlePaste], $[97] = handleKeyDown, $[98] = handlePaste, $[99] = t32, $[100] = t33) : (t32 = $[99], t33 = $[100]), react.useEffect(t32, t33);
  let t34, t35;
  $[101] === Symbol.for("react.memo_cache_sentinel") ? (t34 = () => () => {
    cancelQuerySubscription(), cancelListenerSubscription();
  }, t35 = [cancelQuerySubscription, cancelListenerSubscription], $[101] = t34, $[102] = t35) : (t34 = $[101], t35 = $[102]), react.useEffect(t34, t35);
  let t36;
  $[103] !== setPerspective ? (t36 = (stack) => {
    stack.length > 0 && setPerspective("pinnedRelease");
  }, $[103] = setPerspective, $[104] = t36) : t36 = $[104];
  const handleStudioPerspectiveChange = useEffectEvent.useEffectEvent(t36);
  let t37;
  $[105] !== handleStudioPerspectiveChange || $[106] !== perspectiveStack ? (t37 = () => {
    handleStudioPerspectiveChange(perspectiveStack);
  }, $[105] = handleStudioPerspectiveChange, $[106] = perspectiveStack, $[107] = t37) : t37 = $[107];
  let t38;
  $[108] !== perspectiveStack ? (t38 = [perspectiveStack], $[108] = perspectiveStack, $[109] = t38) : t38 = $[109], react.useEffect(t37, t38);
  let t39;
  $[110] !== client || $[111] !== perspective || $[112] !== perspectiveStack ? (t39 = (queryString, queryParams) => {
    const urlQueryOpts_0 = {
      perspective: getActivePerspective({
        visionPerspective: perspective,
        perspectiveStack
      }) ?? []
    };
    return client.getUrl(client.getDataUrl("query", encodeQueryString(queryString, queryParams, urlQueryOpts_0)));
  }, $[110] = client, $[111] = perspective, $[112] = perspectiveStack, $[113] = t39) : t39 = $[113];
  const generateUrl = t39;
  let t40;
  $[114] !== apiVersion || $[115] !== customApiVersion || $[116] !== dataset || $[117] !== datasets || $[118] !== handleChangeApiVersion || $[119] !== handleChangeDataset || $[120] !== handleChangePerspective || $[121] !== handleCustomApiVersionChange || $[122] !== isValidApiVersion || $[123] !== perspective || $[124] !== url ? (t40 = /* @__PURE__ */ jsxRuntime.jsx(VisionGuiHeader, { apiVersion, customApiVersion, dataset, datasets, onChangeDataset: handleChangeDataset, onChangeApiVersion: handleChangeApiVersion, customApiVersionElementRef, onCustomApiVersionChange: handleCustomApiVersionChange, isValidApiVersion, onChangePerspective: handleChangePerspective, url, perspective }), $[114] = apiVersion, $[115] = customApiVersion, $[116] = dataset, $[117] = datasets, $[118] = handleChangeApiVersion, $[119] = handleChangeDataset, $[120] = handleChangePerspective, $[121] = handleCustomApiVersionChange, $[122] = isValidApiVersion, $[123] = perspective, $[124] = url, $[125] = t40) : t40 = $[125];
  const t41 = isQueryRecallCollapsed ? window.innerWidth : window.innerWidth - 275, t42 = isNarrowBreakpoint ? "vertical" : "horizontal", t43 = isNarrowBreakpoint ? paneSizeOptions.defaultSize : paneSizeOptions.minSize, t44 = paneSizeOptions.size, t45 = paneSizeOptions.allowResize, t46 = isNarrowBreakpoint ? paneSizeOptions.minSize : 100, t47 = paneSizeOptions.maxSize;
  let t48;
  $[126] !== t ? (t48 = t("query.label"), $[126] = t, $[127] = t48) : t48 = $[127];
  let t49;
  $[128] !== t48 ? (t49 = /* @__PURE__ */ jsxRuntime.jsx(InputBackgroundContainerLeft, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(StyledLabel, { muted: !0, children: t48 }) }) }), $[128] = t48, $[129] = t49) : t49 = $[129];
  let t50;
  $[130] !== query ? (t50 = /* @__PURE__ */ jsxRuntime.jsx(VisionCodeMirror, { initialValue: query, onChange: setQuery, ref: editorQueryRef }), $[130] = query, $[131] = t50) : t50 = $[131];
  let t51;
  $[132] !== t49 || $[133] !== t50 ? (t51 = /* @__PURE__ */ jsxRuntime.jsx(InputContainer, { display: "flex", "data-testid": "vision-query-editor", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, children: [
    t49,
    t50
  ] }) }), $[132] = t49, $[133] = t50, $[134] = t51) : t51 = $[134];
  let t52;
  $[135] !== handleParamsChange || $[136] !== params.error || $[137] !== params.raw || $[138] !== params.valid ? (t52 = /* @__PURE__ */ jsxRuntime.jsx(ParamsEditor, { value: params.raw, onChange: handleParamsChange, paramsError: params.error, hasValidParams: params.valid, editorRef: editorParamsRef }), $[135] = handleParamsChange, $[136] = params.error, $[137] = params.raw, $[138] = params.valid, $[139] = t52) : t52 = $[139];
  let t53;
  $[140] !== handleListenExecution || $[141] !== handleQueryExecution || $[142] !== listenInProgress || $[143] !== params.valid || $[144] !== queryInProgress ? (t53 = /* @__PURE__ */ jsxRuntime.jsx(VisionGuiControls, { hasValidParams: params.valid, queryInProgress, listenInProgress, onQueryExecution: handleQueryExecution, onListenExecution: handleListenExecution }), $[140] = handleListenExecution, $[141] = handleQueryExecution, $[142] = listenInProgress, $[143] = params.valid, $[144] = queryInProgress, $[145] = t53) : t53 = $[145];
  let t54;
  $[146] !== t52 || $[147] !== t53 ? (t54 = /* @__PURE__ */ jsxRuntime.jsxs(InputContainer, { display: "flex", children: [
    t52,
    t53
  ] }), $[146] = t52, $[147] = t53, $[148] = t54) : t54 = $[148];
  let t55;
  $[149] !== paneSizeOptions.allowResize || $[150] !== paneSizeOptions.maxSize || $[151] !== paneSizeOptions.size || $[152] !== t43 || $[153] !== t46 || $[154] !== t51 || $[155] !== t54 ? (t55 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { height: "stretch", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(reactSplitPane.SplitPane, { className: "sidebarPanes", split: "horizontal", defaultSize: t43, size: t44, allowResize: t45, minSize: t46, maxSize: t47, primary: "first", children: [
    t51,
    t54
  ] }) }), $[149] = paneSizeOptions.allowResize, $[150] = paneSizeOptions.maxSize, $[151] = paneSizeOptions.size, $[152] = t43, $[153] = t46, $[154] = t51, $[155] = t54, $[156] = t55) : t55 = $[156];
  let t56;
  $[157] !== dataset || $[158] !== e2eTime || $[159] !== error || $[160] !== listenInProgress || $[161] !== listenMutations || $[162] !== queryInProgress || $[163] !== queryResult || $[164] !== queryTime ? (t56 = /* @__PURE__ */ jsxRuntime.jsx(VisionGuiResult, { error, queryInProgress, queryResult, listenInProgress, listenMutations, dataset, queryTime, e2eTime }), $[157] = dataset, $[158] = e2eTime, $[159] = error, $[160] = listenInProgress, $[161] = listenMutations, $[162] = queryInProgress, $[163] = queryResult, $[164] = queryTime, $[165] = t56) : t56 = $[165];
  let t57;
  $[166] !== t42 || $[167] !== t55 || $[168] !== t56 ? (t57 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { height: "stretch", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(reactSplitPane.SplitPane, { className: "sidebarPanes", split: t42, minSize: 300, children: [
    t55,
    t56
  ] }) }), $[166] = t42, $[167] = t55, $[168] = t56, $[169] = t57) : t57 = $[169];
  let t58;
  $[170] === Symbol.for("react.memo_cache_sentinel") ? (t58 = {
    position: "relative",
    height: "100%"
  }, $[170] = t58) : t58 = $[170];
  let t59;
  $[171] === Symbol.for("react.memo_cache_sentinel") ? (t59 = {
    position: "absolute",
    left: -32,
    top: "50%",
    transform: "translateY(-50%)",
    zIndex: 100,
    pointerEvents: "auto"
  }, $[171] = t59) : t59 = $[171];
  let t60;
  $[172] !== isQueryRecallCollapsed ? (t60 = () => setIsQueryRecallCollapsed(!isQueryRecallCollapsed), $[172] = isQueryRecallCollapsed, $[173] = t60) : t60 = $[173];
  let t61;
  $[174] === Symbol.for("react.memo_cache_sentinel") ? (t61 = {
    display: "flex",
    alignItems: "center",
    height: "100%"
  }, $[174] = t61) : t61 = $[174];
  let t62;
  $[175] !== isQueryRecallCollapsed ? (t62 = /* @__PURE__ */ jsxRuntime.jsx("div", { style: t61, children: isQueryRecallCollapsed ? /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronLeftIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}) }), $[175] = isQueryRecallCollapsed, $[176] = t62) : t62 = $[176];
  let t63;
  $[177] !== t60 || $[178] !== t62 ? (t63 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { mode: "ghost", padding: 2, style: t59, onClick: t60, children: t62 }), $[177] = t60, $[178] = t62, $[179] = t63) : t63 = $[179];
  let t64;
  $[180] !== params.parsed ? (t64 = params.parsed || {}, $[180] = params.parsed, $[181] = t64) : t64 = $[181];
  let t65;
  $[182] !== generateUrl || $[183] !== getStateFromUrl || $[184] !== query || $[185] !== setStateFromParsedUrl || $[186] !== t64 || $[187] !== url ? (t65 = /* @__PURE__ */ jsxRuntime.jsx(QueryRecall, { url, getStateFromUrl, setStateFromParsedUrl, currentQuery: query, currentParams: t64, generateUrl }), $[182] = generateUrl, $[183] = getStateFromUrl, $[184] = query, $[185] = setStateFromParsedUrl, $[186] = t64, $[187] = url, $[188] = t65) : t65 = $[188];
  let t66;
  $[189] !== t63 || $[190] !== t65 ? (t66 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { style: t58, children: [
    t63,
    t65
  ] }), $[189] = t63, $[190] = t65, $[191] = t66) : t66 = $[191];
  let t67;
  $[192] !== t41 || $[193] !== t57 || $[194] !== t66 ? (t67 = /* @__PURE__ */ jsxRuntime.jsx(SplitpaneContainer, { flex: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(reactSplitPane.SplitPane, { minSize: 800, defaultSize: window.innerWidth - 275, size: t41, maxSize: -225, primary: "first", children: [
    t57,
    t66
  ] }) }), $[192] = t41, $[193] = t57, $[194] = t66, $[195] = t67) : t67 = $[195];
  let t68;
  return $[196] !== t40 || $[197] !== t67 ? (t68 = /* @__PURE__ */ jsxRuntime.jsxs(Root, { direction: "column", height: "fill", ref: visionRootRef, sizing: "border", overflow: "hidden", "data-testid": "vision-root", children: [
    t40,
    t67
  ] }), $[196] = t40, $[197] = t67, $[198] = t68) : t68 = $[198], t68;
}
function useDatasets(t0) {
  const $ = reactCompilerRuntime.c(7), {
    client,
    datasets: configDatasets
  } = t0;
  let t1;
  bb0: {
    if (Array.isArray(configDatasets)) {
      let t22;
      $[0] !== configDatasets ? (t22 = rxjs.of(configDatasets), $[0] = configDatasets, $[1] = t22) : t22 = $[1], t1 = t22;
      break bb0;
    }
    let t2;
    if ($[2] !== client.observable.datasets || $[3] !== configDatasets) {
      let t3;
      $[5] !== configDatasets ? (t3 = (result) => typeof configDatasets == "function" ? configDatasets(result).map(_temp) : result.map(_temp2), $[5] = configDatasets, $[6] = t3) : t3 = $[6], t2 = client.observable.datasets.list().pipe(rxjs.map(t3), rxjs.catchError(_temp3)), $[2] = client.observable.datasets, $[3] = configDatasets, $[4] = t2;
    } else
      t2 = $[4];
    t1 = t2;
  }
  return reactRx.useObservable(t1, null);
}
function _temp3(err) {
  return rxjs.of(err);
}
function _temp2(ds) {
  return ds.name;
}
function _temp(d) {
  return d.name;
}
function VisionContainer(props) {
  const $ = reactCompilerRuntime.c(19);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    apiVersion: "v2025-06-27"
  }, $[0] = t0) : t0 = $[0];
  const datasetsClient = sanity.useClient(t0);
  let t1;
  $[1] !== datasetsClient || $[2] !== props.config.datasets ? (t1 = {
    client: datasetsClient,
    datasets: props.config.datasets
  }, $[1] = datasetsClient, $[2] = props.config.datasets, $[3] = t1) : t1 = $[3];
  const loadedDatasets = useDatasets(t1);
  if (!loadedDatasets) {
    let t22;
    return $[4] === Symbol.for("react.memo_cache_sentinel") ? (t22 = /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(DelayedSpinner, {}) }), $[4] = t22) : t22 = $[4], t22;
  }
  let t2;
  $[5] !== loadedDatasets || $[6] !== props.client ? (t2 = loadedDatasets instanceof Error ? [props.client.config().dataset || "production"] : loadedDatasets, $[5] = loadedDatasets, $[6] = props.client, $[7] = t2) : t2 = $[7];
  const datasets = t2;
  let t3;
  $[8] !== props.client ? (t3 = props.client.config(), $[8] = props.client, $[9] = t3) : t3 = $[9];
  const projectId = t3.projectId;
  let t4;
  $[10] !== datasets || $[11] !== props.client || $[12] !== props.config.defaultDataset ? (t4 = props.config.defaultDataset || props.client.config().dataset || datasets[0], $[10] = datasets, $[11] = props.client, $[12] = props.config.defaultDataset, $[13] = t4) : t4 = $[13];
  const defaultDataset = t4;
  let t5;
  return $[14] !== datasets || $[15] !== defaultDataset || $[16] !== projectId || $[17] !== props ? (t5 = /* @__PURE__ */ jsxRuntime.jsx(VisionGui, { ...props, datasets, projectId, defaultDataset }, projectId), $[14] = datasets, $[15] = defaultDataset, $[16] = projectId, $[17] = props, $[18] = t5) : t5 = $[18], t5;
}
class VisionErrorBoundary extends react.Component {
  constructor(props) {
    super(props), this.state = {
      error: null,
      numRetries: 0
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error: error instanceof Error ? error.message : `${error}`
    };
  }
  handleRetryRender = () => this.setState((prev) => ({
    error: null,
    numRetries: prev.numRetries + 1
  }));
  handleRetryWithCacheClear = () => {
    clearLocalStorage(), this.handleRetryRender();
  };
  render() {
    if (!this.state.error)
      return this.props.children;
    const message = this.state.error, withCacheClear = this.state.numRetries > 0;
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", overflow: "auto", paddingY: [4, 5, 6, 7], paddingX: 4, sizing: "border", tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { onClick: withCacheClear ? this.handleRetryWithCacheClear : this.handleRetryRender, text: withCacheClear ? "Clear cache and retry" : "Retry", tone: "default" }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { children: "An error occurred" }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 2, overflow: "auto", padding: 4, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, children: message && /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsxs("strong", { children: [
        "Error: ",
        message
      ] }) }) }) })
    ] }) }) });
  }
}
function SanityVision(props) {
  const $ = reactCompilerRuntime.c(6);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    apiVersion: "1"
  }, $[0] = t0) : t0 = $[0];
  const client = sanity.useClient(t0);
  let t1;
  $[1] !== props.tool.options ? (t1 = {
    defaultApiVersion: DEFAULT_API_VERSION,
    ...props.tool.options
  }, $[1] = props.tool.options, $[2] = t1) : t1 = $[2];
  const config = t1;
  let t2;
  return $[3] !== client || $[4] !== config ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(VisionErrorBoundary, { children: /* @__PURE__ */ jsxRuntime.jsx(VisionContainer, { client, config }) }), $[3] = client, $[4] = config, $[5] = t2) : t2 = $[5], t2;
}
exports.default = SanityVision;
//# sourceMappingURL=SanityVision.js.map
