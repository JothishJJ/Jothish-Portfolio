"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var util_getTextBlockText = require("../_chunks-cjs/util.get-text-block-text.cjs"), util_childSelectionPointToBlockOffset = require("../_chunks-cjs/util.child-selection-point-to-block-offset.cjs"), util_isEmptyTextBlock = require("../_chunks-cjs/util.is-empty-text-block.cjs"), schema = require("@portabletext/schema"), util_mergeTextBlocks = require("../_chunks-cjs/util.merge-text-blocks.cjs"), util_sliceTextBlock = require("../_chunks-cjs/util.slice-text-block.cjs");
function isEqualSelections(a, b) {
  return !a && !b ? !0 : !a || !b ? !1 : util_isEmptyTextBlock.isEqualSelectionPoints(a.anchor, b.anchor) && util_isEmptyTextBlock.isEqualSelectionPoints(a.focus, b.focus);
}
function reverseSelection(selection) {
  return selection && (selection.backward ? {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !1
  } : {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !0
  });
}
function splitTextBlock({
  context,
  block,
  point
}) {
  const firstChild = block.children.at(0), lastChild = block.children.at(block.children.length - 1);
  if (!firstChild || !lastChild)
    return;
  const before = util_sliceTextBlock.sliceTextBlock({
    context: {
      schema: context.schema,
      selection: {
        anchor: {
          path: [{
            _key: block._key
          }, "children", {
            _key: firstChild._key
          }],
          offset: 0
        },
        focus: point
      }
    },
    block
  }), after = util_sliceTextBlock.sliceTextBlock({
    context: {
      schema: context.schema,
      selection: {
        anchor: point,
        focus: {
          path: [{
            _key: block._key
          }, "children", {
            _key: lastChild._key
          }],
          offset: schema.isSpan(context, lastChild) ? lastChild.text.length : 0
        }
      }
    },
    block
  });
  return {
    before,
    after
  };
}
exports.blockOffsetToSpanSelectionPoint = util_getTextBlockText.blockOffsetToSpanSelectionPoint;
exports.getBlockStartPoint = util_getTextBlockText.getBlockStartPoint;
exports.getSelectionEndPoint = util_getTextBlockText.getSelectionEndPoint;
exports.getSelectionStartPoint = util_getTextBlockText.getSelectionStartPoint;
exports.getTextBlockText = util_getTextBlockText.getTextBlockText;
exports.isKeyedSegment = util_getTextBlockText.isKeyedSegment;
exports.sliceBlocks = util_getTextBlockText.sliceBlocks;
exports.spanSelectionPointToBlockOffset = util_getTextBlockText.spanSelectionPointToBlockOffset;
exports.blockOffsetToBlockSelectionPoint = util_childSelectionPointToBlockOffset.blockOffsetToBlockSelectionPoint;
exports.blockOffsetToSelectionPoint = util_childSelectionPointToBlockOffset.blockOffsetToSelectionPoint;
exports.blockOffsetsToSelection = util_childSelectionPointToBlockOffset.blockOffsetsToSelection;
exports.childSelectionPointToBlockOffset = util_childSelectionPointToBlockOffset.childSelectionPointToBlockOffset;
exports.getBlockEndPoint = util_isEmptyTextBlock.getBlockEndPoint;
exports.isEmptyTextBlock = util_isEmptyTextBlock.isEmptyTextBlock;
exports.isEqualSelectionPoints = util_isEmptyTextBlock.isEqualSelectionPoints;
exports.isSelectionCollapsed = util_isEmptyTextBlock.isSelectionCollapsed;
Object.defineProperty(exports, "isSpan", {
  enumerable: !0,
  get: function() {
    return schema.isSpan;
  }
});
Object.defineProperty(exports, "isTextBlock", {
  enumerable: !0,
  get: function() {
    return schema.isTextBlock;
  }
});
exports.mergeTextBlocks = util_mergeTextBlocks.mergeTextBlocks;
exports.selectionPointToBlockOffset = util_sliceTextBlock.selectionPointToBlockOffset;
exports.isEqualSelections = isEqualSelections;
exports.reverseSelection = reverseSelection;
exports.splitTextBlock = splitTextBlock;
//# sourceMappingURL=index.cjs.map
