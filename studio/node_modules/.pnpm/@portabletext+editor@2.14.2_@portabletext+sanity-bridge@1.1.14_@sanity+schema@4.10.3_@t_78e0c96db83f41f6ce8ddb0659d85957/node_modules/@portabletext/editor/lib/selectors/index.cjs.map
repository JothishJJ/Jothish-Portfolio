{"version":3,"file":"index.cjs","sources":["../../src/selectors/selector.get-anchor-block.ts","../../src/selectors/selector.get-anchor-text-block.ts","../../src/selectors/selector.get-anchor-child.ts","../../src/selectors/selector.get-anchor-span.ts","../../src/selectors/selector.get-block-offsets.ts","../../src/selectors/selector.get-list-state.ts","../../src/selectors/selector.get-next-inline-objects.ts","../../src/selectors/selector.get-previous-inline-objects.ts","../../src/selectors/selector.get-selected-slice.ts","../../src/selectors/selector.get-selection.ts","../../src/selectors/selector.get-selection-end-child.ts","../../src/selectors/selector.get-selection-start-child.ts","../../src/selectors/selector.get-value.ts"],"sourcesContent":["import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getAnchorBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = getBlockKeyFromSelectionPoint(snapshot.context.selection.anchor)\n  const index = key ? snapshot.blockIndexMap.get(key) : undefined\n  const node =\n    index !== undefined ? snapshot.context.value.at(index) : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getAnchorBlock} from './selector.get-anchor-block'\n\n/**\n * @public\n */\nexport const getAnchorTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const anchorBlock = getAnchorBlock(snapshot)\n\n  return anchorBlock && isTextBlock(snapshot.context, anchorBlock.node)\n    ? {node: anchorBlock.node, path: anchorBlock.path}\n    : undefined\n}\n","import type {PortableTextObject, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getAnchorTextBlock} from './selector.get-anchor-text-block'\n\n/**\n * @public\n */\nexport const getAnchorChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const anchorBlock = getAnchorTextBlock(snapshot)\n\n  if (!anchorBlock) {\n    return undefined\n  }\n\n  const key = getChildKeyFromSelectionPoint(snapshot.context.selection.anchor)\n\n  const node = key\n    ? anchorBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...anchorBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import {isPortableTextSpan, type PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getAnchorChild} from './selector.get-anchor-child'\n\n/**\n * @public\n */\nexport const getAnchorSpan: EditorSelector<\n  {node: PortableTextSpan; path: ChildPath} | undefined\n> = (snapshot) => {\n  const anchorChild = getAnchorChild(snapshot)\n\n  return anchorChild && isPortableTextSpan(anchorChild.node)\n    ? {node: anchorChild.node, path: anchorChild.path}\n    : undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getBlockOffsets: EditorSelector<\n  {start: BlockOffset; end: BlockOffset} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionStartPoint || !selectionEndPoint) {\n    return undefined\n  }\n\n  const start = spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionStartPoint,\n  })\n  const end = spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionEndPoint,\n  })\n\n  return start && end ? {start, end} : undefined\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @beta\n * @deprecated Use the precomputed `data-list-index` on text blocks instead.\n * Given the `path` of a block, this selector will return the \"list index\" of\n * the block.\n */\nexport function getListIndex({\n  path,\n}: {\n  path: BlockPath\n}): EditorSelector<number | undefined> {\n  return (snapshot) => {\n    const selection = {\n      anchor: {\n        path,\n        offset: 0,\n      },\n      focus: {\n        path,\n        offset: 0,\n      },\n    }\n\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    if (!focusTextBlock) {\n      return undefined\n    }\n\n    if (\n      focusTextBlock.node.listItem === undefined ||\n      focusTextBlock.node.level === undefined\n    ) {\n      return undefined\n    }\n\n    const targetListItem = focusTextBlock.node.listItem\n    const targetLevel = focusTextBlock.node.level\n    const targetKey = focusTextBlock.node._key\n\n    // Find the target block's index\n    const targetIndex = snapshot.blockIndexMap.get(targetKey)\n\n    if (targetIndex === undefined) {\n      return undefined\n    }\n\n    // Walk backwards from the target block and count consecutive list items\n    // of the same type and level\n    let listIndex = 1 // Start at 1 for the target block itself\n\n    for (let i = targetIndex - 1; i >= 0; i--) {\n      const block = snapshot.context.value[i]\n\n      if (!isTextBlock(snapshot.context, block)) {\n        // Non-text block breaks the sequence\n        break\n      }\n\n      if (block.listItem === undefined || block.level === undefined) {\n        // Non-list item breaks the sequence\n        break\n      }\n\n      if (block.listItem !== targetListItem) {\n        // Different list type breaks the sequence\n        break\n      }\n\n      if (block.level < targetLevel) {\n        // Lower level breaks the sequence\n        break\n      }\n\n      if (block.level === targetLevel) {\n        // Same level - continue counting\n        listIndex++\n      }\n\n      // Higher level items don't affect the count for the target level\n    }\n\n    return listIndex\n  }\n}\n","import {isSpan} from '@portabletext/schema'\nimport {isKeySegment, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObjects: EditorSelector<\n  Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return []\n  }\n\n  let endPointChildFound = false\n  const inlineObjects: Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }> = []\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObjects.push({\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      })\n      break\n    }\n  }\n\n  return inlineObjects\n}\n","import {isSpan} from '@portabletext/schema'\nimport {isKeySegment, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousInlineObjects: EditorSelector<\n  Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeySegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return []\n  }\n\n  const inlineObjects: Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }> = []\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObjects.push({\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      })\n    }\n  }\n\n  return inlineObjects\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * @public\n * @deprecated Renamed to `getSelectedValue`.\n */\nexport const getSelectedSlice: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return getSelectedValue(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelection: EditorSelector<EditorSelection> = (snapshot) => {\n  return snapshot.context.selection\n}\n","import type {PortableTextObject, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionEndChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextObject, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionStartChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return snapshot.context.value\n}\n"],"names":["getAnchorBlock","snapshot","context","selection","key","getBlockKeyFromSelectionPoint","anchor","index","blockIndexMap","get","undefined","node","value","at","path","_key","getAnchorTextBlock","anchorBlock","isTextBlock","getAnchorChild","getChildKeyFromSelectionPoint","children","find","span","getAnchorSpan","anchorChild","isPortableTextSpan","getBlockOffsets","selectionStartPoint","getSelectionStartPoint","selectionEndPoint","getSelectionEndPoint","start","spanSelectionPointToBlockOffset","selectionPoint","end","getListIndex","offset","focus","focusTextBlock","getFocusTextBlock","listItem","level","targetListItem","targetLevel","targetKey","targetIndex","listIndex","i","block","getNextInlineObjects","selectionEndPointChildKey","isKeySegment","endPointChildFound","inlineObjects","child","isSpan","push","getPreviousInlineObjects","selectionStartPointChildKey","getSelectedSlice","getSelectedValue","getSelection","getSelectionEndChild","endPoint","getFocusChild","getSelectionStartChild","startPoint","getValue"],"mappings":";;;AAQO,MAAMA,iBAERC,CAAAA,aAAa;AAChB,MAAI,CAACA,SAASC,QAAQC;AACpB;AAGF,QAAMC,MAAMC,sBAAAA,8BAA8BJ,SAASC,QAAQC,UAAUG,MAAM,GACrEC,QAAQH,MAAMH,SAASO,cAAcC,IAAIL,GAAG,IAAIM,QAChDC,OACJJ,UAAUG,SAAYT,SAASC,QAAQU,MAAMC,GAAGN,KAAK,IAAIG;AAE3D,SAAOC,QAAQP,MAAM;AAAA,IAACO;AAAAA,IAAMG,MAAM,CAAC;AAAA,MAACC,MAAMX;AAAAA,IAAAA,CAAI;AAAA,EAAA,IAAKM;AACrD,GCZaM,qBAERf,CAAAA,aAAa;AAChB,QAAMgB,cAAcjB,eAAeC,QAAQ;AAE3C,SAAOgB,eAAeC,OAAAA,YAAYjB,SAASC,SAASe,YAAYN,IAAI,IAChE;AAAA,IAACA,MAAMM,YAAYN;AAAAA,IAAMG,MAAMG,YAAYH;AAAAA,EAAAA,IAC3CJ;AACN,GCRaS,iBAMRlB,CAAAA,aAAa;AAChB,MAAI,CAACA,SAASC,QAAQC;AACpB;AAGF,QAAMc,cAAcD,mBAAmBf,QAAQ;AAE/C,MAAI,CAACgB;AACH;AAGF,QAAMb,MAAMgB,sBAAAA,8BAA8BnB,SAASC,QAAQC,UAAUG,MAAM,GAErEK,OAAOP,MACTa,YAAYN,KAAKU,SAASC,KAAMC,UAASA,KAAKR,SAASX,GAAG,IAC1DM;AAEJ,SAAOC,QAAQP,MACX;AAAA,IAACO;AAAAA,IAAMG,MAAM,CAAC,GAAGG,YAAYH,MAAM,YAAY;AAAA,MAACC,MAAMX;AAAAA,IAAAA,CAAI;AAAA,EAAA,IAC1DM;AACN,GC3Bac,gBAERvB,CAAAA,aAAa;AAChB,QAAMwB,cAAcN,eAAelB,QAAQ;AAE3C,SAAOwB,eAAeC,MAAAA,mBAAmBD,YAAYd,IAAI,IACrD;AAAA,IAACA,MAAMc,YAAYd;AAAAA,IAAMG,MAAMW,YAAYX;AAAAA,EAAAA,IAC3CJ;AACN,GCPaiB,kBAER1B,CAAAA,aAAa;AAChB,MAAI,CAACA,SAASC,QAAQC;AACpB;AAGF,QAAMyB,sBAAsBC,0BAAAA,uBAAuB5B,QAAQ,GACrD6B,oBAAoBC,uBAAAA,qBAAqB9B,QAAQ;AAEvD,MAAI,CAAC2B,uBAAuB,CAACE;AAC3B;AAGF,QAAME,QAAQC,sBAAAA,gCAAgC;AAAA,IAC5C/B,SAASD,SAASC;AAAAA,IAClBgC,gBAAgBN;AAAAA,EAAAA,CACjB,GACKO,MAAMF,sDAAgC;AAAA,IAC1C/B,SAASD,SAASC;AAAAA,IAClBgC,gBAAgBJ;AAAAA,EAAAA,CACjB;AAED,SAAOE,SAASG,MAAM;AAAA,IAACH;AAAAA,IAAOG;AAAAA,EAAAA,IAAOzB;AACvC;ACtBO,SAAS0B,aAAa;AAAA,EAC3BtB;AAGF,GAAuC;AACrC,SAAQb,CAAAA,aAAa;AACnB,UAAME,YAAY;AAAA,MAChBG,QAAQ;AAAA,QACNQ;AAAAA,QACAuB,QAAQ;AAAA,MAAA;AAAA,MAEVC,OAAO;AAAA,QACLxB;AAAAA,QACAuB,QAAQ;AAAA,MAAA;AAAA,IACV,GAGIE,iBAAiBC,0BAAAA,kBAAkB;AAAA,MACvC,GAAGvC;AAAAA,MACHC,SAAS;AAAA,QACP,GAAGD,SAASC;AAAAA,QACZC;AAAAA,MAAAA;AAAAA,IACF,CACD;AAMD,QAJI,CAACoC,kBAKHA,eAAe5B,KAAK8B,aAAa/B,UACjC6B,eAAe5B,KAAK+B,UAAUhC;AAE9B;AAGF,UAAMiC,iBAAiBJ,eAAe5B,KAAK8B,UACrCG,cAAcL,eAAe5B,KAAK+B,OAClCG,YAAYN,eAAe5B,KAAKI,MAGhC+B,cAAc7C,SAASO,cAAcC,IAAIoC,SAAS;AAExD,QAAIC,gBAAgBpC;AAClB;AAKF,QAAIqC,YAAY;AAEhB,aAASC,IAAIF,cAAc,GAAGE,KAAK,GAAGA,KAAK;AACzC,YAAMC,QAAQhD,SAASC,QAAQU,MAAMoC,CAAC;AAiBtC,UAfI,CAAC9B,OAAAA,YAAYjB,SAASC,SAAS+C,KAAK,KAKpCA,MAAMR,aAAa/B,UAAauC,MAAMP,UAAUhC,UAKhDuC,MAAMR,aAAaE,kBAKnBM,MAAMP,QAAQE;AAEhB;AAGEK,YAAMP,UAAUE,eAElBG;AAAAA,IAIJ;AAEA,WAAOA;AAAAA,EACT;AACF;ACrFO,MAAMG,uBAKRjD,CAAAA,aAAa;AAChB,QAAMsC,iBAAiBC,0BAAAA,kBAAkBvC,QAAQ,GAC3C6B,oBAAoBC,4CAAqB9B,QAAQ,GACjDkD,4BACJrB,qBAAqBsB,MAAAA,aAAatB,kBAAkBhB,KAAK,CAAC,CAAC,IACvDgB,kBAAkBhB,KAAK,CAAC,EAAEC,OAC1BL;AAEN,MAAI,CAAC6B,kBAAkB,CAACY;AACtB,WAAO,CAAA;AAGT,MAAIE,qBAAqB;AACzB,QAAMC,gBAGD,CAAA;AAEL,aAAWC,SAAShB,eAAe5B,KAAKU,UAAU;AAChD,QAAIkC,MAAMxC,SAASoC,2BAA2B;AAC5CE,2BAAqB;AACrB;AAAA,IACF;AAEA,QAAI,CAACG,OAAAA,OAAOvD,SAASC,SAASqD,KAAK,KAAKF,oBAAoB;AAC1DC,oBAAcG,KAAK;AAAA,QACjB9C,MAAM4C;AAAAA,QACNzC,MAAM,CAAC,GAAGyB,eAAezB,MAAM,YAAY;AAAA,UAACC,MAAMwC,MAAMxC;AAAAA,QAAAA,CAAK;AAAA,MAAA,CAC9D;AACD;AAAA,IACF;AAAA,EACF;AAEA,SAAOuC;AACT,GCvCaI,2BAKRzD,CAAAA,aAAa;AAChB,QAAMsC,iBAAiBC,0BAAAA,kBAAkBvC,QAAQ,GAC3C2B,sBAAsBC,iDAAuB5B,QAAQ,GACrD0D,8BACJ/B,uBAAuBwB,MAAAA,aAAaxB,oBAAoBd,KAAK,CAAC,CAAC,IAC3Dc,oBAAoBd,KAAK,CAAC,EAAEC,OAC5BL;AAEN,MAAI,CAAC6B,kBAAkB,CAACoB;AACtB,WAAO,CAAA;AAGT,QAAML,gBAGD,CAAA;AAEL,aAAWC,SAAShB,eAAe5B,KAAKU,UAAU;AAChD,QAAIkC,MAAMxC,SAAS4C;AACjB;AAGGH,WAAAA,OAAOvD,SAASC,SAASqD,KAAK,KACjCD,cAAcG,KAAK;AAAA,MACjB9C,MAAM4C;AAAAA,MACNzC,MAAM,CAAC,GAAGyB,eAAezB,MAAM,YAAY;AAAA,QAACC,MAAMwC,MAAMxC;AAAAA,MAAAA,CAAK;AAAA,IAAA,CAC9D;AAAA,EAEL;AAEA,SAAOuC;AACT,GCtCaM,mBACX3D,CAAAA,aAEO4D,0BAAAA,iBAAiB5D,QAAQ,GCLrB6D,eAAiD7D,CAAAA,aACrDA,SAASC,QAAQC,WCEb4D,uBAMR9D,CAAAA,aAAa;AAChB,QAAM+D,WAAWjC,sBAAAA,qBAAqB9B,SAASC,QAAQC,SAAS;AAEhE,MAAK6D;AAIL,WAAOC,wCAAc;AAAA,MACnB,GAAGhE;AAAAA,MACHC,SAAS;AAAA,QACP,GAAGD,SAASC;AAAAA,QACZC,WAAW;AAAA,UACTG,QAAQ0D;AAAAA,UACR1B,OAAO0B;AAAAA,QAAAA;AAAAA,MACT;AAAA,IACF,CACD;AACH,GCvBaE,yBAMRjE,CAAAA,aAAa;AAChB,QAAMkE,aAAatC,sBAAAA,uBAAuB5B,SAASC,QAAQC,SAAS;AAEpE,MAAKgE;AAIL,WAAOF,wCAAc;AAAA,MACnB,GAAGhE;AAAAA,MACHC,SAAS;AAAA,QACP,GAAGD,SAASC;AAAAA,QACZC,WAAW;AAAA,UACTG,QAAQ6D;AAAAA,UACR7B,OAAO6B;AAAAA,QAAAA;AAAAA,MACT;AAAA,IACF,CACD;AACH,GC1BaC,WACXnE,CAAAA,aAEOA,SAASC,QAAQU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}