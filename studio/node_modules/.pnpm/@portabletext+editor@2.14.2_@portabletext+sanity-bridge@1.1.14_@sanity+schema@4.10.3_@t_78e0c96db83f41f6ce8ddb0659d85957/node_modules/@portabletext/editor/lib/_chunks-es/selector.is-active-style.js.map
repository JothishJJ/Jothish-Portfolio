{"version":3,"file":"selector.is-active-style.js","sources":["../../src/selectors/selector.get-focus-inline-object.ts","../../src/selectors/selector.get-selected-blocks.ts","../../src/selectors/selector.get-selection-end-block.ts","../../src/selectors/selector.get-selection-start-block.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts","../../src/selectors/selector.is-selecting-entire-blocks.ts","../../src/types/paths.ts","../../src/utils/util.is-selection-expanded.ts","../../src/selectors/selector.get-next-span.ts","../../src/selectors/selector.get-previous-span.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.get-mark-state.ts","../../src/selectors/selector.get-active-decorators.ts","../../src/selectors/selector.get-trimmed-selection.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.get-active-annotation-marks.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.get-focus-block-object.ts","../../src/selectors/selector.get-next-block.ts","../../src/selectors/selector.get-previous-block.ts","../../src/selectors/selector.get-first-block.ts","../../src/selectors/selector.get-last-block.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts","../../src/selectors/selector.get-focus-list-block.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-selected-text-blocks.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.is-active-style.ts"],"sourcesContent":["import {isPortableTextSpan, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusInlineObject: EditorSelector<\n  {node: PortableTextObject; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && !isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: BlockPath}> = []\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const endPoint = getSelectionEndPoint(snapshot.context.selection)\n    const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n    const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey)\n    const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n    if (pointBlockIndex === undefined || endBlockIndex === undefined) {\n      return false\n    }\n\n    if (pointBlockIndex > endBlockIndex) {\n      // The point block is after the end block.\n      return true\n    }\n\n    if (pointBlockIndex < endBlockIndex) {\n      // The point block is before the end block.\n      return false\n    }\n\n    // The point block is the same as the end block.\n    const pointBlock = snapshot.context.value.at(pointBlockIndex)\n\n    if (!pointBlock) {\n      // The point block is not in the value.\n      return false\n    }\n\n    if (!isTextBlock(snapshot.context, pointBlock)) {\n      // The point block is not a text block.\n      // Since the point block is the same as the end block, the point is not\n      // after the selection.\n      return false\n    }\n\n    let pointChildIndex: number | undefined\n    let endChildIndex: number | undefined\n\n    let childIndex = -1\n\n    // The point block is the same as the end block, so we need to find the\n    // child indices and compare them.\n    for (const child of pointBlock.children) {\n      childIndex++\n\n      if (child._key === pointChildKey && child._key === endChildKey) {\n        return point.offset > endPoint.offset\n      }\n\n      if (child._key === pointChildKey) {\n        pointChildIndex = childIndex\n      }\n\n      if (child._key === endChildKey) {\n        endChildIndex = childIndex\n      }\n\n      if (pointChildIndex !== undefined && endChildIndex !== undefined) {\n        break\n      }\n    }\n\n    if (pointChildIndex === undefined || endChildIndex === undefined) {\n      return false\n    }\n\n    return pointChildIndex > endChildIndex\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const startPoint = getSelectionStartPoint(snapshot.context.selection)\n    const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n    const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey)\n\n    if (startBlockIndex === undefined || pointBlockIndex === undefined) {\n      return false\n    }\n\n    if (pointBlockIndex < startBlockIndex) {\n      // The point block is before the start block.\n      return true\n    }\n\n    if (pointBlockIndex > startBlockIndex) {\n      // The point block is after the start block.\n      return false\n    }\n\n    // The point block is the same as the start block.\n    const pointBlock = snapshot.context.value.at(pointBlockIndex)\n\n    if (!pointBlock) {\n      // The point block is not in the value.\n      return false\n    }\n\n    if (!isTextBlock(snapshot.context, pointBlock)) {\n      // The point block is not a text block.\n      // Since the point block is the same as the start block, the point is not\n      // before the selection.\n      return false\n    }\n\n    let pointChildIndex: number | undefined\n    let startChildIndex: number | undefined\n\n    let childIndex = -1\n\n    // The point block is the same as the start block, so we need to find the\n    // child indices and compare them.\n    for (const child of pointBlock.children) {\n      childIndex++\n\n      if (child._key === pointChildKey && child._key === startChildKey) {\n        return point.offset < startPoint.offset\n      }\n\n      if (child._key === pointChildKey) {\n        pointChildIndex = childIndex\n      }\n\n      if (child._key === startChildKey) {\n        startChildIndex = childIndex\n      }\n\n      if (pointChildIndex !== undefined && startChildIndex !== undefined) {\n        break\n      }\n    }\n\n    if (pointChildIndex === undefined || startChildIndex === undefined) {\n      return false\n    }\n\n    return pointChildIndex < startChildIndex\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    const originalSelectionStartPoint = getSelectionStartPoint(snapshot)\n    const originalSelectionEndPoint = getSelectionEndPoint(snapshot)\n\n    if (\n      !selectionStartPoint ||\n      !selectionEndPoint ||\n      !originalSelectionStartPoint ||\n      !originalSelectionEndPoint\n    ) {\n      return false\n    }\n\n    const startPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionStartPoint,\n    )\n    const endPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionEndPoint,\n    )\n\n    if (\n      startPointEqualToOriginalStartPoint &&\n      endPointEqualToOriginalEndPoint\n    ) {\n      return true\n    }\n\n    const startPointBeforeSelection =\n      isPointBeforeSelection(selectionStartPoint)(snapshot)\n    const startPointAfterSelection =\n      isPointAfterSelection(selectionStartPoint)(snapshot)\n    const endPointBeforeSelection =\n      isPointBeforeSelection(selectionEndPoint)(snapshot)\n    const endPointAfterSelection =\n      isPointAfterSelection(selectionEndPoint)(snapshot)\n\n    const originalStartPointBeforeStartPoint = isPointBeforeSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n    const originalStartPointAfterStartPoint = isPointAfterSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n\n    const originalEndPointBeforeEndPoint = isPointBeforeSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n    const originalEndPointAfterEndPoint = isPointAfterSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n\n    const startPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionEndPoint,\n    )\n    const endPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionStartPoint,\n    )\n\n    // If all checks fail then we can deduce that the selection does not exist\n    // and there doesn't overlap with the snapshot selection\n    if (\n      !endPointEqualToOriginalStartPoint &&\n      !startPointEqualToOriginalEndPoint &&\n      !originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return false\n    }\n\n    if (endPointBeforeSelection && !endPointEqualToOriginalStartPoint) {\n      return false\n    }\n\n    if (startPointAfterSelection && !startPointEqualToOriginalEndPoint) {\n      return false\n    }\n\n    if (\n      !originalStartPointBeforeStartPoint &&\n      originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      originalEndPointAfterEndPoint\n    ) {\n      return !endPointEqualToOriginalStartPoint\n    }\n\n    if (\n      originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return !startPointEqualToOriginalEndPoint\n    }\n\n    if (\n      !startPointAfterSelection ||\n      !startPointBeforeSelection ||\n      !endPointAfterSelection ||\n      !endPointBeforeSelection\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: startBlock,\n  })\n  const endBlockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: endBlock,\n  })\n\n  return (\n    isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n","import type {Path} from '@sanity/types'\n\n/**\n * @public\n */\nexport type BlockPath = [{_key: string}]\n\n/**\n * @public\n */\nexport function isBlockPath(path: Path): path is BlockPath {\n  const firstSegment = path.at(0)\n\n  return (\n    path.length === 1 &&\n    firstSegment !== undefined &&\n    isRecord(firstSegment) &&\n    '_key' in firstSegment &&\n    typeof firstSegment._key === 'string'\n  )\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type AnnotationPath = [{_key: string}, 'markDefs', {_key: string}]\n\n/**\n * @public\n */\nexport type ChildPath = [{_key: string}, 'children', {_key: string}]\n","import type {EditorSelection} from '../types/editor'\nimport {isSelectionCollapsed} from './util.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isSelectionExpanded(selection: EditorSelection) {\n  if (!selection) {\n    return false\n  }\n\n  return !isSelectionCollapsed(selection)\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {KeyedSegment, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionEndBlock || !selectionEndPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionEndBlock.node)) {\n    return undefined\n  }\n\n  const selectionEndPointChildKey =\n    getChildKeyFromSelectionPoint(selectionEndPoint)\n\n  let endPointChildFound = false\n  let nextSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionEndBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (isSpan(snapshot.context, child) && endPointChildFound) {\n      nextSpan = {\n        node: child,\n        path: [...selectionEndBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return nextSpan\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {KeyedSegment, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n\n  if (!selectionStartBlock || !selectionStartPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionStartBlock.node)) {\n    return undefined\n  }\n\n  const selectionStartPointChildKey =\n    getChildKeyFromSelectionPoint(selectionStartPoint)\n\n  let previousSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionStartBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (isSpan(snapshot.context, child)) {\n      previousSpan = {\n        node: child,\n        path: [...selectionStartBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return previousSpan\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot)\n  const endPoint = getSelectionEndPoint(snapshot)\n\n  if (!startPoint || !endPoint) {\n    return selectedSpans\n  }\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const startSpanKey = getChildKeyFromSelectionPoint(startPoint)\n  const endSpanKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedSpans\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  let startBlockFound = false\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (startBlockFound) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isBlockPath} from '../types/paths'\nimport {blockOffsetToSpanSelectionPoint} from '../utils/util.block-offset'\nimport {isSelectionExpanded} from '../utils/util.is-selection-expanded'\nimport {getFocusSpan} from './selector.get-focus-span'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextSpan} from './selector.get-next-span'\nimport {getPreviousSpan} from './selector.get-previous-span'\nimport {getSelectedSpans} from './selector.get-selected-spans'\n\n/**\n * @beta\n */\nexport type MarkState =\n  | {\n      state: 'unchanged'\n      marks: Array<string>\n    }\n  | {\n      state: 'changed'\n      marks: Array<string>\n      previousMarks: Array<string>\n    }\n\n/**\n * Given that text is inserted at the current position, what marks should\n * be applied?\n * @beta\n */\nexport const getMarkState: EditorSelector<MarkState | undefined> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  let selection = snapshot.context.selection\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  if (!focusTextBlock) {\n    return undefined\n  }\n\n  if (isBlockPath(selection.anchor.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.anchor.path,\n        offset: selection.anchor.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          anchor: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  if (isBlockPath(selection.focus.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.focus.path,\n        offset: selection.focus.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          focus: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  const focusSpan = getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n\n  if (!focusSpan) {\n    return undefined\n  }\n\n  if (isSelectionExpanded(selection)) {\n    const selectedSpans = getSelectedSpans({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    let index = 0\n    let marks: Array<string> = []\n\n    for (const span of selectedSpans) {\n      if (index === 0) {\n        marks = span.node.marks ?? []\n      } else {\n        if (span.node.marks?.length === 0) {\n          marks = []\n          continue\n        }\n\n        marks = marks.filter((mark) =>\n          (span.node.marks ?? []).some((spanMark) => spanMark === mark),\n        )\n      }\n\n      index++\n    }\n\n    return {\n      state: 'unchanged',\n      marks,\n    }\n  }\n\n  const decorators = snapshot.context.schema.decorators.map(\n    (decorator) => decorator.name,\n  )\n  const marks = focusSpan.node.marks ?? []\n  const marksWithoutAnnotations = marks.filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  const spanHasAnnotations = marks.length > marksWithoutAnnotations.length\n\n  const spanIsEmpty = focusSpan.node.text.length === 0\n\n  const atTheBeginningOfSpan = snapshot.context.selection.anchor.offset === 0\n  const atTheEndOfSpan =\n    snapshot.context.selection.anchor.offset === focusSpan.node.text.length\n\n  const previousSpan = getPreviousSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpan = getNextSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpanAnnotations =\n    nextSpan?.node?.marks?.filter((mark) => !decorators.includes(mark)) ?? []\n  const spanAnnotations = marks.filter((mark) => !decorators.includes(mark))\n\n  const previousSpanHasAnnotations = previousSpan\n    ? previousSpan.node.marks?.some((mark) => !decorators.includes(mark))\n    : false\n  const previousSpanHasSameAnnotations = previousSpan\n    ? previousSpan.node.marks\n        ?.filter((mark) => !decorators.includes(mark))\n        .every((mark) => marks.includes(mark))\n    : false\n  const previousSpanHasSameAnnotation = previousSpan\n    ? previousSpan.node.marks?.some(\n        (mark) => !decorators.includes(mark) && marks.includes(mark),\n      )\n    : false\n\n  const previousSpanHasSameMarks = previousSpan\n    ? previousSpan.node.marks?.every((mark) => marks.includes(mark))\n    : false\n  const nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) =>\n    nextSpanAnnotations?.includes(mark),\n  )\n\n  if (spanHasAnnotations && !spanIsEmpty) {\n    if (atTheBeginningOfSpan) {\n      if (previousSpanHasSameMarks) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotations) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotation) {\n        return {\n          state: 'unchanged',\n          previousMarks: marks,\n          marks: focusSpan.node.marks ?? [],\n        }\n      } else if (!previousSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n    }\n\n    if (atTheEndOfSpan) {\n      if (\n        (nextSpan &&\n          nextSpanSharesSomeAnnotations &&\n          nextSpanAnnotations.length < spanAnnotations.length) ||\n        !nextSpanSharesSomeAnnotations\n      ) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: nextSpan?.node.marks ?? [],\n        }\n      }\n\n      if (!nextSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n    }\n  }\n\n  if (atTheBeginningOfSpan && !spanIsEmpty && !!previousSpan) {\n    if (previousSpanHasAnnotations) {\n      return {\n        state: 'changed',\n        marks,\n        previousMarks: previousSpan?.node.marks ?? [],\n      }\n    } else {\n      return {\n        state: 'changed',\n        previousMarks: marks,\n        marks: (previousSpan?.node.marks ?? []).filter((mark) =>\n          decorators.includes(mark),\n        ),\n      }\n    }\n  }\n\n  return {\n    state: 'unchanged',\n    marks,\n  }\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveDecorators(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const decoratorState = snapshot.decoratorState\n  const markState = getMarkState(snapshot)\n  const decorators = schema.decorators.map((decorator) => decorator.name)\n\n  const markStateDecorators = (markState?.marks ?? []).filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  let activeDecorators: Array<string> = markStateDecorators\n\n  for (const decorator in decoratorState) {\n    if (decoratorState[decorator] === false) {\n      activeDecorators = activeDecorators.filter(\n        (activeDecorator) => activeDecorator !== decorator,\n      )\n    } else if (decoratorState[decorator] === true) {\n      if (!activeDecorators.includes(decorator)) {\n        activeDecorators.push(decorator)\n      }\n    }\n  }\n\n  return activeDecorators\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {isEmptyTextBlock} from '../utils/util.is-empty-text-block'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const getTrimmedSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return snapshot.context.selection\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return snapshot.context.selection\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return snapshot.context.selection\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  let startBlockFound = false\n  let adjustedStartPoint: EditorSelectionPoint | undefined\n  let trimStartPoint = false\n  let adjustedEndPoint: EditorSelectionPoint | undefined\n  let trimEndPoint = false\n  let previousPotentialEndpoint:\n    | {blockKey: string; span: PortableTextSpan}\n    | undefined\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n\n      if (\n        isTextBlock(snapshot.context, block) &&\n        isEmptyTextBlock(snapshot.context, block)\n      ) {\n        continue\n      }\n    }\n\n    if (!startBlockFound) {\n      continue\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (\n      block._key === endBlockKey &&\n      isEmptyTextBlock(snapshot.context, block)\n    ) {\n      break\n    }\n\n    for (const child of block.children) {\n      if (child._key === endChildKey) {\n        if (!isSpan(snapshot.context, child) || endPoint.offset === 0) {\n          adjustedEndPoint = previousPotentialEndpoint\n            ? {\n                path: [\n                  {_key: previousPotentialEndpoint.blockKey},\n                  'children',\n                  {_key: previousPotentialEndpoint.span._key},\n                ],\n                offset: previousPotentialEndpoint.span.text.length,\n              }\n            : undefined\n\n          trimEndPoint = true\n          break\n        }\n      }\n\n      if (trimStartPoint) {\n        const lonelySpan =\n          isSpan(snapshot.context, child) && block.children.length === 1\n\n        if (\n          (isSpan(snapshot.context, child) && child.text.length > 0) ||\n          lonelySpan\n        ) {\n          adjustedStartPoint = {\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n            offset: 0,\n          }\n          previousPotentialEndpoint = {blockKey: block._key, span: child}\n          trimStartPoint = false\n        }\n\n        continue\n      }\n\n      if (child._key === startChildKey) {\n        if (!isSpan(snapshot.context, child)) {\n          trimStartPoint = true\n          continue\n        }\n\n        if (startPoint.offset === child.text.length) {\n          trimStartPoint = true\n          previousPotentialEndpoint =\n            child.text.length > 0\n              ? {blockKey: block._key, span: child}\n              : previousPotentialEndpoint\n          continue\n        }\n      }\n\n      previousPotentialEndpoint =\n        isSpan(snapshot.context, child) && child.text.length > 0\n          ? {blockKey: block._key, span: child}\n          : previousPotentialEndpoint\n    }\n\n    if (block._key === endBlockKey) {\n      break\n    }\n  }\n\n  const trimmedSelection = snapshot.context.selection.backward\n    ? {\n        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n        focus: adjustedStartPoint ?? startPoint,\n        backward: true,\n      }\n    : {\n        anchor: adjustedStartPoint ?? startPoint,\n        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n      }\n\n  if (\n    isSelectionCollapsed({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n  ) {\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n\n    if (\n      focusTextBlock &&\n      !isEmptyTextBlock(snapshot.context, focusTextBlock.node)\n    ) {\n      return null\n    }\n  }\n\n  return trimmedSelection\n}\n","import {isSpan} from '@portabletext/schema'\nimport {isKeySegment, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils/util.block-offset'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        context: snapshot.context,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveAnnotationsMarks(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const markState = getMarkState(snapshot)\n\n  return (markState?.marks ?? []).filter(\n    (mark) =>\n      !schema.decorators.map((decorator) => decorator.name).includes(mark),\n  )\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveAnnotationsMarks} from './selector.get-active-annotation-marks'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * Check whether an annotation is active in the given `snapshot`.\n *\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n  options?: {\n    /**\n     * Choose whether the annotation has to take up the entire selection in the\n     * `snapshot` or if the annotation can be partially selected.\n     *\n     * Defaults to 'full'\n     */\n    mode?: 'partial' | 'full'\n  },\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const mode = options?.mode ?? 'full'\n\n    if (mode === 'partial') {\n      const selectedValue = getSelectedValue(snapshot)\n\n      const selectionMarkDefs = selectedValue.flatMap((block) =>\n        isTextBlock(snapshot.context, block) ? (block.markDefs ?? []) : [],\n      )\n\n      return selectionMarkDefs.some((markDef) => markDef._type === annotation)\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isTextBlock(snapshot.context, block.node)\n        ? (block.node.markDefs ?? [])\n        : [],\n    )\n    const activeAnnotations = getActiveAnnotationsMarks(snapshot)\n    const activeMarkDefs = selectionMarkDefs.filter(\n      (markDef) =>\n        markDef._type === annotation &&\n        activeAnnotations.includes(markDef._key),\n    )\n\n    return activeMarkDefs.length > 0\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key)\n\n  if (index === undefined || index === snapshot.context.value.length - 1) {\n    return undefined\n  }\n\n  const nextBlock = snapshot.context.value.at(index + 1)\n\n  return nextBlock\n    ? {node: nextBlock, path: [{_key: nextBlock._key}]}\n    : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key)\n\n  if (index === undefined || index === 0) {\n    return undefined\n  }\n\n  const previousBlock = snapshot.context.value.at(index - 1)\n\n  return previousBlock\n    ? {node: previousBlock, path: [{_key: previousBlock._key}]}\n    : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = getBlockEndPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = getBlockStartPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {isListBlock} from '../utils/parse-blocks'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node)\n    ? {node: focusTextBlock.node, path: focusTextBlock.path}\n    : undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveDecorators} from './selector.get-active-decorators'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    const activeDecorators = getActiveDecorators(snapshot)\n\n    return activeDecorators.includes(decorator)\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getMarkState} from './selector.get-mark-state'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const markState = getMarkState(snapshot)\n\n  const activeAnnotations = (markState?.marks ?? []).filter(\n    (mark) =>\n      !snapshot.context.schema.decorators\n        .map((decorator) => decorator.name)\n        .includes(mark),\n  )\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isTextBlock(snapshot.context, block.node)\n      ? (block.node.markDefs ?? [])\n      : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    activeAnnotations.includes(markDef._key),\n  )\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: BlockPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedTextBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedTextBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {PortableTextListBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n"],"names":["getFocusInlineObject","snapshot","focusChild","getFocusChild","isPortableTextSpan","node","path","undefined","getSelectedBlocks","context","selection","selectedBlocks","startPoint","getSelectionStartPoint","endPoint","getSelectionEndPoint","startKey","getBlockKeyFromSelectionPoint","endKey","startBlockIndex","blockIndexMap","get","endBlockIndex","slicedValue","value","slice","block","_key","push","length","getSelectionEndBlock","getFocusBlock","anchor","focus","getSelectionStartBlock","backward","isPointAfterSelection","point","endBlockKey","endChildKey","getChildKeyFromSelectionPoint","pointBlockKey","pointChildKey","pointBlockIndex","pointBlock","at","isTextBlock","pointChildIndex","endChildIndex","childIndex","child","children","offset","isPointBeforeSelection","startBlockKey","startChildKey","startChildIndex","isOverlappingSelection","selectionStartPoint","selectionEndPoint","originalSelectionStartPoint","originalSelectionEndPoint","startPointEqualToOriginalStartPoint","isEqualSelectionPoints","endPointEqualToOriginalEndPoint","startPointBeforeSelection","startPointAfterSelection","endPointBeforeSelection","endPointAfterSelection","originalStartPointBeforeStartPoint","originalStartPointAfterStartPoint","originalEndPointBeforeEndPoint","originalEndPointAfterEndPoint","startPointEqualToOriginalEndPoint","endPointEqualToOriginalStartPoint","isSelectingEntireBlocks","startBlock","endBlock","startBlockStartPoint","getBlockStartPoint","endBlockEndPoint","getBlockEndPoint","isBlockPath","firstSegment","isRecord","isSelectionExpanded","isSelectionCollapsed","getNextSpan","selectionEndBlock","selectionEndPointChildKey","endPointChildFound","nextSpan","isSpan","getPreviousSpan","selectionStartBlock","selectionStartPointChildKey","previousSpan","getSelectedSpans","selectedSpans","startSpanKey","endSpanKey","startBlockFound","text","getMarkState","getFocusTextBlock","spanSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","focusSpan","getFocusSpan","index","marks","span","filter","mark","some","spanMark","state","decorators","schema","map","decorator","name","marksWithoutAnnotations","includes","spanHasAnnotations","spanIsEmpty","atTheBeginningOfSpan","atTheEndOfSpan","nextSpanAnnotations","spanAnnotations","previousSpanHasAnnotations","previousSpanHasSameAnnotations","every","previousSpanHasSameAnnotation","previousSpanHasSameMarks","nextSpanSharesSomeAnnotations","previousMarks","getActiveDecorators","decoratorState","markState","activeDecorators","activeDecorator","getTrimmedSelection","adjustedStartPoint","trimStartPoint","adjustedEndPoint","trimEndPoint","previousPotentialEndpoint","isEmptyTextBlock","blockKey","lonelySpan","trimmedSelection","focusTextBlock","getNextInlineObject","isKeySegment","inlineObject","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","getPreviousInlineObject","blockStartPoint","textDirectlyBefore","getSelectionText","split","nextInlineObject","blockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","caretWordEndSelectionPoint","caretWordSelection","getActiveAnnotationsMarks","isActiveAnnotation","annotation","options","mode","getSelectedValue","flatMap","markDefs","markDef","_type","selectionMarkDefs","activeAnnotations","getFocusBlockObject","focusBlock","getNextBlock","nextBlock","getPreviousBlock","previousBlock","getFirstBlock","getLastBlock","isAtTheEndOfBlock","isAtTheStartOfBlock","getFocusListBlock","isListBlock","isActiveDecorator","getActiveAnnotations","getSelectedTextBlocks","selectedTextBlocks","getActiveListItem","firstTextBlock","firstListItem","listItem","isActiveListItem","getActiveStyle","firstStyle","style","isActiveStyle"],"mappings":"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"}