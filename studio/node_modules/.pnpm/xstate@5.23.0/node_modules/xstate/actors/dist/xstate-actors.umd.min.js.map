{"version":3,"file":"xstate-actors.umd.min.js","sources":["../../src/Mailbox.ts","../../src/constants.ts","../../src/dev/index.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/utils.ts","../../src/system.ts","../../src/createActor.ts","../../src/eventUtils.ts","../../src/actors/transition.ts","../../src/actors/callback.ts","../../src/actors/observable.ts","../../src/actors/promise.ts","../../src/actors/index.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if ((w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import isDevelopment from '#is-development';\nimport { isMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { TARGETLESS_KEY } from './constants.ts';\nimport type {\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  AnyTransitionConfig,\n  ErrorActorEvent,\n  EventObject,\n  InvokeConfig,\n  MachineContext,\n  Mapper,\n  NonReducibleUnknown,\n  Observer,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  TransitionConfigTarget\n} from './types.ts';\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key]!, childStateValue[key]!);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n\n  const result: string[] = [];\n  let segment = '';\n\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n\n  result.push(segment);\n\n  return result;\n}\n\nfunction toStateValue(stateValue: StateLike<any> | StateValue): StateValue {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nfunction toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nfunction isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${index}.${stateNodeId}`;\n}\n\nexport function resolveReferencedActor(machine: AnyStateMachine, src: string) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/)!;\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke!;\n  return (\n    Array.isArray(invokeConfig)\n      ? invokeConfig[indexStr as any]\n      : (invokeConfig as InvokeConfig<\n          any,\n          any,\n          any,\n          any,\n          any,\n          any,\n          any, // TEmitted\n          any // TMeta\n        >)\n  ).src;\n}\n\nexport function getAllOwnEventDescriptors(snapshot: AnyMachineSnapshot) {\n  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];\n}\n","import { InspectionEvent } from './inspection.ts';\nimport {\n  AnyEventObject,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  HomomorphicOmit,\n  EventObject,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\ninterface ScheduledEvent {\n  id: string;\n  event: EventObject;\n  startedAt: number; // timestamp\n  delay: number;\n  source: AnyActorRef;\n  target: AnyActorRef;\n}\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\ninterface Scheduler {\n  schedule(\n    source: AnyActorRef,\n    target: AnyActorRef,\n    event: EventObject,\n    delay: number,\n    id: string | undefined\n  ): void;\n  cancel(source: AnyActorRef, id: string): void;\n  cancelAll(actorRef: AnyActorRef): void;\n}\n\ntype ScheduledEventId = string & { __scheduledEventId: never };\n\nfunction createScheduledEventId(\n  actorRef: AnyActorRef,\n  id: string\n): ScheduledEventId {\n  return `${actorRef.sessionId}.${id}` as ScheduledEventId;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /** @internal */\n  _bookId: () => string;\n  /** @internal */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /** @internal */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /** @internal */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n  getAll: () => Partial<T['actors']>;\n\n  inspect: (\n    observer:\n      | Observer<InspectionEvent>\n      | ((inspectionEvent: InspectionEvent) => void)\n  ) => Subscription;\n  /** @internal */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /** @internal */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n  scheduler: Scheduler;\n  getSnapshot: () => {\n    _scheduledEvents: Record<string, ScheduledEvent>;\n  };\n  /** @internal */\n  _snapshot: {\n    _scheduledEvents: Record<ScheduledEventId, ScheduledEvent>;\n  };\n  start: () => void;\n  _clock: Clock;\n  _logger: (...args: any[]) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef,\n  options: {\n    clock: Clock;\n    logger: (...args: any[]) => void;\n    snapshot?: unknown;\n  }\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const inspectionObservers = new Set<Observer<InspectionEvent>>();\n  const timerMap: { [id: ScheduledEventId]: number } = {};\n  const { clock, logger } = options;\n\n  const scheduler: Scheduler = {\n    schedule: (\n      source,\n      target,\n      event,\n      delay,\n      id = Math.random().toString(36).slice(2)\n    ) => {\n      const scheduledEvent: ScheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n\n        system._relay(source, target, event);\n      }, delay);\n\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id: string) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: (actorRef) => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent =\n          system._snapshot._scheduledEvents[\n            scheduledEventId as ScheduledEventId\n          ];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = (event: InspectionEvent) => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent: InspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach((observer) =>\n      observer.next?.(resolvedInspectionEvent)\n    );\n  };\n\n  const system: ActorSystem<T> = {\n    _snapshot: {\n      _scheduledEvents:\n        (options?.snapshot && (options.snapshot as any).scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any] | undefined;\n    },\n    getAll: () => {\n      return Object.fromEntries(keyedActors.entries()) as Partial<T['actors']>;\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observerOrFn) => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent as any,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: { ...system._snapshot._scheduledEvents }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const { source, target, event, delay, id } =\n          scheduledEvents[scheduledId as ScheduledEventId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n\n  return system;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { AnyActorSystem, Clock, createSystem } from './system.ts';\n\n// those are needed to make JSDoc `@link` work properly\nimport type {\n  fromObservable,\n  fromEventObservable\n} from './actors/observable.ts';\nimport type { fromCallback } from './actors/callback.ts';\nimport type { fromPromise } from './actors/promise.ts';\nimport type { fromTransition } from './actors/transition.ts';\nimport type { createMachine } from './createMachine.ts';\n\nexport let executingCustomAction: boolean = false;\n\nimport type {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  ConditionalRequired,\n  DoneActorEvent,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  IsNotNever,\n  Snapshot,\n  SnapshotFrom\n} from './types.ts';\nimport {\n  ActorOptions,\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport const $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nexport enum ProcessingStatus {\n  NotStarted = 0,\n  Running = 1,\n  Stopped = 2\n}\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nexport class Actor<TLogic extends AnyActorLogic>\n  implements\n    ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>\n{\n  /** The current internal state of the actor. */\n  private _snapshot!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as\n   * delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /** The unique identifier for this actor relative to its parent. */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private eventListeners: Map<\n    string,\n    Set<(emittedEvent: EmittedFrom<TLogic>) => void>\n  > = new Map();\n  private logger: (...args: any[]) => void;\n\n  /** @internal */\n  public _processingStatus: ProcessingStatus = ProcessingStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: AnyActorRef;\n  /** @internal */\n  public _syncSnapshot?: boolean;\n  public ref: ActorRef<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    EmittedFrom<TLogic>\n  >;\n  // TODO: add typings for system\n  private _actorScope: ActorScope<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    AnyActorSystem,\n    EmittedFrom<TLogic>\n  >;\n\n  public systemId: string | undefined;\n\n  /** The globally unique process ID for this invocation. */\n  public sessionId: string;\n\n  /** The system to which this actor belongs. */\n  public system: AnyActorSystem;\n  private _doneEvent?: DoneActorEvent;\n\n  public src: string | AnyActorLogic;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(\n    public logic: TLogic,\n    options?: ActorOptions<TLogic>\n  ) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n\n    const { clock, logger, parent, syncSnapshot, id, systemId, inspect } =\n      resolvedOptions;\n\n    this.system = parent\n      ? parent.system\n      : createSystem(this, {\n          clock,\n          logger\n        });\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions as ActorOptions<TLogic> &\n      typeof defaultOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      },\n      emit: (emittedEvent) => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [\n          ...(listeners ? listeners.values() : []),\n          ...(wildcardListener ? wildcardListener.values() : [])\n        ];\n        for (const handler of allListeners) {\n          try {\n            handler(emittedEvent);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n      },\n      actionExecutor: (action) => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n\n    if (systemId) {\n      this.systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this._initState(options?.snapshot ?? options?.state);\n\n    if (systemId && (this._snapshot as any).status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n\n  private _initState(persistedState?: Snapshot<unknown>) {\n    try {\n      this._snapshot = persistedState\n        ? this.logic.restoreSnapshot\n          ? this.logic.restoreSnapshot(persistedState, this._actorScope)\n          : persistedState\n        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      } as any;\n    }\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...(snapshot as any),\n          status: 'error',\n          error: err\n        };\n      }\n    }\n\n    switch ((this._snapshot as any).status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._snapshot as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (snapshot: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((snapshot: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch ((this._snapshot as any).status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error': {\n          const err = (this._snapshot as any).error;\n          if (!observer.error) {\n            reportUnhandledError(err);\n          } else {\n            try {\n              observer.error(err);\n            } catch (err) {\n              reportUnhandledError(err);\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  public on<TType extends EmittedFrom<TLogic>['type'] | '*'>(\n    type: TType,\n    handler: (\n      emitted: EmittedFrom<TLogic> &\n        (TType extends '*' ? unknown : { type: TType })\n    ) => void\n  ): Subscription {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  public start(): this {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent!, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this.systemId) {\n      this.system._set(this.systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n\n    const status = (this._snapshot as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._snapshot,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        return this;\n    }\n\n    if (!this._parent) {\n      this.system.start();\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...(this._snapshot as any),\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(\n        this._snapshot,\n        event,\n        this._actorScope\n      );\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._snapshot = {\n        ...(this._snapshot as any),\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _reportError(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _error(err: unknown): void {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(\n        this,\n        this._parent,\n        createErrorActorEvent(this.id, err)\n      );\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  private _stopProcedure(): this {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /** @internal */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n  public getPersistedSnapshot(): Snapshot<unknown>;\n  public getPersistedSnapshot(options?: unknown): Snapshot<unknown> {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    if (isDevelopment && !this._snapshot) {\n      throw new Error(\n        `Snapshot can't be read while the actor initializes itself`\n      );\n    }\n    return this._snapshot;\n  }\n}\n\nexport type RequiredActorOptionsKeys<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  ...[options]: ConditionalRequired<\n    [\n      options?: ActorOptions<TLogic> & {\n        [K in RequiredActorOptionsKeys<TLogic>]: unknown;\n      }\n    ],\n    IsNotNever<RequiredActorOptionsKeys<TLogic>>\n  >\n): Actor<TLogic> {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\nexport type Interpreter = typeof Actor;\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id: string) {\n  return { type: `xstate.after.${delayRef}.${id}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  error?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, error, actorId: id };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","import { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  ActorScope,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFromLogic<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  transition: (\n    snapshot: TContext,\n    event: TEvent,\n    actorScope: ActorScope<\n      TransitionSnapshot<TContext>,\n      TEvent,\n      TSystem,\n      TEmitted\n    >\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput, TEmitted> {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope as any)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  AnyActorRef,\n  AnyEventObject,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types';\n\ninterface CallbackInstanceState<TEvent extends EventObject> {\n  receivers: Set<(e: TEvent) => void> | undefined;\n  dispose: (() => void) | void;\n}\n\nconst instanceStates = /* #__PURE__ */ new WeakMap<\n  AnyActorRef,\n  CallbackInstanceState<any>\n>();\n\nexport type CallbackSnapshot<TInput> = Snapshot<undefined> & {\n  input: TInput;\n};\n\nexport type CallbackActorLogic<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  CallbackSnapshot<TInput>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\nexport type CallbackActorRef<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown\n> = ActorRefFromLogic<CallbackActorLogic<TEvent, TInput>>;\n\ntype Receiver<TEvent extends EventObject> = (\n  listener: {\n    bivarianceHack(event: TEvent): void;\n  }['bivarianceHack']\n) => void;\n\nexport type CallbackLogicFunction<\n  TEvent extends EventObject = AnyEventObject,\n  TSentEvent extends EventObject = AnyEventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ({\n  input,\n  system,\n  self,\n  sendBack,\n  receive,\n  emit\n}: {\n  /**\n   * Data that was provided to the callback actor\n   *\n   * @see {@link https://stately.ai/docs/input | Input docs}\n   */\n  input: TInput;\n  /** The actor system to which the callback actor belongs */\n  system: AnyActorSystem;\n  /** The parent actor of the callback actor */\n  self: CallbackActorRef<TEvent>;\n  /** A function that can send events back to the parent actor */\n  sendBack: (event: TSentEvent) => void;\n  /**\n   * A function that can be called with a listener function argument; the\n   * listener is then called whenever events are received by the callback actor\n   */\n  receive: Receiver<TEvent>;\n  emit: (emitted: TEmitted) => void;\n}) => (() => void) | void;\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromCallback<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  callback: CallbackLogicFunction<TEvent, AnyEventObject, TInput, TEmitted>\n): CallbackActorLogic<TEvent, TInput, TEmitted> {\n  const logic: CallbackActorLogic<TEvent, TInput, TEmitted> = {\n    config: callback,\n    start: (state, actorScope) => {\n      const { self, system, emit } = actorScope;\n\n      const callbackState: CallbackInstanceState<TEvent> = {\n        receivers: undefined,\n        dispose: undefined\n      };\n\n      instanceStates.set(self, callbackState);\n\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: (event) => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: (listener) => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState: CallbackInstanceState<TEvent> = instanceStates.get(\n        actorScope.self\n      )!;\n\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n\n        callbackState.dispose?.();\n        return state;\n      }\n\n      callbackState.receivers?.forEach((receiver) => receiver(event));\n\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot,\n  Subscribable,\n  Subscription\n} from '../types';\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\nexport type ObservableSnapshot<\n  TContext,\n  TInput extends NonReducibleUnknown\n> = Snapshot<undefined> & {\n  context: TContext | undefined;\n  input: TInput | undefined;\n  _subscription: Subscription | undefined;\n};\n\nexport type ObservableActorLogic<\n  TContext,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  ObservableSnapshot<TContext, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\nexport type ObservableActorRef<TContext> = ActorRefFromLogic<\n  ObservableActorLogic<TContext, any>\n>;\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nexport function fromObservable<\n  TContext,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  observableCreator: ({\n    input,\n    system,\n    self\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TContext>;\n    emit: (emitted: TEmitted) => void;\n  }) => Subscribable<TContext>\n): ObservableActorLogic<TContext, TInput, TEmitted> {\n  // TODO: add event types\n  const logic: ObservableActorLogic<TContext, TInput, TEmitted> = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT: {\n          const newSnapshot = {\n            ...snapshot,\n            context: event.data as TContext\n          };\n          return newSnapshot;\n        }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription!.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system, emit }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input!,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: (value) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...state }) => state,\n    restoreSnapshot: (state) => ({\n      ...(state as any),\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nexport function fromEventObservable<\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  lazyObservable: ({\n    input,\n    system,\n    self,\n    emit\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TEvent>;\n    emit: (emitted: TEmitted) => void;\n  }) => Subscribable<TEvent>\n): ObservableActorLogic<TEvent, TInput, TEmitted> {\n  // TODO: event types\n  const logic: ObservableActorLogic<TEvent, TInput, TEmitted> = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription!.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system, emit }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n\n      state._subscription = lazyObservable({\n        input: state.input!,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: (value) => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...snapshot }) => snapshot,\n    restoreSnapshot: (snapshot: any) => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  AnyActorRef,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type PromiseSnapshot<TOutput, TInput> = Snapshot<TOutput> & {\n  input: TInput | undefined;\n};\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\nexport type PromiseActorLogic<\n  TOutput,\n  TInput = unknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  PromiseSnapshot<TOutput, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput, // input\n  AnyActorSystem,\n  TEmitted // TEmitted\n>;\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\nexport type PromiseActorRef<TOutput> = ActorRefFromLogic<\n  PromiseActorLogic<TOutput, unknown>\n>;\n\nconst controllerMap = new WeakMap<AnyActorRef, AbortController>();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromPromise<\n  TOutput,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  promiseCreator: ({\n    input,\n    system,\n    self,\n    signal,\n    emit\n  }: {\n    /** Data that was provided to the promise actor */\n    input: TInput;\n    /** The actor system to which the promise actor belongs */\n    system: AnyActorSystem;\n    /** The parent actor of the promise actor */\n    self: PromiseActorRef<TOutput>;\n    signal: AbortSignal;\n    emit: (emitted: TEmitted) => void;\n  }) => PromiseLike<TOutput>\n): PromiseActorLogic<TOutput, TInput, TEmitted> {\n  const logic: PromiseActorLogic<TOutput, TInput, TEmitted> = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE: {\n          const resolvedValue = (event as any).data;\n          return {\n            ...state,\n            status: 'done',\n            output: resolvedValue,\n            input: undefined\n          };\n        }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined\n          };\n        case XSTATE_STOP: {\n          controllerMap.get(scope.self)?.abort();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined\n          };\n        }\n        default:\n          return state;\n      }\n    },\n    start: (state, { self, system, emit }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(\n        promiseCreator({\n          input: state.input!,\n          system,\n          self,\n          signal: controller.signal,\n          emit\n        })\n      );\n\n      resolvedPromise.then(\n        (response) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          controllerMap.delete(self);\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_RESOLVE,\n            data: response\n          });\n        },\n        (errorData) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          controllerMap.delete(self);\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_REJECT,\n            data: errorData\n          });\n        }\n      );\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { createActor } from '../createActor.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport {\n  fromCallback,\n  type CallbackActorLogic,\n  type CallbackActorRef,\n  type CallbackSnapshot,\n  type CallbackLogicFunction\n} from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic,\n  type ObservableActorRef,\n  type ObservableSnapshot\n} from './observable.ts';\nexport {\n  fromPromise,\n  type PromiseActorLogic,\n  type PromiseActorRef,\n  type PromiseSnapshot\n} from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionActorRef,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  Snapshot<undefined>,\n  AnyEventObject,\n  AnyEventObject\n> {\n  return createActor(emptyLogic);\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","enqueue","event","enqueued","value","consumed","XSTATE_STOP","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","toObserver","nextHandler","errorHandler","completionHandler","isObserver","undefined","bind","error","complete","createScheduledEventId","actorRef","id","sessionId","idCounter","executingCustomAction","ProcessingStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_snapshot","mailbox","observers","Set","eventListeners","Map","_processingStatus","NotStarted","_parent","_syncSnapshot","ref","_actorScope","systemId","system","_doneEvent","src","_deferred","resolvedOptions","parent","syncSnapshot","inspect","rootActor","children","keyedActors","reverseKeyedActors","WeakMap","inspectionObservers","timerMap","scheduler","schedule","source","target","delay","Math","random","toString","slice","scheduledEvent","startedAt","Date","now","scheduledEventId","_scheduledEvents","timeout","_relay","cancel","cancelAll","snapshot","_bookId","_register","set","_unregister","delete","get","getAll","Object","fromEntries","entries","_set","existing","Error","observerOrFn","observer","add","unsubscribe","_sendInspectionEvent","size","resolvedInspectionEvent","rootId","forEach","type","sourceRef","_send","getSnapshot","scheduledEvents","scheduledId","_clock","_logger","createSystem","defer","push","stopChild","child","_stop","emit","emittedEvent","listeners","wildcardListener","allListeners","values","handler","actionExecutor","action","exec","params","saveExecutingCustomAction","info","Running","send","_initState","state","status","persistedState","restoreSnapshot","getInitialSnapshot","input","output","update","deferredFn","shift","length","_stopProcedure","_complete","invokeId","actorId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","on","wrappedHandler","initEvent","attachDevTools","nextState","caughtError","transition","stop","_reportError","reportError","err2","toJSON","xstate$$type","getPersistedSnapshot","fromTransition","initialContext","config","actorScope","context","_","instanceStates","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","controllerMap","emptyLogic","createActor","callback","callbackState","receivers","dispose","sendBack","receive","listener","receiver","lazyObservable","data","_subscription","observableCreator","promiseCreator","scope","resolvedValue","abort","controller","AbortController","Promise","resolve","signal","then","response","errorData"],"mappings":"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"}