{"version":3,"file":"xstate-graph.umd.min.js","sources":["../../src/Mailbox.ts","../../src/constants.ts","../../src/dev/index.ts","../../src/eventUtils.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/utils.ts","../../src/system.ts","../../src/createActor.ts","../../src/actions/cancel.ts","../../src/actions/spawnChild.ts","../../src/actions/stopChild.ts","../../src/guards.ts","../../src/stateUtils.ts","../../src/actions/raise.ts","../../src/State.ts","../../src/spawn.ts","../../src/actions/assign.ts","../../src/actors/index.ts","../../src/actors/transition.ts","../../src/memo.ts","../../src/StateNode.ts","../../src/StateMachine.ts","../../src/graph/utils.ts","../../src/graph/deduplicatePaths.ts","../../src/graph/pathGenerators.ts","../../src/graph/validateMachine.ts","../../src/graph/TestModel.ts","../../src/graph/actorScope.ts","../../src/graph/graph.ts","../../src/graph/adjacency.ts","../../src/graph/alterPath.ts","../../src/graph/pathFromEvents.ts","../../src/graph/shortestPaths.ts","../../src/graph/simplePaths.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if ((w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id: string) {\n  return { type: `xstate.after.${delayRef}.${id}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  error?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, error, actorId: id };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import isDevelopment from '#is-development';\nimport { isMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { TARGETLESS_KEY } from './constants.ts';\nimport type {\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  AnyTransitionConfig,\n  ErrorActorEvent,\n  EventObject,\n  InvokeConfig,\n  MachineContext,\n  Mapper,\n  NonReducibleUnknown,\n  Observer,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  TransitionConfigTarget\n} from './types.ts';\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key]!, childStateValue[key]!);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n\n  const result: string[] = [];\n  let segment = '';\n\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n\n  result.push(segment);\n\n  return result;\n}\n\nfunction toStateValue(stateValue: StateLike<any> | StateValue): StateValue {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nfunction toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nfunction isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${index}.${stateNodeId}`;\n}\n\nexport function resolveReferencedActor(machine: AnyStateMachine, src: string) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/)!;\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke!;\n  return (\n    Array.isArray(invokeConfig)\n      ? invokeConfig[indexStr as any]\n      : (invokeConfig as InvokeConfig<\n          any,\n          any,\n          any,\n          any,\n          any,\n          any,\n          any, // TEmitted\n          any // TMeta\n        >)\n  ).src;\n}\n\nexport function getAllOwnEventDescriptors(snapshot: AnyMachineSnapshot) {\n  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];\n}\n","import { InspectionEvent } from './inspection.ts';\nimport {\n  AnyEventObject,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  HomomorphicOmit,\n  EventObject,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\ninterface ScheduledEvent {\n  id: string;\n  event: EventObject;\n  startedAt: number; // timestamp\n  delay: number;\n  source: AnyActorRef;\n  target: AnyActorRef;\n}\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\ninterface Scheduler {\n  schedule(\n    source: AnyActorRef,\n    target: AnyActorRef,\n    event: EventObject,\n    delay: number,\n    id: string | undefined\n  ): void;\n  cancel(source: AnyActorRef, id: string): void;\n  cancelAll(actorRef: AnyActorRef): void;\n}\n\ntype ScheduledEventId = string & { __scheduledEventId: never };\n\nfunction createScheduledEventId(\n  actorRef: AnyActorRef,\n  id: string\n): ScheduledEventId {\n  return `${actorRef.sessionId}.${id}` as ScheduledEventId;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /** @internal */\n  _bookId: () => string;\n  /** @internal */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /** @internal */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /** @internal */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n  getAll: () => Partial<T['actors']>;\n\n  inspect: (\n    observer:\n      | Observer<InspectionEvent>\n      | ((inspectionEvent: InspectionEvent) => void)\n  ) => Subscription;\n  /** @internal */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /** @internal */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n  scheduler: Scheduler;\n  getSnapshot: () => {\n    _scheduledEvents: Record<string, ScheduledEvent>;\n  };\n  /** @internal */\n  _snapshot: {\n    _scheduledEvents: Record<ScheduledEventId, ScheduledEvent>;\n  };\n  start: () => void;\n  _clock: Clock;\n  _logger: (...args: any[]) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef,\n  options: {\n    clock: Clock;\n    logger: (...args: any[]) => void;\n    snapshot?: unknown;\n  }\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const inspectionObservers = new Set<Observer<InspectionEvent>>();\n  const timerMap: { [id: ScheduledEventId]: number } = {};\n  const { clock, logger } = options;\n\n  const scheduler: Scheduler = {\n    schedule: (\n      source,\n      target,\n      event,\n      delay,\n      id = Math.random().toString(36).slice(2)\n    ) => {\n      const scheduledEvent: ScheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n\n        system._relay(source, target, event);\n      }, delay);\n\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id: string) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: (actorRef) => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent =\n          system._snapshot._scheduledEvents[\n            scheduledEventId as ScheduledEventId\n          ];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = (event: InspectionEvent) => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent: InspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach((observer) =>\n      observer.next?.(resolvedInspectionEvent)\n    );\n  };\n\n  const system: ActorSystem<T> = {\n    _snapshot: {\n      _scheduledEvents:\n        (options?.snapshot && (options.snapshot as any).scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any] | undefined;\n    },\n    getAll: () => {\n      return Object.fromEntries(keyedActors.entries()) as Partial<T['actors']>;\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observerOrFn) => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent as any,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: { ...system._snapshot._scheduledEvents }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const { source, target, event, delay, id } =\n          scheduledEvents[scheduledId as ScheduledEventId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n\n  return system;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { AnyActorSystem, Clock, createSystem } from './system.ts';\n\n// those are needed to make JSDoc `@link` work properly\nimport type {\n  fromObservable,\n  fromEventObservable\n} from './actors/observable.ts';\nimport type { fromCallback } from './actors/callback.ts';\nimport type { fromPromise } from './actors/promise.ts';\nimport type { fromTransition } from './actors/transition.ts';\nimport type { createMachine } from './createMachine.ts';\n\nexport let executingCustomAction: boolean = false;\n\nimport type {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  ConditionalRequired,\n  DoneActorEvent,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  IsNotNever,\n  Snapshot,\n  SnapshotFrom\n} from './types.ts';\nimport {\n  ActorOptions,\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport const $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nexport enum ProcessingStatus {\n  NotStarted = 0,\n  Running = 1,\n  Stopped = 2\n}\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nexport class Actor<TLogic extends AnyActorLogic>\n  implements\n    ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>\n{\n  /** The current internal state of the actor. */\n  private _snapshot!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as\n   * delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /** The unique identifier for this actor relative to its parent. */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private eventListeners: Map<\n    string,\n    Set<(emittedEvent: EmittedFrom<TLogic>) => void>\n  > = new Map();\n  private logger: (...args: any[]) => void;\n\n  /** @internal */\n  public _processingStatus: ProcessingStatus = ProcessingStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: AnyActorRef;\n  /** @internal */\n  public _syncSnapshot?: boolean;\n  public ref: ActorRef<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    EmittedFrom<TLogic>\n  >;\n  // TODO: add typings for system\n  private _actorScope: ActorScope<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    AnyActorSystem,\n    EmittedFrom<TLogic>\n  >;\n\n  public systemId: string | undefined;\n\n  /** The globally unique process ID for this invocation. */\n  public sessionId: string;\n\n  /** The system to which this actor belongs. */\n  public system: AnyActorSystem;\n  private _doneEvent?: DoneActorEvent;\n\n  public src: string | AnyActorLogic;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(\n    public logic: TLogic,\n    options?: ActorOptions<TLogic>\n  ) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n\n    const { clock, logger, parent, syncSnapshot, id, systemId, inspect } =\n      resolvedOptions;\n\n    this.system = parent\n      ? parent.system\n      : createSystem(this, {\n          clock,\n          logger\n        });\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions as ActorOptions<TLogic> &\n      typeof defaultOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      },\n      emit: (emittedEvent) => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [\n          ...(listeners ? listeners.values() : []),\n          ...(wildcardListener ? wildcardListener.values() : [])\n        ];\n        for (const handler of allListeners) {\n          try {\n            handler(emittedEvent);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n      },\n      actionExecutor: (action) => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n\n    if (systemId) {\n      this.systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this._initState(options?.snapshot ?? options?.state);\n\n    if (systemId && (this._snapshot as any).status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n\n  private _initState(persistedState?: Snapshot<unknown>) {\n    try {\n      this._snapshot = persistedState\n        ? this.logic.restoreSnapshot\n          ? this.logic.restoreSnapshot(persistedState, this._actorScope)\n          : persistedState\n        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      } as any;\n    }\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...(snapshot as any),\n          status: 'error',\n          error: err\n        };\n      }\n    }\n\n    switch ((this._snapshot as any).status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._snapshot as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (snapshot: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((snapshot: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch ((this._snapshot as any).status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error': {\n          const err = (this._snapshot as any).error;\n          if (!observer.error) {\n            reportUnhandledError(err);\n          } else {\n            try {\n              observer.error(err);\n            } catch (err) {\n              reportUnhandledError(err);\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  public on<TType extends EmittedFrom<TLogic>['type'] | '*'>(\n    type: TType,\n    handler: (\n      emitted: EmittedFrom<TLogic> &\n        (TType extends '*' ? unknown : { type: TType })\n    ) => void\n  ): Subscription {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  public start(): this {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent!, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this.systemId) {\n      this.system._set(this.systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n\n    const status = (this._snapshot as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._snapshot,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        return this;\n    }\n\n    if (!this._parent) {\n      this.system.start();\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...(this._snapshot as any),\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(\n        this._snapshot,\n        event,\n        this._actorScope\n      );\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._snapshot = {\n        ...(this._snapshot as any),\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _reportError(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _error(err: unknown): void {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(\n        this,\n        this._parent,\n        createErrorActorEvent(this.id, err)\n      );\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  private _stopProcedure(): this {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /** @internal */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n  public getPersistedSnapshot(): Snapshot<unknown>;\n  public getPersistedSnapshot(options?: unknown): Snapshot<unknown> {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    if (isDevelopment && !this._snapshot) {\n      throw new Error(\n        `Snapshot can't be read while the actor initializes itself`\n      );\n    }\n    return this._snapshot;\n  }\n}\n\nexport type RequiredActorOptionsKeys<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  ...[options]: ConditionalRequired<\n    [\n      options?: ActorOptions<TLogic> & {\n        [K in RequiredActorOptionsKeys<TLogic>]: unknown;\n      }\n    ],\n    IsNotNever<RequiredActorOptionsKeys<TLogic>>\n  >\n): Actor<TLogic> {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\nexport type Interpreter = typeof Actor;\n","import isDevelopment from '#is-development';\nimport {\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ActionArgs,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableSendId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => string);\n\nfunction resolveCancel(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { sendId }: { sendId: ResolvableSendId<any, any, any, any> }\n): BuiltinActionResolution {\n  const resolvedSendId =\n    typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, { sendId: resolvedSendId }, undefined];\n}\n\nfunction executeCancel(actorScope: AnyActorScope, params: { sendId: string }) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n  });\n}\n\nexport interface CancelAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nexport function cancel<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  sendId: ResolvableSendId<TContext, TExpressionEvent, TParams, TEvent>\n): CancelAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function cancel(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n\n  return cancel;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus, createActor } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  EventObject,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  MachineContext,\n  Mapper,\n  ParameterizedObject,\n  ProvidedActor,\n  RequiredActorOptions,\n  BuiltinActionResolution,\n  UnifiedArg\n} from '../types.ts';\nimport { resolveReferencedActor } from '../utils.ts';\n\ntype ResolvableActorId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TId extends string | undefined\n> = TId | ((args: UnifiedArg<TContext, TExpressionEvent, TEvent>) => TId);\n\nfunction resolveSpawn(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  _actionParams: ParameterizedObject['params'] | undefined,\n  {\n    id,\n    systemId,\n    src,\n    input,\n    syncSnapshot\n  }: {\n    id: ResolvableActorId<MachineContext, EventObject, EventObject, string>;\n    systemId: string | undefined;\n    src: AnyActorLogic | string;\n    input?: unknown;\n    syncSnapshot: boolean;\n  }\n): BuiltinActionResolution {\n  const logic =\n    typeof src === 'string'\n      ? resolveReferencedActor(snapshot.machine, src)\n      : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef: AnyActorRef | undefined;\n  let resolvedInput: unknown | undefined = undefined;\n\n  if (logic) {\n    resolvedInput =\n      typeof input === 'function'\n        ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n          })\n        : input;\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: resolvedInput\n    });\n  }\n\n  if (isDevelopment && !actorRef) {\n    console.warn(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n      `Actor type '${src}' not found in machine '${actorScope.id}'.`\n    );\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children: {\n        ...snapshot.children,\n        [resolvedId]: actorRef!\n      }\n    }),\n    {\n      id,\n      systemId,\n      actorRef,\n      src,\n      input: resolvedInput\n    },\n    undefined\n  ];\n}\n\nfunction executeSpawn(\n  actorScope: AnyActorScope,\n  { actorRef }: { id: string; actorRef: AnyActorRef }\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\n\nexport interface SpawnAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\ninterface SpawnActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, TActor['id']>;\n  systemId?: string;\n  input?:\n    | Mapper<TContext, TEvent, InputFrom<TActor['logic']>, TEvent>\n    | InputFrom<TActor['logic']>;\n  syncSnapshot?: boolean;\n}\n\ntype DistributeActors<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  | (TActor extends any\n      ? ConditionalRequired<\n          [\n            src: TActor['src'],\n            options?: SpawnActionOptions<\n              TContext,\n              TExpressionEvent,\n              TEvent,\n              TActor\n            > & {\n              [K in RequiredActorOptions<TActor>]: unknown;\n            }\n          ],\n          IsNotNever<RequiredActorOptions<TActor>>\n        >\n      : never)\n  | [\n      src: AnyActorLogic,\n      options?: SpawnActionOptions<\n        TContext,\n        TExpressionEvent,\n        TEvent,\n        ProvidedActor\n      > & { id?: never }\n    ];\n\ntype SpawnArguments<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  IsLiteralString<TActor['src']> extends true\n    ? DistributeActors<TContext, TExpressionEvent, TEvent, TActor>\n    : [\n        src: string | AnyActorLogic,\n        options?: {\n          id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, string>;\n          systemId?: string;\n          input?: unknown;\n          syncSnapshot?: boolean;\n        }\n      ];\n\nexport function spawnChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  ...[\n    src,\n    { id, systemId, input, syncSnapshot = false } = {} as any\n  ]: SpawnArguments<TContext, TExpressionEvent, TEvent, TActor>\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  function spawnChild(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  spawnChild.type = 'xstate.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n\n  return spawnChild;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus } from '../createActor.ts';\nimport {\n  ActionArgs,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableActorRef<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | AnyActorRef\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => AnyActorRef | string);\n\nfunction resolveStop(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { actorRef }: { actorRef: ResolvableActorRef<any, any, any, any> }\n): BuiltinActionResolution {\n  const actorRefOrString =\n    typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef: AnyActorRef | undefined =\n    typeof actorRefOrString === 'string'\n      ? snapshot.children[actorRefOrString]\n      : actorRefOrString;\n\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = { ...children };\n    delete children[resolvedActorRef.id];\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children\n    }),\n    resolvedActorRef,\n    undefined\n  ];\n}\nfunction executeStop(\n  actorScope: AnyActorScope,\n  actorRef: AnyActorRef | undefined\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  actorScope.system._unregister(actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n\nexport interface StopAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nexport function stopChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  actorRef: ResolvableActorRef<TContext, TExpressionEvent, TParams, TEvent>\n): StopAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function stop(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nexport const stop = stopChild;\n","import isDevelopment from '#is-development';\nimport type {\n  EventObject,\n  StateValue,\n  MachineContext,\n  ParameterizedObject,\n  AnyMachineSnapshot,\n  NoRequiredParams,\n  WithDynamicParams,\n  Identity,\n  Elements,\n  DoNotInfer\n} from './types.ts';\nimport { isStateId } from './stateUtils.ts';\n\ntype SingleGuardArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuardArg\n> = [TGuardArg] extends [{ type: string }]\n  ? Identity<TGuardArg>\n  : [TGuardArg] extends [string]\n    ? TGuardArg\n    : GuardPredicate<TContext, TExpressionEvent, TParams, ParameterizedObject>;\n\ntype NormalizeGuardArg<TGuardArg> = TGuardArg extends { type: string }\n  ? Identity<TGuardArg> & { params: unknown }\n  : TGuardArg extends string\n    ? { type: TGuardArg; params: undefined }\n    : '_out_TGuard' extends keyof TGuardArg\n      ? TGuardArg['_out_TGuard'] & ParameterizedObject\n      : never;\n\ntype NormalizeGuardArgArray<TArg extends unknown[]> = Elements<{\n  [K in keyof TArg]: NormalizeGuardArg<TArg[K]>;\n}>;\n\nexport type GuardPredicate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> = {\n  (args: GuardArgs<TContext, TExpressionEvent>, params: TParams): boolean;\n  _out_TGuard?: TGuard;\n};\n\nexport interface GuardArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n> {\n  context: TContext;\n  event: TExpressionEvent;\n}\n\nexport type Guard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> =\n  | NoRequiredParams<TGuard>\n  | WithDynamicParams<TContext, TExpressionEvent, TGuard>\n  | GuardPredicate<TContext, TExpressionEvent, TParams, TGuard>;\n\nexport type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;\n\ntype UnknownReferencedGuard = Guard<\n  MachineContext,\n  EventObject,\n  ParameterizedObject['params'],\n  ParameterizedObject\n>;\n\ntype UnknownInlineGuard = Guard<\n  MachineContext,\n  EventObject,\n  undefined,\n  ParameterizedObject\n>;\n\ninterface BuiltinGuard {\n  (): boolean;\n  check: (\n    snapshot: AnyMachineSnapshot,\n    guardArgs: GuardArgs<any, any>,\n    params: unknown\n  ) => boolean;\n}\n\nfunction checkStateIn(\n  snapshot: AnyMachineSnapshot,\n  _: GuardArgs<any, any>,\n  { stateValue }: { stateValue: StateValue }\n) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some((sn) => sn === target);\n  }\n\n  return snapshot.matches(stateValue);\n}\n\nexport function stateIn<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined\n>(\n  stateValue: StateValue\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  TParams,\n  any // TODO: recheck if we could replace this with something better here\n> {\n  function stateIn() {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n\n  return stateIn;\n}\n\nfunction checkNot(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nexport function not<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg\n>(\n  guard: SingleGuardArg<TContext, TExpressionEvent, unknown, TArg>\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArg<DoNotInfer<TArg>>\n> {\n  function not(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  not.check = checkNot;\n  not.guards = [guard];\n\n  return not;\n}\n\nfunction checkAnd(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.every((guard) =>\n    evaluateGuard(guard, context, event, snapshot)\n  );\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function and<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function and(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  and.check = checkAnd;\n  and.guards = guards;\n\n  return and;\n}\n\nfunction checkOr(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.some((guard) => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function or<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function or(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  or.check = checkOr;\n  or.guards = guards;\n\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nexport function evaluateGuard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  guard: UnknownGuard | UnknownInlineGuard,\n  context: TContext,\n  event: TExpressionEvent,\n  snapshot: AnyMachineSnapshot\n): boolean {\n  const { machine } = snapshot;\n  const isInline = typeof guard === 'function';\n\n  const resolved = isInline\n    ? guard\n    : machine.implementations.guards[\n        typeof guard === 'string' ? guard : guard.type\n      ];\n\n  if (!isInline && !resolved) {\n    throw new Error(\n      `Guard '${\n        typeof guard === 'string' ? guard : guard.type\n      }' is not implemented.'.`\n    );\n  }\n\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved!, context, event, snapshot);\n  }\n\n  const guardArgs = {\n    context,\n    event\n  };\n\n  const guardParams =\n    isInline || typeof guard === 'string'\n      ? undefined\n      : 'params' in guard\n        ? typeof guard.params === 'function'\n          ? guard.params({ context, event })\n          : guard.params\n        : undefined;\n\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams as never);\n  }\n\n  const builtinGuard = resolved as unknown as BuiltinGuard;\n\n  return builtinGuard.check(\n    snapshot,\n    guardArgs,\n    resolved // this holds all params\n  );\n}\n","import isDevelopment from '#is-development';\nimport { MachineSnapshot, cloneMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { raise } from './actions.ts';\nimport { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';\nimport { cancel } from './actions/cancel.ts';\nimport { spawnChild } from './actions/spawnChild.ts';\nimport { stopChild } from './actions/stopChild.ts';\nimport {\n  XSTATE_INIT,\n  NULL_EVENT,\n  STATE_DELIMITER,\n  STATE_IDENTIFIER,\n  XSTATE_STOP,\n  WILDCARD\n} from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport {\n  ActionArgs,\n  AnyEventObject,\n  AnyHistoryValue,\n  AnyMachineSnapshot,\n  AnyStateNode,\n  AnyTransitionDefinition,\n  DelayedTransitionDefinition,\n  EventObject,\n  HistoryValue,\n  InitialTransitionConfig,\n  InitialTransitionDefinition,\n  MachineContext,\n  StateValue,\n  StateValueMap,\n  TransitionDefinition,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyTransitionConfig,\n  AnyActorScope,\n  ActionExecutor,\n  AnyStateMachine\n} from './types.ts';\nimport {\n  resolveOutput,\n  normalizeTarget,\n  toArray,\n  toStatePath,\n  toTransitionConfigArray,\n  isErrorActorEvent\n} from './utils.ts';\n\ntype StateNodeIterable<\n  TContext extends MachineContext,\n  TE extends EventObject\n> = Iterable<StateNode<TContext, TE>>;\ntype AnyStateNodeIterable = StateNodeIterable<any, any>;\n\ntype AdjList = Map<AnyStateNode, Array<AnyStateNode>>;\n\nconst isAtomicStateNode = (stateNode: StateNode<any, any>) =>\n  stateNode.type === 'atomic' || stateNode.type === 'final';\n\nfunction getChildren<TContext extends MachineContext, TE extends EventObject>(\n  stateNode: StateNode<TContext, TE>\n): Array<StateNode<TContext, TE>> {\n  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');\n}\n\nfunction getProperAncestors(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined\n): Array<typeof stateNode> {\n  const ancestors: Array<typeof stateNode> = [];\n\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n\n  return ancestors;\n}\n\nexport function getAllStateNodes(\n  stateNodes: Iterable<AnyStateNode>\n): Set<AnyStateNode> {\n  const nodeSet = new Set(stateNodes);\n\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach((sn) =>\n        nodeSet.add(sn)\n      );\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n\n  return nodeSet;\n}\n\nfunction getValueFromAdj(baseNode: AnyStateNode, adjList: AdjList): StateValue {\n  const childStateNodes = adjList.get(baseNode);\n\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n\n  const stateValue: StateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n\n  return stateValue;\n}\n\nfunction getAdjList<TContext extends MachineContext, TE extends EventObject>(\n  stateNodes: StateNodeIterable<TContext, TE>\n): AdjList {\n  const adjList: AdjList = new Map();\n\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n\n      adjList.get(s.parent)!.push(s);\n    }\n  }\n\n  return adjList;\n}\n\nexport function getStateValue(\n  rootNode: AnyStateNode,\n  stateNodes: AnyStateNodeIterable\n): StateValue {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\n\nexport function isInFinalState(\n  stateNodeSet: Set<AnyStateNode>,\n  stateNode: AnyStateNode\n): boolean {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(\n      (s) => s.type === 'final' && stateNodeSet.has(s)\n    );\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every((sn) =>\n      isInFinalState(stateNodeSet, sn)\n    );\n  }\n\n  return stateNode.type === 'final';\n}\n\nexport const isStateId = (str: string) => str[0] === STATE_IDENTIFIER;\n\nexport function getCandidates<TEvent extends EventObject>(\n  stateNode: StateNode<any, TEvent>,\n  receivedEventType: TEvent['type']\n): Array<TransitionDefinition<any, TEvent>> {\n  const candidates =\n    stateNode.transitions.get(receivedEventType) ||\n    [...stateNode.transitions.keys()]\n      .filter((eventDescriptor) => {\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (eventDescriptor === WILDCARD) {\n          return true;\n        }\n\n        if (!eventDescriptor.endsWith('.*')) {\n          return false;\n        }\n\n        if (isDevelopment && /.*\\*.+/.test(eventDescriptor)) {\n          console.warn(\n            `Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${eventDescriptor}\" event.`\n          );\n        }\n\n        const partialEventTokens = eventDescriptor.split('.');\n        const eventTokens = receivedEventType.split('.');\n\n        for (\n          let tokenIndex = 0;\n          tokenIndex < partialEventTokens.length;\n          tokenIndex++\n        ) {\n          const partialEventToken = partialEventTokens[tokenIndex];\n          const eventToken = eventTokens[tokenIndex];\n\n          if (partialEventToken === '*') {\n            const isLastToken = tokenIndex === partialEventTokens.length - 1;\n\n            if (isDevelopment && !isLastToken) {\n              console.warn(\n                `Infix wildcards in transition events are not allowed. Check the \"${eventDescriptor}\" transition.`\n              );\n            }\n\n            return isLastToken;\n          }\n\n          if (partialEventToken !== eventToken) {\n            return false;\n          }\n        }\n\n        return true;\n      })\n      .sort((a, b) => b.length - a.length)\n      .flatMap((key) => stateNode.transitions.get(key)!);\n\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nexport function getDelayedTransitions(\n  stateNode: AnyStateNode\n): Array<DelayedTransitionDefinition<MachineContext, EventObject>> {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n\n  const mutateEntryExit = (delay: string | number) => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n\n    stateNode.entry.push(\n      raise(afterEvent, {\n        id: eventType,\n        delay\n      })\n    );\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n\n  const delayedTransitions = Object.keys(afterConfig).flatMap((delay) => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition =\n      typeof configTransition === 'string'\n        ? { target: configTransition }\n        : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map((transition) => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map((delayedTransition) => {\n    const { delay } = delayedTransition;\n    return {\n      ...formatTransition(\n        stateNode,\n        delayedTransition.event,\n        delayedTransition\n      ),\n      delay\n    };\n  });\n}\n\nexport function formatTransition(\n  stateNode: AnyStateNode,\n  descriptor: string,\n  transitionConfig: AnyTransitionConfig\n): AnyTransitionDefinition {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (isDevelopment && (transitionConfig as any).cond) {\n    throw new Error(\n      `State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`\n    );\n  }\n\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard as never,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map((t) => `#${t.id}`) : undefined\n    })\n  };\n\n  return transition;\n}\n\nexport function formatTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode\n): Map<string, TransitionDefinition<TContext, TEvent>[]> {\n  const transitions = new Map<\n    string,\n    TransitionDefinition<TContext, AnyEventObject>[]\n  >();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error(\n          'Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.'\n        );\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(transitionsConfig).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(\n      descriptor,\n      toTransitionConfigArray(stateNode.config.onDone).map((t) =>\n        formatTransition(stateNode, descriptor, t)\n      )\n    );\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onDone).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onError).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions as Map<string, TransitionDefinition<TContext, any>[]>;\n}\n\nexport function formatInitialTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  _target:\n    | string\n    | undefined\n    | InitialTransitionConfig<TContext, TEvent, TODO, TODO, TODO, TODO>\n): InitialTransitionDefinition<TContext, TEvent> {\n  const resolvedTarget =\n    typeof _target === 'string'\n      ? stateNode.states[_target]\n      : _target\n        ? stateNode.states[_target.target]\n        : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n      `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`\n    );\n  }\n  const transition: InitialTransitionDefinition<TContext, TEvent> = {\n    source: stateNode,\n    actions:\n      !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null as any,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n\n  return transition;\n}\n\nfunction resolveTarget(\n  stateNode: AnyStateNode,\n  targets: ReadonlyArray<string | AnyStateNode> | undefined\n): ReadonlyArray<AnyStateNode> | undefined {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map((target) => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(\n          stateNode.parent,\n          resolvedTarget\n        );\n        return targetStateNode;\n      } catch (err: any) {\n        throw new Error(\n          `Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`\n      );\n    }\n  });\n}\n\nfunction resolveHistoryDefaultTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(stateNode: AnyStateNode & { type: 'history' }) {\n  const normalizedTarget = normalizeTarget<TContext, TEvent>(\n    stateNode.config.target\n  );\n  if (!normalizedTarget) {\n    return stateNode.parent!.initial;\n  }\n  return {\n    target: normalizedTarget.map((t) =>\n      typeof t === 'string' ? getStateNodeByPath(stateNode.parent!, t) : t\n    )\n  };\n}\n\nfunction isHistoryNode(\n  stateNode: AnyStateNode\n): stateNode is AnyStateNode & { type: 'history' } {\n  return stateNode.type === 'history';\n}\n\nfunction getInitialStateNodesWithTheirAncestors(stateNode: AnyStateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\n\nexport function getInitialStateNodes(stateNode: AnyStateNode) {\n  const set = new Set<AnyStateNode>();\n\n  function iter(descStateNode: AnyStateNode): void {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n\n  iter(stateNode);\n\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode: AnyStateNode, stateKey: string): AnyStateNode {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(\n      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`\n    );\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(\n      `Child state '${stateKey}' does not exist on '${stateNode.id}'`\n    );\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nexport function getStateNodeByPath(\n  stateNode: AnyStateNode,\n  statePath: string | string[]\n): AnyStateNode {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode: AnyStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift()!;\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nexport function getStateNodes(\n  stateNode: AnyStateNode,\n  stateValue: StateValue\n): Array<AnyStateNode> {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(\n        `State '${stateValue}' does not exist on '${stateNode.id}'`\n      );\n    }\n    return [stateNode, childStateNode];\n  }\n\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes: Array<AnyStateNode> = childStateKeys\n    .map((subStateKey) => getStateNode(stateNode, subStateKey))\n    .filter(Boolean);\n\n  return [stateNode.machine.root, stateNode].concat(\n    childStateNodes,\n    childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n      const subStateNode = getStateNode(stateNode, subStateKey);\n      if (!subStateNode) {\n        return allSubStateNodes;\n      }\n      const subStateNodes = getStateNodes(\n        subStateNode,\n        stateValue[subStateKey]!\n      );\n\n      return allSubStateNodes.concat(subStateNodes);\n    }, [] as Array<AnyStateNode>)\n  );\n}\n\nfunction transitionAtomicNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: string,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionCompoundNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const subStateKeys = Object.keys(stateValue);\n\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(\n    childStateNode,\n    stateValue[subStateKeys[0]]!,\n    snapshot,\n    event\n  );\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionParallelNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const allInnerTransitions: Array<TransitionDefinition<TContext, TEvent>> = [];\n\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n\n    if (!subStateValue) {\n      continue;\n    }\n\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(\n      subStateNode,\n      subStateValue,\n      snapshot,\n      event\n    );\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return allInnerTransitions;\n}\n\nexport function transitionNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValue,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\n\nfunction getHistoryNodes(stateNode: AnyStateNode): Array<AnyStateNode> {\n  return Object.keys(stateNode.states)\n    .map((key) => stateNode.states[key])\n    .filter((sn) => sn.type === 'history');\n}\n\nfunction isDescendant(\n  childStateNode: AnyStateNode,\n  parentStateNode: AnyStateNode\n): boolean {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n\n  return marker.parent === parentStateNode;\n}\n\nfunction hasIntersection<T>(s1: Iterable<T>, s2: Iterable<T>): boolean {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction removeConflictingTransitions(\n  enabledTransitions: Array<AnyTransitionDefinition>,\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyTransitionDefinition> {\n  const filteredTransitions = new Set<AnyTransitionDefinition>();\n\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set<AnyTransitionDefinition>();\n    for (const t2 of filteredTransitions) {\n      if (\n        hasIntersection(\n          computeExitSet([t1], stateNodeSet, historyValue),\n          computeExitSet([t2], stateNodeSet, historyValue)\n        )\n      ) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n\n  return Array.from(filteredTransitions);\n}\n\nfunction findLeastCommonAncestor(\n  stateNodes: Array<AnyStateNode>\n): AnyStateNode | undefined {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every((sn) => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\n\nfunction getEffectiveTargetStates(\n  transition: Pick<AnyTransitionDefinition, 'target'>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  if (!transition.target) {\n    return [];\n  }\n\n  const targets = new Set<AnyStateNode>();\n\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(\n          resolveHistoryDefaultTransition(targetNode),\n          historyValue\n        )) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n\n  return [...targets];\n}\n\nfunction getTransitionDomain(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): AnyStateNode | undefined {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n\n  if (!targetStates) {\n    return;\n  }\n\n  if (\n    !transition.reenter &&\n    targetStates.every(\n      (target) =>\n        target === transition.source || isDescendant(target, transition.source)\n    )\n  ) {\n    return transition.source;\n  }\n\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n\n  return transition.source.machine.root;\n}\n\nfunction computeExitSet(\n  transitions: AnyTransitionDefinition[],\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  const statesToExit = new Set<AnyStateNode>();\n\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain!)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n\n  return [...statesToExit];\n}\n\nfunction areStateNodeCollectionsEqual(\n  prevStateNodes: StateNode[],\n  nextStateNodeSet: Set<StateNode>\n) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nexport function microstep(\n  transitions: Array<AnyTransitionDefinition>,\n  currentSnapshot: AnyMachineSnapshot,\n  actorScope: AnyActorScope,\n  event: AnyEventObject,\n  isInitial: boolean,\n  internalQueue: Array<AnyEventObject>\n): AnyMachineSnapshot {\n  if (!transitions.length) {\n    return currentSnapshot;\n  }\n  const mutStateNodeSet = new Set(currentSnapshot._nodes);\n  let historyValue = currentSnapshot.historyValue;\n\n  const filteredTransitions = removeConflictingTransitions(\n    transitions,\n    mutStateNodeSet,\n    historyValue\n  );\n\n  let nextState = currentSnapshot;\n\n  // Exit states\n  if (!isInitial) {\n    [nextState, historyValue] = exitStates(\n      nextState,\n      event,\n      actorScope,\n      filteredTransitions,\n      mutStateNodeSet,\n      historyValue,\n      internalQueue,\n      actorScope.actionExecutor\n    );\n  }\n\n  // Execute transition content\n  nextState = resolveActionsAndContext(\n    nextState,\n    event,\n    actorScope,\n    filteredTransitions.flatMap((t) => t.actions),\n    internalQueue,\n    undefined\n  );\n\n  // Enter states\n  nextState = enterStates(\n    nextState,\n    event,\n    actorScope,\n    filteredTransitions,\n    mutStateNodeSet,\n    internalQueue,\n    historyValue,\n    isInitial\n  );\n\n  const nextStateNodes = [...mutStateNodeSet];\n\n  if (nextState.status === 'done') {\n    nextState = resolveActionsAndContext(\n      nextState,\n      event,\n      actorScope,\n      nextStateNodes\n        .sort((a, b) => b.order - a.order)\n        .flatMap((state) => state.exit),\n      internalQueue,\n      undefined\n    );\n  }\n\n  // eslint-disable-next-line no-useless-catch\n  try {\n    if (\n      historyValue === currentSnapshot.historyValue &&\n      areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)\n    ) {\n      return nextState;\n    }\n    return cloneMachineSnapshot(nextState, {\n      _nodes: nextStateNodes,\n      historyValue\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\n\nfunction getMachineOutput(\n  snapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  rootNode: AnyStateNode,\n  rootCompletionNode: AnyStateNode\n) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(\n    rootCompletionNode.id,\n    rootCompletionNode.output !== undefined && rootCompletionNode.parent\n      ? resolveOutput(\n          rootCompletionNode.output,\n          snapshot.context,\n          event,\n          actorScope.self\n        )\n      : undefined\n  );\n  return resolveOutput(\n    rootNode.output,\n    snapshot.context,\n    doneStateEvent,\n    actorScope.self\n  );\n}\n\nfunction enterStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  filteredTransitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  internalQueue: AnyEventObject[],\n  historyValue: HistoryValue<any, any>,\n  isInitial: boolean\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set<AnyStateNode>();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set<AnyStateNode>();\n  computeEntrySet(\n    filteredTransitions,\n    historyValue,\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n\n  const completedNodes = new Set();\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions: UnknownAction[] = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(\n        spawnChild(invokeDef.src, {\n          ...invokeDef,\n          syncSnapshot: !!invokeDef.onSnapshot\n        })\n      );\n    }\n\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      actions,\n      internalQueue,\n      stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)\n    );\n\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n\n      let ancestorMarker =\n        parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n\n      if (parent?.type === 'compound') {\n        internalQueue.push(\n          createDoneStateEvent(\n            parent.id,\n            stateNodeToEnter.output !== undefined\n              ? resolveOutput(\n                  stateNodeToEnter.output,\n                  nextSnapshot.context,\n                  event,\n                  actorScope.self\n                )\n              : undefined\n          )\n        );\n      }\n      while (\n        ancestorMarker?.type === 'parallel' &&\n        !completedNodes.has(ancestorMarker) &&\n        isInFinalState(mutStateNodeSet, ancestorMarker)\n      ) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(\n          nextSnapshot,\n          event,\n          actorScope,\n          nextSnapshot.machine.root,\n          rootCompletionNode\n        )\n      });\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction computeEntrySet(\n  transitions: Array<AnyTransitionDefinition>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n\n    for (const s of t.target || []) {\n      if (\n        !isHistoryNode(s) &&\n        // if the target is different than the source then it will *definitely* be entered\n        (t.source !== s ||\n          // we know that the domain can't lie within the source\n          // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n          t.source !== domain ||\n          // reentering transitions always enter the target, even if it's the source itself\n          t.reenter)\n      ) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(\n        s,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry,\n        ancestors,\n        !t.source.parent && t.reenter ? undefined : domain\n      );\n    }\n  }\n}\n\nfunction addDescendantStatesToEnter<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition<\n        TContext,\n        TEvent\n      >(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(\n        initialState,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n\n      addProperAncestorStatesToEnter(\n        initialState,\n        stateNode,\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry\n      );\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(\n          (sn) => !isHistoryNode(sn)\n        )) {\n          if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(\n              child,\n              historyValue,\n              statesForDefaultEntry,\n              statesToEnter\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addAncestorStatesToEnter(\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  ancestors: AnyStateNode[],\n  reentrancyDomain?: AnyStateNode\n) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(\n            child,\n            historyValue,\n            statesForDefaultEntry,\n            statesToEnter\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction addProperAncestorStatesToEnter(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined,\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>\n) {\n  addAncestorStatesToEnter(\n    statesToEnter,\n    historyValue,\n    statesForDefaultEntry,\n    getProperAncestors(stateNode, toStateNode)\n  );\n}\n\nfunction exitStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  transitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  internalQueue: AnyEventObject[],\n  _actionExecutor: ActionExecutor\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(\n    transitions,\n    mutStateNodeSet,\n    historyValue\n  );\n\n  statesToExit.sort((a, b) => b.order - a.order);\n\n  let changedHistory: typeof historyValue | undefined;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate: (sn: AnyStateNode) => boolean;\n      if (historyNode.history === 'deep') {\n        predicate = (sn) =>\n          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = (sn) => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= { ...historyValue };\n      changedHistory[historyNode.id] =\n        Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      [...s.exit, ...s.invoke.map((def) => stopChild(def.id))],\n      internalQueue,\n      undefined\n    );\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue] as const;\n}\n\nexport interface BuiltinAction {\n  (): void;\n  type: `xstate.${string}`;\n  resolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    actionArgs: ActionArgs<any, any, any>,\n    actionParams: ParameterizedObject['params'] | undefined,\n    action: unknown,\n    extra: unknown\n  ) => [\n    newState: AnyMachineSnapshot,\n    params: unknown,\n    actions?: UnknownAction[]\n  ];\n  retryResolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    params: unknown\n  ) => void;\n  execute: (actorScope: AnyActorScope, params: unknown) => void;\n}\n\nfunction getAction(machine: AnyStateMachine, actionType: string) {\n  return machine.implementations.actions[actionType];\n}\n\nfunction resolveAndExecuteActionsWithContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  extra: {\n    internalQueue: AnyEventObject[];\n    deferredActorIds: string[] | undefined;\n  },\n  retries: (readonly [BuiltinAction, unknown])[] | undefined\n): AnyMachineSnapshot {\n  const { machine } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline\n      ? action\n      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n\n        getAction(machine, typeof action === 'string' ? action : action.type);\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n\n    const actionParams =\n      isInline || typeof action === 'string'\n        ? undefined\n        : 'params' in action\n          ? typeof action.params === 'function'\n            ? action.params({ context: intermediateSnapshot.context, event })\n            : action.params\n          : undefined;\n\n    if (!resolvedAction || !('resolve' in resolvedAction)) {\n      actorScope.actionExecutor({\n        type:\n          typeof action === 'string'\n            ? action\n            : typeof action === 'object'\n              ? action.type\n              : action.name || '(anonymous)',\n        info: actionArgs,\n        params: actionParams,\n        exec: resolvedAction\n      });\n      continue;\n    }\n\n    const builtinAction = resolvedAction as BuiltinAction;\n\n    const [nextState, params, actions] = builtinAction.resolve(\n      actorScope,\n      intermediateSnapshot,\n      actionArgs,\n      actionParams,\n      resolvedAction, // this holds all params\n      extra\n    );\n    intermediateSnapshot = nextState;\n\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n\n    if ('execute' in builtinAction) {\n      actorScope.actionExecutor({\n        type: builtinAction.type,\n        info: actionArgs,\n        params,\n        exec: builtinAction.execute.bind(null, actorScope, params)\n      });\n    }\n\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(\n        intermediateSnapshot,\n        event,\n        actorScope,\n        actions,\n        extra,\n        retries\n      );\n    }\n  }\n\n  return intermediateSnapshot;\n}\n\nexport function resolveActionsAndContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  internalQueue: AnyEventObject[],\n  deferredActorIds: string[] | undefined\n): AnyMachineSnapshot {\n  const retries: (readonly [BuiltinAction, unknown])[] | undefined =\n    deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(\n    currentSnapshot,\n    event,\n    actorScope,\n    actions,\n    { internalQueue, deferredActorIds },\n    retries\n  );\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\n\nexport function macrostep(\n  snapshot: AnyMachineSnapshot,\n  event: EventObject,\n  actorScope: AnyActorScope,\n  internalQueue: AnyEventObject[]\n): {\n  snapshot: typeof snapshot;\n  microstates: Array<typeof snapshot>;\n} {\n  if (isDevelopment && event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n\n  let nextSnapshot = snapshot;\n  const microstates: AnyMachineSnapshot[] = [];\n\n  function addMicrostate(\n    microstate: AnyMachineSnapshot,\n    event: AnyEventObject,\n    transitions: AnyTransitionDefinition[]\n  ) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: microstate,\n      _transitions: transitions\n    });\n    microstates.push(microstate);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(\n      stopChildren(nextSnapshot, event, actorScope),\n      {\n        status: 'stopped'\n      }\n    );\n    addMicrostate(nextSnapshot, event, []);\n\n    return {\n      snapshot: nextSnapshot,\n      microstates\n    };\n  }\n\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot<typeof snapshot>(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostate(nextSnapshot, currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microstates\n      };\n    }\n    nextSnapshot = microstep(\n      transitions,\n      snapshot,\n      actorScope,\n      nextEvent,\n      false, // isInitial\n      internalQueue\n    );\n    addMicrostate(nextSnapshot, currentEvent, transitions);\n  }\n\n  let shouldSelectEventlessTransitions = true;\n\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions: AnyTransitionDefinition[] =\n      shouldSelectEventlessTransitions\n        ? selectEventlessTransitions(nextSnapshot, nextEvent)\n        : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift()!;\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n\n    nextSnapshot = microstep(\n      enabledTransitions,\n      nextSnapshot,\n      actorScope,\n      nextEvent,\n      false,\n      internalQueue\n    );\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n  }\n\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n\n  return {\n    snapshot: nextSnapshot,\n    microstates\n  };\n}\n\nfunction stopChildren(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope\n) {\n  return resolveActionsAndContext(\n    nextState,\n    event,\n    actorScope,\n    Object.values(nextState.children).map((child: any) => stopChild(child)),\n    [],\n    undefined\n  );\n}\n\nfunction selectTransitions(\n  event: AnyEventObject,\n  nextState: AnyMachineSnapshot\n): AnyTransitionDefinition[] {\n  return nextState.machine.getTransitionData(nextState as any, event);\n}\n\nfunction selectEventlessTransitions(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject\n): AnyTransitionDefinition[] {\n  const enabledTransitionSet: Set<AnyTransitionDefinition> = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(\n      getProperAncestors(stateNode, undefined)\n    )) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (\n          transition.guard === undefined ||\n          evaluateGuard(transition.guard, nextState.context, event, nextState)\n        ) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n\n  return removeConflictingTransitions(\n    Array.from(enabledTransitionSet),\n    new Set(nextState._nodes),\n    nextState.historyValue\n  );\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nexport function resolveStateValue(\n  rootNode: AnyStateNode,\n  stateValue: StateValue\n): StateValue {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n","import isDevelopment from '#is-development';\nimport { executingCustomAction } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  DelayExpr,\n  DoNotInfer,\n  EventObject,\n  ExecutableActionObject,\n  MachineContext,\n  ParameterizedObject,\n  RaiseActionOptions,\n  SendExpr,\n  BuiltinActionResolution\n} from '../types.ts';\n\nfunction resolveRaise(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject\n        >\n      | undefined;\n  },\n  { internalQueue }: { internalQueue: AnyEventObject[] }\n): BuiltinActionResolution {\n  const delaysMap = snapshot.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function'\n      ? eventOrExpr(args, actionParams)\n      : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function'\n        ? configDelay(args, actionParams)\n        : configDelay;\n  } else {\n    resolvedDelay =\n      typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [\n    snapshot,\n    {\n      event: resolvedEvent,\n      id,\n      delay: resolvedDelay\n    },\n    undefined\n  ];\n}\n\nfunction executeRaise(\n  actorScope: AnyActorScope,\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  const { event, delay, id } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n\nexport interface RaiseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TEvent?: TEvent;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nexport function raise<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TDelay extends string = never,\n  TUsedDelay extends TDelay = never\n>(\n  eventOrExpr:\n    | DoNotInfer<TEvent>\n    | SendExpr<TContext, TExpressionEvent, TParams, DoNotInfer<TEvent>, TEvent>,\n  options?: RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    DoNotInfer<TEvent>,\n    TUsedDelay\n  >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  never,\n  never,\n  never,\n  TDelay,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function raise(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n\n  return raise;\n}\n\nexport interface ExecutableRaiseAction extends ExecutableActionObject {\n  type: 'xstate.raise';\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  };\n}\n","import isDevelopment from '#is-development';\nimport { $$ACTOR_TYPE } from './createActor.ts';\nimport type { StateNode } from './StateNode.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { getStateValue } from './stateUtils.ts';\nimport type {\n  ProvidedActor,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  EventObject,\n  HistoryValue,\n  MachineContext,\n  StateConfig,\n  StateValue,\n  AnyActorRef,\n  Snapshot,\n  ParameterizedObject,\n  IsNever,\n  MetaObject,\n  StateSchema,\n  StateId,\n  SnapshotStatus,\n  PersistedHistoryValue\n} from './types.ts';\nimport { matchesState } from './utils.ts';\n\ntype ToTestStateValue<TStateValue extends StateValue> =\n  TStateValue extends string\n    ? TStateValue\n    : IsNever<keyof TStateValue> extends true\n      ? never\n      :\n          | keyof TStateValue\n          | {\n              [K in keyof TStateValue]?: ToTestStateValue<\n                NonNullable<TStateValue[K]>\n              >;\n            };\n\nexport function isMachineSnapshot(value: unknown): value is AnyMachineSnapshot {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'machine' in value &&\n    'value' in value\n  );\n}\n\ninterface MachineSnapshotBase<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta,\n  TStateSchema extends StateSchema = StateSchema\n> {\n  /** The state machine that produced this state snapshot. */\n  machine: StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    ProvidedActor,\n    ParameterizedObject,\n    ParameterizedObject,\n    string,\n    TStateValue,\n    TTag,\n    unknown,\n    TOutput,\n    EventObject, // TEmitted\n    any, // TMeta\n    TStateSchema\n  >;\n  /** The tags of the active state nodes that represent the current state value. */\n  tags: Set<string>;\n  /**\n   * The current state value.\n   *\n   * This represents the active state nodes in the state machine.\n   *\n   * - For atomic state nodes, it is a string.\n   * - For compound parent state nodes, it is an object where:\n   *\n   *   - The key is the parent state node's key\n   *   - The value is the current state value of the active child state node(s)\n   *\n   * @example\n   *\n   * ```ts\n   * // single-level state node\n   * snapshot.value; // => 'yellow'\n   *\n   * // nested state nodes\n   * snapshot.value; // => { red: 'wait' }\n   * ```\n   */\n  value: TStateValue;\n  /** The current status of this snapshot. */\n  status: SnapshotStatus;\n  error: unknown;\n  context: TContext;\n\n  historyValue: Readonly<HistoryValue<TContext, TEvent>>;\n  /** The enabled state nodes representative of the state value. */\n  _nodes: Array<StateNode<TContext, TEvent>>;\n  /** An object mapping actor names to spawned/invoked actors. */\n  children: TChildren;\n\n  /**\n   * Whether the current state value is a subset of the given partial state\n   * value.\n   *\n   * @param partialStateValue\n   */\n  matches: (partialStateValue: ToTestStateValue<TStateValue>) => boolean;\n\n  /**\n   * Whether the current state nodes has a state node with the specified `tag`.\n   *\n   * @param tag\n   */\n  hasTag: (tag: TTag) => boolean;\n\n  /**\n   * Determines whether sending the `event` will cause a non-forbidden\n   * transition to be selected, even if the transitions have no actions nor\n   * change the state value.\n   *\n   * @param event The event to test\n   * @returns Whether the event will cause a transition\n   */\n  can: (event: TEvent) => boolean;\n\n  getMeta: () => Record<\n    StateId<TStateSchema> & string,\n    TMeta | undefined // States might not have meta defined\n  >;\n\n  toJSON: () => unknown;\n}\n\ninterface ActiveMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'active';\n  output: undefined;\n  error: undefined;\n}\n\ninterface DoneMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'done';\n  output: TOutput;\n  error: undefined;\n}\n\ninterface ErrorMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'error';\n  output: undefined;\n  error: unknown;\n}\n\ninterface StoppedMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'stopped';\n  output: undefined;\n  error: undefined;\n}\n\nexport type MachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> =\n  | ActiveMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  | DoneMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  | ErrorMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  | StoppedMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >;\n\nconst machineSnapshotMatches = function matches(\n  this: AnyMachineSnapshot,\n  testValue: StateValue\n) {\n  return matchesState(testValue, this.value);\n};\n\nconst machineSnapshotHasTag = function hasTag(\n  this: AnyMachineSnapshot,\n  tag: string\n) {\n  return this.tags.has(tag);\n};\n\nconst machineSnapshotCan = function can(\n  this: AnyMachineSnapshot,\n  event: EventObject\n) {\n  if (isDevelopment && !this.machine) {\n    console.warn(\n      `state.can(...) used outside of a machine-created State object; this will always return false.`\n    );\n  }\n\n  const transitionData = this.machine.getTransitionData(this, event);\n\n  return (\n    !!transitionData?.length &&\n    // Check that at least one transition is not forbidden\n    transitionData.some((t) => t.target !== undefined || t.actions.length)\n  );\n};\n\nconst machineSnapshotToJSON = function toJSON(this: AnyMachineSnapshot) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return { ...jsonValues, tags: Array.from(tags) };\n};\n\nconst machineSnapshotGetMeta = function getMeta(this: AnyMachineSnapshot) {\n  return this._nodes.reduce(\n    (acc, stateNode) => {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n};\n\nexport function createMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n>(\n  config: StateConfig<TContext, TEvent>,\n  machine: AnyStateMachine\n): MachineSnapshot<\n  TContext,\n  TEvent,\n  TChildren,\n  TStateValue,\n  TTag,\n  undefined,\n  TMeta,\n  TStateSchema\n> {\n  return {\n    status: config.status as never,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes) as never,\n    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),\n    children: config.children as any,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches as never,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\n\nexport function cloneMachineSnapshot<TState extends AnyMachineSnapshot>(\n  snapshot: TState,\n  config: Partial<StateConfig<any, any>> = {}\n): TState {\n  return createMachineSnapshot(\n    { ...snapshot, ...config } as StateConfig<any, any>,\n    snapshot.machine\n  ) as TState;\n}\n\nfunction serializeHistoryValue<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(historyValue: HistoryValue<TContext, TEvent>): PersistedHistoryValue {\n  if (typeof historyValue !== 'object' || historyValue === null) {\n    return {};\n  }\n  const result: PersistedHistoryValue = {};\n\n  for (const key in historyValue) {\n    const value = historyValue[key];\n    if (Array.isArray(value)) {\n      result[key] = value.map((item) => ({ id: item.id }));\n    }\n  }\n\n  return result;\n}\n\nexport function getPersistedSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject\n>(\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    any // state schema\n  >,\n  options?: unknown\n): Snapshot<unknown> {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n\n  const childrenJson: Record<string, unknown> = {};\n\n  for (const id in children) {\n    const child = children[id] as any;\n    if (\n      isDevelopment &&\n      typeof child.src !== 'string' &&\n      (!options || !('__unsafeAllowInlineActors' in (options as object)))\n    ) {\n      throw new Error('An inline child actor cannot be persisted.');\n    }\n    childrenJson[id as keyof typeof childrenJson] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child.systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context) as any,\n    children: childrenJson,\n    historyValue: serializeHistoryValue<TContext, TEvent>(\n      jsonValues.historyValue\n    )\n  };\n\n  return persisted;\n}\n\nfunction persistContext(contextPart: Record<string, unknown>) {\n  let copy: typeof contextPart | undefined;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart)\n          ? (contextPart.slice() as typeof contextPart)\n          : { ...contextPart };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: (value as any as AnyActorRef).id\n        };\n      } else {\n        const result = persistContext(value as typeof contextPart);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart)\n            ? (contextPart.slice() as typeof contextPart)\n            : { ...contextPart };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n","import { ProcessingStatus, createActor } from './createActor.ts';\nimport {\n  ActorRefFromLogic,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  GetConcreteByKey,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  ProvidedActor,\n  RequiredActorOptions,\n  TODO,\n  type RequiredLogicInput\n} from './types.ts';\nimport { resolveReferencedActor } from './utils.ts';\n\ntype SpawnOptions<\n  TActor extends ProvidedActor,\n  TSrc extends TActor['src']\n> = TActor extends {\n  src: TSrc;\n}\n  ? ConditionalRequired<\n      [\n        options?: {\n          id?: TActor['id'];\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        } & { [K in RequiredActorOptions<TActor>]: unknown }\n      ],\n      IsNotNever<RequiredActorOptions<TActor>>\n    >\n  : never;\n\nexport type Spawner<TActor extends ProvidedActor> =\n  IsLiteralString<TActor['src']> extends true\n    ? {\n        <TSrc extends TActor['src']>(\n          logic: TSrc,\n          ...[options]: SpawnOptions<TActor, TSrc>\n        ): ActorRefFromLogic<GetConcreteByKey<TActor, 'src', TSrc>['logic']>;\n        <TLogic extends AnyActorLogic>(\n          src: TLogic,\n          ...[options]: ConditionalRequired<\n            [\n              options?: {\n                id?: never;\n                systemId?: string;\n                input?: InputFrom<TLogic>;\n                syncSnapshot?: boolean;\n              } & { [K in RequiredLogicInput<TLogic>]: unknown }\n            ],\n            IsNotNever<RequiredLogicInput<TLogic>>\n          >\n        ): ActorRefFromLogic<TLogic>;\n      }\n    : <TLogic extends AnyActorLogic | string>(\n        src: TLogic,\n        ...[options]: ConditionalRequired<\n          [\n            options?: {\n              id?: string;\n              systemId?: string;\n              input?: TLogic extends string ? unknown : InputFrom<TLogic>;\n              syncSnapshot?: boolean;\n            } & (TLogic extends AnyActorLogic\n              ? { [K in RequiredLogicInput<TLogic>]: unknown }\n              : {})\n          ],\n          IsNotNever<\n            TLogic extends AnyActorLogic ? RequiredLogicInput<TLogic> : never\n          >\n        >\n      ) => TLogic extends AnyActorLogic\n        ? ActorRefFromLogic<TLogic>\n        : AnyActorRef;\n\nexport function createSpawner(\n  actorScope: AnyActorScope,\n  { machine, context }: AnyMachineSnapshot,\n  event: AnyEventObject,\n  spawnedChildren: Record<string, AnyActorRef>\n): Spawner<any> {\n  const spawn: Spawner<any> = ((src, options) => {\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n\n      if (!logic) {\n        throw new Error(\n          `Actor logic '${src}' not implemented in machine '${machine.id}'`\n        );\n      }\n\n      const actorRef = createActor(logic, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input:\n          typeof options?.input === 'function'\n            ? options.input({\n                context,\n                event,\n                self: actorScope.self\n              })\n            : options?.input,\n        src,\n        systemId: options?.systemId\n      }) as any;\n\n      spawnedChildren[actorRef.id] = actorRef;\n\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: options?.input,\n        src,\n        systemId: options?.systemId\n      });\n\n      return actorRef;\n    }\n  }) as Spawner<any>;\n  return ((src, options) => {\n    const actorRef = spawn(src, options) as TODO; // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  }) as Spawner<any>;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { executingCustomAction } from '../createActor.ts';\nimport { Spawner, createSpawner } from '../spawn.ts';\nimport type {\n  ActionArgs,\n  AnyActorScope,\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  Assigner,\n  EventObject,\n  LowInfer,\n  MachineContext,\n  ParameterizedObject,\n  PropertyAssigner,\n  ProvidedActor,\n  ActionFunction,\n  BuiltinActionResolution\n} from '../types.ts';\n\nexport interface AssignArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> extends ActionArgs<TContext, TExpressionEvent, TEvent> {\n  spawn: Spawner<TActor>;\n}\n\nfunction resolveAssign(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    assignment\n  }: {\n    assignment:\n      | Assigner<any, any, any, any, any>\n      | PropertyAssigner<any, any, any, any, any>;\n  }\n): BuiltinActionResolution {\n  if (!snapshot.context) {\n    throw new Error(\n      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.'\n    );\n  }\n  const spawnedChildren: Record<string, AnyActorRef> = {};\n\n  const assignArgs: AssignArgs<any, any, any, any> = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(\n      actorScope,\n      snapshot,\n      actionArgs.event,\n      spawnedChildren\n    ),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate: Record<string, unknown> = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] =\n        typeof propAssignment === 'function'\n          ? propAssignment(assignArgs, actionParams)\n          : propAssignment;\n    }\n  }\n\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n\n  return [\n    cloneMachineSnapshot(snapshot, {\n      context: updatedContext,\n      children: Object.keys(spawnedChildren).length\n        ? {\n            ...snapshot.children,\n            ...spawnedChildren\n          }\n        : snapshot.children\n    }),\n    undefined,\n    undefined\n  ];\n}\n\nexport interface AssignAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nexport function assign<\n  TContext extends MachineContext,\n  TExpressionEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  assignment:\n    | Assigner<LowInfer<TContext>, TExpressionEvent, TParams, TEvent, TActor>\n    | PropertyAssigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TParams,\n        TEvent,\n        TActor\n      >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function assign(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n\n  assign.resolve = resolveAssign;\n\n  return assign;\n}\n","import { createActor } from '../createActor.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport {\n  fromCallback,\n  type CallbackActorLogic,\n  type CallbackActorRef,\n  type CallbackSnapshot,\n  type CallbackLogicFunction\n} from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic,\n  type ObservableActorRef,\n  type ObservableSnapshot\n} from './observable.ts';\nexport {\n  fromPromise,\n  type PromiseActorLogic,\n  type PromiseActorRef,\n  type PromiseSnapshot\n} from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionActorRef,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  Snapshot<undefined>,\n  AnyEventObject,\n  AnyEventObject\n> {\n  return createActor(emptyLogic);\n}\n","import { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  ActorScope,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFromLogic<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  transition: (\n    snapshot: TContext,\n    event: TEvent,\n    actorScope: ActorScope<\n      TransitionSnapshot<TContext>,\n      TEvent,\n      TSystem,\n      TEmitted\n    >\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput, TEmitted> {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope as any)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n}\n","const cache = new WeakMap<any, any>();\n\nexport function memo<T>(object: any, key: string, fn: () => T): T {\n  let memoizedData = cache.get(object);\n\n  if (!memoizedData) {\n    memoizedData = { [key]: fn() };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n\n  return memoizedData[key];\n}\n","import { MachineSnapshot } from './State.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { NULL_EVENT, STATE_DELIMITER } from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { memo } from './memo.ts';\nimport {\n  BuiltinAction,\n  formatInitialTransition,\n  formatTransition,\n  formatTransitions,\n  getCandidates,\n  getDelayedTransitions\n} from './stateUtils.ts';\nimport type {\n  DelayedTransitionDefinition,\n  EventObject,\n  InitialTransitionDefinition,\n  InvokeDefinition,\n  MachineContext,\n  Mapper,\n  StateNodeConfig,\n  StateNodeDefinition,\n  StateNodesConfig,\n  StatesDefinition,\n  TransitionDefinition,\n  TransitionDefinitionMap,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyStateMachine,\n  AnyStateNodeConfig,\n  ProvidedActor,\n  NonReducibleUnknown,\n  EventDescriptor\n} from './types.ts';\nimport {\n  createInvokeId,\n  mapValues,\n  toArray,\n  toTransitionConfigArray\n} from './utils.ts';\n\nconst EMPTY_OBJECT = {};\n\nconst toSerializableAction = (action: UnknownAction) => {\n  if (typeof action === 'string') {\n    return { type: action };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return { type: (action as BuiltinAction).type };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\n\ninterface StateNodeOptions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  _key: string;\n  _parent?: StateNode<TContext, TEvent>;\n  _machine: AnyStateMachine;\n}\n\nexport class StateNode<\n  TContext extends MachineContext = MachineContext,\n  TEvent extends EventObject = EventObject\n> {\n  /**\n   * The relative key of the state node, which represents its location in the\n   * overall state value.\n   */\n  public key: string;\n  /** The unique ID of the state node. */\n  public id: string;\n  /**\n   * The type of this state node:\n   *\n   * - `'atomic'` - no child state nodes\n   * - `'compound'` - nested child state nodes (XOR)\n   * - `'parallel'` - orthogonal nested child state nodes (AND)\n   * - `'history'` - history state node\n   * - `'final'` - final state node\n   */\n  public type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /** The string path from the root machine node to this node. */\n  public path: string[];\n  /** The child state nodes. */\n  public states: StateNodesConfig<TContext, TEvent>;\n  /**\n   * The type of history on this state node. Can be:\n   *\n   * - `'shallow'` - recalls only top-level historical state value\n   * - `'deep'` - recalls historical state value at all levels\n   */\n  public history: false | 'shallow' | 'deep';\n  /** The action(s) to be executed upon entering the state node. */\n  public entry: UnknownAction[];\n  /** The action(s) to be executed upon exiting the state node. */\n  public exit: UnknownAction[];\n  /** The parent state node. */\n  public parent?: StateNode<TContext, TEvent>;\n  /** The root machine node. */\n  public machine: StateMachine<\n    TContext,\n    TEvent,\n    any, // children\n    any, // actor\n    any, // action\n    any, // guard\n    any, // delay\n    any, // state value\n    any, // tag\n    any, // input\n    any, // output\n    any, // emitted\n    any, // meta\n    any // state schema\n  >;\n  /**\n   * The meta data associated with this state node, which will be returned in\n   * State instances.\n   */\n  public meta?: any;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a\n   * final state node.\n   */\n  public output?:\n    | Mapper<MachineContext, EventObject, unknown, EventObject>\n    | NonReducibleUnknown;\n\n  /**\n   * The order this state node appears. Corresponds to the implicit document\n   * order.\n   */\n  public order: number = -1;\n\n  public description?: string;\n\n  public tags: string[] = [];\n  public transitions!: Map<string, TransitionDefinition<TContext, TEvent>[]>;\n  public always?: Array<TransitionDefinition<TContext, TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: StateNodeConfig<\n      TContext,\n      TEvent,\n      TODO, // actors\n      TODO, // actions\n      TODO, // guards\n      TODO, // delays\n      TODO, // tags\n      TODO, // output\n      TODO, // emitted\n      TODO // meta\n    >,\n    options: StateNodeOptions<TContext, TEvent>\n  ) {\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id =\n      this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type =\n      this.config.type ||\n      (this.config.states && Object.keys(this.config.states).length\n        ? 'compound'\n        : this.config.history\n          ? 'history'\n          : 'atomic');\n    this.description = this.config.description;\n\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n\n    this.states = (\n      this.config.states\n        ? mapValues(\n            this.config.states,\n            (stateConfig: AnyStateNodeConfig, key) => {\n              const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n              });\n              return stateNode;\n            }\n          )\n        : EMPTY_OBJECT\n    ) as StateNodesConfig<TContext, TEvent>;\n\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(\n        `No initial state specified for compound state node \"#${\n          this.id\n        }\". Try adding { initial: \"${\n          Object.keys(this.states)[0]\n        }\" } to the state config.`\n      );\n    }\n\n    // History config\n    this.history =\n      this.config.history === true ? 'shallow' : this.config.history || false;\n\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n\n    this.meta = this.config.meta;\n    this.output =\n      this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  public _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map((t) =>\n        formatTransition(this, NULL_EVENT, t)\n      );\n    }\n\n    Object.keys(this.states).forEach((key) => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  public get definition(): StateNodeDefinition<TContext, TEvent> {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial\n        ? {\n            target: this.initial.target,\n            source: this,\n            actions: this.initial.actions.map(toSerializableAction),\n            eventType: null as any,\n            reenter: false,\n            toJSON: () => ({\n              target: this.initial.target.map((t) => `#${t.id}`),\n              source: `#${this.id}`,\n              actions: this.initial.actions.map(toSerializableAction),\n              eventType: null as any\n            })\n          }\n        : undefined,\n      history: this.history,\n      states: mapValues(this.states, (state: StateNode<TContext, TEvent>) => {\n        return state.definition;\n      }) as StatesDefinition<TContext, TEvent>,\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map((t) => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  public toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  public get invoke(): Array<\n    InvokeDefinition<\n      TContext,\n      TEvent,\n      ProvidedActor,\n      ParameterizedObject,\n      ParameterizedObject,\n      string,\n      TODO, // TEmitted\n      TODO // TMeta\n    >\n  > {\n    return memo(this, 'invoke', () =>\n      toArray(this.config.invoke).map((invokeConfig, i) => {\n        const { src, systemId } = invokeConfig;\n        const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n        const sourceName =\n          typeof src === 'string'\n            ? src\n            : `xstate.invoke.${createInvokeId(this.id, i)}`;\n\n        return {\n          ...invokeConfig,\n          src: sourceName,\n          id: resolvedId,\n          systemId: systemId,\n          toJSON() {\n            const { onDone, onError, ...invokeDefValues } = invokeConfig;\n            return {\n              ...invokeDefValues,\n              type: 'xstate.invoke',\n              src: sourceName,\n              id: resolvedId\n            };\n          }\n        } as InvokeDefinition<\n          TContext,\n          TEvent,\n          ProvidedActor,\n          ParameterizedObject,\n          ParameterizedObject,\n          string,\n          TODO, // TEmitted\n          TODO // TMeta\n        >;\n      })\n    );\n  }\n\n  /** The mapping of events to transitions. */\n  public get on(): TransitionDefinitionMap<TContext, TEvent> {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n\n      return [...transitions]\n        .flatMap(([descriptor, t]) => t.map((t) => [descriptor, t] as const))\n        .reduce(\n          (map: any, [descriptor, transition]) => {\n            map[descriptor] = map[descriptor] || [];\n            map[descriptor].push(transition);\n            return map;\n          },\n          {} as TransitionDefinitionMap<TContext, TEvent>\n        );\n    });\n  }\n\n  public get after(): Array<DelayedTransitionDefinition<TContext, TEvent>> {\n    return memo(\n      this,\n      'delayedTransitions',\n      () => getDelayedTransitions(this) as any\n    );\n  }\n\n  public get initial(): InitialTransitionDefinition<TContext, TEvent> {\n    return memo(this, 'initial', () =>\n      formatInitialTransition(this, this.config.initial)\n    );\n  }\n\n  /** @internal */\n  public next(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any, // TMeta\n      any // TStateSchema\n    >,\n    event: TEvent\n  ): TransitionDefinition<TContext, TEvent>[] | undefined {\n    const eventType = event.type;\n    const actions: UnknownAction[] = [];\n\n    let selectedTransition: TransitionDefinition<TContext, TEvent> | undefined;\n\n    const candidates: Array<TransitionDefinition<TContext, TEvent>> = memo(\n      this,\n      `candidates-${eventType}`,\n      () => getCandidates(this, eventType)\n    );\n\n    for (const candidate of candidates) {\n      const { guard } = candidate;\n      const resolvedContext = snapshot.context;\n\n      let guardPassed = false;\n\n      try {\n        guardPassed =\n          !guard ||\n          evaluateGuard<TContext, TEvent>(\n            guard,\n            resolvedContext,\n            event,\n            snapshot\n          );\n      } catch (err: any) {\n        const guardType =\n          typeof guard === 'string'\n            ? guard\n            : typeof guard === 'object'\n              ? guard.type\n              : undefined;\n        throw new Error(\n          `Unable to evaluate guard ${\n            guardType ? `'${guardType}' ` : ''\n          }in transition for event '${eventType}' in state node '${\n            this.id\n          }':\\n${err.message}`\n        );\n      }\n\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  public get events(): Array<EventDescriptor<TEvent>> {\n    return memo(this, 'events', () => {\n      const { states } = this;\n      const events = new Set(this.ownEvents);\n\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  public get ownEvents(): Array<EventDescriptor<TEvent>> {\n    const events = new Set(\n      [...this.transitions.keys()].filter((descriptor) => {\n        return this.transitions\n          .get(descriptor)!\n          .some(\n            (transition) =>\n              !(\n                !transition.target &&\n                !transition.actions.length &&\n                !transition.reenter\n              )\n          );\n      })\n    );\n\n    return Array.from(events);\n  }\n}\n","import isDevelopment from '#is-development';\nimport { assign } from './actions.ts';\nimport { $$ACTOR_TYPE, createActor } from './createActor.ts';\nimport { createInitEvent } from './eventUtils.ts';\nimport {\n  createMachineSnapshot,\n  getPersistedSnapshot,\n  MachineSnapshot\n} from './State.ts';\nimport { StateNode } from './StateNode.ts';\nimport {\n  getAllStateNodes,\n  getInitialStateNodes,\n  getStateNodeByPath,\n  getStateNodes,\n  isInFinalState,\n  isStateId,\n  macrostep,\n  microstep,\n  resolveActionsAndContext,\n  resolveStateValue,\n  transitionNode\n} from './stateUtils.ts';\nimport { AnyActorSystem } from './system.ts';\nimport type {\n  ActorLogic,\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  DoNotInfer,\n  Equals,\n  EventDescriptor,\n  EventObject,\n  HistoryValue,\n  InternalMachineImplementations,\n  MachineConfig,\n  MachineContext,\n  MachineImplementationsSimplified,\n  MetaObject,\n  ParameterizedObject,\n  ProvidedActor,\n  Snapshot,\n  SnapshotFrom,\n  StateMachineDefinition,\n  StateValue,\n  TransitionDefinition,\n  ResolvedStateMachineTypes,\n  StateSchema,\n  SnapshotStatus\n} from './types.ts';\nimport { resolveReferencedActor, toStatePath } from './utils.ts';\n\nconst STATE_IDENTIFIER = '#';\n\nexport class StateMachine<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> implements\n    ActorLogic<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TConfig\n      >,\n      TEvent,\n      TInput,\n      AnyActorSystem,\n      TEmitted\n    >\n{\n  /** The machine's own version. */\n  public version?: string;\n\n  public schemas: unknown;\n\n  public implementations: MachineImplementationsSimplified<TContext, TEvent>;\n\n  /** @internal */\n  public __xstatenode = true as const;\n\n  /** @internal */\n  public idMap: Map<string, StateNode<TContext, TEvent>> = new Map();\n\n  public root: StateNode<TContext, TEvent>;\n\n  public id: string;\n\n  public states: StateNode<TContext, TEvent>['states'];\n  public events: Array<EventDescriptor<TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: MachineConfig<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      TOutput,\n      any, // TEmitted\n      any // TMeta\n    > & {\n      schemas?: unknown;\n    },\n    implementations?: MachineImplementationsSimplified<TContext, TEvent>\n  ) {\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this as any\n    });\n\n    this.root._initialize();\n\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n\n    if (\n      isDevelopment &&\n      !('output' in this.root) &&\n      Object.values(this.states).some(\n        (state) => state.type === 'final' && 'output' in state\n      )\n    ) {\n      console.warn(\n        'Missing `machine.output` declaration (top-level final state with output detected)'\n      );\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  public provide(\n    implementations: InternalMachineImplementations<\n      ResolvedStateMachineTypes<\n        TContext,\n        DoNotInfer<TEvent>,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TTag,\n        TEmitted\n      >\n    >\n  ): StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TStateValue,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta,\n    TConfig\n  > {\n    const { actions, guards, actors, delays } = this.implementations;\n\n    return new StateMachine(this.config, {\n      actions: { ...actions, ...implementations.actions },\n      guards: { ...guards, ...implementations.guards },\n      actors: { ...actors, ...implementations.actors },\n      delays: { ...delays, ...implementations.delays }\n    });\n  }\n\n  public resolveState(\n    config: {\n      value: StateValue;\n      context?: TContext;\n      historyValue?: HistoryValue<TContext, TEvent>;\n      status?: SnapshotStatus;\n      output?: TOutput;\n      error?: unknown;\n    } & (Equals<TContext, MachineContext> extends false\n      ? { context: unknown }\n      : {})\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(\n      getStateNodes(this.root, resolvedStateValue)\n    );\n\n    return createMachineSnapshot(\n      {\n        _nodes: [...nodeSet],\n        context: config.context || ({} as TContext),\n        children: {},\n        status: isInFinalState(nodeSet, this.root)\n          ? 'done'\n          : config.status || 'active',\n        output: config.output,\n        error: config.error,\n        historyValue: config.historyValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >;\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  public transition(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    event: TEvent,\n    actorScope: ActorScope<typeof snapshot, TEvent, AnyActorSystem, TEmitted>\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    return macrostep(snapshot, event, actorScope, [])\n      .snapshot as typeof snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  public microstep(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    event: TEvent,\n    actorScope: AnyActorScope\n  ): Array<\n    MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  > {\n    return macrostep(snapshot, event, actorScope, []).microstates;\n  }\n\n  public getTransitionData(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    event: TEvent\n  ): Array<TransitionDefinition<TContext, TEvent>> {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  private getPreInitialState(\n    actorScope: AnyActorScope,\n    initEvent: any,\n    internalQueue: AnyEventObject[]\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const { context } = this.config;\n\n    const preInitial = createMachineSnapshot(\n      {\n        context:\n          typeof context !== 'function' && context ? context : ({} as TContext),\n        _nodes: [this.root],\n        children: {},\n        status: 'active'\n      },\n      this\n    );\n\n    if (typeof context === 'function') {\n      const assignment = ({ spawn, event, self }: any) =>\n        context({ spawn, input: event.input, self });\n      return resolveActionsAndContext(\n        preInitial,\n        initEvent,\n        actorScope,\n        [assign(assignment)],\n        internalQueue,\n        undefined\n      ) as SnapshotFrom<this>;\n    }\n\n    return preInitial as SnapshotFrom<this>;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  public getInitialSnapshot(\n    actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TConfig\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >,\n    input?: TInput\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const initEvent = createInitEvent(input) as unknown as TEvent; // TODO: fix;\n    const internalQueue: AnyEventObject[] = [];\n    const preInitialState = this.getPreInitialState(\n      actorScope,\n      initEvent,\n      internalQueue\n    );\n    const nextState = microstep(\n      [\n        {\n          target: [...getInitialStateNodes(this.root)],\n          source: this.root,\n          reenter: true,\n          actions: [],\n          eventType: null as any,\n          toJSON: null as any // TODO: fix\n        }\n      ],\n      preInitialState,\n      actorScope,\n      initEvent,\n      true,\n      internalQueue\n    );\n\n    const { snapshot: macroState } = macrostep(\n      nextState,\n      initEvent as AnyEventObject,\n      actorScope,\n      internalQueue\n    );\n\n    return macroState as SnapshotFrom<this>;\n  }\n\n  public start(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  ): void {\n    Object.values(snapshot.children as Record<string, AnyActorRef>).forEach(\n      (child: any) => {\n        if (child.getSnapshot().status === 'active') {\n          child.start();\n        }\n      }\n    );\n  }\n\n  public getStateNodeById(stateId: string): StateNode<TContext, TEvent> {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0])\n      ? fullPath[0].slice(STATE_IDENTIFIER.length)\n      : fullPath[0];\n\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(\n        `Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`\n      );\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n\n  public get definition(): StateMachineDefinition<TContext, TEvent> {\n    return this.root.definition;\n  }\n\n  public toJSON() {\n    return this.definition;\n  }\n\n  public getPersistedSnapshot(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    options?: unknown\n  ) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n\n  public restoreSnapshot(\n    snapshot: Snapshot<unknown>,\n    _actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TConfig\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const children: Record<string, AnyActorRef> = {};\n    const snapshotChildren: Record<\n      string,\n      {\n        src: string | AnyActorLogic;\n        snapshot: Snapshot<unknown>;\n        syncSnapshot?: boolean;\n        systemId?: string;\n      }\n    > = (snapshot as any).children;\n\n    Object.keys(snapshotChildren).forEach((actorId) => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n\n      const logic =\n        typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n\n      if (!logic) {\n        return;\n      }\n\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n\n      children[actorId] = actorRef;\n    });\n\n    function resolveHistoryReferencedState(\n      root: StateNode<TContext, TEvent>,\n      referenced: { id: string } | StateNode<TContext, TEvent>\n    ) {\n      if (referenced instanceof StateNode) {\n        return referenced;\n      }\n      try {\n        return root.machine.getStateNodeById(referenced.id);\n      } catch {\n        if (isDevelopment) {\n          console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n        }\n      }\n    }\n\n    function reviveHistoryValue(\n      root: StateNode<TContext, TEvent>,\n      historyValue: Record<\n        string,\n        ({ id: string } | StateNode<TContext, TEvent>)[]\n      >\n    ): HistoryValue<TContext, TEvent> {\n      if (!historyValue || typeof historyValue !== 'object') {\n        return {};\n      }\n      const revived: HistoryValue<TContext, TEvent> = {};\n      for (const key in historyValue) {\n        const arr = historyValue[key];\n\n        for (const item of arr) {\n          const resolved = resolveHistoryReferencedState(root, item);\n\n          if (!resolved) {\n            continue;\n          }\n\n          revived[key] ??= [];\n          revived[key].push(resolved);\n        }\n      }\n      return revived;\n    }\n\n    const revivedHistoryValue = reviveHistoryValue(\n      this.root,\n      (snapshot as any).historyValue\n    );\n\n    const restoredSnapshot = createMachineSnapshot(\n      {\n        ...(snapshot as any),\n        children,\n        _nodes: Array.from(\n          getAllStateNodes(getStateNodes(this.root, (snapshot as any).value))\n        ),\n        historyValue: revivedHistoryValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >;\n\n    const seen = new Set();\n\n    function reviveContext(\n      contextPart: Record<string, unknown>,\n      children: Record<string, AnyActorRef>\n    ) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (const key in contextPart) {\n        const value: unknown = contextPart[key];\n\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[(value as any).id];\n            continue;\n          }\n          reviveContext(value as typeof contextPart, children);\n        }\n      }\n    }\n\n    reviveContext(restoredSnapshot.context, children);\n\n    return restoredSnapshot;\n  }\n}\n","import {\n  SerializationConfig,\n  StatePath,\n  TestMeta,\n  TestPathResult\n} from './types.ts';\nimport { AnyMachineSnapshot, MachineContext } from '../index.ts';\n\ninterface TestResultStringOptions extends SerializationConfig<any, any> {\n  formatColor: (color: string, string: string) => string;\n}\n\nexport function simpleStringify(value: any): string {\n  return JSON.stringify(value);\n}\n\nexport function formatPathTestResult(\n  path: StatePath<any, any>,\n  testPathResult: TestPathResult,\n  options?: Partial<TestResultStringOptions>\n): string {\n  const resolvedOptions: TestResultStringOptions = {\n    formatColor: (_color, string) => string,\n    serializeState: simpleStringify,\n    serializeEvent: simpleStringify,\n    ...options\n  };\n\n  const { formatColor, serializeState, serializeEvent } = resolvedOptions;\n\n  const { state } = path;\n\n  const targetStateString = serializeState(\n    state,\n    path.steps.length ? path.steps[path.steps.length - 1].event : undefined\n  );\n\n  let errMessage = '';\n  let hasFailed = false;\n  errMessage +=\n    '\\nPath:\\n' +\n    testPathResult.steps\n      .map((s, i, steps) => {\n        const stateString = serializeState(\n          s.step.state,\n          i > 0 ? steps[i - 1].step.event : undefined\n        );\n        const eventString = serializeEvent(s.step.event);\n\n        const stateResult = `\\tState: ${\n          hasFailed\n            ? formatColor('gray', stateString)\n            : s.state.error\n              ? ((hasFailed = true), formatColor('redBright', stateString))\n              : formatColor('greenBright', stateString)\n        }`;\n        const eventResult = `\\tEvent: ${\n          hasFailed\n            ? formatColor('gray', eventString)\n            : s.event.error\n              ? ((hasFailed = true), formatColor('red', eventString))\n              : formatColor('green', eventString)\n        }`;\n\n        return [stateResult, eventResult].join('\\n');\n      })\n      .concat(\n        `\\tState: ${\n          hasFailed\n            ? formatColor('gray', targetStateString)\n            : testPathResult.state.error\n              ? formatColor('red', targetStateString)\n              : formatColor('green', targetStateString)\n        }`\n      )\n      .join('\\n\\n');\n\n  return errMessage;\n}\n\nexport function getDescription<T, TContext extends MachineContext>(\n  snapshot: AnyMachineSnapshot\n): string {\n  const contextString = !Object.keys(snapshot.context).length\n    ? ''\n    : `(${JSON.stringify(snapshot.context)})`;\n\n  const stateStrings = snapshot._nodes\n    .filter((sn) => sn.type === 'atomic' || sn.type === 'final')\n    .map(({ id, path }) => {\n      const meta = snapshot.getMeta()[id] as TestMeta<T, TContext>;\n      if (!meta) {\n        return `\"${path.join('.')}\"`;\n      }\n\n      const { description } = meta;\n\n      if (typeof description === 'function') {\n        return description(snapshot);\n      }\n\n      return description ? `\"${description}\"` : JSON.stringify(snapshot.value);\n    });\n\n  return (\n    `state${stateStrings.length === 1 ? '' : 's'} ` +\n    stateStrings.join(', ') +\n    ` ${contextString}`.trim()\n  );\n}\n","import { StatePath } from './index.ts';\nimport { EventObject, Snapshot } from '../index.ts';\nimport { simpleStringify } from './utils.ts';\n\n/**\n * Deduplicates your paths so that A -> B is not executed separately to A -> B\n * -> C\n */\nexport const deduplicatePaths = <\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject\n>(\n  paths: StatePath<TSnapshot, TEvent>[],\n  serializeEvent: (event: TEvent) => string = simpleStringify\n): StatePath<TSnapshot, TEvent>[] => {\n  /** Put all paths on the same level so we can dedup them */\n  const allPathsWithEventSequence: Array<{\n    path: StatePath<TSnapshot, TEvent>;\n    eventSequence: string[];\n  }> = [];\n\n  paths.forEach((path) => {\n    allPathsWithEventSequence.push({\n      path,\n      eventSequence: path.steps.map((step) => serializeEvent(step.event))\n    });\n  });\n\n  // Sort by path length, descending\n  allPathsWithEventSequence.sort(\n    (a, z) => z.path.steps.length - a.path.steps.length\n  );\n\n  const superpathsWithEventSequence: typeof allPathsWithEventSequence = [];\n\n  /** Filter out the paths that are subpaths of superpaths */\n  pathLoop: for (const pathWithEventSequence of allPathsWithEventSequence) {\n    // Check each existing superpath to see if the path is a subpath of it\n    superpathLoop: for (const superpathWithEventSequence of superpathsWithEventSequence) {\n      // eslint-disable-next-line @typescript-eslint/no-for-in-array\n      for (const i in pathWithEventSequence.eventSequence) {\n        // Check event sequence to determine if path is subpath, e.g.:\n        //\n        // This will short-circuit the check\n        // ['a', 'b', 'c', 'd'] (superpath)\n        // ['a', 'b', 'x']      (path)\n        //\n        // This will not short-circuit; path is subpath\n        // ['a', 'b', 'c', 'd'] (superpath)\n        // ['a', 'b', 'c']      (path)\n        if (\n          pathWithEventSequence.eventSequence[i] !==\n          superpathWithEventSequence.eventSequence[i]\n        ) {\n          // If the path is different from the superpath,\n          // continue to the next superpath\n          continue superpathLoop;\n        }\n      }\n\n      // If we reached here, path is subpath of superpath\n      // Continue & do not add path to superpaths\n      continue pathLoop;\n    }\n\n    // If we reached here, path is not a subpath of any existing superpaths\n    // So add it to the superpaths\n    superpathsWithEventSequence.push(pathWithEventSequence);\n  }\n\n  return superpathsWithEventSequence.map((path) => path.path);\n};\n","import { getShortestPaths, getSimplePaths } from './index.ts';\nimport { EventObject, Snapshot } from '../index.ts';\nimport { PathGenerator } from './types.ts';\n\nexport const createShortestPathsGen =\n  <\n    TSnapshot extends Snapshot<unknown>,\n    TEvent extends EventObject,\n    TInput\n  >(): PathGenerator<TSnapshot, TEvent, TInput> =>\n  (logic, defaultOptions) => {\n    const paths = getShortestPaths(logic, defaultOptions);\n\n    return paths;\n  };\n\nexport const createSimplePathsGen =\n  <\n    TSnapshot extends Snapshot<unknown>,\n    TEvent extends EventObject,\n    TInput\n  >(): PathGenerator<TSnapshot, TEvent, TInput> =>\n  (logic, defaultOptions) => {\n    const paths = getSimplePaths(logic, defaultOptions);\n\n    return paths;\n  };\n","import { AnyStateMachine, AnyStateNode } from '../index.ts';\n\nconst validateState = (state: AnyStateNode) => {\n  if (state.invoke.length > 0) {\n    throw new Error('Invocations on test machines are not supported');\n  }\n  if (state.after.length > 0) {\n    throw new Error('After events on test machines are not supported');\n  }\n  // TODO: this doesn't account for always transitions\n  [\n    ...state.entry,\n    ...state.exit,\n    ...[...state.transitions.values()].flatMap((t) =>\n      t.flatMap((t) => t.actions)\n    )\n  ].forEach((action) => {\n    // TODO: this doesn't check referenced actions, only the inline ones\n    if (\n      typeof action === 'function' &&\n      'resolve' in action &&\n      typeof (action as any).delay === 'number'\n    ) {\n      throw new Error('Delayed actions on test machines are not supported');\n    }\n  });\n\n  for (const child of Object.values(state.states)) {\n    validateState(child);\n  }\n};\n\nexport const validateMachine = (machine: AnyStateMachine) => {\n  validateState(machine.root);\n};\n","import {\n  getPathsFromEvents,\n  getAdjacencyMap,\n  joinPaths,\n  serializeSnapshot\n} from './index.ts';\nimport type {\n  AdjacencyMap,\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Step,\n  TraversalOptions,\n  EventExecutor,\n  PathGenerator,\n  TestModelOptions,\n  TestParam,\n  TestPath,\n  TestPathResult,\n  TestStepResult\n} from './types.ts';\nimport {\n  EventObject,\n  ActorLogic,\n  Snapshot,\n  isMachineSnapshot,\n  __unsafe_getAllOwnEventDescriptors,\n  AnyActorRef,\n  AnyEventObject,\n  AnyStateMachine,\n  EventFromLogic,\n  MachineContext,\n  MachineSnapshot,\n  SnapshotFrom,\n  StateValue,\n  TODO,\n  InputFrom\n} from '../index.ts';\nimport { deduplicatePaths } from './deduplicatePaths.ts';\nimport {\n  createShortestPathsGen,\n  createSimplePathsGen\n} from './pathGenerators.ts';\nimport {\n  formatPathTestResult,\n  getDescription,\n  simpleStringify\n} from './utils.ts';\nimport { validateMachine } from './validateMachine.ts';\n\ntype GetPathOptions<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput\n> = Partial<TraversalOptions<TSnapshot, TEvent, TInput>> & {\n  /**\n   * Whether to allow deduplicate paths so that paths that are contained by\n   * longer paths are included.\n   *\n   * @default false\n   */\n  allowDuplicatePaths?: boolean;\n};\n\n/**\n * Creates a test model that represents an abstract model of a system under test\n * (SUT).\n *\n * The test model is used to generate test paths, which are used to verify that\n * states in the model are reachable in the SUT.\n */\nexport class TestModel<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput\n> {\n  public options: TestModelOptions<TSnapshot, TEvent, TInput>;\n  public defaultTraversalOptions?: TraversalOptions<TSnapshot, TEvent, TInput>;\n  public getDefaultOptions(): TestModelOptions<TSnapshot, TEvent, TInput> {\n    return {\n      serializeState: (state) => simpleStringify(state) as SerializedSnapshot,\n      serializeEvent: (event) => simpleStringify(event) as SerializedEvent,\n      // For non-state-machine test models, we cannot identify\n      // separate transitions, so just use event type\n      serializeTransition: (state, event) =>\n        `${simpleStringify(state)}|${event?.type}`,\n      events: [],\n      stateMatcher: (_, stateKey) => stateKey === '*',\n      logger: {\n        log: console.log.bind(console),\n        error: console.error.bind(console)\n      }\n    };\n  }\n\n  constructor(\n    public testLogic: ActorLogic<TSnapshot, TEvent, TInput>,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ) {\n    this.options = {\n      ...this.getDefaultOptions(),\n      ...options\n    };\n  }\n\n  public getPaths(\n    pathGenerator: PathGenerator<TSnapshot, TEvent, TInput>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const allowDuplicatePaths = options?.allowDuplicatePaths ?? false;\n    const paths = pathGenerator(this.testLogic, this._resolveOptions(options));\n    return (allowDuplicatePaths ? paths : deduplicatePaths(paths)).map(\n      this._toTestPath\n    );\n  }\n\n  public getShortestPaths(\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    return this.getPaths(createShortestPathsGen(), options);\n  }\n\n  public getShortestPathsFrom(\n    paths: Array<TestPath<TSnapshot, TEvent>>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const resultPaths: TestPath<TSnapshot, TEvent>[] = [];\n\n    for (const path of paths) {\n      const shortestPaths = this.getShortestPaths({\n        ...options,\n        fromState: path.state\n      });\n      for (const shortestPath of shortestPaths) {\n        resultPaths.push(this._toTestPath(joinPaths(path, shortestPath)));\n      }\n    }\n\n    return resultPaths;\n  }\n\n  public getSimplePaths(\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    return this.getPaths(createSimplePathsGen(), options);\n  }\n\n  public getSimplePathsFrom(\n    paths: Array<TestPath<TSnapshot, TEvent>>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const resultPaths: TestPath<TSnapshot, TEvent>[] = [];\n\n    for (const path of paths) {\n      const shortestPaths = this.getSimplePaths({\n        ...options,\n        fromState: path.state\n      });\n      for (const shortestPath of shortestPaths) {\n        resultPaths.push(this._toTestPath(joinPaths(path, shortestPath)));\n      }\n    }\n\n    return resultPaths;\n  }\n\n  private _toTestPath = (\n    statePath: StatePath<TSnapshot, TEvent>\n  ): TestPath<TSnapshot, TEvent> => {\n    function formatEvent(event: EventObject): string {\n      const { type, ...other } = event;\n\n      const propertyString = Object.keys(other).length\n        ? ` (${JSON.stringify(other)})`\n        : '';\n\n      return `${type}${propertyString}`;\n    }\n\n    const eventsString = statePath.steps\n      .map((s) => formatEvent(s.event))\n      .join(' → ');\n    return {\n      ...statePath,\n      test: (params: TestParam<TSnapshot, TEvent>) =>\n        this.testPath(statePath, params),\n      description: isMachineSnapshot(statePath.state)\n        ? `Reaches ${getDescription(\n            statePath.state as any\n          ).trim()}: ${eventsString}`\n        : JSON.stringify(statePath.state)\n    };\n  };\n\n  public getPathsFromEvents(\n    events: TEvent[],\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const paths = getPathsFromEvents(this.testLogic, events, options);\n\n    return paths.map(this._toTestPath);\n  }\n\n  /**\n   * An array of adjacencies, which are objects that represent each `state` with\n   * the `nextState` given the `event`.\n   */\n  public getAdjacencyMap(): AdjacencyMap<TSnapshot, TEvent> {\n    const adjMap = getAdjacencyMap(this.testLogic, this.options);\n    return adjMap;\n  }\n\n  public async testPath(\n    path: StatePath<TSnapshot, TEvent>,\n    params: TestParam<TSnapshot, TEvent>,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): Promise<TestPathResult> {\n    const testPathResult: TestPathResult = {\n      steps: [],\n      state: {\n        error: null\n      }\n    };\n\n    try {\n      for (const step of path.steps) {\n        const testStepResult: TestStepResult = {\n          step,\n          state: { error: null },\n          event: { error: null }\n        };\n\n        testPathResult.steps.push(testStepResult);\n\n        try {\n          await this.testTransition(params, step);\n        } catch (err: any) {\n          testStepResult.event.error = err;\n\n          throw err;\n        }\n\n        try {\n          await this.testState(params, step.state, options);\n        } catch (err: any) {\n          testStepResult.state.error = err;\n\n          throw err;\n        }\n      }\n    } catch (err: any) {\n      // TODO: make option\n      err.message += formatPathTestResult(path, testPathResult, this.options);\n      throw err;\n    }\n\n    return testPathResult;\n  }\n\n  public async testState(\n    params: TestParam<TSnapshot, TEvent>,\n    state: TSnapshot,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): Promise<void> {\n    const resolvedOptions = this._resolveOptions(options);\n\n    const stateTestKeys = this._getStateTestKeys(\n      params,\n      state,\n      resolvedOptions\n    );\n\n    for (const stateTestKey of stateTestKeys) {\n      await params.states?.[stateTestKey](state);\n    }\n  }\n\n  private _getStateTestKeys(\n    params: TestParam<TSnapshot, TEvent>,\n    state: TSnapshot,\n    resolvedOptions: TestModelOptions<TSnapshot, TEvent, TInput>\n  ) {\n    const states = params.states || {};\n    const stateTestKeys = Object.keys(states).filter((stateKey) => {\n      return resolvedOptions.stateMatcher(state, stateKey);\n    });\n\n    // Fallthrough state tests\n    if (!stateTestKeys.length && '*' in states) {\n      stateTestKeys.push('*');\n    }\n\n    return stateTestKeys;\n  }\n\n  private _getEventExec(\n    params: TestParam<TSnapshot, TEvent>,\n    step: Step<TSnapshot, TEvent>\n  ) {\n    const eventExec =\n      params.events?.[(step.event as any).type as TEvent['type']];\n\n    return eventExec;\n  }\n\n  public async testTransition(\n    params: TestParam<TSnapshot, TEvent>,\n    step: Step<TSnapshot, TEvent>\n  ): Promise<void> {\n    const eventExec = this._getEventExec(params, step);\n    await (eventExec as EventExecutor<TSnapshot, TEvent>)?.(step);\n  }\n\n  private _resolveOptions(\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): TestModelOptions<TSnapshot, TEvent, TInput> {\n    return { ...this.defaultTraversalOptions, ...this.options, ...options };\n  }\n}\n\nfunction stateValuesEqual(\n  a: StateValue | undefined,\n  b: StateValue | undefined\n): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return a === b;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  return (\n    aKeys.length === bKeys.length &&\n    aKeys.every((key) => stateValuesEqual(a[key], b[key]))\n  );\n}\n\nfunction serializeMachineTransition(\n  snapshot: MachineSnapshot<\n    MachineContext,\n    EventObject,\n    Record<string, AnyActorRef | undefined>,\n    StateValue,\n    string,\n    unknown,\n    TODO, // TMeta\n    TODO // TStateSchema\n  >,\n  event: AnyEventObject | undefined,\n  previousSnapshot:\n    | MachineSnapshot<\n        MachineContext,\n        EventObject,\n        Record<string, AnyActorRef | undefined>,\n        StateValue,\n        string,\n        unknown,\n        TODO, // TMeta\n        TODO // TStateSchema\n      >\n    | undefined,\n  { serializeEvent }: { serializeEvent: (event: AnyEventObject) => string }\n): string {\n  // TODO: the stateValuesEqual check here is very likely not exactly correct\n  // but I'm not sure what the correct check is and what this is trying to do\n  if (\n    !event ||\n    (previousSnapshot &&\n      stateValuesEqual(previousSnapshot.value, snapshot.value))\n  ) {\n    return '';\n  }\n\n  const prevStateString = previousSnapshot\n    ? ` from ${simpleStringify(previousSnapshot.value)}`\n    : '';\n\n  return ` via ${serializeEvent(event)}${prevStateString}`;\n}\n\n/**\n * Creates a test model that represents an abstract model of a system under test\n * (SUT).\n *\n * The test model is used to generate test paths, which are used to verify that\n * states in the `machine` are reachable in the SUT.\n *\n * @example\n *\n * ```js\n * const toggleModel = createModel(toggleMachine).withEvents({\n *   TOGGLE: {\n *     exec: async (page) => {\n *       await page.click('input');\n *     }\n *   }\n * });\n * ```\n *\n * @param machine The state machine used to represent the abstract model.\n * @param options Options for the created test model:\n *\n *   - `events`: an object mapping string event types (e.g., `SUBMIT`) to an event\n *       test config (e.g., `{exec: () => {...}, cases: [...]}`)\n */\nexport function createTestModel<TMachine extends AnyStateMachine>(\n  machine: TMachine,\n  options?: Partial<\n    TestModelOptions<\n      SnapshotFrom<TMachine>,\n      EventFromLogic<TMachine>,\n      InputFrom<TMachine>\n    >\n  >\n): TestModel<SnapshotFrom<TMachine>, EventFromLogic<TMachine>, unknown> {\n  validateMachine(machine);\n\n  const serializeEvent = (options?.serializeEvent ?? simpleStringify) as (\n    event: AnyEventObject\n  ) => string;\n  const serializeTransition =\n    options?.serializeTransition ?? serializeMachineTransition;\n  const { events: getEvents, ...otherOptions } = options ?? {};\n\n  const testModel = new TestModel<\n    SnapshotFrom<TMachine>,\n    EventFromLogic<TMachine>,\n    unknown\n  >(machine as any, {\n    serializeState: (state, event, prevState) => {\n      // Only consider the `state` if `serializeTransition()` is opted out (empty string)\n      return `${serializeSnapshot(state)}${serializeTransition(\n        state,\n        event,\n        prevState,\n        {\n          serializeEvent\n        }\n      )}` as SerializedSnapshot;\n    },\n    stateMatcher: (state, key) => {\n      return key.startsWith('#')\n        ? (state as any)._nodes.includes(machine.getStateNodeById(key))\n        : (state as any).matches(key);\n    },\n    events: (state) => {\n      const events =\n        typeof getEvents === 'function' ? getEvents(state) : (getEvents ?? []);\n\n      return __unsafe_getAllOwnEventDescriptors(state).flatMap(\n        (eventType: string) => {\n          if (events.some((e) => (e as EventObject).type === eventType)) {\n            return events.filter((e) => (e as EventObject).type === eventType);\n          }\n\n          return [{ type: eventType } as any]; // TODO: fix types\n        }\n      );\n    },\n    ...otherOptions\n  });\n\n  return testModel;\n}\n","import { AnyActorScope, createEmptyActor } from '../index.ts';\n\nexport function createMockActorScope(): AnyActorScope {\n  const emptyActor = createEmptyActor();\n  return {\n    self: emptyActor,\n    logger: console.log,\n    id: '',\n    sessionId: Math.random().toString(32).slice(2),\n    defer: () => {},\n    system: emptyActor.system, // TODO: mock system?\n    stopChild: () => {},\n    emit: () => {},\n    actionExecutor: () => {}\n  };\n}\n","import {\n  EventObject,\n  AnyStateMachine,\n  StateMachine,\n  AnyActorLogic,\n  EventFromLogic,\n  Snapshot,\n  __unsafe_getAllOwnEventDescriptors,\n  InputFrom\n} from '../index.ts';\nimport type {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  DirectedGraphEdge,\n  DirectedGraphNode,\n  TraversalOptions,\n  AnyStateNode,\n  TraversalConfig\n} from './types.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\n/**\n * Returns all state nodes of the given `node`.\n *\n * @param stateNode State node to recursively get child state nodes from\n */\nexport function getStateNodes(\n  stateNode: AnyStateNode | AnyStateMachine\n): AnyStateNode[] {\n  const { states } = stateNode;\n  const nodes = Object.keys(states).reduce((accNodes, stateKey) => {\n    const childStateNode = states[stateKey];\n    const childStateNodes = getStateNodes(childStateNode);\n\n    accNodes.push(childStateNode, ...childStateNodes);\n    return accNodes;\n  }, [] as AnyStateNode[]);\n\n  return nodes;\n}\n\nfunction getChildren(stateNode: AnyStateNode): AnyStateNode[] {\n  if (!stateNode.states) {\n    return [];\n  }\n\n  const children = Object.keys(stateNode.states).map((key) => {\n    return stateNode.states[key];\n  });\n\n  return children;\n}\n\nexport function serializeSnapshot(snapshot: Snapshot<any>): SerializedSnapshot {\n  const { value, context } = snapshot as any;\n  return JSON.stringify({\n    value,\n    context: Object.keys(context ?? {}).length ? context : undefined\n  }) as SerializedSnapshot;\n}\n\nfunction serializeEvent<TEvent extends EventObject>(\n  event: TEvent\n): SerializedEvent {\n  return JSON.stringify(event) as SerializedEvent;\n}\n\nexport function createDefaultMachineOptions<TMachine extends AnyStateMachine>(\n  machine: TMachine,\n  options?: TraversalOptions<\n    ReturnType<TMachine['transition']>,\n    EventFromLogic<TMachine>,\n    InputFrom<TMachine>\n  >\n): TraversalOptions<\n  ReturnType<TMachine['transition']>,\n  EventFromLogic<TMachine>,\n  InputFrom<TMachine>\n> {\n  const { events: getEvents, ...otherOptions } = options ?? {};\n  const traversalOptions: TraversalOptions<\n    ReturnType<TMachine['transition']>,\n    EventFromLogic<TMachine>,\n    InputFrom<TMachine>\n  > = {\n    serializeState: serializeSnapshot,\n    serializeEvent,\n    events: (state) => {\n      const events =\n        typeof getEvents === 'function' ? getEvents(state) : (getEvents ?? []);\n      return __unsafe_getAllOwnEventDescriptors(state).flatMap((type) => {\n        const matchingEvents = events.filter((ev) => (ev as any).type === type);\n        if (matchingEvents.length) {\n          return matchingEvents;\n        }\n        return [{ type }];\n      }) as any[];\n    },\n    fromState: machine.getInitialSnapshot(\n      createMockActorScope(),\n      options?.input\n    ) as ReturnType<TMachine['transition']>,\n    ...otherOptions\n  };\n\n  return traversalOptions;\n}\n\nexport function createDefaultLogicOptions(): TraversalOptions<any, any, any> {\n  return {\n    serializeState: (state) => JSON.stringify(state),\n    serializeEvent\n  };\n}\n\nexport function toDirectedGraph(\n  stateMachine: AnyStateNode | AnyStateMachine\n): DirectedGraphNode {\n  const stateNode =\n    stateMachine instanceof StateMachine ? stateMachine.root : stateMachine; // TODO: accept only machines\n\n  const edges: DirectedGraphEdge[] = [...stateNode.transitions.values()]\n    .flat()\n    .flatMap((t, transitionIndex) => {\n      const targets = t.target ? t.target : [stateNode];\n\n      return targets.map((target, targetIndex) => {\n        const edge: DirectedGraphEdge = {\n          id: `${stateNode.id}:${transitionIndex}:${targetIndex}`,\n          source: stateNode,\n          target: target as AnyStateNode,\n          transition: t,\n          label: {\n            text: t.eventType,\n            toJSON: () => ({ text: t.eventType })\n          },\n          toJSON: () => {\n            const { label } = edge;\n\n            return { source: stateNode.id, target: target.id, label };\n          }\n        };\n\n        return edge;\n      });\n    });\n\n  const graph = {\n    id: stateNode.id,\n    stateNode: stateNode,\n    children: getChildren(stateNode).map(toDirectedGraph),\n    edges,\n    toJSON: () => {\n      const { id, children, edges: graphEdges } = graph;\n      return { id, children, edges: graphEdges };\n    }\n  };\n\n  return graph;\n}\n\nfunction isMachineLogic(logic: AnyActorLogic): logic is AnyStateMachine {\n  return 'getStateNodeById' in logic;\n}\n\nexport function resolveTraversalOptions<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  traversalOptions?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >,\n  defaultOptions?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): TraversalConfig<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>> {\n  const resolvedDefaultOptions =\n    defaultOptions ??\n    (isMachineLogic(logic)\n      ? (createDefaultMachineOptions(\n          logic,\n          traversalOptions as any\n        ) as TraversalOptions<\n          ReturnType<TLogic['transition']>,\n          EventFromLogic<TLogic>,\n          InputFrom<TLogic>\n        >)\n      : undefined);\n  const serializeState =\n    traversalOptions?.serializeState ??\n    resolvedDefaultOptions?.serializeState ??\n    ((state) => JSON.stringify(state));\n  const traversalConfig: TraversalConfig<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>\n  > = {\n    serializeState,\n    serializeEvent,\n    events: [],\n    limit: Infinity,\n    fromState: undefined,\n    toState: undefined,\n    // Traversal should not continue past the `toState` predicate\n    // since the target state has already been reached at that point\n    stopWhen: traversalOptions?.toState,\n    ...resolvedDefaultOptions,\n    ...traversalOptions\n  };\n\n  return traversalConfig;\n}\n\nexport function joinPaths<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject\n>(\n  headPath: StatePath<TSnapshot, TEvent>,\n  tailPath: StatePath<TSnapshot, TEvent>\n): StatePath<TSnapshot, TEvent> {\n  const secondPathSource = tailPath.steps[0].state;\n\n  if (secondPathSource !== headPath.state) {\n    throw new Error(`Paths cannot be joined`);\n  }\n\n  return {\n    state: tailPath.state,\n    // e.g. [A, B, C] + [C, D, E] = [A, B, C, D, E]\n    steps: headPath.steps.concat(tailPath.steps.slice(1)),\n    weight: headPath.weight + tailPath.weight\n  };\n}\n","import {\n  ActorScope,\n  ActorLogic,\n  ActorSystem,\n  EventObject,\n  Snapshot\n} from '../index.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  TraversalOptions,\n  AdjacencyMap,\n  AdjacencyValue\n} from './types';\nimport { resolveTraversalOptions } from './graph.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getAdjacencyMap<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n>(\n  logic: ActorLogic<TSnapshot, TEvent, TInput, TSystem>,\n  options: TraversalOptions<TSnapshot, TEvent, TInput>\n): AdjacencyMap<TSnapshot, TEvent> {\n  const { transition } = logic;\n  const {\n    serializeEvent,\n    serializeState,\n    events: getEvents,\n    limit,\n    fromState: customFromState,\n    stopWhen\n  } = resolveTraversalOptions(logic, options);\n  const actorScope = createMockActorScope() as ActorScope<\n    TSnapshot,\n    TEvent,\n    TSystem\n  >;\n  const fromState =\n    customFromState ??\n    logic.getInitialSnapshot(\n      actorScope,\n      // TODO: fix this\n      options.input as TInput\n    );\n  const adj: AdjacencyMap<TSnapshot, TEvent> = {};\n\n  let iterations = 0;\n  const queue: Array<{\n    nextState: TSnapshot;\n    event: TEvent | undefined;\n    prevState: TSnapshot | undefined;\n  }> = [{ nextState: fromState, event: undefined, prevState: undefined }];\n  const stateMap = new Map<SerializedSnapshot, TSnapshot>();\n\n  while (queue.length) {\n    const { nextState: state, event, prevState } = queue.shift()!;\n\n    if (iterations++ > limit) {\n      throw new Error('Traversal limit exceeded');\n    }\n\n    const serializedState = serializeState(\n      state,\n      event,\n      prevState\n    ) as SerializedSnapshot;\n    if (adj[serializedState]) {\n      continue;\n    }\n    stateMap.set(serializedState, state);\n\n    adj[serializedState] = {\n      state,\n      transitions: {}\n    };\n\n    if (stopWhen && stopWhen(state)) {\n      continue;\n    }\n\n    const events =\n      typeof getEvents === 'function' ? getEvents(state) : getEvents;\n\n    for (const nextEvent of events) {\n      const nextSnapshot = transition(state, nextEvent, actorScope);\n\n      adj[serializedState].transitions[\n        serializeEvent(nextEvent) as SerializedEvent\n      ] = {\n        event: nextEvent,\n        state: nextSnapshot\n      };\n      queue.push({\n        nextState: nextSnapshot,\n        event: nextEvent,\n        prevState: state\n      });\n    }\n  }\n\n  return adj;\n}\n\nexport function adjacencyMapToArray<TSnapshot, TEvent>(\n  adjMap: AdjacencyMap<TSnapshot, TEvent>\n): Array<{\n  state: TSnapshot;\n  event: TEvent;\n  nextState: TSnapshot;\n}> {\n  const adjList: Array<{\n    state: TSnapshot;\n    event: TEvent;\n    nextState: TSnapshot;\n  }> = [];\n\n  for (const adjValue of Object.values(adjMap)) {\n    for (const transition of Object.values(\n      (adjValue as AdjacencyValue<TSnapshot, TEvent>).transitions\n    )) {\n      adjList.push({\n        state: (adjValue as AdjacencyValue<TSnapshot, TEvent>).state,\n        event: transition.event,\n        nextState: transition.state\n      });\n    }\n  }\n\n  return adjList;\n}\n","import { StatePath } from './types.ts';\n\n// TODO: rewrite parts of the algorithm leading to this to make this function obsolete\nexport function alterPath<T extends StatePath<any, any>>(path: T): T {\n  let steps: T['steps'] = [];\n\n  if (!path.steps.length) {\n    steps = [\n      {\n        state: path.state,\n        event: { type: 'xstate.init' } as any\n      }\n    ];\n  } else {\n    for (let i = 0; i < path.steps.length; i++) {\n      const step = path.steps[i];\n\n      steps.push({\n        state: step.state,\n        event: i === 0 ? { type: 'xstate.init' } : path.steps[i - 1].event\n      });\n    }\n    steps.push({\n      state: path.state,\n      event: path.steps[path.steps.length - 1].event\n    });\n  }\n  return {\n    ...path,\n    steps\n  };\n}\n","import {\n  ActorScope,\n  ActorLogic,\n  ActorSystem,\n  AnyStateMachine,\n  EventObject,\n  Snapshot\n} from '../index.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Steps,\n  TraversalOptions\n} from './types.ts';\nimport {\n  resolveTraversalOptions,\n  createDefaultMachineOptions,\n  createDefaultLogicOptions\n} from './graph.ts';\nimport { alterPath } from './alterPath.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nfunction isMachine(value: any): value is AnyStateMachine {\n  return !!value && '__xstatenode' in value;\n}\n\nexport function getPathsFromEvents<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n>(\n  logic: ActorLogic<TSnapshot, TEvent, TInput, TSystem>,\n  events: TEvent[],\n  options?: TraversalOptions<TSnapshot, TEvent, TInput>\n): Array<StatePath<TSnapshot, TEvent>> {\n  const resolvedOptions = resolveTraversalOptions(\n    logic,\n    {\n      events,\n      ...options\n    },\n    (isMachine(logic)\n      ? createDefaultMachineOptions(logic)\n      : createDefaultLogicOptions()) as TraversalOptions<\n      TSnapshot,\n      TEvent,\n      TInput\n    >\n  );\n  const actorScope = createMockActorScope() as ActorScope<\n    TSnapshot,\n    TEvent,\n    TSystem\n  >;\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(\n      actorScope,\n      // TODO: fix this\n      options?.input as TInput\n    );\n\n  const { serializeState, serializeEvent } = resolvedOptions;\n\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n\n  const stateMap = new Map<SerializedSnapshot, TSnapshot>();\n  const steps: Steps<TSnapshot, TEvent> = [];\n\n  const serializedFromState = serializeState(\n    fromState,\n    undefined,\n    undefined\n  ) as SerializedSnapshot;\n  stateMap.set(serializedFromState, fromState);\n\n  let stateSerial = serializedFromState;\n  let state = fromState;\n  for (const event of events) {\n    steps.push({\n      state: stateMap.get(stateSerial)!,\n      event\n    });\n\n    const eventSerial = serializeEvent(event) as SerializedEvent;\n    const { state: nextState, event: _nextEvent } =\n      adjacency[stateSerial].transitions[eventSerial];\n\n    if (!nextState) {\n      throw new Error(\n        `Invalid transition from ${stateSerial} with ${eventSerial}`\n      );\n    }\n    const prevState = stateMap.get(stateSerial);\n    const nextStateSerial = serializeState(\n      nextState,\n      event,\n      prevState\n    ) as SerializedSnapshot;\n    stateMap.set(nextStateSerial, nextState);\n\n    stateSerial = nextStateSerial;\n    state = nextState;\n  }\n\n  // If it is expected to reach a specific state (`toState`) and that state\n  // isn't reached, there are no paths\n  if (resolvedOptions.toState && !resolvedOptions.toState(state)) {\n    return [];\n  }\n\n  return [\n    alterPath({\n      state,\n      steps,\n      weight: steps.length\n    })\n  ];\n}\n","import { AnyActorLogic, EventFromLogic, InputFrom } from '../index.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport { alterPath } from './alterPath.ts';\nimport { resolveTraversalOptions } from './graph.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  StatePlanMap,\n  TraversalOptions\n} from './types.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getShortestPaths<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): Array<StatePath<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>>> {\n  type TInternalState = ReturnType<TLogic['transition']>;\n  type TEvent = EventFromLogic<TLogic>;\n\n  const resolvedOptions = resolveTraversalOptions(logic, options);\n  const serializeState = resolvedOptions.serializeState as (\n    ...args: Parameters<typeof resolvedOptions.serializeState>\n  ) => SerializedSnapshot;\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(createMockActorScope(), options?.input);\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n\n  // weight, state, event\n  const weightMap = new Map<\n    SerializedSnapshot,\n    {\n      weight: number;\n      state: SerializedSnapshot | undefined;\n      event: TEvent | undefined;\n    }\n  >();\n  const stateMap = new Map<SerializedSnapshot, TInternalState>();\n  const serializedFromState = serializeState(fromState, undefined, undefined);\n  stateMap.set(serializedFromState, fromState);\n\n  weightMap.set(serializedFromState, {\n    weight: 0,\n    state: undefined,\n    event: undefined\n  });\n  const unvisited = new Set<SerializedSnapshot>();\n  const visited = new Set<SerializedSnapshot>();\n\n  unvisited.add(serializedFromState);\n  for (const serializedState of unvisited) {\n    const prevState = stateMap.get(serializedState);\n    const { weight } = weightMap.get(serializedState)!;\n    for (const event of Object.keys(\n      adjacency[serializedState].transitions\n    ) as SerializedEvent[]) {\n      const { state: nextState, event: eventObject } =\n        adjacency[serializedState].transitions[event];\n      const nextSerializedState = serializeState(\n        nextState,\n        eventObject,\n        prevState\n      );\n      stateMap.set(nextSerializedState, nextState);\n      if (!weightMap.has(nextSerializedState)) {\n        weightMap.set(nextSerializedState, {\n          weight: weight + 1,\n          state: serializedState,\n          event: eventObject\n        });\n      } else {\n        const { weight: nextWeight } = weightMap.get(nextSerializedState)!;\n        if (nextWeight > weight + 1) {\n          weightMap.set(nextSerializedState, {\n            weight: weight + 1,\n            state: serializedState,\n            event: eventObject\n          });\n        }\n      }\n      if (!visited.has(nextSerializedState)) {\n        unvisited.add(nextSerializedState);\n      }\n    }\n    visited.add(serializedState);\n    unvisited.delete(serializedState);\n  }\n\n  const statePlanMap: StatePlanMap<TInternalState, TEvent> = {};\n  const paths: Array<StatePath<TInternalState, TEvent>> = [];\n\n  weightMap.forEach(\n    ({ weight, state: fromState, event: fromEvent }, stateSerial) => {\n      const state = stateMap.get(stateSerial)!;\n      const steps = !fromState\n        ? []\n        : statePlanMap[fromState].paths[0].steps.concat({\n            state: stateMap.get(fromState)!,\n            event: fromEvent!\n          });\n\n      paths.push({\n        state,\n        steps,\n        weight\n      });\n      statePlanMap[stateSerial] = {\n        state,\n        paths: [\n          {\n            state,\n            steps,\n            weight\n          }\n        ]\n      };\n    }\n  );\n\n  if (resolvedOptions.toState) {\n    return paths\n      .filter((path) => resolvedOptions.toState!(path.state))\n      .map(alterPath);\n  }\n\n  return paths.map(alterPath);\n}\n","import { AnyActorLogic, EventFromLogic, InputFrom } from '../index.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Steps,\n  TraversalOptions,\n  VisitedContext\n} from './types.ts';\nimport { resolveTraversalOptions } from './graph.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport { alterPath } from './alterPath.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getSimplePaths<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): Array<StatePath<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>>> {\n  type TState = ReturnType<TLogic['transition']>;\n  type TEvent = EventFromLogic<TLogic>;\n\n  const resolvedOptions = resolveTraversalOptions(logic, options);\n  const actorScope = createMockActorScope();\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(actorScope, options?.input);\n  const serializeState = resolvedOptions.serializeState as (\n    ...args: Parameters<typeof resolvedOptions.serializeState>\n  ) => SerializedSnapshot;\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n  const stateMap = new Map<SerializedSnapshot, TState>();\n  const visitCtx: VisitedContext<TState, TEvent> = {\n    vertices: new Set(),\n    edges: new Set()\n  };\n  const steps: Steps<TState, TEvent> = [];\n  const pathMap: Record<\n    SerializedSnapshot,\n    { state: TState; paths: Array<StatePath<TState, TEvent>> }\n  > = {};\n\n  function util(\n    fromStateSerial: SerializedSnapshot,\n    toStateSerial: SerializedSnapshot\n  ) {\n    const fromState = stateMap.get(fromStateSerial)!;\n    visitCtx.vertices.add(fromStateSerial);\n\n    if (fromStateSerial === toStateSerial) {\n      if (!pathMap[toStateSerial]) {\n        pathMap[toStateSerial] = {\n          state: stateMap.get(toStateSerial)!,\n          paths: []\n        };\n      }\n\n      const toStatePlan = pathMap[toStateSerial];\n\n      const path2: StatePath<TState, TEvent> = {\n        state: fromState,\n        weight: steps.length,\n        steps: [...steps]\n      };\n\n      toStatePlan.paths.push(path2);\n    } else {\n      for (const serializedEvent of Object.keys(\n        adjacency[fromStateSerial].transitions\n      ) as SerializedEvent[]) {\n        const { state: nextState, event: subEvent } =\n          adjacency[fromStateSerial].transitions[serializedEvent];\n\n        if (!(serializedEvent in adjacency[fromStateSerial].transitions)) {\n          continue;\n        }\n        const prevState = stateMap.get(fromStateSerial);\n\n        const nextStateSerial = serializeState(nextState, subEvent, prevState);\n        stateMap.set(nextStateSerial, nextState);\n\n        if (!visitCtx.vertices.has(nextStateSerial)) {\n          visitCtx.edges.add(serializedEvent);\n          steps.push({\n            state: stateMap.get(fromStateSerial)!,\n            event: subEvent\n          });\n          util(nextStateSerial, toStateSerial);\n        }\n      }\n    }\n\n    steps.pop();\n    visitCtx.vertices.delete(fromStateSerial);\n  }\n\n  const fromStateSerial = serializeState(fromState, undefined);\n  stateMap.set(fromStateSerial, fromState);\n\n  for (const nextStateSerial of Object.keys(\n    adjacency\n  ) as SerializedSnapshot[]) {\n    util(fromStateSerial, nextStateSerial);\n  }\n\n  const simplePaths = Object.values(pathMap).flatMap((p) => p.paths);\n\n  if (resolvedOptions.toState) {\n    return simplePaths\n      .filter((path) => resolvedOptions.toState!(path.state))\n      .map(alterPath);\n  }\n\n  return simplePaths.map(alterPath);\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","enqueue","event","enqueued","value","consumed","XSTATE_INIT","XSTATE_STOP","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","createDoneStateEvent","id","output","type","createInitEvent","input","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","matchesState","parentStateId","childStateId","parentStateValue","toStateValue","childStateValue","Object","keys","every","key","toStatePath","stateId","isArray","result","segment","i","length","charCodeAt","push","stateValue","isMachineSnapshot","statePath","marker","previous","pathToStateValue","mapValues","collection","iteratee","collectionKeys","toArrayStrict","toArray","undefined","resolveOutput","mapper","context","Array","toTransitionConfigArray","configLike","map","transitionLike","target","normalizeTarget","toObserver","nextHandler","errorHandler","completionHandler","isObserver","bind","error","complete","createInvokeId","stateNodeId","index","resolveReferencedActor","machine","src","match","implementations","actors","indexStr","nodeId","invokeConfig","getStateNodeById","config","invoke","getAllOwnEventDescriptors","snapshot","Set","_nodes","flatMap","sn","ownEvents","createScheduledEventId","actorRef","sessionId","idCounter","executingCustomAction","ProcessingStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_snapshot","mailbox","observers","eventListeners","Map","_processingStatus","NotStarted","_parent","_syncSnapshot","ref","_actorScope","systemId","system","_doneEvent","_deferred","resolvedOptions","parent","syncSnapshot","inspect","rootActor","children","keyedActors","reverseKeyedActors","WeakMap","inspectionObservers","timerMap","scheduler","schedule","source","delay","Math","random","toString","slice","scheduledEvent","startedAt","Date","now","scheduledEventId","_scheduledEvents","timeout","_relay","cancel","cancelAll","_bookId","_register","set","_unregister","delete","get","getAll","fromEntries","entries","_set","existing","Error","observerOrFn","observer","add","unsubscribe","_sendInspectionEvent","size","resolvedInspectionEvent","rootId","forEach","sourceRef","_send","getSnapshot","scheduledEvents","scheduledId","_clock","_logger","createSystem","defer","stopChild","child","_stop","emit","emittedEvent","listeners","wildcardListener","allListeners","values","handler","actionExecutor","action","exec","params","saveExecutingCustomAction","info","Running","send","_initState","state","status","persistedState","restoreSnapshot","getInitialSnapshot","update","deferredFn","shift","_stopProcedure","_complete","invokeId","actorId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","on","wrappedHandler","initEvent","attachDevTools","nextState","caughtError","transition","stop","_reportError","reportError","err2","toJSON","xstate$$type","getPersistedSnapshot","createActor","resolveCancel","_","actionArgs","actionParams","sendId","executeCancel","actorScope","resolveSpawn","_actionParams","resolvedId","resolvedInput","cloneMachineSnapshot","executeSpawn","spawnChild","_args","_params","resolve","execute","resolveStop","args","actorRefOrString","resolvedActorRef","executeStop","evaluateGuard","guard","isInline","resolved","guards","guardArgs","guardParams","check","isAtomicStateNode","stateNode","getChildren","states","filter","getProperAncestors","toStateNode","ancestors","m","getAllStateNodes","stateNodes","nodeSet","adjList","getAdjList","s","has","initialStates","getInitialStateNodesWithTheirAncestors","initialStateNode","getValueFromAdj","baseNode","childStateNodes","childStateNode","getStateValue","rootNode","isInFinalState","stateNodeSet","some","isStateId","str","getDelayedTransitions","afterConfig","after","mutateEntryExit","afterEvent","delayRef","eventType","entry","eventOrExpr","raise","resolveRaise","executeRaise","exit","configTransition","resolvedTransition","resolvedDelay","Number","isNaN","delayedTransition","formatTransition","descriptor","transitionConfig","normalizedTarget","reenter","targets","isInternalTarget","getStateNodeByPath","resolvedTarget","message","resolveTarget","actions","t","resolveHistoryDefaultTransition","initial","isHistoryNode","getInitialStateNodes","initialState","ancestor","iter","descStateNode","getStateNode","stateKey","arrayStatePath","currentStateNode","getStateNodes","childStateKeys","subStateKey","Boolean","root","concat","reduce","allSubStateNodes","subStateNode","subStateNodes","transitionNode","transitionAtomicNode","subStateKeys","transitionCompoundNode","allInnerTransitions","subStateValue","innerTransitions","transitionParallelNode","getHistoryNodes","isDescendant","parentStateNode","hasIntersection","s1","s2","set1","set2","item","removeConflictingTransitions","enabledTransitions","historyValue","filteredTransitions","t1","t1Preempted","transitionsToRemove","t2","computeExitSet","t3","from","getEffectiveTargetStates","targetNode","node","getTransitionDomain","targetStates","lca","head","tail","findLeastCommonAncestor","transitions","statesToExit","domain","microstep","currentSnapshot","isInitial","internalQueue","mutStateNodeSet","nextSnapshot","changedHistory","sort","a","b","order","exitStateNode","historyNode","predicate","history","resolveActionsAndContext","def","exitStates","statesToEnter","statesForDefaultEntry","addDescendantStatesToEnter","addAncestorStatesToEnter","computeEntrySet","completedNodes","stateNodeToEnter","invokeDef","onSnapshot","initialActions","ancestorMarker","rootCompletionNode","getMachineOutput","enterStates","nextStateNodes","prevStateNodes","nextStateNodeSet","areStateNodeCollectionsEqual","e","doneStateEvent","historyStateNodes","addProperAncestorStatesToEnter","historyDefaultTransition","reentrancyDomain","anc","getAction","actionType","resolveAndExecuteActionsWithContext","extra","retries","intermediateSnapshot","resolvedAction","name","builtinAction","deferredActorIds","retryResolve","macrostep","microstates","addMicrostate","microstate","_transitions","stopChildren","nextEvent","currentEvent","isErr","startsWith","isErrorActorEvent","selectTransitions","shouldSelectEventlessTransitions","selectEventlessTransitions","previousState","getTransitionData","enabledTransitionSet","atomicStates","loop","always","machineSnapshotMatches","testValue","machineSnapshotHasTag","tag","tags","machineSnapshotCan","transitionData","machineSnapshotToJSON","nodes","getMeta","can","hasTag","matches","jsonValues","machineSnapshotGetMeta","acc","meta","createMachineSnapshot","serializeHistoryValue","persistContext","contextPart","copy","createSpawner","spawnedChildren","spawn","resolveAssign","assignment","assignArgs","partialUpdate","propAssignment","assign","delaysMap","delays","resolvedEvent","configDelay","emptyLogic","initialContext","cache","memo","object","memoizedData","EMPTY_OBJECT","toSerializableAction","StateNode","path","description","_key","_machine","join","idMap","stateConfig","_initialize","transitionsConfig","onDone","onError","formatTransitions","definition","version","flat","sourceName","invokeDefValues","_target","formatInitialTransition","selectedTransition","candidates","getCandidates","receivedEventType","eventDescriptor","endsWith","partialEventTokens","split","eventTokens","tokenIndex","partialEventToken","eventToken","candidate","resolvedContext","guardPassed","guardType","events","StateMachine","schemas","__xstatenode","provide","resolveState","resolvedStateValue","getPreInitialState","preInitial","preInitialState","macroState","fullPath","relativePath","resolvedStateId","STATE_IDENTIFIER","childrenJson","snapshotChildren","resolveHistoryReferencedState","referenced","actorData","childState","revivedHistoryValue","revived","arr","reviveHistoryValue","restoredSnapshot","seen","reviveContext","simpleStringify","JSON","stringify","getDescription","contextString","stateStrings","trim","createShortestPathsGen","getShortestPaths","createSimplePathsGen","getSimplePaths","validateState","TestModel","getDefaultOptions","serializeState","serializeEvent","serializeTransition","stateMatcher","testLogic","defaultTraversalOptions","_toTestPath","eventsString","steps","other","formatEvent","test","testPath","getPaths","pathGenerator","allowDuplicatePaths","paths","_resolveOptions","deduplicatePaths","allPathsWithEventSequence","eventSequence","step","z","superpathsWithEventSequence","pathLoop","pathWithEventSequence","superpathLoop","superpathWithEventSequence","getShortestPathsFrom","resultPaths","shortestPaths","fromState","shortestPath","joinPaths","getSimplePathsFrom","getPathsFromEvents","getAdjacencyMap","testPathResult","testStepResult","testTransition","testState","formatColor","_color","string","targetStateString","errMessage","hasFailed","stateString","eventString","formatPathTestResult","stateTestKeys","_getStateTestKeys","stateTestKey","_getEventExec","eventExec","stateValuesEqual","aKeys","bKeys","serializeMachineTransition","previousSnapshot","prevStateString","createMockActorScope","emptyActor","serializeSnapshot","createDefaultMachineOptions","getEvents","otherOptions","__unsafe_getAllOwnEventDescriptors","matchingEvents","ev","createDefaultLogicOptions","resolveTraversalOptions","traversalOptions","resolvedDefaultOptions","isMachineLogic","limit","Infinity","toState","stopWhen","headPath","tailPath","weight","customFromState","adj","iterations","queue","prevState","stateMap","serializedState","alterPath","adjacency","serializedFromState","stateSerial","eventSerial","_nextEvent","nextStateSerial","weightMap","unvisited","visited","eventObject","nextSerializedState","nextWeight","statePlanMap","fromEvent","visitCtx","vertices","edges","pathMap","util","fromStateSerial","toStateSerial","toStatePlan","path2","serializedEvent","subEvent","pop","simplePaths","p","adjMap","adjValue","validateMachine","includes","accNodes","toDirectedGraph","stateMachine","transitionIndex","targetIndex","edge","label","text","graph","graphEdges"],"mappings":"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"}