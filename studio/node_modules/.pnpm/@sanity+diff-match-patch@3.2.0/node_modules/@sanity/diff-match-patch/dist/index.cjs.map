{"version":3,"file":"index.cjs","sources":["../src/diff/clone.ts","../src/diff/commonOverlap.ts","../src/diff/commonPrefix.ts","../src/diff/commonSuffix.ts","../src/utils/surrogatePairs.ts","../src/diff/bisect.ts","../src/diff/halfMatch.ts","../src/diff/charsToLines.ts","../src/diff/linesToChars.ts","../src/diff/lineMode.ts","../src/diff/compute.ts","../src/diff/diff.ts","../src/diff/cleanup.ts","../src/match/bitap.ts","../src/match/match.ts","../src/diff/diffText.ts","../src/diff/levenshtein.ts","../src/diff/xIndex.ts","../src/utils/utf8Indices.ts","../src/patch/constants.ts","../src/patch/addPadding.ts","../src/patch/createPatchObject.ts","../src/patch/splitMax.ts","../src/patch/apply.ts","../src/patch/make.ts","../src/patch/parse.ts","../src/patch/stringify.ts"],"sourcesContent":["import {type Diff} from './diff.js'\n\n/**\n * Clones a diff tuple.\n *\n * @param diff - Tuple to clone.\n * @returns New, cloned tuple.\n * @internal\n */\nexport function cloneDiff(diff: Diff): Diff {\n  const [type, patch] = diff\n  return [type, patch]\n}\n","/**\n * Determine if the suffix of one string is the prefix of another.\n *\n * @param textA - First string.\n * @param textB - Second string.\n * @returns Number of characters common to the end of the first string\n *   and the start of the second string.\n * @internal\n */\nexport function getCommonOverlap(textA: string, textB: string): number {\n  let text1 = textA\n  let text2 = textB\n\n  // Cache the text lengths to prevent multiple calls.\n  const text1Length = text1.length\n  const text2Length = text2.length\n\n  // Eliminate the null case.\n  if (text1Length === 0 || text2Length === 0) {\n    return 0\n  }\n\n  // Truncate the longer string.\n  if (text1Length > text2Length) {\n    text1 = text1.substring(text1Length - text2Length)\n  } else if (text1Length < text2Length) {\n    text2 = text2.substring(0, text1Length)\n  }\n  const textLength = Math.min(text1Length, text2Length)\n\n  // Quick check for the worst case.\n  if (text1 === text2) {\n    return textLength\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  let best = 0\n  let length = 1\n\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length)\n    found = text2.indexOf(pattern)\n    if (found === -1) {\n      return best\n    }\n    length += found\n    if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n      best = length\n      length++\n    }\n  }\n\n  // Only for typescript, never reached\n  return best\n}\n","/**\n * Determine the common prefix of two strings.\n *\n * @param text1 - First string.\n * @param text2 - Second string.\n * @returns The number of characters common to the start of each string.\n * @internal\n */\nexport function getCommonPrefix(text1: string, text2: string): number {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1[0] !== text2[0]) {\n    return 0\n  }\n\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  let pointerMin = 0\n  let pointerMax = Math.min(text1.length, text2.length)\n  let pointerMid = pointerMax\n  let pointerStart = 0\n  while (pointerMin < pointerMid) {\n    if (text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid)) {\n      pointerMin = pointerMid\n      pointerStart = pointerMin\n    } else {\n      pointerMax = pointerMid\n    }\n    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin)\n  }\n  return pointerMid\n}\n","/**\n * Determine the common suffix of two strings.\n *\n * @param text1 - First string.\n * @param text2 - Second string.\n * @returns The number of characters common to the end of each string.\n * @internal\n */\nexport function getCommonSuffix(text1: string, text2: string): number {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) {\n    return 0\n  }\n\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  let pointerMin = 0\n  let pointerMax = Math.min(text1.length, text2.length)\n  let pointerMid = pointerMax\n  let pointerEnd = 0\n  while (pointerMin < pointerMid) {\n    if (\n      text1.substring(text1.length - pointerMid, text1.length - pointerEnd) ===\n      text2.substring(text2.length - pointerMid, text2.length - pointerEnd)\n    ) {\n      pointerMin = pointerMid\n      pointerEnd = pointerMin\n    } else {\n      pointerMax = pointerMid\n    }\n    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin)\n  }\n\n  return pointerMid\n}\n","/**\n * Checks if the character is a high surrogate\n *\n * @param char - Character to check\n * @returns True if high surrogate, false otherwise\n */\nexport function isHighSurrogate(char: string): boolean {\n  const charCode = char.charCodeAt(0)\n  return charCode >= 0xd800 && charCode <= 0xdbff\n}\n\n/**\n * Checks if the character is a low surrogate\n *\n * @param char - Character to check\n * @returns True if low surrogate, false otherwise\n */\nexport function isLowSurrogate(char: string): boolean {\n  const charCode = char.charCodeAt(0)\n  return charCode >= 0xdc00 && charCode <= 0xdfff\n}\n","import {type Diff, DIFF_DELETE, DIFF_INSERT, doDiff} from './diff.js'\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n *\n * @param text1 - Old string to be diffed.\n * @param text2 - New string to be diffed.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function bisect(text1: string, text2: string, deadline: number): Diff[] {\n  // Cache the text lengths to prevent multiple calls.\n  const text1Length = text1.length\n  const text2Length = text2.length\n  const maxD = Math.ceil((text1Length + text2Length) / 2)\n  const vOffset = maxD\n  const vLength = 2 * maxD\n  const v1 = new Array(vLength)\n  const v2 = new Array(vLength)\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (let x = 0; x < vLength; x++) {\n    v1[x] = -1\n    v2[x] = -1\n  }\n  v1[vOffset + 1] = 0\n  v2[vOffset + 1] = 0\n  const delta = text1Length - text2Length\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  const front = delta % 2 !== 0\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  let k1start = 0\n  let k1end = 0\n  let k2start = 0\n  let k2end = 0\n  for (let d = 0; d < maxD; d++) {\n    // Bail out if deadline is reached.\n    if (Date.now() > deadline) {\n      break\n    }\n    // Walk the front path one step.\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1\n      let x1\n      if (k1 === -d || (k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1])) {\n        x1 = v1[k1Offset + 1]\n      } else {\n        x1 = v1[k1Offset - 1] + 1\n      }\n      let y1 = x1 - k1\n      while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n        x1++\n        y1++\n      }\n      v1[k1Offset] = x1\n      if (x1 > text1Length) {\n        // Ran off the right of the graph.\n        k1end += 2\n      } else if (y1 > text2Length) {\n        // Ran off the bottom of the graph.\n        k1start += 2\n      } else if (front) {\n        const k2Offset = vOffset + delta - k1\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          // Mirror x2 onto top-left coordinate system.\n          const x2 = text1Length - v2[k2Offset]\n          if (x1 >= x2) {\n            // Overlap detected.\n            return bisectSplit(text1, text2, x1, y1, deadline)\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2\n      let x2\n      if (k2 === -d || (k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1])) {\n        x2 = v2[k2Offset + 1]\n      } else {\n        x2 = v2[k2Offset - 1] + 1\n      }\n      let y2 = x2 - k2\n      while (\n        x2 < text1Length &&\n        y2 < text2Length &&\n        text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)\n      ) {\n        x2++\n        y2++\n      }\n      v2[k2Offset] = x2\n      if (x2 > text1Length) {\n        // Ran off the left of the graph.\n        k2end += 2\n      } else if (y2 > text2Length) {\n        // Ran off the top of the graph.\n        k2start += 2\n      } else if (!front) {\n        const k1Offset = vOffset + delta - k2\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset]\n          const y1 = vOffset + x1 - k1Offset\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1Length - x2\n          if (x1 >= x2) {\n            // Overlap detected.\n            return bisectSplit(text1, text2, x1, y1, deadline)\n          }\n        }\n      }\n    }\n  }\n  // Number of diffs equals number of characters, no commonality at all.\n  return [\n    [DIFF_DELETE, text1],\n    [DIFF_INSERT, text2],\n  ]\n}\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n *\n * @param text1 - Old string to be diffed.\n * @param text2 - New string to be diffed.\n * @param x - Index of split point in text1.\n * @param y - Index of split point in text2.\n * @param deadline - Time at which to bail if not yet complete.\n * @returns Array of diff tuples.\n * @internal\n */\nfunction bisectSplit(text1: string, text2: string, x: number, y: number, deadline: number): Diff[] {\n  const text1a = text1.substring(0, x)\n  const text2a = text2.substring(0, y)\n  const text1b = text1.substring(x)\n  const text2b = text2.substring(y)\n\n  // Compute both diffs serially.\n  const diffs = doDiff(text1a, text2a, {checkLines: false, deadline})\n  const diffsb = doDiff(text1b, text2b, {checkLines: false, deadline})\n\n  return diffs.concat(diffsb)\n}\n","import {getCommonPrefix} from './commonPrefix.js'\nimport {getCommonSuffix} from './commonSuffix.js'\n\ntype HalfMatch = [string, string, string, string, string]\n\n/**\n * Does a slice of shorttext exist within longtext such that the slice\n * is at least half the length of longtext?\n *\n * @param longtext - Longer string.\n * @param shorttext - Shorter string.\n * @param i - Start index of quarter length slice within longtext.\n * @returns Five element Array, containing the prefix of\n *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n *     of shorttext and the common middle.  Or null if there was no match.\n * @internal\n */\nexport function findHalfMatch(text1: string, text2: string, timeout = 1): null | HalfMatch {\n  if (timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null\n  }\n\n  const longText = text1.length > text2.length ? text1 : text2\n  const shortText = text1.length > text2.length ? text2 : text1\n  if (longText.length < 4 || shortText.length * 2 < longText.length) {\n    return null // Pointless.\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4))\n  // Check again based on the third quarter.\n  const halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2))\n\n  let halfMatch\n  if (halfMatch1 && halfMatch2) {\n    // Both matched.  Select the longest.\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2\n  } else if (!halfMatch1 && !halfMatch2) {\n    return null\n  } else if (!halfMatch2) {\n    halfMatch = halfMatch1\n  } else if (!halfMatch1) {\n    halfMatch = halfMatch2\n  }\n\n  if (!halfMatch) {\n    throw new Error('Unable to find a half match.')\n  }\n\n  // A half-match was found, sort out the return data.\n  let text1A: string\n  let text1B: string\n  let text2A: string\n  let text2B: string\n\n  if (text1.length > text2.length) {\n    text1A = halfMatch[0]\n    text1B = halfMatch[1]\n    text2A = halfMatch[2]\n    text2B = halfMatch[3]\n  } else {\n    text2A = halfMatch[0]\n    text2B = halfMatch[1]\n    text1A = halfMatch[2]\n    text1B = halfMatch[3]\n  }\n  const midCommon = halfMatch[4]\n  return [text1A, text1B, text2A, text2B, midCommon]\n}\n\n/**\n * Do the two texts share a slice which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n *\n * @param longText - First string.\n * @param shortText - Second string.\n * @returns Five element array, containing the prefix of longText,\n *     the suffix of longText, the prefix of shortText, the suffix of\n *     shortText and the common middle.  Or null if there was no match.\n * @internal\n */\nfunction halfMatchI(longText: string, shortText: string, i: number): null | HalfMatch {\n  // Start with a 1/4 length slice at position i as a seed.\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4))\n  let j = -1\n  let bestCommon = ''\n  let bestLongTextA\n  let bestLongTextB\n  let bestShortTextA\n  let bestShortTextB\n\n  while ((j = shortText.indexOf(seed, j + 1)) !== -1) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j))\n    const suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j))\n    if (bestCommon.length < suffixLength + prefixLength) {\n      bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength)\n      bestLongTextA = longText.slice(0, i - suffixLength)\n      bestLongTextB = longText.slice(i + prefixLength)\n      bestShortTextA = shortText.slice(0, j - suffixLength)\n      bestShortTextB = shortText.slice(j + prefixLength)\n    }\n  }\n  if (bestCommon.length * 2 >= longText.length) {\n    return [\n      bestLongTextA || '',\n      bestLongTextB || '',\n      bestShortTextA || '',\n      bestShortTextB || '',\n      bestCommon || '',\n    ]\n  }\n\n  return null\n}\n","import {type Diff} from './diff.js'\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of text.\n *\n * @param diffs - Array of diff tuples.\n * @param lineArray - Array of unique strings.\n * @internal\n */\nexport function charsToLines(diffs: Diff[], lineArray: string[]): void {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1]\n    const text: string[] = []\n    for (let y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)]\n    }\n    diffs[x][1] = text.join('')\n  }\n}\n","/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n *\n * @param textA - First string.\n * @param textB - Second string.\n * @returns An object containing the encoded textA, the encoded textB and\n *   the array of unique strings. The zeroth element of the array of unique\n *   strings is intentionally blank.\n * @internal\n */\nexport function linesToChars(\n  textA: string,\n  textB: string,\n): {\n  chars1: string\n  chars2: string\n  lineArray: string[]\n} {\n  const lineArray: string[] = [] // e.g. lineArray[4] === 'Hello\\n'\n  const lineHash: {[key: string]: number} = {} // e.g. lineHash['Hello\\n'] === 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = ''\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   *\n   * @param text - String to encode.\n   * @returns Encoded string.\n   * @internal\n   */\n  function diffLinesToMunge(text: string) {\n    let chars = ''\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    let lineStart = 0\n    let lineEnd = -1\n    // Keeping our own length variable is faster than looking it up.\n    let lineArrayLength = lineArray.length\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart)\n      if (lineEnd === -1) {\n        lineEnd = text.length - 1\n      }\n      let line = text.slice(lineStart, lineEnd + 1)\n\n      // eslint-disable-next-line no-prototype-builtins\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {\n        chars += String.fromCharCode(lineHash[line])\n      } else {\n        if (lineArrayLength === maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.slice(lineStart)\n          lineEnd = text.length\n        }\n        chars += String.fromCharCode(lineArrayLength)\n        lineHash[line] = lineArrayLength\n        lineArray[lineArrayLength++] = line\n      }\n      lineStart = lineEnd + 1\n    }\n    return chars\n  }\n  // Allocate 2/3rds of the space for textA, the rest for textB.\n  let maxLines = 40000\n  const chars1 = diffLinesToMunge(textA)\n  maxLines = 65535\n  const chars2 = diffLinesToMunge(textB)\n  return {chars1, chars2, lineArray}\n}\n","import {charsToLines} from './charsToLines.js'\nimport {cleanupSemantic} from './cleanup.js'\nimport {\n  type Diff,\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  doDiff,\n  type InternalDiffOptions,\n} from './diff.js'\nimport {linesToChars} from './linesToChars.js'\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n *\n * @param textA - Old string to be diffed.\n * @param textB - New string to be diffed.\n * @param options - Options for the differ.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function doLineModeDiff(textA: string, textB: string, opts: InternalDiffOptions): Diff[] {\n  // Don't reassign fn params\n  let text1 = textA\n  let text2 = textB\n\n  // Scan the text on a line-by-line basis first.\n  const a = linesToChars(text1, text2)\n  text1 = a.chars1\n  text2 = a.chars2\n  const linearray = a.lineArray\n\n  let diffs = doDiff(text1, text2, {\n    checkLines: false,\n    deadline: opts.deadline,\n  })\n\n  // Convert the diff back to original text.\n  charsToLines(diffs, linearray)\n  // Eliminate freak matches (e.g. blank lines)\n  diffs = cleanupSemantic(diffs)\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, ''])\n  let pointer = 0\n  let countDelete = 0\n  let countInsert = 0\n  let textDelete = ''\n  let textInsert = ''\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++\n        textInsert += diffs[pointer][1]\n        break\n      case DIFF_DELETE:\n        countDelete++\n        textDelete += diffs[pointer][1]\n        break\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (countDelete >= 1 && countInsert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert)\n          pointer = pointer - countDelete - countInsert\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: false,\n            deadline: opts.deadline,\n          })\n          for (let j = aa.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, aa[j])\n          }\n          pointer += aa.length\n        }\n        countInsert = 0\n        countDelete = 0\n        textDelete = ''\n        textInsert = ''\n        break\n      default:\n        throw new Error('Unknown diff operation.')\n    }\n    pointer++\n  }\n  diffs.pop() // Remove the dummy entry at the end.\n\n  return diffs\n}\n","import {bisect} from './bisect.js'\nimport {\n  type Diff,\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  doDiff,\n  type InternalDiffOptions,\n} from './diff.js'\nimport {findHalfMatch} from './halfMatch.js'\nimport {doLineModeDiff} from './lineMode.js'\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n *\n * @param text1 - Old string to be diffed.\n * @param text2 - New string to be diffed.\n * @param checklines - Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param deadline - Time when the diff should be complete by.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function computeDiff(text1: string, text2: string, opts: InternalDiffOptions): Diff[] {\n  let diffs: Diff[]\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]]\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]]\n  }\n\n  const longtext = text1.length > text2.length ? text1 : text2\n  const shorttext = text1.length > text2.length ? text2 : text1\n  const i = longtext.indexOf(shorttext)\n  if (i !== -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)],\n    ]\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = DIFF_DELETE\n      diffs[2][0] = DIFF_DELETE\n    }\n    return diffs\n  }\n\n  if (shorttext.length === 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [\n      [DIFF_DELETE, text1],\n      [DIFF_INSERT, text2],\n    ]\n  }\n\n  // Check to see if the problem can be split in two.\n  const halfMatch = findHalfMatch(text1, text2)\n  if (halfMatch) {\n    // A half-match was found, sort out the return data.\n    const text1A = halfMatch[0]\n    const text1B = halfMatch[1]\n    const text2A = halfMatch[2]\n    const text2B = halfMatch[3]\n    const midCommon = halfMatch[4]\n    // Send both pairs off for separate processing.\n    const diffsA = doDiff(text1A, text2A, opts)\n    const diffsB = doDiff(text1B, text2B, opts)\n    // Merge the results.\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB)\n  }\n\n  if (opts.checkLines && text1.length > 100 && text2.length > 100) {\n    return doLineModeDiff(text1, text2, opts)\n  }\n\n  return bisect(text1, text2, opts.deadline)\n}\n","import {isHighSurrogate, isLowSurrogate} from '../utils/surrogatePairs.js'\nimport {cleanupMerge} from './cleanup.js'\nimport {getCommonPrefix} from './commonPrefix.js'\nimport {getCommonSuffix} from './commonSuffix.js'\nimport {computeDiff} from './compute.js'\n\n/**\n * Diff type for deleted text.\n *\n * @public\n */\nexport const DIFF_DELETE = -1\n\n/**\n * Diff type for inserted text.\n *\n * @public\n */\nexport const DIFF_INSERT = 1\n\n/**\n * Diff type for text that is equal.\n *\n * @public\n */\nexport const DIFF_EQUAL = 0\n\n/**\n * The three different types of changes possible in a diff:\n * - `DIFF_DELETE`: a deletion of text\n * - `DIFF_INSERT`: an insertion of text\n * - `DIFF_EQUAL` : an equal text\n *\n * @public\n */\nexport type DiffType = typeof DIFF_DELETE | typeof DIFF_INSERT | typeof DIFF_EQUAL\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n *\n * @public\n */\nexport type Diff = [DiffType, string]\n\n/**\n * Options for generating a diff.\n *\n * @public\n */\nexport interface DiffOptions {\n  checkLines: boolean\n  timeout: number\n}\n\n/**\n * @internal\n */\nexport interface InternalDiffOptions {\n  checkLines: boolean\n\n  /**\n   * Time when the diff should be complete by.\n   */\n  deadline: number\n}\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n *\n * @param textA - Old string to be diffed.\n * @param textA - New string to be diffed.\n * @returns Array of diff tuples.\n * @public\n */\nexport function diff(\n  textA: null | string,\n  textB: null | string,\n  opts?: Partial<DiffOptions>,\n): Diff[] {\n  // Check for null inputs.\n  if (textA === null || textB === null) {\n    throw new Error('Null input. (diff)')\n  }\n\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}))\n  adjustDiffForSurrogatePairs(diffs)\n  return diffs\n}\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n *\n * @param textA - Old string to be diffed.\n * @param textB - New string to be diffed.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function doDiff(textA: string, textB: string, options: InternalDiffOptions): Diff[] {\n  // Don't reassign fn params\n  let text1 = textA\n  let text2 = textB\n\n  // Check for equality (speedup).\n  if (text1 === text2) {\n    return text1 ? [[DIFF_EQUAL, text1]] : []\n  }\n\n  // Trim off common prefix (speedup).\n  let commonlength = getCommonPrefix(text1, text2)\n  const commonprefix = text1.substring(0, commonlength)\n  text1 = text1.substring(commonlength)\n  text2 = text2.substring(commonlength)\n\n  // Trim off common suffix (speedup).\n  commonlength = getCommonSuffix(text1, text2)\n  const commonsuffix = text1.substring(text1.length - commonlength)\n  text1 = text1.substring(0, text1.length - commonlength)\n  text2 = text2.substring(0, text2.length - commonlength)\n\n  // Compute the diff on the middle block.\n  let diffs = computeDiff(text1, text2, options)\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix])\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix])\n  }\n  diffs = cleanupMerge(diffs)\n  return diffs\n}\n\nfunction createDeadLine(timeout: undefined | number): number {\n  let t = 1\n  if (typeof timeout !== 'undefined') {\n    t = timeout <= 0 ? Number.MAX_VALUE : timeout\n  }\n  return Date.now() + t * 1000\n}\n\nfunction createInternalOpts(opts: Partial<DiffOptions>): InternalDiffOptions {\n  return {\n    checkLines: true,\n    deadline: createDeadLine(opts.timeout || 1.0),\n    ...opts,\n  }\n}\n\nfunction combineChar(data: string, char: string, dir: 1 | -1) {\n  return dir === 1 ? data + char : char + data\n}\n\n/**\n * Splits out a character in a given direction.\n */\nfunction splitChar(data: string, dir: 1 | -1): [string, string] {\n  return dir === 1\n    ? [data.substring(0, data.length - 1), data[data.length - 1]]\n    : [data.substring(1), data[0]]\n}\n\n/**\n * Checks if two entries of the diff has the same character in the same \"direction\".\n */\nfunction hasSharedChar(diffs: Diff[], i: number, j: number, dir: 1 | -1): boolean {\n  return dir === 1\n    ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1]\n    : diffs[i][1][0] === diffs[j][1][0]\n}\n\n/**\n * Takes in a position of an EQUAL diff-type and attempts to \"deisolate\" the character for a given direction.\n * By this we mean that we attempt to either \"shift\" it to the later diffs, or bring another character next into this one.\n *\n * It's easier to understand with an example:\n *   [INSERT a, DELETE b, EQUAL cde, INSERT f, DELETE g]\n * shifting this forward will produce\n *   [INSERT a, DELETE b, EQUAL cd, INSERT ef, DELETE eg]\n *\n * This behavior is useful when `e` is actually a high surrogate character.\n *\n * Shifting it backwards produces\n *   [INSERT ac, DELETE bc, EQUAL cde, INSERT f, DELETE g]\n * which is useful when `c` is a low surrogate character.\n *\n * Note that these diffs are 100% semantically equal.\n *\n * If there's not a matching INSERT/DELETE then it's forced to insert an additional entry:\n *   [EQUAL abc, INSERT d, EQUAL e]\n * shifted forward becomes:\n *   [EQUAL ab, INSERT cd, DELETE c, EQUAL e]\n *\n * If the INSERT and DELETE ends with the same character it will instead deisolate it by\n * bring that charcter into _this_ equal:\n *   [EQUAL abc, INSERT de, DELETE df]\n * shifted forward actually becomes\n *   [EQUAL abcd, INSERT e, DELETE f]\n *\n * The original diff here is typically never produced by the diff algorithm directly,\n * but they occur when we isolate characters in other places.\n */\nfunction deisolateChar(diffs: Diff[], i: number, dir: 1 | -1) {\n  const inv = dir === 1 ? -1 : 1\n  let insertIdx: null | number = null\n  let deleteIdx: null | number = null\n\n  let j = i + dir\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text] = diffs[j]\n    if (text.length === 0) {\n      continue\n    }\n\n    if (op === DIFF_INSERT) {\n      if (insertIdx === null) {\n        insertIdx = j\n      }\n      continue\n    } else if (op === DIFF_DELETE) {\n      if (deleteIdx === null) {\n        deleteIdx = j\n      }\n      continue\n    } else if (op === DIFF_EQUAL) {\n      if (insertIdx === null && deleteIdx === null) {\n        // This means that there was two consecutive EQUAL. Kinda weird, but easy to handle.\n        const [rest, char] = splitChar(diffs[i][1], dir)\n        diffs[i][1] = rest\n        diffs[j][1] = combineChar(diffs[j][1], char, inv)\n        return\n      }\n      break\n    }\n  }\n\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    // Special case.\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv)\n    const [deleteText] = splitChar(diffs[deleteIdx][1], inv)\n    diffs[insertIdx][1] = insertText\n    diffs[deleteIdx][1] = deleteText\n    diffs[i][1] = combineChar(diffs[i][1], insertChar, dir)\n    return\n  }\n\n  const [text, char] = splitChar(diffs[i][1], dir)\n  diffs[i][1] = text\n\n  if (insertIdx === null) {\n    diffs.splice(j, 0, [DIFF_INSERT, char])\n\n    // We need to adjust deleteIdx here since it's been shifted\n    if (deleteIdx !== null && deleteIdx >= j) deleteIdx++\n  } else {\n    diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv)\n  }\n\n  if (deleteIdx === null) {\n    diffs.splice(j, 0, [DIFF_DELETE, char])\n  } else {\n    diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv)\n  }\n}\n\nfunction adjustDiffForSurrogatePairs(diffs: Diff[]) {\n  // Go over each pair of diffs and see if there was a split at a surrogate pair\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i]\n\n    if (diffText.length === 0) continue\n\n    const firstChar = diffText[0]\n    const lastChar = diffText[diffText.length - 1]\n\n    if (isHighSurrogate(lastChar) && diffType === DIFF_EQUAL) {\n      deisolateChar(diffs, i, 1)\n    }\n\n    if (isLowSurrogate(firstChar) && diffType === DIFF_EQUAL) {\n      deisolateChar(diffs, i, -1)\n    }\n  }\n\n  for (let i = 0; i < diffs.length; i++) {\n    // Remove any empty diffs\n    if (diffs[i][1].length === 0) {\n      diffs.splice(i, 1)\n    }\n  }\n}\n","import {cloneDiff} from './clone.js'\nimport {getCommonOverlap} from './commonOverlap.js'\nimport {getCommonPrefix} from './commonPrefix.js'\nimport {getCommonSuffix} from './commonSuffix.js'\nimport {type Diff, DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from './diff.js'\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n *\n * @param rawDiffs - Array of diff tuples.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupSemantic(rawDiffs: Diff[]): Diff[] {\n  let diffs: Diff[] = rawDiffs.map((diff) => cloneDiff(diff))\n\n  let hasChanges = false\n  const equalities: number[] = [] // Stack of indices where equalities are found.\n  let equalitiesLength = 0 // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  let lastEquality = null\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  let pointer = 0 // Index of current position.\n  // Number of characters that changed prior to the equality.\n  let lengthInsertions1 = 0\n  let lengthDeletions1 = 0\n  // Number of characters that changed after the equality.\n  let lengthInsertions2 = 0\n  let lengthDeletions2 = 0\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer\n      lengthInsertions1 = lengthInsertions2\n      lengthDeletions1 = lengthDeletions2\n      lengthInsertions2 = 0\n      lengthDeletions2 = 0\n      lastEquality = diffs[pointer][1]\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] === DIFF_INSERT) {\n        lengthInsertions2 += diffs[pointer][1].length\n      } else {\n        lengthDeletions2 += diffs[pointer][1].length\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (\n        lastEquality &&\n        lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) &&\n        lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2)\n      ) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality])\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT\n        // Throw away the equality we just deleted.\n        equalitiesLength--\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1\n        lengthInsertions1 = 0 // Reset the counters.\n        lengthDeletions1 = 0\n        lengthInsertions2 = 0\n        lengthDeletions2 = 0\n        lastEquality = null\n        hasChanges = true\n      }\n    }\n    pointer++\n  }\n\n  // Normalize the diff.\n  if (hasChanges) {\n    diffs = cleanupMerge(diffs)\n  }\n  diffs = cleanupSemanticLossless(diffs)\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abczzz</del><ins>zzzdef</ins>\n  //   -> <del>abc</del>zzz<ins>def</ins>\n  // e.g: <del>zzzabc</del><ins>defzzz</ins>\n  //   -> <ins>def</ins>zzz<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1]\n      const insertion = diffs[pointer][1]\n      const overlapLength1 = getCommonOverlap(deletion, insertion)\n      const overlapLength2 = getCommonOverlap(insertion, deletion)\n      if (overlapLength1 >= overlapLength2) {\n        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)])\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1)\n          diffs[pointer + 1][1] = insertion.substring(overlapLength1)\n          pointer++\n        }\n      } else if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n        // Reverse overlap found.\n        // Insert an equality and swap and trim the surrounding edits.\n        diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)])\n        diffs[pointer - 1][0] = DIFF_INSERT\n        diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2)\n        diffs[pointer + 1][0] = DIFF_DELETE\n        diffs[pointer + 1][1] = deletion.substring(overlapLength2)\n        pointer++\n      }\n      pointer++\n    }\n    pointer++\n  }\n  return diffs\n}\n\n// Define some regex patterns for matching boundaries.\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/\nconst whitespaceRegex = /\\s/\nconst linebreakRegex = /[\\r\\n]/\nconst blanklineEndRegex = /\\n\\r?\\n$/\nconst blanklineStartRegex = /^\\r?\\n\\r?\\n/\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n *\n * @param rawDiffs - Array of diff tuples.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupSemanticLossless(rawDiffs: Diff[]): Diff[] {\n  const diffs = rawDiffs.map((diff) => cloneDiff(diff))\n\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   *\n   * @param one - First string.\n   * @param two - Second string.\n   * @returns The score.\n   * @internal\n   */\n  function diffCleanupSemanticScore(one: string, two: string) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    const char1 = one.charAt(one.length - 1)\n    const char2 = two.charAt(0)\n    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex)\n    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex)\n    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex)\n    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex)\n    const lineBreak1 = whitespace1 && char1.match(linebreakRegex)\n    const lineBreak2 = whitespace2 && char2.match(linebreakRegex)\n    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex)\n    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex)\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1\n    }\n    return 0\n  }\n\n  let pointer = 1\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      let equality1 = diffs[pointer - 1][1]\n      let edit = diffs[pointer][1]\n      let equality2 = diffs[pointer + 1][1]\n\n      // First, shift the edit as far left as possible.\n      const commonOffset = getCommonSuffix(equality1, edit)\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset)\n        equality1 = equality1.substring(0, equality1.length - commonOffset)\n        edit = commonString + edit.substring(0, edit.length - commonOffset)\n        equality2 = commonString + equality2\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      let bestEquality1 = equality1\n      let bestEdit = edit\n      let bestEquality2 = equality2\n      let bestScore =\n        diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2)\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0)\n        edit = edit.substring(1) + equality2.charAt(0)\n        equality2 = equality2.substring(1)\n        const score =\n          diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2)\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score\n          bestEquality1 = equality1\n          bestEdit = edit\n          bestEquality2 = equality2\n        }\n      }\n\n      if (diffs[pointer - 1][1] !== bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1\n        } else {\n          diffs.splice(pointer - 1, 1)\n          pointer--\n        }\n        diffs[pointer][1] = bestEdit\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2\n        } else {\n          diffs.splice(pointer + 1, 1)\n          pointer--\n        }\n      }\n    }\n    pointer++\n  }\n\n  return diffs\n}\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n *\n * @param rawDiffs - Array of diff tuples.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupMerge(rawDiffs: Diff[]): Diff[] {\n  let diffs = rawDiffs.map((diff) => cloneDiff(diff))\n\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, ''])\n  let pointer = 0\n  let countDelete = 0\n  let countInsert = 0\n  let textDelete = ''\n  let textInsert = ''\n  let commonlength\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++\n        textInsert += diffs[pointer][1]\n        pointer++\n        break\n      case DIFF_DELETE:\n        countDelete++\n        textDelete += diffs[pointer][1]\n        pointer++\n        break\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (countDelete + countInsert > 1) {\n          if (countDelete !== 0 && countInsert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = getCommonPrefix(textInsert, textDelete)\n            if (commonlength !== 0) {\n              if (\n                pointer - countDelete - countInsert > 0 &&\n                diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL\n              ) {\n                diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(\n                  0,\n                  commonlength,\n                )\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)])\n                pointer++\n              }\n              textInsert = textInsert.substring(commonlength)\n              textDelete = textDelete.substring(commonlength)\n            }\n            // Factor out any common suffixies.\n            commonlength = getCommonSuffix(textInsert, textDelete)\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1]\n              textInsert = textInsert.substring(0, textInsert.length - commonlength)\n              textDelete = textDelete.substring(0, textDelete.length - commonlength)\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= countDelete + countInsert\n          diffs.splice(pointer, countDelete + countInsert)\n          if (textDelete.length) {\n            diffs.splice(pointer, 0, [DIFF_DELETE, textDelete])\n            pointer++\n          }\n          if (textInsert.length) {\n            diffs.splice(pointer, 0, [DIFF_INSERT, textInsert])\n            pointer++\n          }\n          pointer++\n        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1]\n          diffs.splice(pointer, 1)\n        } else {\n          pointer++\n        }\n        countInsert = 0\n        countDelete = 0\n        textDelete = ''\n        textInsert = ''\n        break\n      default:\n        throw new Error('Unknown diff operation')\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop() // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  let hasChanges = false\n  pointer = 1\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (\n        diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) ===\n        diffs[pointer - 1][1]\n      ) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] =\n          diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length)\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1]\n        diffs.splice(pointer - 1, 1)\n        hasChanges = true\n      } else if (\n        diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]\n      ) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1]\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1]\n        diffs.splice(pointer + 1, 1)\n        hasChanges = true\n      }\n    }\n    pointer++\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (hasChanges) {\n    diffs = cleanupMerge(diffs)\n  }\n\n  return diffs\n}\n\nfunction trueCount(...args: boolean[]) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0)\n}\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n *\n * @param rawDiffs - Array of diff tuples.\n * @param editCost - Cost of an empty edit operation in terms of edit characters.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupEfficiency(rawDiffs: Diff[], editCost: number = 4): Diff[] {\n  let diffs = rawDiffs.map((diff) => cloneDiff(diff))\n  let hasChanges = false\n  const equalities: number[] = [] // Stack of indices where equalities are found.\n  let equalitiesLength = 0 // Keeping our own length var is faster in JS.\n  let lastEquality: string | null = null\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  let pointer = 0 // Index of current position.\n  // Is there an insertion operation before the last equality.\n  let preIns = false\n  // Is there a deletion operation before the last equality.\n  let preDel = false\n  // Is there an insertion operation after the last equality.\n  let postIns = false\n  // Is there a deletion operation after the last equality.\n  let postDel = false\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      // Equality found.\n      if (diffs[pointer][1].length < editCost && (postIns || postDel)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer\n        preIns = postIns\n        preDel = postDel\n        lastEquality = diffs[pointer][1]\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0\n        lastEquality = null\n      }\n      postIns = false\n      postDel = false\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] === DIFF_DELETE) {\n        postDel = true\n      } else {\n        postIns = true\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (\n        lastEquality &&\n        ((preIns && preDel && postIns && postDel) ||\n          (lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3))\n      ) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality])\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT\n        equalitiesLength-- // Throw away the equality we just deleted;\n        lastEquality = null\n        if (preIns && preDel) {\n          // No hasChanges made which could affect previous entry, keep going.\n          postIns = true\n          postDel = true\n          equalitiesLength = 0\n        } else {\n          equalitiesLength-- // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1\n          postIns = false\n          postDel = false\n        }\n        hasChanges = true\n      }\n    }\n    pointer++\n  }\n\n  if (hasChanges) {\n    diffs = cleanupMerge(diffs)\n  }\n\n  return diffs\n}\n","interface BitapOptions {\n  threshold: number\n  distance: number\n}\n\ninterface Alphabet {\n  [char: string]: number\n}\n\nconst DEFAULT_OPTIONS: BitapOptions = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1000,\n}\n\nfunction applyDefaults(options: Partial<BitapOptions>): BitapOptions {\n  return {...DEFAULT_OPTIONS, ...options}\n}\n\n// The number of bits in an int.\nconst MAX_BITS = 32\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n *\n * @param text - The text to search.\n * @param pattern - The pattern to search for.\n * @param loc - The location to search around.\n * @param options - Options {@link BitapOptions}\n * @returns Best match index or -1.\n * @internal\n */\nexport function bitap(\n  text: string,\n  pattern: string,\n  loc: number,\n  opts: Partial<BitapOptions> = {},\n): number {\n  if (pattern.length > MAX_BITS) {\n    throw new Error('Pattern too long for this browser.')\n  }\n\n  const options = applyDefaults(opts)\n\n  // Initialise the alphabet.\n  const s = getAlphabetFromPattern(pattern)\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   *\n   * @param e - Number of errors in match.\n   * @param x - Location of match.\n   * @returns Overall - score for match (0.0 = good, 1.0 = bad).\n   * @internal\n   */\n  function getBitapScore(e: number, x: number) {\n    const accuracy = e / pattern.length\n    const proximity = Math.abs(loc - x)\n    if (!options.distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy\n    }\n    return accuracy + proximity / options.distance\n  }\n\n  // Highest score beyond which we give up.\n  let scoreThreshold = options.threshold\n  // Is there a nearby exact match? (speedup)\n  let bestLoc = text.indexOf(pattern, loc)\n  if (bestLoc !== -1) {\n    scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)\n    // What about in the other direction? (speedup)\n    bestLoc = text.lastIndexOf(pattern, loc + pattern.length)\n    if (bestLoc !== -1) {\n      scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)\n    }\n  }\n\n  // Initialise the bit arrays.\n  const matchmask = 1 << (pattern.length - 1)\n  bestLoc = -1\n\n  let binMin\n  let binMid\n  let binMax = pattern.length + text.length\n  let lastRd: number[] = []\n  for (let d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    binMin = 0\n    binMid = binMax\n    while (binMin < binMid) {\n      if (getBitapScore(d, loc + binMid) <= scoreThreshold) {\n        binMin = binMid\n      } else {\n        binMax = binMid\n      }\n      binMid = Math.floor((binMax - binMin) / 2 + binMin)\n    }\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid\n    let start = Math.max(1, loc - binMid + 1)\n    const finish = Math.min(loc + binMid, text.length) + pattern.length\n\n    const rd: number[] = new Array(finish + 2)\n    rd[finish + 1] = (1 << d) - 1\n    for (let j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      const charMatch = s[text.charAt(j - 1)]\n      if (d === 0) {\n        // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch\n      } else {\n        // Subsequent passes: fuzzy match.\n        rd[j] =\n          (((rd[j + 1] << 1) | 1) & charMatch) |\n          (((lastRd[j + 1] | lastRd[j]) << 1) | 1) |\n          lastRd[j + 1]\n      }\n      if (rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1)\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= scoreThreshold) {\n          // Told you so.\n          scoreThreshold = score\n          bestLoc = j - 1\n          if (bestLoc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - bestLoc)\n          } else {\n            // Already passed loc, downhill from here on in.\n            break\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (getBitapScore(d + 1, loc) > scoreThreshold) {\n      break\n    }\n    lastRd = rd\n  }\n  return bestLoc\n}\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n *\n * @param pattern - The text to encode.\n * @returns Hash of character locations.\n * @internal\n */\nfunction getAlphabetFromPattern(pattern: string): Alphabet {\n  const s: Alphabet = {}\n  for (let i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0\n  }\n  for (let i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1)\n  }\n  return s\n}\n","import {bitap} from './bitap.js'\n\n/**\n * @public\n */\nexport interface MatchOptions {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   * The larger threshold is, the slower match() may take to compute\n   *\n   * Defaults to 0.5\n   */\n  threshold?: number\n\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   *\n   * The larger distance is, the slower match() may take to compute.\n   *\n   * Defaults to 1000.\n   */\n  distance?: number\n}\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n *\n * @param text - The text to search.\n * @param pattern - The pattern to search for.\n * @param searchLocation - The location to search around.\n * @param options - Options {@link MatchOptions}\n * @returns Best match index or -1.\n * @public\n */\nexport function match(\n  text: string,\n  pattern: string,\n  searchLocation: number,\n  options: MatchOptions = {},\n): number {\n  // Check for null inputs.\n  if (text === null || pattern === null || searchLocation === null) {\n    throw new Error('Null input. (match())')\n  }\n\n  const loc = Math.max(0, Math.min(searchLocation, text.length))\n  if (text === pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1\n  } else if (text.substring(loc, loc + pattern.length) === pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc\n  }\n\n  // Do a fuzzy compare.\n  return bitap(text, pattern, loc, options)\n}\n","import {type Diff, DIFF_DELETE, DIFF_INSERT} from './diff.js'\n\n/**\n * Compute and return the source text (all equalities and deletions).\n *\n * @param diffs - Array of diff tuples.\n * @returns Source text.\n * @private\n */\nexport function diffText1(diffs: Diff[]): string {\n  const text: string[] = []\n  for (let x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1]\n    }\n  }\n  return text.join('')\n}\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n *\n * @param diffs - Array of diff tuples.\n * @returns Destination text.\n * @private\n */\nexport function diffText2(diffs: Diff[]): string {\n  const text: string[] = []\n  for (let x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1]\n    }\n  }\n  return text.join('')\n}\n","import {type Diff, DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from './diff.js'\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n *\n * @param diffs - Array of diff tuples.\n * @returns Number of changes.\n * @internal\n */\nexport function levenshtein(diffs: Diff[]): number {\n  let leven = 0\n  let insertions = 0\n  let deletions = 0\n\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0]\n    const data = diffs[x][1]\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length\n        break\n      case DIFF_DELETE:\n        deletions += data.length\n        break\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        leven += Math.max(insertions, deletions)\n        insertions = 0\n        deletions = 0\n        break\n      default:\n        throw new Error('Unknown diff operation.')\n    }\n  }\n  leven += Math.max(insertions, deletions)\n  return leven\n}\n","import {type Diff, DIFF_DELETE, DIFF_INSERT} from './diff.js'\n\n/**\n * loc is a location in textA, compute and return the equivalent location in\n * textB.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n *\n * @param diffs - Array of diff tuples.\n * @param location - Location within textA.\n * @returns Location within textB.\n * @public\n */\nexport function xIndex(diffs: Diff[], location: number): number {\n  let chars1 = 0\n  let chars2 = 0\n  let lastChars1 = 0\n  let lastChars2 = 0\n  let x\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      // Equality or deletion.\n      chars1 += diffs[x][1].length\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {\n      // Equality or insertion.\n      chars2 += diffs[x][1].length\n    }\n    if (chars1 > location) {\n      // Overshot the location.\n      break\n    }\n    lastChars1 = chars1\n    lastChars2 = chars2\n  }\n  // Was the location was deleted?\n  if (diffs.length !== x && diffs[x][0] === DIFF_DELETE) {\n    return lastChars2\n  }\n  // Add the remaining character length.\n  return lastChars2 + (location - lastChars1)\n}\n","import {cloneDiff} from '../diff/clone.js'\nimport {type Patch} from '../index.js'\n\n/**\n * Counts the number of bytes in a string.\n * Note that while this approach may seem heavy-handed, it is actually\n * significantly faster than both `new Blob([str]).size` and `TextEncoder`.\n *\n * @param str - String to count\n * @returns Number of bytes\n */\nexport function countUtf8Bytes(str: string): number {\n  let bytes = 0\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i)\n    if (typeof codePoint === 'undefined') {\n      throw new Error('Failed to get codepoint')\n    }\n    bytes += utf8len(codePoint)\n  }\n  return bytes\n}\n\n/**\n * Options for the index adjustment operations.\n *\n * @public\n */\nexport interface AdjustmentOptions {\n  /**\n   * When converting indices between UTF-8 and UCS-2, certain scenarios can occur\n   * where we go beyond the target offset. This can happen in particular with\n   * surrogate pairs/high codepoints, when the base string we are applying the\n   * patch to does not fully match the one that was used to generate the patch.\n   * Defaults to `false`.\n   */\n  allowExceedingIndices?: boolean\n}\n\n/**\n * Takes a `patches` array as produced by diff-match-patch and adjusts the\n * `start1` and `start2` properties so that they refer to UCS-2 index instead\n * of a UTF-8 index.\n *\n * @param patches - The patches to adjust\n * @param base - The base string to use for counting bytes\n * @param options - Options for the adjustment of indices\n * @returns A new array of patches with adjusted indicies\n * @beta\n */\nexport function adjustIndiciesToUcs2(\n  patches: Patch[],\n  base: string,\n  options: AdjustmentOptions = {},\n): Patch[] {\n  let byteOffset = 0\n  let idx = 0 // index into the input.\n\n  function advanceTo(target: number) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx)\n      if (typeof codePoint === 'undefined') {\n        // Reached the end of the base string - the indicies won't be correct,\n        // but we also cannot advance any further to find a closer index.\n        return idx\n      }\n\n      byteOffset += utf8len(codePoint)\n\n      // This is encoded as a surrogate pair.\n      if (codePoint > 0xffff) {\n        idx += 2\n      } else {\n        idx += 1\n      }\n    }\n\n    if (!options.allowExceedingIndices && byteOffset !== target) {\n      throw new Error('Failed to determine byte offset')\n    }\n\n    return idx\n  }\n\n  const adjusted: Patch[] = []\n  for (const patch of patches) {\n    adjusted.push({\n      diffs: patch.diffs.map((diff) => cloneDiff(diff)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2,\n    })\n  }\n\n  return adjusted\n}\n\nfunction utf8len(codePoint: number): 1 | 2 | 3 | 4 {\n  // See table at https://en.wikipedia.org/wiki/UTF-8\n  if (codePoint <= 0x007f) return 1\n  if (codePoint <= 0x07ff) return 2\n  if (codePoint <= 0xffff) return 3\n  return 4\n}\n","// The number of bits in an int.\nexport const MAX_BITS = 32\n\nexport const DEFAULT_MARGIN = 4\n","import {DIFF_EQUAL} from '../diff/diff.js'\nimport {DEFAULT_MARGIN} from './constants.js'\nimport {type Patch} from './createPatchObject.js'\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n *\n * @param patches - Array of Patch objects.\n * @param margin - The margin length to add.\n * @returns The string, padded on each side.\n * @internal\n */\nexport function addPadding(patches: Patch[], margin: number = DEFAULT_MARGIN): string {\n  const paddingLength = margin\n  let nullPadding = ''\n  for (let x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x)\n  }\n\n  // Bump all the patches forward.\n  for (const p of patches) {\n    p.start1 += paddingLength\n    p.start2 += paddingLength\n    p.utf8Start1 += paddingLength\n    p.utf8Start2 += paddingLength\n  }\n\n  // Add some padding on start of first diff.\n  let patch = patches[0]\n  let diffs = patch.diffs\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding])\n    patch.start1 -= paddingLength // Should be 0.\n    patch.start2 -= paddingLength // Should be 0.\n    patch.utf8Start1 -= paddingLength // Should be 0.\n    patch.utf8Start2 -= paddingLength // Should be 0.\n    patch.length1 += paddingLength\n    patch.length2 += paddingLength\n    patch.utf8Length1 += paddingLength\n    patch.utf8Length2 += paddingLength\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    const firstDiffLength = diffs[0][1].length\n    const extraLength = paddingLength - firstDiffLength\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1]\n    patch.start1 -= extraLength\n    patch.start2 -= extraLength\n    patch.utf8Start1 -= extraLength\n    patch.utf8Start2 -= extraLength\n    patch.length1 += extraLength\n    patch.length2 += extraLength\n    patch.utf8Length1 += extraLength\n    patch.utf8Length2 += extraLength\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1]\n  diffs = patch.diffs\n  if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding])\n    patch.length1 += paddingLength\n    patch.length2 += paddingLength\n    patch.utf8Length1 += paddingLength\n    patch.utf8Length2 += paddingLength\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength)\n    patch.length1 += extraLength\n    patch.length2 += extraLength\n    patch.utf8Length1 += extraLength\n    patch.utf8Length2 += extraLength\n  }\n\n  return nullPadding\n}\n","import {type Diff} from '../diff/diff.js'\n\n/**\n * Object representing one patch operation.\n *\n * @public\n */\nexport interface Patch {\n  diffs: Diff[]\n\n  start1: number\n  start2: number\n  utf8Start1: number\n  utf8Start2: number\n\n  length1: number\n  length2: number\n  utf8Length1: number\n  utf8Length2: number\n}\n\n/**\n * Clones a patch object.\n *\n * @param patch - The patch to clone\n * @returns Cloned object\n * @private\n */\nexport function clone(patch: Patch): Patch {\n  return {...patch, diffs: patch.diffs.map((diff) => ({...diff}))}\n}\n\n/**\n * Performs a deep copy of a patch array.\n *\n * @param patches - Patches to clone\n * @returns Cloned array\n * @internal\n */\nexport function deepCopy(patches: Patch[]): Patch[] {\n  return patches.map(clone)\n}\n\n/**\n * Create a new, empty, patch object.\n *\n * @param start1 - The index to start the \"from\" at\n * @param start2 - The index to start the \"to\" at\n * @returns New patch object\n * @internal\n */\nexport function createPatchObject(start1: number, start2: number): Patch {\n  return {\n    diffs: [],\n\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0,\n  }\n}\n","import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {diffText1, diffText2} from '../diff/diffText.js'\nimport {countUtf8Bytes} from '../utils/utf8Indices.js'\nimport {DEFAULT_MARGIN, MAX_BITS} from './constants.js'\nimport {createPatchObject, type Patch} from './createPatchObject.js'\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n *\n * @param patches - Array of Patch objects.\n * @internal\n */\nexport function splitMax(patches: Patch[], margin: number = DEFAULT_MARGIN): void {\n  const patchSize = MAX_BITS\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize) {\n      continue\n    }\n    const bigpatch = patches[x]\n    // Remove the big old patch.\n    patches.splice(x--, 1)\n    let start1 = bigpatch.start1\n    let start2 = bigpatch.start2\n    let preContext = ''\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length)\n      let empty = true\n\n      if (preContext !== '') {\n        const precontextByteCount = countUtf8Bytes(preContext)\n        patch.length1 = preContext.length\n        patch.utf8Length1 = precontextByteCount\n        patch.length2 = preContext.length\n        patch.utf8Length2 = precontextByteCount\n        patch.diffs.push([DIFF_EQUAL, preContext])\n      }\n      while (bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin) {\n        const diffType = bigpatch.diffs[0][0]\n        let diffText = bigpatch.diffs[0][1]\n        let diffTextByteCount = countUtf8Bytes(diffText)\n        if (diffType === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diffText.length\n          patch.utf8Length2 += diffTextByteCount\n          start2 += diffText.length\n          const diff = bigpatch.diffs.shift()\n          if (diff) {\n            patch.diffs.push(diff)\n          }\n          empty = false\n        } else if (\n          diffType === DIFF_DELETE &&\n          patch.diffs.length === 1 &&\n          patch.diffs[0][0] === DIFF_EQUAL &&\n          diffText.length > 2 * patchSize\n        ) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diffText.length\n          patch.utf8Length1 += diffTextByteCount\n          start1 += diffText.length\n          empty = false\n          patch.diffs.push([diffType, diffText])\n          bigpatch.diffs.shift()\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diffText = diffText.substring(0, patchSize - patch.length1 - margin)\n          diffTextByteCount = countUtf8Bytes(diffText)\n          patch.length1 += diffText.length\n          patch.utf8Length1 += diffTextByteCount\n          start1 += diffText.length\n          if (diffType === DIFF_EQUAL) {\n            patch.length2 += diffText.length\n            patch.utf8Length2 += diffTextByteCount\n            start2 += diffText.length\n          } else {\n            empty = false\n          }\n          patch.diffs.push([diffType, diffText])\n          if (diffText === bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift()\n          } else {\n            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length)\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      preContext = diffText2(patch.diffs)\n      preContext = preContext.substring(preContext.length - margin)\n      // Append the end context for this patch.\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin)\n      const postContextByteCount = countUtf8Bytes(postContext)\n      if (postContext !== '') {\n        patch.length1 += postContext.length\n        patch.length2 += postContext.length\n        patch.utf8Length1 += postContextByteCount\n        patch.utf8Length2 += postContextByteCount\n        if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postContext\n        } else {\n          patch.diffs.push([DIFF_EQUAL, postContext])\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch)\n      }\n    }\n  }\n}\n","/* eslint-disable max-depth */\n/* eslint-disable max-statements */\nimport {cleanupSemanticLossless} from '../diff/cleanup.js'\nimport {diff, DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {diffText1, diffText2} from '../diff/diffText.js'\nimport {levenshtein} from '../diff/levenshtein.js'\nimport {xIndex} from '../diff/xIndex.js'\nimport {match} from '../match/match.js'\nimport {adjustIndiciesToUcs2} from '../utils/utf8Indices.js'\nimport {addPadding} from './addPadding.js'\nimport {DEFAULT_MARGIN, MAX_BITS} from './constants.js'\nimport {type Patch} from './createPatchObject.js'\nimport {splitMax} from './splitMax.js'\n\n/**\n * Options for applying a patch.\n *\n * @public\n */\nexport interface ApplyPatchOptions {\n  /**\n   * Chunk size for context length\n   */\n  margin: number\n\n  /**\n   * When deleting a large block of text (over ~64 characters),\n   * how close do the contents have to be to match the expected contents.\n   * (0.0 = perfection, 1.0 = very loose).\n   */\n  deleteThreshold: number\n\n  /**\n   * When converting indices between UTF-8 and UCS-2, certain scenarios can occur\n   * where we go beyond the target offset. This can happen in particular with\n   * surrogate pairs/high codepoints, when the base string we are applying the\n   * patch to does not fully match the one that was used to generate the patch.\n   * Defaults to `false`.\n   */\n  allowExceedingIndices: boolean\n}\n\n/**\n * Result of a patch application operation.\n * Index 0 contains the new text\n * Index 1 contains an array of booleans indicating which patches were applied\n *\n * @public\n */\nexport type PatchResult = [string, boolean[]]\n\n/**\n * Merge a set of patches onto the text. Returns patched text, as well as a\n * list of true/false values indicating which patches were applied.\n *\n * @param patches - Array of Patch objects.\n * @param text - Old text.\n * @param opts - Optional settings for the patch application.\n * @returns Two element Array, containing the new text and an array of boolean values.\n * @public\n */\nexport function apply(\n  patches: Patch[],\n  originalText: string,\n  opts: Partial<ApplyPatchOptions> = {},\n): PatchResult {\n  if (typeof patches === 'string') {\n    throw new Error('Patches must be an array - pass the patch to `parsePatch()` first')\n  }\n\n  let text = originalText\n  if (patches.length === 0) {\n    return [text, []]\n  }\n\n  // Note: adjustment also deep-copies patches so that no changes are made to the originals.\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices,\n  })\n\n  const margin = opts.margin || DEFAULT_MARGIN\n  const deleteThreshold = opts.deleteThreshold || 0.4\n\n  const nullPadding = addPadding(parsed, margin)\n  text = nullPadding + text + nullPadding\n\n  splitMax(parsed, margin)\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  let delta = 0\n  const results: boolean[] = []\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta\n    const text1 = diffText1(parsed[x].diffs)\n    let startLoc\n    let endLoc = -1\n    if (text1.length > MAX_BITS) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc)\n      if (startLoc !== -1) {\n        endLoc = match(\n          text,\n          text1.substring(text1.length - MAX_BITS),\n          expectedLoc + text1.length - MAX_BITS,\n        )\n        if (endLoc === -1 || startLoc >= endLoc) {\n          // Can't find valid trailing context.  Drop this patch.\n          startLoc = -1\n        }\n      }\n    } else {\n      startLoc = match(text, text1, expectedLoc)\n    }\n    if (startLoc === -1) {\n      // No match found.  :(\n      results[x] = false\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= parsed[x].length2 - parsed[x].length1\n    } else {\n      // Found a match.  :)\n      results[x] = true\n      delta = startLoc - expectedLoc\n      let text2\n      if (endLoc === -1) {\n        text2 = text.substring(startLoc, startLoc + text1.length)\n      } else {\n        text2 = text.substring(startLoc, endLoc + MAX_BITS)\n      }\n      if (text1 === text2) {\n        // Perfect match, just shove the replacement text in.\n        text =\n          text.substring(0, startLoc) +\n          diffText2(parsed[x].diffs) +\n          text.substring(startLoc + text1.length)\n      } else {\n        // Imperfect match. Run a diff to get a framework of equivalent indices.\n        let diffs = diff(text1, text2, {checkLines: false})\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false\n        } else {\n          diffs = cleanupSemanticLossless(diffs)\n          let index1 = 0\n          let index2 = 0\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y]\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = xIndex(diffs, index1)\n            }\n            if (mod[0] === DIFF_INSERT) {\n              // Insertion\n              text =\n                text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2)\n            } else if (mod[0] === DIFF_DELETE) {\n              // Deletion\n              text =\n                text.substring(0, startLoc + index2) +\n                text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length)\n  return [text, results]\n}\n","import {cleanupEfficiency, cleanupSemantic} from '../diff/cleanup.js'\nimport {type Diff, diff, DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {diffText1} from '../diff/diffText.js'\nimport {isLowSurrogate} from '../utils/surrogatePairs.js'\nimport {countUtf8Bytes} from '../utils/utf8Indices.js'\nimport {MAX_BITS} from './constants.js'\nimport {createPatchObject, type Patch} from './createPatchObject.js'\n\n/**\n * Options for patch generation.\n *\n * @public\n */\nexport interface MakePatchOptions {\n  // Chunk size for context length.\n  margin: number\n}\n\nconst DEFAULT_OPTS: MakePatchOptions = {\n  margin: 4,\n}\n\nfunction getDefaultOpts(opts: Partial<MakePatchOptions> = {}): MakePatchOptions {\n  return {\n    ...DEFAULT_OPTS,\n    ...opts,\n  }\n}\n\n/**\n * Compute a list of patches to turn based on passed diffs.\n *\n * @param diffs - Array of diff tuples.\n * @param options - Options for the patch generation.\n * @returns Array of Patch objects.\n * @public\n */\nexport function make(diffs: Diff[], options?: Partial<MakePatchOptions>): Patch[]\n\n/**\n * Compute a list of patches to turn textA into textB.\n *\n * @param textA - Original text.\n * @param textB - New text.\n * @param options - Options for the patch generation.\n * @returns Array of Patch objects.\n * @public\n */\nexport function make(textA: string, textB: string, options?: Partial<MakePatchOptions>): Patch[]\n\n/**\n * Compute a list of patches to turn textA into textB using provided diff tuples.\n *\n * @param textA - Original text.\n * @param diffs - Diff tuples to use as base.\n * @param options - Options for the patch generation.\n * @returns Array of Patch objects.\n * @public\n */\nexport function make(textA: string, diffs: Diff[], options?: Partial<MakePatchOptions>): Patch[]\n\nexport function make(\n  a: Diff[] | string,\n  b?: Partial<MakePatchOptions> | string | Diff[],\n  options?: Partial<MakePatchOptions>,\n): Patch[] {\n  if (typeof a === 'string' && typeof b === 'string') {\n    // Method 1: textA, textB\n    // Compute diffs from textA and textB.\n    let diffs = diff(a, b, {checkLines: true})\n    if (diffs.length > 2) {\n      diffs = cleanupSemantic(diffs)\n      diffs = cleanupEfficiency(diffs)\n    }\n    return _make(a, diffs, getDefaultOpts(options))\n  }\n\n  if (a && Array.isArray(a) && typeof b === 'undefined') {\n    // Method 2: diffs\n    // Compute textA from diffs.\n    return _make(diffText1(a), a, getDefaultOpts(options))\n  }\n\n  if (typeof a === 'string' && b && Array.isArray(b)) {\n    // Method 3: textA, diffs\n    return _make(a, b, getDefaultOpts(options))\n  }\n\n  throw new Error('Unknown call format to make()')\n}\n\nfunction _make(textA: string, diffs: Diff[], options: MakePatchOptions): Patch[] {\n  if (diffs.length === 0) {\n    return [] // Get rid of the null case.\n  }\n  const patches: Patch[] = []\n\n  let patch = createPatchObject(0, 0)\n  let patchDiffLength = 0 // Keeping our own length var is faster in JS.\n  let charCount1 = 0 // Number of characters into the textA string.\n  let charCount2 = 0 // Number of characters into the textB string.\n  let utf8Count1 = 0 // Number of utf-8 bytes into the textA string.\n  let utf8Count2 = 0 // Number of utf-8 bytes into the textB string.\n\n  // Start with textA (prepatchText) and apply the diffs until we arrive at\n  // textB (postpatchText).  We recreate the patches one by one to determine\n  // context info.\n  let prepatchText = textA\n  let postpatchText = textA\n\n  for (let x = 0; x < diffs.length; x++) {\n    const currentDiff = diffs[x]\n    const [diffType, diffText] = currentDiff\n    const diffTextLength = diffText.length\n    const diffByteLength = countUtf8Bytes(diffText)\n\n    if (!patchDiffLength && diffType !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = charCount1\n      patch.start2 = charCount2\n      patch.utf8Start1 = utf8Count1\n      patch.utf8Start2 = utf8Count2\n    }\n\n    switch (diffType) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = currentDiff\n        patch.length2 += diffTextLength\n        patch.utf8Length2 += diffByteLength\n        postpatchText =\n          postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2)\n        break\n      case DIFF_DELETE:\n        patch.length1 += diffTextLength\n        patch.utf8Length1 += diffByteLength\n        patch.diffs[patchDiffLength++] = currentDiff\n        postpatchText =\n          postpatchText.substring(0, charCount2) +\n          postpatchText.substring(charCount2 + diffTextLength)\n        break\n      case DIFF_EQUAL:\n        if (diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = currentDiff\n          patch.length1 += diffTextLength\n          patch.length2 += diffTextLength\n          patch.utf8Length1 += diffByteLength\n          patch.utf8Length2 += diffByteLength\n        } else if (diffTextLength >= 2 * options.margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            addContext(patch, prepatchText, options)\n            patches.push(patch)\n            patch = createPatchObject(-1, -1)\n            patchDiffLength = 0\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatchText = postpatchText\n            charCount1 = charCount2\n            utf8Count1 = utf8Count2\n          }\n        }\n        break\n      default:\n        throw new Error('Unknown diff type')\n    }\n\n    // Update the current character count.\n    if (diffType !== DIFF_INSERT) {\n      charCount1 += diffTextLength\n      utf8Count1 += diffByteLength\n    }\n    if (diffType !== DIFF_DELETE) {\n      charCount2 += diffTextLength\n      utf8Count2 += diffByteLength\n    }\n  }\n\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    addContext(patch, prepatchText, options)\n    patches.push(patch)\n  }\n\n  return patches\n}\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond MAX_BITS.\n *\n * @param patch - The patch to grow.\n * @param text - Source text.\n * @param opts\n * @internal\n */\nexport function addContext(patch: Patch, text: string, opts: MakePatchOptions): void {\n  if (text.length === 0) {\n    return\n  }\n  let pattern = text.substring(patch.start2, patch.start2 + patch.length1)\n  let padding = 0\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (\n    text.indexOf(pattern) !== text.lastIndexOf(pattern) &&\n    pattern.length < MAX_BITS - opts.margin - opts.margin\n  ) {\n    padding += opts.margin\n    pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding)\n  }\n  // Add one chunk for good luck.\n  padding += opts.margin\n\n  // Add the prefix.\n\n  // Avoid splitting inside a surrogate.\n  let prefixStart = patch.start2 - padding\n  if (prefixStart >= 1 && isLowSurrogate(text[prefixStart])) {\n    prefixStart--\n  }\n\n  const prefix = text.substring(prefixStart, patch.start2)\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix])\n  }\n\n  const prefixLength = prefix.length\n  const prefixUtf8Length = countUtf8Bytes(prefix)\n\n  // Add the suffix.\n\n  // Avoid splitting inside a surrogate.\n  let suffixEnd = patch.start2 + patch.length1 + padding\n  if (suffixEnd < text.length && isLowSurrogate(text[suffixEnd])) {\n    suffixEnd++\n  }\n\n  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd)\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix])\n  }\n\n  const suffixLength = suffix.length\n  const suffixUtf8Length = countUtf8Bytes(suffix)\n\n  // Roll back the start points.\n  patch.start1 -= prefixLength\n  patch.start2 -= prefixLength\n  patch.utf8Start1 -= prefixUtf8Length\n  patch.utf8Start2 -= prefixUtf8Length\n\n  // Extend the lengths.\n  patch.length1 += prefixLength + suffixLength\n  patch.length2 += prefixLength + suffixLength\n  patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length\n  patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length\n}\n","import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {countUtf8Bytes} from '../utils/utf8Indices.js'\nimport {createPatchObject, type Patch} from './createPatchObject.js'\n\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n *\n * @param textline - Text representation of patches.\n * @returns Array of Patch objects.\n * @public\n */\nexport function parse(textline: string): Patch[] {\n  if (!textline) {\n    return []\n  }\n\n  const patches: Patch[] = []\n  const lines = textline.split('\\n')\n\n  let textPointer = 0\n  while (textPointer < lines.length) {\n    const m = lines[textPointer].match(patchHeader)\n    if (!m) {\n      throw new Error(`Invalid patch string: ${lines[textPointer]}`)\n    }\n\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]))\n    patches.push(patch)\n    if (m[2] === '') {\n      patch.start1--\n      patch.utf8Start1--\n      patch.length1 = 1\n      patch.utf8Length1 = 1\n    } else if (m[2] === '0') {\n      patch.length1 = 0\n      patch.utf8Length1 = 0\n    } else {\n      patch.start1--\n      patch.utf8Start1--\n      // The patch itself will contain the UTF-8 length\n      patch.utf8Length1 = toInt(m[2])\n      // We start with UCS-2 length set to the same, but we adjust for it later\n      patch.length1 = patch.utf8Length1\n    }\n\n    if (m[4] === '') {\n      patch.start2--\n      patch.utf8Start2--\n      patch.length2 = 1\n      patch.utf8Length2 = 1\n    } else if (m[4] === '0') {\n      patch.length2 = 0\n      patch.utf8Length2 = 0\n    } else {\n      patch.start2--\n      patch.utf8Start2--\n      // The patch itself will contain the UTF-8 length\n      patch.utf8Length2 = toInt(m[4])\n      // We start with UCS-2 length set to the same, but we adjust for it later\n      patch.length2 = patch.utf8Length2\n    }\n    textPointer++\n\n    while (textPointer < lines.length) {\n      const currentLine = lines[textPointer]\n      const sign = currentLine.charAt(0)\n\n      if (sign === '@') {\n        // Start of next patch\n        break\n      }\n\n      if (sign === '') {\n        // Blank line? Ignore.\n        textPointer++\n        continue\n      }\n\n      let line: string\n      try {\n        line = decodeURI(currentLine.slice(1))\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error(`Illegal escape in parse: ${currentLine}`)\n      }\n\n      // The number of bytes in a line does not equate to the number of \"characters\"\n      // returned by `string.length` - we have to subtract the diff here in order to\n      // make slicing/calculations work correctly\n      const utf8Diff = countUtf8Bytes(line) - line.length\n      if (sign === '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line])\n        patch.length1 -= utf8Diff\n      } else if (sign === '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line])\n        patch.length2 -= utf8Diff\n      } else if (sign === ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line])\n        patch.length1 -= utf8Diff\n        patch.length2 -= utf8Diff\n      } else {\n        // WTF?\n        throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`)\n      }\n      textPointer++\n    }\n  }\n  return patches\n}\n\nfunction toInt(num: string): number {\n  return parseInt(num, 10)\n}\n","import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {type Patch} from './createPatchObject.js'\n\n/**\n * Create a textual representation of a patch list.\n *\n * @param patches - Patches to stringify\n * @returns Text representation of patches\n * @public\n */\nexport function stringify(patches: Patch[]): string {\n  return patches.map(stringifyPatch).join('')\n}\n\n/**\n * Create a textual representation of a patch.\n *\n * @param patch - Patch to stringify\n * @returns Text representation of patch\n * @public\n */\nexport function stringifyPatch(patch: Patch): string {\n  const {utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs} = patch\n\n  let coords1: string\n  if (utf8Length1 === 0) {\n    coords1 = `${utf8Start1},0`\n  } else if (utf8Length1 === 1) {\n    coords1 = `${utf8Start1 + 1}`\n  } else {\n    coords1 = `${utf8Start1 + 1},${utf8Length1}`\n  }\n\n  let coords2: string\n  if (utf8Length2 === 0) {\n    coords2 = `${utf8Start2},0`\n  } else if (utf8Length2 === 1) {\n    coords2 = `${utf8Start2 + 1}`\n  } else {\n    coords2 = `${utf8Start2 + 1},${utf8Length2}`\n  }\n\n  const text = [`@@ -${coords1} +${coords2} @@\\n`]\n  let op\n\n  // Escape the body of the patch with %xx notation.\n  for (let x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+'\n        break\n      case DIFF_DELETE:\n        op = '-'\n        break\n      case DIFF_EQUAL:\n        op = ' '\n        break\n      default:\n        throw new Error('Unknown patch operation.')\n    }\n    text[x + 1] = `${op + encodeURI(diffs[x][1])}\\n`\n  }\n\n  return text.join('').replace(/%20/g, ' ')\n}\n"],"names":["diff","__spreadValues","text","char","MAX_BITS"],"mappings":";;AASO,SAAS,UAAUA,OAAkB;AACpC,QAAA,CAAC,MAAM,KAAK,IAAIA;AACf,SAAA,CAAC,MAAM,KAAK;AACrB;ACHgB,SAAA,iBAAiB,OAAe,OAAuB;AACjE,MAAA,QAAQ,OACR,QAAQ;AAGZ,QAAM,cAAc,MAAM,QACpB,cAAc,MAAM;AAGtB,MAAA,gBAAgB,KAAK,gBAAgB;AAChC,WAAA;AAIL,gBAAc,cAChB,QAAQ,MAAM,UAAU,cAAc,WAAW,IACxC,cAAc,gBACvB,QAAQ,MAAM,UAAU,GAAG,WAAW;AAExC,QAAM,aAAa,KAAK,IAAI,aAAa,WAAW;AAGpD,MAAI,UAAU;AACL,WAAA;AAML,MAAA,OAAO,GACP,SAAS;AAEJ,WAAA,QAAQ,GAAG,UAAU,MAAM;AAClC,UAAM,UAAU,MAAM,UAAU,aAAa,MAAM;AAEnD,QADA,QAAQ,MAAM,QAAQ,OAAO,GACzB,UAAU;AACL,aAAA;AAET,cAAU,QACN,UAAU,KAAK,MAAM,UAAU,aAAa,MAAM,MAAM,MAAM,UAAU,GAAG,MAAM,OACnF,OAAO,QACP;AAAA,EAAA;AAKG,SAAA;AACT;AChDgB,SAAA,gBAAgB,OAAe,OAAuB;AAEhE,MAAA,CAAC,SAAS,CAAC,SAAS,MAAM,CAAC,MAAM,MAAM,CAAC;AACnC,WAAA;AAKT,MAAI,aAAa,GACb,aAAa,KAAK,IAAI,MAAM,QAAQ,MAAM,MAAM,GAChD,aAAa,YACb,eAAe;AACnB,SAAO,aAAa;AACd,UAAM,UAAU,cAAc,UAAU,MAAM,MAAM,UAAU,cAAc,UAAU,KACxF,aAAa,YACb,eAAe,cAEf,aAAa,YAEf,aAAa,KAAK,OAAO,aAAa,cAAc,IAAI,UAAU;AAE7D,SAAA;AACT;ACtBgB,SAAA,gBAAgB,OAAe,OAAuB;AAEpE,MAAI,CAAC,SAAS,CAAC,SAAS,MAAM,MAAM,SAAS,CAAC,MAAM,MAAM,MAAM,SAAS,CAAC;AACjE,WAAA;AAKT,MAAI,aAAa,GACb,aAAa,KAAK,IAAI,MAAM,QAAQ,MAAM,MAAM,GAChD,aAAa,YACb,aAAa;AACjB,SAAO,aAAa;AAEhB,UAAM,UAAU,MAAM,SAAS,YAAY,MAAM,SAAS,UAAU,MACpE,MAAM,UAAU,MAAM,SAAS,YAAY,MAAM,SAAS,UAAU,KAEpE,aAAa,YACb,aAAa,cAEb,aAAa,YAEf,aAAa,KAAK,OAAO,aAAa,cAAc,IAAI,UAAU;AAG7D,SAAA;AACT;AC5BO,SAAS,gBAAgB,MAAuB;AAC/C,QAAA,WAAW,KAAK,WAAW,CAAC;AAC3B,SAAA,YAAY,SAAU,YAAY;AAC3C;AAQO,SAAS,eAAe,MAAuB;AAC9C,QAAA,WAAW,KAAK,WAAW,CAAC;AAC3B,SAAA,YAAY,SAAU,YAAY;AAC3C;ACRgB,SAAA,OAAO,OAAe,OAAe,UAA0B;AAEvE,QAAA,cAAc,MAAM,QACpB,cAAc,MAAM,QACpB,OAAO,KAAK,MAAM,cAAc,eAAe,CAAC,GAChD,UAAU,MACV,UAAU,IAAI,MACd,KAAK,IAAI,MAAM,OAAO,GACtB,KAAK,IAAI,MAAM,OAAO;AAGnB,WAAA,IAAI,GAAG,IAAI,SAAS;AAC3B,OAAG,CAAC,IAAI,IACR,GAAG,CAAC,IAAI;AAEV,KAAG,UAAU,CAAC,IAAI,GAClB,GAAG,UAAU,CAAC,IAAI;AAClB,QAAM,QAAQ,cAAc,aAGtB,QAAQ,QAAQ,MAAM;AAG5B,MAAI,UAAU,GACV,QAAQ,GACR,UAAU,GACV,QAAQ;AACH,WAAA,IAAI,GAAG,IAAI,QAEd,OAAK,IAAI,IAAI,WAFO,KAAK;AAMpB,aAAA,KAAK,CAAC,IAAI,SAAS,MAAM,IAAI,OAAO,MAAM,GAAG;AACpD,YAAM,WAAW,UAAU;AACvB,UAAA;AACA,aAAO,CAAC,KAAM,OAAO,KAAK,GAAG,WAAW,CAAC,IAAI,GAAG,WAAW,CAAC,IAC9D,KAAK,GAAG,WAAW,CAAC,IAEpB,KAAK,GAAG,WAAW,CAAC,IAAI;AAE1B,UAAI,KAAK,KAAK;AACP,aAAA,KAAK,eAAe,KAAK,eAAe,MAAM,OAAO,EAAE,MAAM,MAAM,OAAO,EAAE;AAEjF,cAAA;AAGF,UADA,GAAG,QAAQ,IAAI,IACX,KAAK;AAEE,iBAAA;AAAA,eACA,KAAK;AAEH,mBAAA;AAAA,eACF,OAAO;AACV,cAAA,WAAW,UAAU,QAAQ;AACnC,YAAI,YAAY,KAAK,WAAW,WAAW,GAAG,QAAQ,MAAM,IAAI;AAExD,gBAAA,KAAK,cAAc,GAAG,QAAQ;AACpC,cAAI,MAAM;AAER,mBAAO,YAAY,OAAO,OAAO,IAAI,IAAI,QAAQ;AAAA,QAAA;AAAA,MAErD;AAAA,IACF;AAIO,aAAA,KAAK,CAAC,IAAI,SAAS,MAAM,IAAI,OAAO,MAAM,GAAG;AACpD,YAAM,WAAW,UAAU;AACvB,UAAA;AACA,aAAO,CAAC,KAAM,OAAO,KAAK,GAAG,WAAW,CAAC,IAAI,GAAG,WAAW,CAAC,IAC9D,KAAK,GAAG,WAAW,CAAC,IAEpB,KAAK,GAAG,WAAW,CAAC,IAAI;AAE1B,UAAI,KAAK,KAAK;AACd,aACE,KAAK,eACL,KAAK,eACL,MAAM,OAAO,cAAc,KAAK,CAAC,MAAM,MAAM,OAAO,cAAc,KAAK,CAAC;AAGxE,cAAA;AAGF,UADA,GAAG,QAAQ,IAAI,IACX,KAAK;AAEE,iBAAA;AAAA,eACA,KAAK;AAEH,mBAAA;AAAA,eACF,CAAC,OAAO;AACX,cAAA,WAAW,UAAU,QAAQ;AACnC,YAAI,YAAY,KAAK,WAAW,WAAW,GAAG,QAAQ,MAAM,IAAI;AAC9D,gBAAM,KAAK,GAAG,QAAQ,GAChB,KAAK,UAAU,KAAK;AAE1B,cAAA,KAAK,cAAc,IACf,MAAM;AAER,mBAAO,YAAY,OAAO,OAAO,IAAI,IAAI,QAAQ;AAAA,QAAA;AAAA,MAErD;AAAA,IACF;AAAA,EACF;AAGK,SAAA;AAAA,IACL,CAAC,aAAa,KAAK;AAAA,IACnB,CAAC,aAAa,KAAK;AAAA,EACrB;AACF;AAcA,SAAS,YAAY,OAAe,OAAe,GAAW,GAAW,UAA0B;AACjG,QAAM,SAAS,MAAM,UAAU,GAAG,CAAC,GAC7B,SAAS,MAAM,UAAU,GAAG,CAAC,GAC7B,SAAS,MAAM,UAAU,CAAC,GAC1B,SAAS,MAAM,UAAU,CAAC,GAG1B,QAAQ,OAAO,QAAQ,QAAQ,EAAC,YAAY,IAAO,SAAQ,CAAC,GAC5D,SAAS,OAAO,QAAQ,QAAQ,EAAC,YAAY,IAAO,UAAS;AAE5D,SAAA,MAAM,OAAO,MAAM;AAC5B;ACnIO,SAAS,cAAc,OAAe,OAAe,UAAU,GAAqB;AACzF,MAAI,WAAW;AAEN,WAAA;AAGT,QAAM,WAAW,MAAM,SAAS,MAAM,SAAS,QAAQ,OACjD,YAAY,MAAM,SAAS,MAAM,SAAS,QAAQ;AACxD,MAAI,SAAS,SAAS,KAAK,UAAU,SAAS,IAAI,SAAS;AAClD,WAAA;AAIH,QAAA,aAAa,WAAW,UAAU,WAAW,KAAK,KAAK,SAAS,SAAS,CAAC,CAAC,GAE3E,aAAa,WAAW,UAAU,WAAW,KAAK,KAAK,SAAS,SAAS,CAAC,CAAC;AAE7E,MAAA;AACJ,MAAI,cAAc;AAEJ,gBAAA,WAAW,CAAC,EAAE,SAAS,WAAW,CAAC,EAAE,SAAS,aAAa;AAAA,OAClE;AAAI,QAAA,CAAC,cAAc,CAAC;AAClB,aAAA;AACG,iBAEA,eACV,YAAY,cAFZ,YAAY;AAAA,EAAA;AAKd,MAAI,CAAC;AACG,UAAA,IAAI,MAAM,8BAA8B;AAI5C,MAAA,QACA,QACA,QACA;AAEA,QAAM,SAAS,MAAM,UACvB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,MAEpB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC;AAEhB,QAAA,YAAY,UAAU,CAAC;AAC7B,SAAO,CAAC,QAAQ,QAAQ,QAAQ,QAAQ,SAAS;AACnD;AAcA,SAAS,WAAW,UAAkB,WAAmB,GAA6B;AAE9E,QAAA,OAAO,SAAS,MAAM,GAAG,IAAI,KAAK,MAAM,SAAS,SAAS,CAAC,CAAC;AAClE,MAAI,IAAI,IACJ,aAAa,IACb,eACA,eACA,gBACA;AAEJ,UAAQ,IAAI,UAAU,QAAQ,MAAM,IAAI,CAAC,OAAO,MAAI;AAC5C,UAAA,eAAe,gBAAgB,SAAS,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,CAAC,GACpE,eAAe,gBAAgB,SAAS,MAAM,GAAG,CAAC,GAAG,UAAU,MAAM,GAAG,CAAC,CAAC;AAC5E,eAAW,SAAS,eAAe,iBACrC,aAAa,UAAU,MAAM,IAAI,cAAc,CAAC,IAAI,UAAU,MAAM,GAAG,IAAI,YAAY,GACvF,gBAAgB,SAAS,MAAM,GAAG,IAAI,YAAY,GAClD,gBAAgB,SAAS,MAAM,IAAI,YAAY,GAC/C,iBAAiB,UAAU,MAAM,GAAG,IAAI,YAAY,GACpD,iBAAiB,UAAU,MAAM,IAAI,YAAY;AAAA,EAAA;AAGrD,SAAI,WAAW,SAAS,KAAK,SAAS,SAC7B;AAAA,IACL,iBAAiB;AAAA,IACjB,iBAAiB;AAAA,IACjB,kBAAkB;AAAA,IAClB,kBAAkB;AAAA,IAClB,cAAc;AAAA,EAAA,IAIX;AACT;AC1GgB,SAAA,aAAa,OAAe,WAA2B;AACrE,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,QAAQ,MAAM,CAAC,EAAE,CAAC,GAClB,OAAiB,CAAC;AACxB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ;AAChC,WAAK,CAAC,IAAI,UAAU,MAAM,WAAW,CAAC,CAAC;AAEzC,UAAM,CAAC,EAAE,CAAC,IAAI,KAAK,KAAK,EAAE;AAAA,EAAA;AAE9B;ACPgB,SAAA,aACd,OACA,OAKA;AACA,QAAM,YAAsB,IACtB,WAAoC,CAAC;AAI3C,YAAU,CAAC,IAAI;AAWf,WAAS,iBAAiB,MAAc;AACtC,QAAI,QAAQ,IAIR,YAAY,GACZ,UAAU,IAEV,kBAAkB,UAAU;AACzB,WAAA,UAAU,KAAK,SAAS,KAAG;AAChC,gBAAU,KAAK,QAAQ;AAAA,GAAM,SAAS,GAClC,YAAY,OACd,UAAU,KAAK,SAAS;AAE1B,UAAI,OAAO,KAAK,MAAM,WAAW,UAAU,CAAC;AAG5C,OAAI,SAAS,iBAAiB,SAAS,eAAe,IAAI,IAAI,SAAS,IAAI,MAAM,UAC/E,SAAS,OAAO,aAAa,SAAS,IAAI,CAAC,KAEvC,oBAAoB,aAGtB,OAAO,KAAK,MAAM,SAAS,GAC3B,UAAU,KAAK,SAEjB,SAAS,OAAO,aAAa,eAAe,GAC5C,SAAS,IAAI,IAAI,iBACjB,UAAU,iBAAiB,IAAI,OAEjC,YAAY,UAAU;AAAA,IAAA;AAEjB,WAAA;AAAA,EAAA;AAGT,MAAI,WAAW;AACT,QAAA,SAAS,iBAAiB,KAAK;AAC1B,aAAA;AACL,QAAA,SAAS,iBAAiB,KAAK;AAC9B,SAAA,EAAC,QAAQ,QAAQ,UAAS;AACnC;ACpDgB,SAAA,eAAe,OAAe,OAAe,MAAmC;AAE1F,MAAA,QAAQ,OACR,QAAQ;AAGN,QAAA,IAAI,aAAa,OAAO,KAAK;AAC3B,UAAA,EAAE,QACV,QAAQ,EAAE;AACV,QAAM,YAAY,EAAE;AAEhB,MAAA,QAAQ,OAAO,OAAO,OAAO;AAAA,IAC/B,YAAY;AAAA,IACZ,UAAU,KAAK;AAAA,EAAA,CAChB;AAGD,eAAa,OAAO,SAAS,GAE7B,QAAQ,gBAAgB,KAAK,GAI7B,MAAM,KAAK,CAAC,YAAY,EAAE,CAAC;AACvB,MAAA,UAAU,GACV,cAAc,GACd,cAAc,GACd,aAAa,IACb,aAAa;AACV,SAAA,UAAU,MAAM,UAAQ;AAC7B,YAAQ,MAAM,OAAO,EAAE,CAAC,GAAG;AAAA,MACzB,KAAK;AACH,uBACA,cAAc,MAAM,OAAO,EAAE,CAAC;AAC9B;AAAA,MACF,KAAK;AACH,uBACA,cAAc,MAAM,OAAO,EAAE,CAAC;AAC9B;AAAA,MACF,KAAK;AAEC,YAAA,eAAe,KAAK,eAAe,GAAG;AAElC,gBAAA,OAAO,UAAU,cAAc,aAAa,cAAc,WAAW,GAC3E,UAAU,UAAU,cAAc;AAC5B,gBAAA,KAAK,OAAO,YAAY,YAAY;AAAA,YACxC,YAAY;AAAA,YACZ,UAAU,KAAK;AAAA,UAAA,CAChB;AACD,mBAAS,IAAI,GAAG,SAAS,GAAG,KAAK,GAAG;AAClC,kBAAM,OAAO,SAAS,GAAG,GAAG,CAAC,CAAC;AAEhC,qBAAW,GAAG;AAAA,QAAA;AAEhB,sBAAc,GACd,cAAc,GACd,aAAa,IACb,aAAa;AACb;AAAA,MACF;AACQ,cAAA,IAAI,MAAM,yBAAyB;AAAA,IAAA;AAE7C;AAAA,EAAA;AAEF,SAAA,MAAM,OAEC;AACT;ACjEgB,SAAA,YAAY,OAAe,OAAe,MAAmC;AACvF,MAAA;AAEJ,MAAI,CAAC;AAEH,WAAO,CAAC,CAAC,aAAa,KAAK,CAAC;AAG9B,MAAI,CAAC;AAEH,WAAO,CAAC,CAAC,aAAa,KAAK,CAAC;AAG9B,QAAM,WAAW,MAAM,SAAS,MAAM,SAAS,QAAQ,OACjD,YAAY,MAAM,SAAS,MAAM,SAAS,QAAQ,OAClD,IAAI,SAAS,QAAQ,SAAS;AACpC,MAAI,MAAM;AAEA,WAAA,QAAA;AAAA,MACN,CAAC,aAAa,SAAS,UAAU,GAAG,CAAC,CAAC;AAAA,MACtC,CAAC,YAAY,SAAS;AAAA,MACtB,CAAC,aAAa,SAAS,UAAU,IAAI,UAAU,MAAM,CAAC;AAAA,IAAA,GAGpD,MAAM,SAAS,MAAM,WACvB,MAAM,CAAC,EAAE,CAAC,IAAI,aACd,MAAM,CAAC,EAAE,CAAC,IAAI,cAET;AAGT,MAAI,UAAU,WAAW;AAGhB,WAAA;AAAA,MACL,CAAC,aAAa,KAAK;AAAA,MACnB,CAAC,aAAa,KAAK;AAAA,IACrB;AAII,QAAA,YAAY,cAAc,OAAO,KAAK;AAC5C,MAAI,WAAW;AAEb,UAAM,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,GACpB,SAAS,UAAU,CAAC,GACpB,YAAY,UAAU,CAAC,GAEvB,SAAS,OAAO,QAAQ,QAAQ,IAAI,GACpC,SAAS,OAAO,QAAQ,QAAQ,IAAI;AAEnC,WAAA,OAAO,OAAO,CAAC,CAAC,YAAY,SAAS,CAAC,GAAG,MAAM;AAAA,EAAA;AAGxD,SAAI,KAAK,cAAc,MAAM,SAAS,OAAO,MAAM,SAAS,MACnD,eAAe,OAAO,OAAO,IAAI,IAGnC,OAAO,OAAO,OAAO,KAAK,QAAQ;AAC3C;;;;;;;;;AC3EO,MAAM,cAAc,IAOd,cAAc,GAOd,aAAa;AAoDV,SAAA,KACd,OACA,OACA,MACQ;AAEJ,MAAA,UAAU,QAAQ,UAAU;AACxB,UAAA,IAAI,MAAM,oBAAoB;AAGhC,QAAA,QAAQ,OAAO,OAAO,OAAO,mBAAmB,QAAQ,CAAA,CAAE,CAAC;AACjE,SAAA,4BAA4B,KAAK,GAC1B;AACT;AAWgB,SAAA,OAAO,OAAe,OAAe,SAAsC;AAErF,MAAA,QAAQ,OACR,QAAQ;AAGZ,MAAI,UAAU;AACZ,WAAO,QAAQ,CAAC,CAAC,YAAY,KAAK,CAAC,IAAI,CAAC;AAItC,MAAA,eAAe,gBAAgB,OAAO,KAAK;AAC/C,QAAM,eAAe,MAAM,UAAU,GAAG,YAAY;AACpD,UAAQ,MAAM,UAAU,YAAY,GACpC,QAAQ,MAAM,UAAU,YAAY,GAGpC,eAAe,gBAAgB,OAAO,KAAK;AAC3C,QAAM,eAAe,MAAM,UAAU,MAAM,SAAS,YAAY;AAChE,UAAQ,MAAM,UAAU,GAAG,MAAM,SAAS,YAAY,GACtD,QAAQ,MAAM,UAAU,GAAG,MAAM,SAAS,YAAY;AAGtD,MAAI,QAAQ,YAAY,OAAO,OAAO,OAAO;AAG7C,SAAI,gBACF,MAAM,QAAQ,CAAC,YAAY,YAAY,CAAC,GAEtC,gBACF,MAAM,KAAK,CAAC,YAAY,YAAY,CAAC,GAEvC,QAAQ,aAAa,KAAK,GACnB;AACT;AAEA,SAAS,eAAe,SAAqC;AAC3D,MAAI,IAAI;AACR,SAAI,OAAO,UAAY,QACrB,IAAI,WAAW,IAAI,OAAO,YAAY,UAEjC,KAAK,IAAI,IAAI,IAAI;AAC1B;AAEA,SAAS,mBAAmB,MAAiD;AACpE,SAAAC,iBAAA;AAAA,IACL,YAAY;AAAA,IACZ,UAAU,eAAe,KAAK,WAAW,CAAG;AAAA,EACzC,GAAA,IAAA;AAEP;AAEA,SAAS,YAAY,MAAc,MAAc,KAAa;AAC5D,SAAO,QAAQ,IAAI,OAAO,OAAO,OAAO;AAC1C;AAKA,SAAS,UAAU,MAAc,KAA+B;AACvD,SAAA,QAAQ,IACX,CAAC,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC,GAAG,KAAK,KAAK,SAAS,CAAC,CAAC,IAC1D,CAAC,KAAK,UAAU,CAAC,GAAG,KAAK,CAAC,CAAC;AACjC;AAKA,SAAS,cAAc,OAAe,GAAW,GAAW,KAAsB;AAChF,SAAO,QAAQ,IACX,MAAM,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,MAAM,MAAM,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,IAC1E,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC;AACtC;AAiCA,SAAS,cAAc,OAAe,GAAW,KAAa;AACtD,QAAA,MAAM,QAAQ,IAAI,KAAK;AAC7B,MAAI,YAA2B,MAC3B,YAA2B,MAE3B,IAAI,IAAI;AACL,SAAA,KAAK,KAAK,IAAI,MAAM,WAAW,cAAc,QAAQ,cAAc,OAAO,KAAK,KAAK;AACzF,UAAM,CAAC,IAAIC,KAAI,IAAI,MAAM,CAAC;AAC1B,QAAIA,MAAK,WAAW;AAIpB,UAAI,OAAO,aAAa;AAClB,sBAAc,SAChB,YAAY;AAEd;AAAA,MAAA,WACS,OAAO,aAAa;AACzB,sBAAc,SAChB,YAAY;AAEd;AAAA,MAAA,WACS,OAAO,YAAY;AACxB,YAAA,cAAc,QAAQ,cAAc,MAAM;AAEtC,gBAAA,CAAC,MAAMC,KAAI,IAAI,UAAU,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG;AAC/C,gBAAM,CAAC,EAAE,CAAC,IAAI,MACd,MAAM,CAAC,EAAE,CAAC,IAAI,YAAY,MAAM,CAAC,EAAE,CAAC,GAAGA,OAAM,GAAG;AAChD;AAAA,QAAA;AAEF;AAAA,MAAA;AAAA;AAAA,EACF;AAGE,MAAA,cAAc,QAAQ,cAAc,QAAQ,cAAc,OAAO,WAAW,WAAW,GAAG,GAAG;AAEzF,UAAA,CAAC,YAAY,UAAU,IAAI,UAAU,MAAM,SAAS,EAAE,CAAC,GAAG,GAAG,GAC7D,CAAC,UAAU,IAAI,UAAU,MAAM,SAAS,EAAE,CAAC,GAAG,GAAG;AACjD,UAAA,SAAS,EAAE,CAAC,IAAI,YACtB,MAAM,SAAS,EAAE,CAAC,IAAI,YACtB,MAAM,CAAC,EAAE,CAAC,IAAI,YAAY,MAAM,CAAC,EAAE,CAAC,GAAG,YAAY,GAAG;AACtD;AAAA,EAAA;AAGI,QAAA,CAAC,MAAM,IAAI,IAAI,UAAU,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG;AACzC,QAAA,CAAC,EAAE,CAAC,IAAI,MAEV,cAAc,QAChB,MAAM,OAAO,GAAG,GAAG,CAAC,aAAa,IAAI,CAAC,GAGlC,cAAc,QAAQ,aAAa,KAAG,eAE1C,MAAM,SAAS,EAAE,CAAC,IAAI,YAAY,MAAM,SAAS,EAAE,CAAC,GAAG,MAAM,GAAG,GAG9D,cAAc,OAChB,MAAM,OAAO,GAAG,GAAG,CAAC,aAAa,IAAI,CAAC,IAEtC,MAAM,SAAS,EAAE,CAAC,IAAI,YAAY,MAAM,SAAS,EAAE,CAAC,GAAG,MAAM,GAAG;AAEpE;AAEA,SAAS,4BAA4B,OAAe;AAElD,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,CAAC,UAAU,QAAQ,IAAI,MAAM,CAAC;AAEhC,QAAA,SAAS,WAAW,EAAG;AAErB,UAAA,YAAY,SAAS,CAAC,GACtB,WAAW,SAAS,SAAS,SAAS,CAAC;AAEzC,oBAAgB,QAAQ,KAAK,aAAa,cAC5C,cAAc,OAAO,GAAG,CAAC,GAGvB,eAAe,SAAS,KAAK,aAAa,cAC5C,cAAc,OAAO,GAAG,EAAE;AAAA,EAAA;AAI9B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ;AAE5B,UAAM,CAAC,EAAE,CAAC,EAAE,WAAW,KACzB,MAAM,OAAO,GAAG,CAAC;AAGvB;ACzRO,SAAS,gBAAgB,UAA0B;AACpD,MAAA,QAAgB,SAAS,IAAI,CAACH,UAAS,UAAUA,KAAI,CAAC,GAEtD,aAAa;AACjB,QAAM,aAAuB,CAAC;AAC9B,MAAI,mBAAmB,GAEnB,eAAe,MAEf,UAAU,GAEV,oBAAoB,GACpB,mBAAmB,GAEnB,oBAAoB,GACpB,mBAAmB;AACvB,SAAO,UAAU,MAAM;AACjB,UAAM,OAAO,EAAE,CAAC,MAAM,cAExB,WAAW,kBAAkB,IAAI,SACjC,oBAAoB,mBACpB,mBAAmB,kBACnB,oBAAoB,GACpB,mBAAmB,GACnB,eAAe,MAAM,OAAO,EAAE,CAAC,MAG3B,MAAM,OAAO,EAAE,CAAC,MAAM,cACxB,qBAAqB,MAAM,OAAO,EAAE,CAAC,EAAE,SAEvC,oBAAoB,MAAM,OAAO,EAAE,CAAC,EAAE,QAKtC,gBACA,aAAa,UAAU,KAAK,IAAI,mBAAmB,gBAAgB,KACnE,aAAa,UAAU,KAAK,IAAI,mBAAmB,gBAAgB,MAGnE,MAAM,OAAO,WAAW,mBAAmB,CAAC,GAAG,GAAG,CAAC,aAAa,YAAY,CAAC,GAE7E,MAAM,WAAW,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,aAEjD,oBAEA,oBACA,UAAU,mBAAmB,IAAI,WAAW,mBAAmB,CAAC,IAAI,IACpE,oBAAoB,GACpB,mBAAmB,GACnB,oBAAoB,GACpB,mBAAmB,GACnB,eAAe,MACf,aAAa,MAGjB;AAgBF,OAZI,eACF,QAAQ,aAAa,KAAK,IAE5B,QAAQ,wBAAwB,KAAK,GAQrC,UAAU,GACH,UAAU,MAAM,UAAQ;AAC7B,QAAI,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,eAAe,MAAM,OAAO,EAAE,CAAC,MAAM,aAAa;AACxE,YAAA,WAAW,MAAM,UAAU,CAAC,EAAE,CAAC,GAC/B,YAAY,MAAM,OAAO,EAAE,CAAC,GAC5B,iBAAiB,iBAAiB,UAAU,SAAS,GACrD,iBAAiB,iBAAiB,WAAW,QAAQ;AACvD,wBAAkB,kBAChB,kBAAkB,SAAS,SAAS,KAAK,kBAAkB,UAAU,SAAS,OAEhF,MAAM,OAAO,SAAS,GAAG,CAAC,YAAY,UAAU,UAAU,GAAG,cAAc,CAAC,CAAC,GAC7E,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,SAAS,UAAU,GAAG,SAAS,SAAS,cAAc,GAC9E,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,UAAU,UAAU,cAAc,GAC1D,cAEO,kBAAkB,SAAS,SAAS,KAAK,kBAAkB,UAAU,SAAS,OAGvF,MAAM,OAAO,SAAS,GAAG,CAAC,YAAY,SAAS,UAAU,GAAG,cAAc,CAAC,CAAC,GAC5E,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,aACxB,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,UAAU,UAAU,GAAG,UAAU,SAAS,cAAc,GAChF,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,aACxB,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,SAAS,UAAU,cAAc,GACzD,YAEF;AAAA,IAAA;AAEF;AAAA,EAAA;AAEK,SAAA;AACT;AAGA,MAAM,uBAAuB,gBACvB,kBAAkB,MAClB,iBAAiB,UACjB,oBAAoB,YACpB,sBAAsB;AAWrB,SAAS,wBAAwB,UAA0B;AAChE,QAAM,QAAQ,SAAS,IAAI,CAACA,UAAS,UAAUA,KAAI,CAAC;AAa3C,WAAA,yBAAyB,KAAa,KAAa;AACtD,QAAA,CAAC,OAAO,CAAC;AAEJ,aAAA;AAQH,UAAA,QAAQ,IAAI,OAAO,IAAI,SAAS,CAAC,GACjC,QAAQ,IAAI,OAAO,CAAC,GACpB,mBAAmB,MAAM,MAAM,oBAAoB,GACnD,mBAAmB,MAAM,MAAM,oBAAoB,GACnD,cAAc,oBAAoB,MAAM,MAAM,eAAe,GAC7D,cAAc,oBAAoB,MAAM,MAAM,eAAe,GAC7D,aAAa,eAAe,MAAM,MAAM,cAAc,GACtD,aAAa,eAAe,MAAM,MAAM,cAAc,GACtD,aAAa,cAAc,IAAI,MAAM,iBAAiB,GACtD,aAAa,cAAc,IAAI,MAAM,mBAAmB;AAE9D,WAAI,cAAc,aAET,IACE,cAAc,aAEhB,IACE,oBAAoB,CAAC,eAAe,cAEtC,IACE,eAAe,cAEjB,IACE,oBAAoB,mBAEtB,IAEF;AAAA,EAAA;AAGT,MAAI,UAAU;AAEP,SAAA,UAAU,MAAM,SAAS,KAAG;AACjC,QAAI,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,cAAc,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,YAAY;AAEhF,UAAI,YAAY,MAAM,UAAU,CAAC,EAAE,CAAC,GAChC,OAAO,MAAM,OAAO,EAAE,CAAC,GACvB,YAAY,MAAM,UAAU,CAAC,EAAE,CAAC;AAG9B,YAAA,eAAe,gBAAgB,WAAW,IAAI;AACpD,UAAI,cAAc;AAChB,cAAM,eAAe,KAAK,UAAU,KAAK,SAAS,YAAY;AAC9D,oBAAY,UAAU,UAAU,GAAG,UAAU,SAAS,YAAY,GAClE,OAAO,eAAe,KAAK,UAAU,GAAG,KAAK,SAAS,YAAY,GAClE,YAAY,eAAe;AAAA,MAAA;AAI7B,UAAI,gBAAgB,WAChB,WAAW,MACX,gBAAgB,WAChB,YACF,yBAAyB,WAAW,IAAI,IAAI,yBAAyB,MAAM,SAAS;AACtF,aAAO,KAAK,OAAO,CAAC,MAAM,UAAU,OAAO,CAAC,KAAG;AAC7C,qBAAa,KAAK,OAAO,CAAC,GAC1B,OAAO,KAAK,UAAU,CAAC,IAAI,UAAU,OAAO,CAAC,GAC7C,YAAY,UAAU,UAAU,CAAC;AACjC,cAAM,QACJ,yBAAyB,WAAW,IAAI,IAAI,yBAAyB,MAAM,SAAS;AAElF,iBAAS,cACX,YAAY,OACZ,gBAAgB,WAChB,WAAW,MACX,gBAAgB;AAAA,MAAA;AAIhB,YAAM,UAAU,CAAC,EAAE,CAAC,MAAM,kBAExB,gBACF,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,iBAExB,MAAM,OAAO,UAAU,GAAG,CAAC,GAC3B,YAEF,MAAM,OAAO,EAAE,CAAC,IAAI,UAChB,gBACF,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,iBAExB,MAAM,OAAO,UAAU,GAAG,CAAC,GAC3B;AAAA,IAAA;AAIN;AAAA,EAAA;AAGK,SAAA;AACT;AAUO,SAAS,aAAa,UAA0B;AACrD,MAAI,QAAQ,SAAS,IAAI,CAACA,UAAS,UAAUA,KAAI,CAAC;AAGlD,QAAM,KAAK,CAAC,YAAY,EAAE,CAAC;AACvB,MAAA,UAAU,GACV,cAAc,GACd,cAAc,GACd,aAAa,IACb,aAAa,IACb;AACJ,SAAO,UAAU,MAAM;AACrB,YAAQ,MAAM,OAAO,EAAE,CAAC,GAAG;AAAA,MACzB,KAAK;AACH,uBACA,cAAc,MAAM,OAAO,EAAE,CAAC,GAC9B;AACA;AAAA,MACF,KAAK;AACH,uBACA,cAAc,MAAM,OAAO,EAAE,CAAC,GAC9B;AACA;AAAA,MACF,KAAK;AAEC,sBAAc,cAAc,KAC1B,gBAAgB,KAAK,gBAAgB,MAEvC,eAAe,gBAAgB,YAAY,UAAU,GACjD,iBAAiB,MAEjB,UAAU,cAAc,cAAc,KACtC,MAAM,UAAU,cAAc,cAAc,CAAC,EAAE,CAAC,MAAM,aAEtD,MAAM,UAAU,cAAc,cAAc,CAAC,EAAE,CAAC,KAAK,WAAW;AAAA,UAC9D;AAAA,UACA;AAAA,QAGF,KAAA,MAAM,OAAO,GAAG,GAAG,CAAC,YAAY,WAAW,UAAU,GAAG,YAAY,CAAC,CAAC,GACtE,YAEF,aAAa,WAAW,UAAU,YAAY,GAC9C,aAAa,WAAW,UAAU,YAAY,IAGhD,eAAe,gBAAgB,YAAY,UAAU,GACjD,iBAAiB,MACnB,MAAM,OAAO,EAAE,CAAC,IACd,WAAW,UAAU,WAAW,SAAS,YAAY,IAAI,MAAM,OAAO,EAAE,CAAC,GAC3E,aAAa,WAAW,UAAU,GAAG,WAAW,SAAS,YAAY,GACrE,aAAa,WAAW,UAAU,GAAG,WAAW,SAAS,YAAY,KAIzE,WAAW,cAAc,aACzB,MAAM,OAAO,SAAS,cAAc,WAAW,GAC3C,WAAW,WACb,MAAM,OAAO,SAAS,GAAG,CAAC,aAAa,UAAU,CAAC,GAClD,YAEE,WAAW,WACb,MAAM,OAAO,SAAS,GAAG,CAAC,aAAa,UAAU,CAAC,GAClD,YAEF,aACS,YAAY,KAAK,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,cAEpD,MAAM,UAAU,CAAC,EAAE,CAAC,KAAK,MAAM,OAAO,EAAE,CAAC,GACzC,MAAM,OAAO,SAAS,CAAC,KAEvB,WAEF,cAAc,GACd,cAAc,GACd,aAAa,IACb,aAAa;AACb;AAAA,MACF;AACQ,cAAA,IAAI,MAAM,wBAAwB;AAAA,IAAA;AAG1C,QAAM,MAAM,SAAS,CAAC,EAAE,CAAC,MAAM,MACjC,MAAM,IAAI;AAMZ,MAAI,aAAa;AAGjB,OAFA,UAAU,GAEH,UAAU,MAAM,SAAS;AAC1B,UAAM,UAAU,CAAC,EAAE,CAAC,MAAM,cAAc,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,eAGlE,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,MAAM,OAAO,EAAE,CAAC,EAAE,SAAS,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,MACnF,MAAM,UAAU,CAAC,EAAE,CAAC,KAGpB,MAAM,OAAO,EAAE,CAAC,IACd,MAAM,UAAU,CAAC,EAAE,CAAC,IACpB,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,GAAG,MAAM,OAAO,EAAE,CAAC,EAAE,SAAS,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,GACxF,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC,GACpE,MAAM,OAAO,UAAU,GAAG,CAAC,GAC3B,aAAa,MAEb,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,GAAG,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,MAAM,MAAM,UAAU,CAAC,EAAE,CAAC,MAGrF,MAAM,UAAU,CAAC,EAAE,CAAC,KAAK,MAAM,UAAU,CAAC,EAAE,CAAC,GAC7C,MAAM,OAAO,EAAE,CAAC,IACd,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC,GAClF,MAAM,OAAO,UAAU,GAAG,CAAC,GAC3B,aAAa,MAGjB;AAGF,SAAI,eACF,QAAQ,aAAa,KAAK,IAGrB;AACT;AAEA,SAAS,aAAa,MAAiB;AAC9B,SAAA,KAAK,OAAO,CAAC,GAAG,SAAS,KAAK,OAAO,IAAI,IAAI,CAAC;AACvD;AAUgB,SAAA,kBAAkB,UAAkB,WAAmB,GAAW;AAC5E,MAAA,QAAQ,SAAS,IAAI,CAACA,UAAS,UAAUA,KAAI,CAAC,GAC9C,aAAa;AACjB,QAAM,aAAuB,CAAC;AAC9B,MAAI,mBAAmB,GACnB,eAA8B,MAE9B,UAAU,GAEV,SAAS,IAET,SAAS,IAET,UAAU,IAEV,UAAU;AACd,SAAO,UAAU,MAAM;AACjB,UAAM,OAAO,EAAE,CAAC,MAAM,cAEpB,MAAM,OAAO,EAAE,CAAC,EAAE,SAAS,aAAa,WAAW,YAErD,WAAW,kBAAkB,IAAI,SACjC,SAAS,SACT,SAAS,SACT,eAAe,MAAM,OAAO,EAAE,CAAC,MAG/B,mBAAmB,GACnB,eAAe,OAEjB,UAAU,IACV,UAAU,OAGN,MAAM,OAAO,EAAE,CAAC,MAAM,cACxB,UAAU,KAEV,UAAU,IAWV,iBACE,UAAU,UAAU,WAAW,WAC9B,aAAa,SAAS,WAAW,KAAK,UAAU,QAAQ,QAAQ,SAAS,OAAO,MAAM,OAGzF,MAAM,OAAO,WAAW,mBAAmB,CAAC,GAAG,GAAG,CAAC,aAAa,YAAY,CAAC,GAE7E,MAAM,WAAW,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,aACjD,oBACA,eAAe,MACX,UAAU,UAEZ,UAAU,IACV,UAAU,IACV,mBAAmB,MAEnB,oBACA,UAAU,mBAAmB,IAAI,WAAW,mBAAmB,CAAC,IAAI,IACpE,UAAU,IACV,UAAU,KAEZ,aAAa,MAGjB;AAGF,SAAI,eACF,QAAQ,aAAa,KAAK,IAGrB;AACT;;;;;;;;;ACndA,MAAM,kBAAgC;AAAA;AAAA;AAAA;AAAA,EAIpC,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOX,UAAU;AACZ;AAEA,SAAS,cAAc,SAA8C;AACnE,SAAOC,sCAAI,eAAoB,GAAA,OAAA;AACjC;AAGA,MAAMG,aAAW;AAaV,SAAS,MACd,MACA,SACA,KACA,OAA8B,CAAA,GACtB;AACR,MAAI,QAAQ,SAASA;AACb,UAAA,IAAI,MAAM,oCAAoC;AAGtD,QAAM,UAAU,cAAc,IAAI,GAG5B,IAAI,uBAAuB,OAAO;AAW/B,WAAA,cAAc,GAAW,GAAW;AACrC,UAAA,WAAW,IAAI,QAAQ,QACvB,YAAY,KAAK,IAAI,MAAM,CAAC;AAClC,WAAK,QAAQ,WAIN,WAAW,YAAY,QAAQ,WAF7B,YAAY,IAAM;AAAA,EAAA;AAM7B,MAAI,iBAAiB,QAAQ,WAEzB,UAAU,KAAK,QAAQ,SAAS,GAAG;AACnC,cAAY,OACd,iBAAiB,KAAK,IAAI,cAAc,GAAG,OAAO,GAAG,cAAc,GAEnE,UAAU,KAAK,YAAY,SAAS,MAAM,QAAQ,MAAM,GACpD,YAAY,OACd,iBAAiB,KAAK,IAAI,cAAc,GAAG,OAAO,GAAG,cAAc;AAKjE,QAAA,YAAY,KAAM,QAAQ,SAAS;AAC/B,YAAA;AAEN,MAAA,QACA,QACA,SAAS,QAAQ,SAAS,KAAK,QAC/B,SAAmB,CAAC;AACxB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AAMvC,SAFA,SAAS,GACT,SAAS,QACF,SAAS;AACV,oBAAc,GAAG,MAAM,MAAM,KAAK,iBACpC,SAAS,SAET,SAAS,QAEX,SAAS,KAAK,OAAO,SAAS,UAAU,IAAI,MAAM;AAG3C,aAAA;AACT,QAAI,QAAQ,KAAK,IAAI,GAAG,MAAM,SAAS,CAAC;AACxC,UAAM,SAAS,KAAK,IAAI,MAAM,QAAQ,KAAK,MAAM,IAAI,QAAQ,QAEvD,KAAe,IAAI,MAAM,SAAS,CAAC;AACzC,OAAG,SAAS,CAAC,KAAK,KAAK,KAAK;AAC5B,aAAS,IAAI,QAAQ,KAAK,OAAO,KAAK;AAGpC,YAAM,YAAY,EAAE,KAAK,OAAO,IAAI,CAAC,CAAC;AAWtC,UAVI,MAAM,IAER,GAAG,CAAC,KAAM,GAAG,IAAI,CAAC,KAAK,IAAK,KAAK,YAGjC,GAAG,CAAC,KACC,GAAG,IAAI,CAAC,KAAK,IAAK,KAAK,cACvB,OAAO,IAAI,CAAC,IAAI,OAAO,CAAC,MAAM,IAAK,KACtC,OAAO,IAAI,CAAC,GAEZ,GAAG,CAAC,IAAI,WAAW;AACrB,cAAM,QAAQ,cAAc,GAAG,IAAI,CAAC;AAGpC,YAAI,SAAS;AAIX,cAFA,iBAAiB,OACjB,UAAU,IAAI,GACV,UAAU;AAEZ,oBAAQ,KAAK,IAAI,GAAG,IAAI,MAAM,OAAO;AAAA;AAGrC;AAAA,MAAA;AAAA,IAGN;AAGF,QAAI,cAAc,IAAI,GAAG,GAAG,IAAI;AAC9B;AAEO,aAAA;AAAA,EAAA;AAEJ,SAAA;AACT;AASA,SAAS,uBAAuB,SAA2B;AACzD,QAAM,IAAc,CAAC;AACrB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ;AAClC,MAAE,QAAQ,OAAO,CAAC,CAAC,IAAI;AAEzB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ;AAChC,MAAA,QAAQ,OAAO,CAAC,CAAC,KAAK,KAAM,QAAQ,SAAS,IAAI;AAE9C,SAAA;AACT;AC1IO,SAAS,MACd,MACA,SACA,gBACA,UAAwB,CAAA,GAChB;AAER,MAAI,SAAS,QAAQ,YAAY,QAAQ,mBAAmB;AACpD,UAAA,IAAI,MAAM,uBAAuB;AAGnC,QAAA,MAAM,KAAK,IAAI,GAAG,KAAK,IAAI,gBAAgB,KAAK,MAAM,CAAC;AAC7D,MAAI,SAAS;AAEJ,WAAA;AACF,MAAK,KAAK;AAGV,QAAI,KAAK,UAAU,KAAK,MAAM,QAAQ,MAAM,MAAM;AAEhD,aAAA;AAAA,QAHA,QAAA;AAOT,SAAO,MAAM,MAAM,SAAS,KAAK,OAAO;AAC1C;ACpDO,SAAS,UAAU,OAAuB;AAC/C,QAAM,OAAiB,CAAC;AACxB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ;AAC5B,UAAM,CAAC,EAAE,CAAC,MAAM,gBAClB,KAAK,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC;AAGjB,SAAA,KAAK,KAAK,EAAE;AACrB;AASO,SAAS,UAAU,OAAuB;AAC/C,QAAM,OAAiB,CAAC;AACxB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ;AAC5B,UAAM,CAAC,EAAE,CAAC,MAAM,gBAClB,KAAK,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC;AAGjB,SAAA,KAAK,KAAK,EAAE;AACrB;ACxBO,SAAS,YAAY,OAAuB;AACjD,MAAI,QAAQ,GACR,aAAa,GACb,YAAY;AAEhB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAC/B,UAAA,KAAK,MAAM,CAAC,EAAE,CAAC,GACf,OAAO,MAAM,CAAC,EAAE,CAAC;AACvB,YAAQ,IAAI;AAAA,MACV,KAAK;AACH,sBAAc,KAAK;AACnB;AAAA,MACF,KAAK;AACH,qBAAa,KAAK;AAClB;AAAA,MACF,KAAK;AAEH,iBAAS,KAAK,IAAI,YAAY,SAAS,GACvC,aAAa,GACb,YAAY;AACZ;AAAA,MACF;AACQ,cAAA,IAAI,MAAM,yBAAyB;AAAA,IAAA;AAAA,EAC7C;AAEF,SAAA,SAAS,KAAK,IAAI,YAAY,SAAS,GAChC;AACT;ACzBgB,SAAA,OAAO,OAAe,UAA0B;AAC9D,MAAI,SAAS,GACT,SAAS,GACT,aAAa,GACb,aAAa,GACb;AACJ,OAAK,IAAI,GAAG,IAAI,MAAM,WAChB,MAAM,CAAC,EAAE,CAAC,MAAM,gBAElB,UAAU,MAAM,CAAC,EAAE,CAAC,EAAE,SAEpB,MAAM,CAAC,EAAE,CAAC,MAAM,gBAElB,UAAU,MAAM,CAAC,EAAE,CAAC,EAAE,SAEpB,WAAS,YATe;AAa5B,iBAAa,QACb,aAAa;AAGX,SAAA,MAAM,WAAW,KAAK,MAAM,CAAC,EAAE,CAAC,MAAM,cACjC,aAGF,cAAc,WAAW;AAClC;AC7BO,SAAS,eAAe,KAAqB;AAClD,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AAC7B,UAAA,YAAY,IAAI,YAAY,CAAC;AACnC,QAAI,OAAO,YAAc;AACjB,YAAA,IAAI,MAAM,yBAAyB;AAE3C,aAAS,QAAQ,SAAS;AAAA,EAAA;AAErB,SAAA;AACT;AA6BO,SAAS,qBACd,SACA,MACA,UAA6B,CAAA,GACpB;AACL,MAAA,aAAa,GACb,MAAM;AAEV,WAAS,UAAU,QAAgB;AACjC,WAAO,aAAa,UAAU;AACtB,YAAA,YAAY,KAAK,YAAY,GAAG;AACtC,UAAI,OAAO,YAAc;AAGhB,eAAA;AAGT,oBAAc,QAAQ,SAAS,GAG3B,YAAY,QACd,OAAO,IAEP,OAAO;AAAA,IAAA;AAIP,QAAA,CAAC,QAAQ,yBAAyB,eAAe;AAC7C,YAAA,IAAI,MAAM,iCAAiC;AAG5C,WAAA;AAAA,EAAA;AAGT,QAAM,WAAoB,CAAC;AAC3B,aAAW,SAAS;AAClB,aAAS,KAAK;AAAA,MACZ,OAAO,MAAM,MAAM,IAAI,CAACJ,UAAS,UAAUA,KAAI,CAAC;AAAA,MAChD,QAAQ,UAAU,MAAM,MAAM;AAAA,MAC9B,QAAQ,UAAU,MAAM,MAAM;AAAA,MAC9B,YAAY,MAAM;AAAA,MAClB,YAAY,MAAM;AAAA,MAClB,SAAS,MAAM;AAAA,MACf,SAAS,MAAM;AAAA,MACf,aAAa,MAAM;AAAA,MACnB,aAAa,MAAM;AAAA,IAAA,CACpB;AAGI,SAAA;AACT;AAEA,SAAS,QAAQ,WAAkC;AAE7C,SAAA,aAAa,MAAe,IAC5B,aAAa,OAAe,IAC5B,aAAa,QAAe,IACzB;AACT;AC3Ga,MAAA,WAAW,IAEX,iBAAiB;ACUd,SAAA,WAAW,SAAkB,SAAiB,gBAAwB;AACpF,QAAM,gBAAgB;AACtB,MAAI,cAAc;AACT,WAAA,IAAI,GAAG,KAAK,eAAe;AACnB,mBAAA,OAAO,aAAa,CAAC;AAItC,aAAW,KAAK;AACZ,MAAA,UAAU,eACZ,EAAE,UAAU,eACZ,EAAE,cAAc,eAChB,EAAE,cAAc;AAIlB,MAAI,QAAQ,QAAQ,CAAC,GACjB,QAAQ,MAAM;AAClB,MAAI,MAAM,WAAW,KAAK,MAAM,CAAC,EAAE,CAAC,MAAM;AAExC,UAAM,QAAQ,CAAC,YAAY,WAAW,CAAC,GACvC,MAAM,UAAU,eAChB,MAAM,UAAU,eAChB,MAAM,cAAc,eACpB,MAAM,cAAc,eACpB,MAAM,WAAW,eACjB,MAAM,WAAW,eACjB,MAAM,eAAe,eACrB,MAAM,eAAe;AAAA,WACZ,gBAAgB,MAAM,CAAC,EAAE,CAAC,EAAE,QAAQ;AAEvC,UAAA,kBAAkB,MAAM,CAAC,EAAE,CAAC,EAAE,QAC9B,cAAc,gBAAgB;AACpC,UAAM,CAAC,EAAE,CAAC,IAAI,YAAY,UAAU,eAAe,IAAI,MAAM,CAAC,EAAE,CAAC,GACjE,MAAM,UAAU,aAChB,MAAM,UAAU,aAChB,MAAM,cAAc,aACpB,MAAM,cAAc,aACpB,MAAM,WAAW,aACjB,MAAM,WAAW,aACjB,MAAM,eAAe,aACrB,MAAM,eAAe;AAAA,EAAA;AAMvB,MAFA,QAAQ,QAAQ,QAAQ,SAAS,CAAC,GAClC,QAAQ,MAAM,OACV,MAAM,WAAW,KAAK,MAAM,MAAM,SAAS,CAAC,EAAE,CAAC,MAAM;AAEvD,UAAM,KAAK,CAAC,YAAY,WAAW,CAAC,GACpC,MAAM,WAAW,eACjB,MAAM,WAAW,eACjB,MAAM,eAAe,eACrB,MAAM,eAAe;AAAA,WACZ,gBAAgB,MAAM,MAAM,SAAS,CAAC,EAAE,CAAC,EAAE,QAAQ;AAEtD,UAAA,cAAc,gBAAgB,MAAM,MAAM,SAAS,CAAC,EAAE,CAAC,EAAE;AACzD,UAAA,MAAM,SAAS,CAAC,EAAE,CAAC,KAAK,YAAY,UAAU,GAAG,WAAW,GAClE,MAAM,WAAW,aACjB,MAAM,WAAW,aACjB,MAAM,eAAe,aACrB,MAAM,eAAe;AAAA,EAAA;AAGhB,SAAA;AACT;AC3BgB,SAAA,kBAAkB,QAAgB,QAAuB;AAChE,SAAA;AAAA,IACL,OAAO,CAAC;AAAA,IAER;AAAA,IACA;AAAA,IACA,YAAY;AAAA,IACZ,YAAY;AAAA,IAEZ,SAAS;AAAA,IACT,SAAS;AAAA,IACT,aAAa;AAAA,IACb,aAAa;AAAA,EACf;AACF;ACnDgB,SAAA,SAAS,SAAkB,SAAiB,gBAAsB;AAChF,QAAM,YAAY;AAClB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACnC,QAAA,QAAQ,CAAC,EAAE,WAAW;AACxB;AAEI,UAAA,WAAW,QAAQ,CAAC;AAElB,YAAA,OAAO,KAAK,CAAC;AACrB,QAAI,SAAS,SAAS,QAClB,SAAS,SAAS,QAClB,aAAa;AACV,WAAA,SAAS,MAAM,WAAW,KAAG;AAElC,YAAM,QAAQ,kBAAkB,SAAS,WAAW,QAAQ,SAAS,WAAW,MAAM;AACtF,UAAI,QAAQ;AAEZ,UAAI,eAAe,IAAI;AACf,cAAA,sBAAsB,eAAe,UAAU;AACrD,cAAM,UAAU,WAAW,QAC3B,MAAM,cAAc,qBACpB,MAAM,UAAU,WAAW,QAC3B,MAAM,cAAc,qBACpB,MAAM,MAAM,KAAK,CAAC,YAAY,UAAU,CAAC;AAAA,MAAA;AAE3C,aAAO,SAAS,MAAM,WAAW,KAAK,MAAM,UAAU,YAAY,UAAQ;AACxE,cAAM,WAAW,SAAS,MAAM,CAAC,EAAE,CAAC;AAChC,YAAA,WAAW,SAAS,MAAM,CAAC,EAAE,CAAC,GAC9B,oBAAoB,eAAe,QAAQ;AAC/C,YAAI,aAAa,aAAa;AAE5B,gBAAM,WAAW,SAAS,QAC1B,MAAM,eAAe,mBACrB,UAAU,SAAS;AACb,gBAAAA,QAAO,SAAS,MAAM,MAAM;AAC9B,UAAAA,SACF,MAAM,MAAM,KAAKA,KAAI,GAEvB,QAAQ;AAAA,QACV,MACE,cAAa,eACb,MAAM,MAAM,WAAW,KACvB,MAAM,MAAM,CAAC,EAAE,CAAC,MAAM,cACtB,SAAS,SAAS,IAAI,aAGtB,MAAM,WAAW,SAAS,QAC1B,MAAM,eAAe,mBACrB,UAAU,SAAS,QACnB,QAAQ,IACR,MAAM,MAAM,KAAK,CAAC,UAAU,QAAQ,CAAC,GACrC,SAAS,MAAM,YAGf,WAAW,SAAS,UAAU,GAAG,YAAY,MAAM,UAAU,MAAM,GACnE,oBAAoB,eAAe,QAAQ,GAC3C,MAAM,WAAW,SAAS,QAC1B,MAAM,eAAe,mBACrB,UAAU,SAAS,QACf,aAAa,cACf,MAAM,WAAW,SAAS,QAC1B,MAAM,eAAe,mBACrB,UAAU,SAAS,UAEnB,QAAQ,IAEV,MAAM,MAAM,KAAK,CAAC,UAAU,QAAQ,CAAC,GACjC,aAAa,SAAS,MAAM,CAAC,EAAE,CAAC,IAClC,SAAS,MAAM,MAAA,IAEf,SAAS,MAAM,CAAC,EAAE,CAAC,IAAI,SAAS,MAAM,CAAC,EAAE,CAAC,EAAE,UAAU,SAAS,MAAM;AAAA,MAAA;AAK9D,mBAAA,UAAU,MAAM,KAAK,GAClC,aAAa,WAAW,UAAU,WAAW,SAAS,MAAM;AAEtD,YAAA,cAAc,UAAU,SAAS,KAAK,EAAE,UAAU,GAAG,MAAM,GAC3D,uBAAuB,eAAe,WAAW;AACnD,sBAAgB,OAClB,MAAM,WAAW,YAAY,QAC7B,MAAM,WAAW,YAAY,QAC7B,MAAM,eAAe,sBACrB,MAAM,eAAe,sBACjB,MAAM,MAAM,WAAW,KAAK,MAAM,MAAM,MAAM,MAAM,SAAS,CAAC,EAAE,CAAC,MAAM,aACzE,MAAM,MAAM,MAAM,MAAM,SAAS,CAAC,EAAE,CAAC,KAAK,cAE1C,MAAM,MAAM,KAAK,CAAC,YAAY,WAAW,CAAC,IAGzC,SACH,QAAQ,OAAO,EAAE,GAAG,GAAG,KAAK;AAAA,IAAA;AAAA,EAEhC;AAEJ;ACjDO,SAAS,MACd,SACA,cACA,OAAmC,CAAA,GACtB;AACb,MAAI,OAAO,WAAY;AACf,UAAA,IAAI,MAAM,mEAAmE;AAGrF,MAAI,OAAO;AACX,MAAI,QAAQ,WAAW;AACd,WAAA,CAAC,MAAM,EAAE;AAIZ,QAAA,SAAS,qBAAqB,SAAS,MAAM;AAAA,IACjD,uBAAuB,KAAK;AAAA,EAC7B,CAAA,GAEK,SAAS,KAAK,UAAU,gBACxB,kBAAkB,KAAK,mBAAmB,KAE1C,cAAc,WAAW,QAAQ,MAAM;AAC7C,SAAO,cAAc,OAAO,aAE5B,SAAS,QAAQ,MAAM;AAKvB,MAAI,QAAQ;AACZ,QAAM,UAAqB,CAAC;AAC5B,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAChC,UAAA,cAAc,OAAO,CAAC,EAAE,SAAS,OACjC,QAAQ,UAAU,OAAO,CAAC,EAAE,KAAK;AACvC,QAAI,UACA,SAAS;AAmBb,QAlBI,MAAM,SAAS,YAGjB,WAAW,MAAM,MAAM,MAAM,UAAU,GAAG,QAAQ,GAAG,WAAW,GAC5D,aAAa,OACf,SAAS;AAAA,MACP;AAAA,MACA,MAAM,UAAU,MAAM,SAAS,QAAQ;AAAA,MACvC,cAAc,MAAM,SAAS;AAAA,IAAA,IAE3B,WAAW,MAAM,YAAY,YAE/B,WAAW,QAIf,WAAW,MAAM,MAAM,OAAO,WAAW,GAEvC,aAAa;AAEP,cAAA,CAAC,IAAI,IAEb,SAAS,OAAO,CAAC,EAAE,UAAU,OAAO,CAAC,EAAE;AAAA,SAClC;AAEL,cAAQ,CAAC,IAAI,IACb,QAAQ,WAAW;AACf,UAAA;AAMJ,UALI,WAAW,KACb,QAAQ,KAAK,UAAU,UAAU,WAAW,MAAM,MAAM,IAExD,QAAQ,KAAK,UAAU,UAAU,SAAS,QAAQ,GAEhD,UAAU;AAEZ,eACE,KAAK,UAAU,GAAG,QAAQ,IAC1B,UAAU,OAAO,CAAC,EAAE,KAAK,IACzB,KAAK,UAAU,WAAW,MAAM,MAAM;AAAA,WACnC;AAEL,YAAI,QAAQ,KAAK,OAAO,OAAO,EAAC,YAAY,IAAM;AAClD,YAAI,MAAM,SAAS,YAAY,YAAY,KAAK,IAAI,MAAM,SAAS;AAEjE,kBAAQ,CAAC,IAAI;AAAA,aACR;AACL,kBAAQ,wBAAwB,KAAK;AACjC,cAAA,SAAS,GACT,SAAS;AACJ,mBAAA,IAAI,GAAG,IAAI,OAAO,CAAC,EAAE,MAAM,QAAQ,KAAK;AAC/C,kBAAM,MAAM,OAAO,CAAC,EAAE,MAAM,CAAC;AACzB,gBAAI,CAAC,MAAM,eACb,SAAS,OAAO,OAAO,MAAM,IAE3B,IAAI,CAAC,MAAM,cAEb,OACE,KAAK,UAAU,GAAG,WAAW,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,WAAW,MAAM,IACzE,IAAI,CAAC,MAAM,gBAEpB,OACE,KAAK,UAAU,GAAG,WAAW,MAAM,IACnC,KAAK,UAAU,WAAW,OAAO,OAAO,SAAS,IAAI,CAAC,EAAE,MAAM,CAAC,IAE/D,IAAI,CAAC,MAAM,gBACb,UAAU,IAAI,CAAC,EAAE;AAAA,UAAA;AAAA,QAErB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGK,SAAA,OAAA,KAAK,UAAU,YAAY,QAAQ,KAAK,SAAS,YAAY,MAAM,GACnE,CAAC,MAAM,OAAO;AACvB;;;;;;;;;AC3JA,MAAM,eAAiC;AAAA,EACrC,QAAQ;AACV;AAEA,SAAS,eAAe,OAAkC,IAAsB;AAC9E,SAAO,kCACF,YACA,GAAA,IAAA;AAEP;AAkCgB,SAAA,KACd,GACA,GACA,SACS;AACT,MAAI,OAAO,KAAM,YAAY,OAAO,KAAM,UAAU;AAGlD,QAAI,QAAQ,KAAK,GAAG,GAAG,EAAC,YAAY,IAAK;AACzC,WAAI,MAAM,SAAS,MACjB,QAAQ,gBAAgB,KAAK,GAC7B,QAAQ,kBAAkB,KAAK,IAE1B,MAAM,GAAG,OAAO,eAAe,OAAO,CAAC;AAAA,EAAA;AAGhD,MAAI,KAAK,MAAM,QAAQ,CAAC,KAAK,OAAO,IAAM;AAGxC,WAAO,MAAM,UAAU,CAAC,GAAG,GAAG,eAAe,OAAO,CAAC;AAGvD,MAAI,OAAO,KAAM,YAAY,KAAK,MAAM,QAAQ,CAAC;AAE/C,WAAO,MAAM,GAAG,GAAG,eAAe,OAAO,CAAC;AAGtC,QAAA,IAAI,MAAM,+BAA+B;AACjD;AAEA,SAAS,MAAM,OAAe,OAAe,SAAoC;AAC/E,MAAI,MAAM,WAAW;AACnB,WAAO,CAAC;AAEV,QAAM,UAAmB,CAAC;AAE1B,MAAI,QAAQ,kBAAkB,GAAG,CAAC,GAC9B,kBAAkB,GAClB,aAAa,GACb,aAAa,GACb,aAAa,GACb,aAAa,GAKb,eAAe,OACf,gBAAgB;AAEpB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,cAAc,MAAM,CAAC,GACrB,CAAC,UAAU,QAAQ,IAAI,aACvB,iBAAiB,SAAS,QAC1B,iBAAiB,eAAe,QAAQ;AAU9C,YARI,CAAC,mBAAmB,aAAa,eAEnC,MAAM,SAAS,YACf,MAAM,SAAS,YACf,MAAM,aAAa,YACnB,MAAM,aAAa,aAGb,UAAU;AAAA,MAChB,KAAK;AACH,cAAM,MAAM,iBAAiB,IAAI,aACjC,MAAM,WAAW,gBACjB,MAAM,eAAe,gBACrB,gBACE,cAAc,UAAU,GAAG,UAAU,IAAI,WAAW,cAAc,UAAU,UAAU;AACxF;AAAA,MACF,KAAK;AACH,cAAM,WAAW,gBACjB,MAAM,eAAe,gBACrB,MAAM,MAAM,iBAAiB,IAAI,aACjC,gBACE,cAAc,UAAU,GAAG,UAAU,IACrC,cAAc,UAAU,aAAa,cAAc;AACrD;AAAA,MACF,KAAK;AACC,0BAAkB,IAAI,QAAQ,UAAU,mBAAmB,MAAM,WAAW,IAAI,KAElF,MAAM,MAAM,iBAAiB,IAAI,aACjC,MAAM,WAAW,gBACjB,MAAM,WAAW,gBACjB,MAAM,eAAe,gBACrB,MAAM,eAAe,kBACZ,kBAAkB,IAAI,QAAQ,UAEnC,oBACF,WAAW,OAAO,cAAc,OAAO,GACvC,QAAQ,KAAK,KAAK,GAClB,QAAQ,kBAAkB,IAAI,EAAE,GAChC,kBAAkB,GAKlB,eAAe,eACf,aAAa,YACb,aAAa;AAGjB;AAAA,MACF;AACQ,cAAA,IAAI,MAAM,mBAAmB;AAAA,IAAA;AAInC,iBAAa,gBACf,cAAc,gBACd,cAAc,iBAEZ,aAAa,gBACf,cAAc,gBACd,cAAc;AAAA,EAAA;AAKd,SAAA,oBACF,WAAW,OAAO,cAAc,OAAO,GACvC,QAAQ,KAAK,KAAK,IAGb;AACT;AAWgB,SAAA,WAAW,OAAc,MAAc,MAA8B;AACnF,MAAI,KAAK,WAAW;AAClB;AAEE,MAAA,UAAU,KAAK,UAAU,MAAM,QAAQ,MAAM,SAAS,MAAM,OAAO,GACnE,UAAU;AAId,SACE,KAAK,QAAQ,OAAO,MAAM,KAAK,YAAY,OAAO,KAClD,QAAQ,SAAS,WAAW,KAAK,SAAS,KAAK;AAE/C,eAAW,KAAK,QAChB,UAAU,KAAK,UAAU,MAAM,SAAS,SAAS,MAAM,SAAS,MAAM,UAAU,OAAO;AAGzF,aAAW,KAAK;AAKZ,MAAA,cAAc,MAAM,SAAS;AAC7B,iBAAe,KAAK,eAAe,KAAK,WAAW,CAAC,KACtD;AAGF,QAAM,SAAS,KAAK,UAAU,aAAa,MAAM,MAAM;AACnD,YACF,MAAM,MAAM,QAAQ,CAAC,YAAY,MAAM,CAAC;AAG1C,QAAM,eAAe,OAAO,QACtB,mBAAmB,eAAe,MAAM;AAK9C,MAAI,YAAY,MAAM,SAAS,MAAM,UAAU;AAC3C,cAAY,KAAK,UAAU,eAAe,KAAK,SAAS,CAAC,KAC3D;AAGF,QAAM,SAAS,KAAK,UAAU,MAAM,SAAS,MAAM,SAAS,SAAS;AACjE,YACF,MAAM,MAAM,KAAK,CAAC,YAAY,MAAM,CAAC;AAGvC,QAAM,eAAe,OAAO,QACtB,mBAAmB,eAAe,MAAM;AAGxC,QAAA,UAAU,cAChB,MAAM,UAAU,cAChB,MAAM,cAAc,kBACpB,MAAM,cAAc,kBAGpB,MAAM,WAAW,eAAe,cAChC,MAAM,WAAW,eAAe,cAChC,MAAM,eAAe,mBAAmB,kBACxC,MAAM,eAAe,mBAAmB;AAC1C;AChQA,MAAM,cAAc;AASb,SAAS,MAAM,UAA2B;AAC/C,MAAI,CAAC;AACH,WAAO,CAAC;AAGV,QAAM,UAAmB,CACnB,GAAA,QAAQ,SAAS,MAAM;AAAA,CAAI;AAEjC,MAAI,cAAc;AACX,SAAA,cAAc,MAAM,UAAQ;AACjC,UAAM,IAAI,MAAM,WAAW,EAAE,MAAM,WAAW;AAC9C,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,yBAAyB,MAAM,WAAW,CAAC,EAAE;AAGzD,UAAA,QAAQ,kBAAkB,MAAM,EAAE,CAAC,CAAC,GAAG,MAAM,EAAE,CAAC,CAAC,CAAC;AAqCxD,SApCA,QAAQ,KAAK,KAAK,GACd,EAAE,CAAC,MAAM,MACX,MAAM,UACN,MAAM,cACN,MAAM,UAAU,GAChB,MAAM,cAAc,KACX,EAAE,CAAC,MAAM,OAClB,MAAM,UAAU,GAChB,MAAM,cAAc,MAEpB,MAAM,UACN,MAAM,cAEN,MAAM,cAAc,MAAM,EAAE,CAAC,CAAC,GAE9B,MAAM,UAAU,MAAM,cAGpB,EAAE,CAAC,MAAM,MACX,MAAM,UACN,MAAM,cACN,MAAM,UAAU,GAChB,MAAM,cAAc,KACX,EAAE,CAAC,MAAM,OAClB,MAAM,UAAU,GAChB,MAAM,cAAc,MAEpB,MAAM,UACN,MAAM,cAEN,MAAM,cAAc,MAAM,EAAE,CAAC,CAAC,GAE9B,MAAM,UAAU,MAAM,cAExB,eAEO,cAAc,MAAM,UAAQ;AACjC,YAAM,cAAc,MAAM,WAAW,GAC/B,OAAO,YAAY,OAAO,CAAC;AAEjC,UAAI,SAAS;AAEX;AAGF,UAAI,SAAS,IAAI;AAEf;AACA;AAAA,MAAA;AAGE,UAAA;AACA,UAAA;AACF,eAAO,UAAU,YAAY,MAAM,CAAC,CAAC;AAAA,eAE9B,IAAI;AAEX,cAAM,IAAI,MAAM,4BAA4B,WAAW,EAAE;AAAA,MAAA;AAM3D,YAAM,WAAW,eAAe,IAAI,IAAI,KAAK;AAC7C,UAAI,SAAS;AAEL,cAAA,MAAM,KAAK,CAAC,aAAa,IAAI,CAAC,GACpC,MAAM,WAAW;AAAA,eACR,SAAS;AAEZ,cAAA,MAAM,KAAK,CAAC,aAAa,IAAI,CAAC,GACpC,MAAM,WAAW;AAAA,eACR,SAAS;AAEZ,cAAA,MAAM,KAAK,CAAC,YAAY,IAAI,CAAC,GACnC,MAAM,WAAW,UACjB,MAAM,WAAW;AAAA;AAGjB,cAAM,IAAI,MAAM,uBAAuB,IAAI,SAAS,IAAI,EAAE;AAE5D;AAAA,IAAA;AAAA,EACF;AAEK,SAAA;AACT;AAEA,SAAS,MAAM,KAAqB;AAC3B,SAAA,SAAS,KAAK,EAAE;AACzB;AC5GO,SAAS,UAAU,SAA0B;AAClD,SAAO,QAAQ,IAAI,cAAc,EAAE,KAAK,EAAE;AAC5C;AASO,SAAS,eAAe,OAAsB;AACnD,QAAM,EAAC,aAAa,aAAa,YAAY,YAAY,UAAS;AAE9D,MAAA;AACA,kBAAgB,IAClB,UAAU,GAAG,UAAU,OACd,gBAAgB,IACzB,UAAU,GAAG,aAAa,CAAC,KAE3B,UAAU,GAAG,aAAa,CAAC,IAAI,WAAW;AAGxC,MAAA;AACA,kBAAgB,IAClB,UAAU,GAAG,UAAU,OACd,gBAAgB,IACzB,UAAU,GAAG,aAAa,CAAC,KAE3B,UAAU,GAAG,aAAa,CAAC,IAAI,WAAW;AAG5C,QAAM,OAAO,CAAC,OAAO,OAAO,KAAK,OAAO;AAAA,CAAO;AAC3C,MAAA;AAGJ,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAQ,MAAM,CAAC,EAAE,CAAC,GAAG;AAAA,MACnB,KAAK;AACE,aAAA;AACL;AAAA,MACF,KAAK;AACE,aAAA;AACL;AAAA,MACF,KAAK;AACE,aAAA;AACL;AAAA,MACF;AACQ,cAAA,IAAI,MAAM,0BAA0B;AAAA,IAAA;AAEzC,SAAA,IAAI,CAAC,IAAI,GAAG,KAAK,UAAU,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA;AAAA,EAAA;AAG9C,SAAO,KAAK,KAAK,EAAE,EAAE,QAAQ,QAAQ,GAAG;AAC1C;;;;;;;;;;;;;;;"}