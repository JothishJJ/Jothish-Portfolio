{"version":3,"file":"index.js","sources":["../src/addMarkers.ts","../src/mapChildren.ts","../src/Refractor.tsx"],"sourcesContent":["import type {\n  ElementContent,\n  Node,\n  Parent,\n  Element as RefractorElement,\n  Root as RefractorRoot,\n  RootContent,\n  Text,\n} from 'hast'\nimport {filter} from 'unist-util-filter'\nimport {visitParents} from 'unist-util-visit-parents'\n\nimport type {Marker} from './types.js'\n\nexport function addMarkers(\n  ast: RefractorRoot,\n  options: {markers: (Marker | number)[]},\n): RefractorRoot {\n  const markers = options.markers\n    .map((marker) => (typeof marker === 'number' ? {line: marker} : marker))\n    .sort((nodeA, nodeB) => nodeA.line - nodeB.line)\n\n  const numbered = lineNumberify(ast.children).nodes\n  if (markers.length === 0 || numbered.length === 0) {\n    return {...ast, children: numbered}\n  }\n\n  return wrapLines(numbered, markers, options)\n}\n\nfunction lineNumberify(ast: RootContent[], context = {lineNumber: 1}) {\n  const resultNodes: ElementContent[] = []\n  return ast.reduce(\n    (result, node) => {\n      if (node.type === 'doctype') {\n        return result // Doctypes are not relevant for line numbers\n      }\n\n      const lineStart = context.lineNumber\n\n      if (node.type === 'text') {\n        if (node.value.indexOf('\\n') === -1) {\n          setLineInfo(node, lineStart, lineStart)\n          result.nodes.push(node)\n          return result\n        }\n\n        const lines = node.value.split('\\n')\n        for (let i = 0; i < lines.length; i++) {\n          const lineNum = i === 0 ? context.lineNumber : ++context.lineNumber\n          const text: Text = {\n            type: 'text',\n            value: i === lines.length - 1 ? lines[i] : `${lines[i]}\\n`,\n          }\n          const withLineInfo = setLineInfo(text, lineNum, lineNum)\n          result.nodes.push(withLineInfo)\n        }\n\n        result.lineNumber = context.lineNumber\n        return result\n      }\n\n      if (node.type === 'element' && node.children) {\n        const processed = lineNumberify(node.children, context)\n        const firstChild = processed.nodes.find(isElementOrText)\n        const lastChild = processed.nodes.findLast(isElementOrText)\n        setLineInfo(\n          node,\n          firstChild ? getLineStart(firstChild, lineStart) : lineStart,\n          lastChild ? getLineEnd(lastChild, lineStart) : lineStart,\n        )\n        node.children = processed.nodes\n        result.lineNumber = processed.lineNumber\n        result.nodes.push(node)\n        return result\n      }\n\n      result.nodes.push(node)\n      return result\n    },\n    {nodes: resultNodes, lineNumber: context.lineNumber},\n  )\n}\n\nfunction isElementOrText(node: RootContent | Node): node is RefractorElement | Text {\n  return node.type === 'element' || node.type === 'text'\n}\n\nfunction getLineStart(node: Node, fallbackLineStart = 1) {\n  return node.data && typeof node.data.lineStart === 'number'\n    ? node.data.lineStart\n    : fallbackLineStart\n}\n\nfunction getLineEnd(node: Node, fallbackLineEnd = 1) {\n  return node.data && typeof node.data.lineEnd === 'number' ? node.data.lineEnd : fallbackLineEnd\n}\n\nfunction setLineInfo<T extends RefractorElement | Text | Parent>(\n  node: T,\n  lineStart: number,\n  lineEnd: number,\n): T {\n  if (!node.data) {\n    node.data = {}\n  }\n\n  node.data.lineStart = lineStart\n  node.data.lineEnd = lineEnd\n  return node\n}\n\nfunction unwrapLine(markerLine: number, nodes: RootContent[]) {\n  const tree: RefractorRoot = {type: 'root', children: nodes}\n\n  const headMap = new WeakMap()\n  const lineMap = new WeakMap()\n  const tailMap = new WeakMap()\n  const cloned: Node[] = []\n\n  function addCopy(\n    map: WeakMap<object, any>,\n    node: Text,\n    ancestors: Array<RefractorRoot | RefractorElement>,\n  ) {\n    cloned.push(node)\n\n    ancestors.forEach((ancestor) => {\n      if (!map.has(ancestor)) {\n        map.set(ancestor, Object.assign({}, ancestor, {children: []}))\n\n        if (ancestor !== tree) {\n          cloned.push(ancestor)\n        }\n      }\n    })\n\n    let i = ancestors.length\n    while (i--) {\n      const ancestor = map.get(ancestors[i])\n      if (!ancestor || !('children' in ancestor)) {\n        continue\n      }\n\n      const child = ancestors[i + 1]\n      const leaf = map.get(child) || node\n      if (ancestor.children.indexOf(leaf) === -1) {\n        ancestor.children.push(leaf)\n      }\n    }\n  }\n\n  visitParents(tree, (node, ancestors) => {\n    if ('children' in node || !isElementOrText(node)) {\n      return\n    }\n\n    // These nodes are on previous lines, but nested within the same structure\n    if (getLineStart(node) < markerLine) {\n      addCopy(headMap, node, ancestors)\n      return\n    }\n\n    // These nodes are on the target line\n    if (getLineStart(node) === markerLine) {\n      addCopy(lineMap, node, ancestors)\n      return\n    }\n\n    // If we have shared ancestors with some of the cloned elements,\n    // create another tree of the remaining nodes\n    if (getLineEnd(node) > markerLine && cloned.some((clone) => ancestors.includes(clone as any))) {\n      addCopy(tailMap, node, ancestors)\n    }\n  })\n\n  // Get the remaining nodes - the ones who were not part of the same tree\n  const filtered = filter(tree, (node) => cloned.indexOf(node as any) === -1)\n  const getChildren = (map: WeakMap<Node, Parent>) => {\n    const rootNode = map.get(tree)\n    if (!rootNode) {\n      return []\n    }\n\n    visitParents(rootNode, (leaf, ancestors) => {\n      if (isElementOrText(leaf) && 'children' in leaf) {\n        setLineInfo(leaf, 0, 0)\n        return\n      }\n\n      ancestors.forEach((ancestor) => {\n        setLineInfo(\n          ancestor,\n          Math.max(getLineStart(ancestor), getLineStart(leaf)),\n          Math.max(getLineEnd(ancestor), getLineEnd(leaf)),\n        )\n      })\n    })\n\n    return rootNode.children\n  }\n\n  const merged = [\n    ...getChildren(headMap),\n    ...getChildren(lineMap),\n    ...getChildren(tailMap),\n    ...(filtered ? filtered.children : []),\n  ]\n\n  return merged\n}\n\nfunction wrapBatch(\n  children: Array<ElementContent>,\n  marker: Marker,\n  options: {markers: (Marker | number)[]},\n): RefractorElement {\n  const className = marker.className || 'refractor-marker'\n  const baseData: RefractorElement['data'] = {\n    lineStart: marker.line,\n    lineEnd: getLineEnd(children[children.length - 1]),\n    isMarker: true,\n  }\n  return {\n    type: 'element',\n    tagName: 'div',\n    data: marker.component\n      ? {...baseData, component: marker.component, markerProperties: options}\n      : baseData,\n    properties: {className},\n    children,\n  }\n}\n\nfunction wrapLines(\n  treeNodes: RootContent[],\n  markers: Marker[],\n  options: {markers: (Marker | number)[]},\n): RefractorRoot {\n  const ast: Array<RootContent> = markers.reduce(\n    (acc, marker) => unwrapLine(marker.line, acc),\n    treeNodes,\n  )\n  const wrapped: Array<RootContent> = []\n\n  // Note: Markers are already sorted by line number (ascending)\n  let astIndex: number = 0\n  for (let m = 0; m < markers.length; m++) {\n    const marker = markers[m]\n\n    // Start by eating all AST nodes with line numbers up to the given marker\n    for (let node = ast[astIndex]; node && getLineEnd(node) < marker.line; node = ast[++astIndex]) {\n      wrapped.push(node)\n    }\n\n    // Now proceed to find all _contiguous_ nodes on the same line\n    const batch: Array<ElementContent> = []\n    for (\n      let node = ast[astIndex];\n      node && getLineEnd(node) === marker.line;\n      node = ast[++astIndex]\n    ) {\n      if (node.type !== 'doctype') {\n        batch.push(node)\n      }\n    }\n\n    // Now add that batch, if we have anything\n    if (batch.length > 0) {\n      wrapped.push(wrapBatch(batch, marker, options))\n    }\n  }\n\n  // Now add the remaining AST nodes\n  while (astIndex < ast.length) {\n    wrapped.push(ast[astIndex++])\n  }\n\n  return {type: 'root', children: wrapped}\n}\n","import {createElement, type JSXElementConstructor, type ReactElement} from 'react'\nimport {type ElementContent, type RootContent} from 'hast'\nimport type {ReactRefractorMarkerDataWithComponent} from './types.js'\n\n/**\n * @internal\n */\nexport function mapWithDepth(\n  depth: number,\n): (\n  child: ElementContent | RootContent,\n  i: number,\n) => string | ReactElement<unknown, string | JSXElementConstructor<unknown>> | null {\n  return function mapChildrenWithDepth(child: ElementContent | RootContent, i: number) {\n    return mapChild(child, i, depth)\n  }\n}\n\nfunction mapChild(\n  child: ElementContent | RootContent,\n  i: number,\n  depth: number,\n): string | ReactElement | null {\n  if (child.type === 'doctype') {\n    return null\n  }\n\n  if (!('tagName' in child)) {\n    return child.value\n  }\n\n  let className = ''\n  if (typeof child.properties !== 'undefined') {\n    className = Array.isArray(child.properties.className)\n      ? child.properties.className.join(' ')\n      : `${child.properties.className}`\n  }\n\n  const key = `fract-${depth}-${i}`\n  const children = child.children && child.children.map(mapWithDepth(depth + 1))\n\n  if (!isReactRefractorMarkerDataWithComponent(child.data)) {\n    return createElement(child.tagName, {key, className}, children)\n  }\n\n  return createElement(\n    child.data.component,\n    {key, ...child.properties, ...child.data.markerProperties, className},\n    children,\n  )\n}\n\nfunction isReactRefractorMarkerDataWithComponent(\n  data: unknown,\n): data is ReactRefractorMarkerDataWithComponent {\n  return (\n    typeof data === 'object' && data !== null && 'component' in data && 'markerProperties' in data\n  )\n}\n","import type {HTMLAttributes} from 'react'\nimport type {Syntax} from 'refractor'\nimport {refractor as fract} from 'refractor/core'\nimport {addMarkers} from './addMarkers.js'\nimport {mapWithDepth} from './mapChildren.js'\nimport type {RefractorProps} from './types.js'\n\nconst DEFAULT_CLASSNAME = 'refractor'\n\n/**\n * @public\n */\nexport function Refractor(props: RefractorProps) {\n  const className = props.className || DEFAULT_CLASSNAME\n  const langClassName = `language-${props.language}`\n  const codeProps: HTMLAttributes<HTMLElement> = {className: langClassName}\n  const preClass = [className, langClassName].filter(Boolean).join(' ')\n\n  if (props.inline) {\n    codeProps.style = {display: 'inline'}\n    codeProps.className = className\n  }\n\n  if (props.plainText) {\n    const code = <code {...codeProps}>{props.value}</code>\n    return props.inline ? code : <pre className={preClass}>{code}</pre>\n  }\n\n  let ast = fract.highlight(props.value, props.language)\n  if (props.markers && props.markers.length > 0) {\n    ast = addMarkers(ast, {markers: props.markers})\n  }\n\n  const value = ast.children.length === 0 ? props.value : ast.children.map(mapWithDepth(0))\n\n  const code = <code {...codeProps}>{value}</code>\n  return props.inline ? code : <pre className={preClass}>{code}</pre>\n}\n\n/**\n * @public\n */\nexport const registerLanguage = (lang: Syntax) => fract.register(lang)\n\n/**\n * @public\n */\nexport const hasLanguage = (lang: string) => fract.registered(lang)\n"],"names":["__spreadProps","__spreadValues","code","fract"],"mappings":"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"}