import { isHTMLElement, isHTMLAnchorElement, isHTMLInputElement, isHTMLButtonElement, isHTMLSelectElement, isHTMLTextAreaElement, _getArrayProp, EMPTY_ARRAY, useElementSize, Code, Box, _isEnterToClickElement, EMPTY_RECORD, Card, Text, Button, Stack, Popover, TextInput, useClickOutsideEvent, _responsive, createGlobalScopedContext, Container, Flex, usePortal, useBoundaryElement, useLayer, useGlobalKeyDown, useTheme_v2, usePrefersReducedMotion, Portal, containsOrEqualsElement, Layer, responsivePaddingStyle, responsiveRadiusStyle, Grid, LayerProvider, isRecord, _cardColorStyle, rem } from "./_chunks-es/_visual-editing.mjs";
import { Arrow, Avatar, AvatarCounter, AvatarStack, Badge, BoundaryElementProvider, Checkbox, ConditionalWrapper, ElementQuery, Heading, Hotkeys, Inline, KBD, Label, Menu, MenuDivider, MenuGroup, MenuItem, PortalProvider, Radio, Select, Spinner, SrOnly, Switch, Tab, TabList, TextArea, ThemeColorProvider, ThemeProvider, Tooltip, TooltipDelayGroupContext, TooltipDelayGroupProvider, VirtualList, _ResizeObserver, _elementSizeObserver, _fillCSSObject, _getResponsiveSpace, _isScrollable, createColorTheme, hexToRgb, hslToRgb, multiply, parseColor, responsiveCodeFontStyle, responsiveHeadingFont, responsiveLabelFont, responsiveTextAlignStyle, responsiveTextFont, rgbToHex, rgbToHsl, rgba, screen, studioTheme, useCustomValidity, useMatchMedia, useMediaIndex, usePrefersDark, useRootTheme, useTheme, useTooltipDelayGroup } from "./_chunks-es/_visual-editing.mjs";
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { SpinnerIcon, ChevronDownIcon, CloseIcon, ToggleArrowRightIcon } from "@sanity/icons";
import { useState, useRef, useEffect, useImperativeHandle, Component, forwardRef, useReducer, startTransition, cloneElement, Children, isValidElement, Fragment, useContext, useSyncExternalStore, useId } from "react";
import { styled, keyframes, css } from "styled-components";
import { getTheme_v2 } from "@sanity/ui/theme";
import { motion, AnimatePresence } from "framer-motion";
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    innerDispose && innerDispose(), outerDispose();
  };
}
function _hasFocus(element) {
  return !!document.activeElement && element.contains(document.activeElement);
}
function isFocusable(element) {
  return element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null ? !0 : isHTMLAnchorElement(element) ? !!element.href && element.rel !== "ignore" : isHTMLInputElement(element) ? element.type !== "hidden" && element.type !== "file" && !element.disabled : isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element) ? !element.disabled : !1;
}
function attemptFocus(element) {
  if (!isFocusable(element))
    return !1;
  try {
    element.focus();
  } catch {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child)))
      return !0;
  }
  return !1;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child)))
      return !0;
  }
  return !1;
}
function useArrayProp(val, defaultVal) {
  const $ = c(3);
  let t0;
  return $[0] !== defaultVal || $[1] !== val ? (t0 = _getArrayProp(val, defaultVal), $[0] = defaultVal, $[1] = val, $[2] = t0) : t0 = $[2], t0;
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg)
    Array.isArray(el) ? ret.push(...el) : ret.push(el);
  return ret.filter(Boolean);
}
function useClickOutside(listener, t0, boundaryElement) {
  const $ = c(12), elementsArg = t0 === void 0 ? EMPTY_ARRAY : t0, [element, setElement] = useState(null);
  let t1;
  $[0] !== element || $[1] !== elementsArg ? (t1 = () => _getElements(element, elementsArg), $[0] = element, $[1] = elementsArg, $[2] = t1) : t1 = $[2];
  const [elements, setElements] = useState(t1), elementsRef = useRef(elements);
  let t2, t3;
  $[3] !== element || $[4] !== elementsArg ? (t2 = () => {
    const prevElements = elementsRef.current, nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements), elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements)
      if (!nextElements.includes(el)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
    for (const el_0 of nextElements)
      if (!prevElements.includes(el_0)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
  }, t3 = [element, elementsArg], $[3] = element, $[4] = elementsArg, $[5] = t2, $[6] = t3) : (t2 = $[5], t3 = $[6]), useEffect(t2, t3);
  let t4, t5;
  return $[7] !== boundaryElement || $[8] !== elements || $[9] !== listener ? (t4 = () => {
    if (!listener)
      return;
    const handleWindowMouseDown = (evt) => {
      const target = evt.target;
      if (target instanceof Node && !(boundaryElement && !boundaryElement.contains(target))) {
        for (const el_1 of elements)
          if (target === el_1 || el_1.contains(target))
            return;
        listener(evt);
      }
    };
    return window.addEventListener("mousedown", handleWindowMouseDown), () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, t5 = [boundaryElement, listener, elements], $[7] = boundaryElement, $[8] = elements, $[9] = listener, $[10] = t4, $[11] = t5) : (t4 = $[10], t5 = $[11]), useEffect(t4, t5), setElement;
}
function useElementRect(element) {
  return useElementSize(element)?._contentRect || null;
}
function useForwardedRef(ref) {
  const $ = c(1), innerRef = useRef(null);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => innerRef.current, $[0] = t0) : t0 = $[0], useImperativeHandle(ref, t0), innerRef;
}
class ErrorBoundary extends Component {
  state = {
    error: null
  };
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({
      error,
      info
    });
  }
  render() {
    const {
      error
    } = this.state;
    if (error) {
      const message = typeof error?.message == "string" ? error.message : "Error";
      return /* @__PURE__ */ jsx(Code, { children: message });
    }
    return this.props.children;
  }
}
const StyledAutocomplete = styled.div.withConfig({
  displayName: "StyledAutocomplete",
  componentId: "sc-1igauft-0"
})`line-height:0;`, ListBox = styled(Box).withConfig({
  displayName: "ListBox",
  componentId: "sc-1igauft-1"
})`& > ul{list-style:none;padding:0;margin:0;}`, rotate = keyframes`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styled(SpinnerIcon).withConfig({
  displayName: "AnimatedSpinnerIcon",
  componentId: "sc-1igauft-2"
})`animation:${rotate} 500ms linear infinite;`;
function AutocompleteOption(props) {
  const $ = c(11), {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  let t0;
  $[0] !== onSelect || $[1] !== value ? (t0 = () => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, $[0] = onSelect, $[1] = value, $[2] = t0) : t0 = $[2];
  const handleClick = t0;
  let t1;
  $[3] !== handleClick ? (t1 = (event) => {
    event.key === "Enter" && !_isEnterToClickElement(event.currentTarget) && handleClick();
  }, $[3] = handleClick, $[4] = t1) : t1 = $[4];
  const handleKeyDown = t1;
  let t2;
  return $[5] !== children || $[6] !== handleClick || $[7] !== handleKeyDown || $[8] !== id || $[9] !== selected ? (t2 = /* @__PURE__ */ jsx("li", { "aria-selected": selected, "data-ui": "AutocompleteOption", id, role: "option", onClick: handleClick, onKeyDown: handleKeyDown, children }), $[5] = children, $[6] = handleClick, $[7] = handleKeyDown, $[8] = id, $[9] = selected, $[10] = t2) : t2 = $[10], t2;
}
function autocompleteReducer(state, msg) {
  return msg.type === "input/change" ? {
    ...state,
    activeValue: null,
    focused: !0,
    query: msg.query
  } : msg.type === "input/focus" ? {
    ...state,
    focused: !0
  } : msg.type === "root/blur" ? {
    ...state,
    focused: !1,
    query: null
  } : msg.type === "root/clear" ? {
    ...state,
    activeValue: null,
    query: null,
    value: null
  } : msg.type === "root/escape" ? {
    ...state,
    focused: !1,
    query: null
  } : msg.type === "root/open" ? {
    ...state,
    query: state.query || msg.query
  } : msg.type === "root/setActiveValue" ? {
    ...state,
    activeValue: msg.value,
    listFocused: msg.listFocused || state.listFocused
  } : msg.type === "root/setListFocused" ? {
    ...state,
    listFocused: msg.listFocused
  } : msg.type === "value/change" ? {
    ...state,
    activeValue: msg.value,
    query: null,
    value: msg.value
  } : state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"], AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start", AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"], DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value, DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1, InnerAutocomplete = forwardRef(function(props, forwardedRef) {
  const $ = c(181);
  let customValidity, disabled, filterOptionProp, icon, id, loading, onBlur, onChange, onFocus, onQueryChange, onSelect, openButton, openOnFocus, optionsProp, prefix, readOnly, relatedElements, renderOptionProp, renderPopover, restProps, suffix, t0, t1, t2, t3, t4, t5, t6, valueProp;
  $[0] !== props ? ({
    border: t0,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: t1,
    icon,
    id,
    listBox: t2,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    openOnFocus,
    options: optionsProp,
    padding: t3,
    popover: t4,
    prefix,
    radius: t5,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue: t6,
    suffix,
    value: valueProp,
    ...restProps
  } = props, $[0] = props, $[1] = customValidity, $[2] = disabled, $[3] = filterOptionProp, $[4] = icon, $[5] = id, $[6] = loading, $[7] = onBlur, $[8] = onChange, $[9] = onFocus, $[10] = onQueryChange, $[11] = onSelect, $[12] = openButton, $[13] = openOnFocus, $[14] = optionsProp, $[15] = prefix, $[16] = readOnly, $[17] = relatedElements, $[18] = renderOptionProp, $[19] = renderPopover, $[20] = restProps, $[21] = suffix, $[22] = t0, $[23] = t1, $[24] = t2, $[25] = t3, $[26] = t4, $[27] = t5, $[28] = t6, $[29] = valueProp) : (customValidity = $[1], disabled = $[2], filterOptionProp = $[3], icon = $[4], id = $[5], loading = $[6], onBlur = $[7], onChange = $[8], onFocus = $[9], onQueryChange = $[10], onSelect = $[11], openButton = $[12], openOnFocus = $[13], optionsProp = $[14], prefix = $[15], readOnly = $[16], relatedElements = $[17], renderOptionProp = $[18], renderPopover = $[19], restProps = $[20], suffix = $[21], t0 = $[22], t1 = $[23], t2 = $[24], t3 = $[25], t4 = $[26], t5 = $[27], t6 = $[28], valueProp = $[29]);
  const border = t0 === void 0 ? !0 : t0, fontSize = t1 === void 0 ? 2 : t1, listBox = t2 === void 0 ? EMPTY_RECORD : t2, paddingProp = t3 === void 0 ? 3 : t3, popover = t4 === void 0 ? EMPTY_RECORD : t4, radius = t5 === void 0 ? 2 : t5, renderValue = t6 === void 0 ? DEFAULT_RENDER_VALUE : t6, t7 = valueProp || null, t8 = valueProp || null;
  let t9;
  $[30] !== t7 || $[31] !== t8 ? (t9 = {
    activeValue: t7,
    focused: !1,
    listFocused: !1,
    query: null,
    value: t8
  }, $[30] = t7, $[31] = t8, $[32] = t9) : t9 = $[32];
  const [state, dispatch] = useReducer(autocompleteReducer, t9), {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state;
  let t10;
  $[33] !== fontSize || $[34] !== paddingProp ? (t10 = (t112) => {
    const {
      value: value_0
    } = t112;
    return /* @__PURE__ */ jsx(Card, { "data-as": "button", padding: paddingProp, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsx(Text, { size: fontSize, textOverflow: "ellipsis", children: value_0 }) });
  }, $[33] = fontSize, $[34] = paddingProp, $[35] = t10) : t10 = $[35];
  const renderOption = typeof renderOptionProp == "function" ? renderOptionProp : t10, filterOption = typeof filterOptionProp == "function" ? filterOptionProp : DEFAULT_FILTER_OPTION, rootElementRef = useRef(null), resultsPopoverElementRef = useRef(null), inputElementRef = useRef(null), listBoxElementRef = useRef(null), [inputElement, _setInputElement] = useState(null);
  let t11;
  $[36] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (node) => {
    startTransition(() => _setInputElement(node));
  }, $[36] = t11) : t11 = $[36];
  const setInputElement = t11, listFocusedRef = useRef(!1), valueRef = useRef(value), valuePropRef = useRef(valueProp), popoverMouseWithinRef = useRef(!1);
  let t12, t13;
  $[37] !== inputElement ? (t12 = () => inputElement, t13 = [inputElement], $[37] = inputElement, $[38] = t12, $[39] = t13) : (t12 = $[38], t13 = $[39]), useImperativeHandle(inputElementRef, t12, t13);
  let t14, t15;
  $[40] !== inputElement ? (t14 = () => inputElement, t15 = [inputElement], $[40] = inputElement, $[41] = t14, $[42] = t15) : (t14 = $[41], t15 = $[42]), useImperativeHandle(forwardedRef, t14, t15);
  const listBoxId = `${id}-listbox`, options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY, padding = _getArrayProp(paddingProp);
  let t16;
  $[43] !== options || $[44] !== value ? (t16 = value !== null ? options.find((o) => o.value === value) : void 0, $[43] = options, $[44] = value, $[45] = t16) : t16 = $[45];
  const currentOption = t16;
  let t17;
  if ($[46] !== filterOption || $[47] !== options || $[48] !== query) {
    let t182;
    $[50] !== filterOption || $[51] !== query ? (t182 = (option) => query ? filterOption(query, option) : !0, $[50] = filterOption, $[51] = query, $[52] = t182) : t182 = $[52], t17 = options.filter(t182), $[46] = filterOption, $[47] = options, $[48] = query, $[49] = t17;
  } else
    t17 = $[49];
  const filteredOptions = t17, filteredOptionsLen = filteredOptions.length, activeItemId = activeValue ? `${id}-option-${activeValue}` : void 0, expanded = query !== null && loading || focused && query !== null;
  let t18;
  $[53] !== onBlur || $[54] !== onQueryChange || $[55] !== relatedElements ? (t18 = (event) => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current)
        return;
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = !1;
      if (document.activeElement) {
        for (const e of elements)
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = !0;
            break;
          }
      }
      focusInside === !1 && (dispatch({
        type: "root/blur"
      }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), onBlur && onBlur(event));
    }, 0);
  }, $[53] = onBlur, $[54] = onQueryChange, $[55] = relatedElements, $[56] = t18) : t18 = $[56];
  const handleRootBlur = t18;
  let t19;
  $[57] === Symbol.for("react.memo_cache_sentinel") ? (t19 = (event_0) => {
    const listBoxElement = listBoxElementRef.current, focusedElement = event_0.target instanceof HTMLElement ? event_0.target : null, listFocused_0 = listBoxElement?.contains(focusedElement) || !1;
    listFocused_0 !== listFocusedRef.current && (listFocusedRef.current = listFocused_0, dispatch({
      type: "root/setListFocused",
      listFocused: listFocused_0
    }));
  }, $[57] = t19) : t19 = $[57];
  const handleRootFocus = t19;
  let t20;
  $[58] !== onChange || $[59] !== onQueryChange || $[60] !== onSelect ? (t20 = (v) => {
    dispatch({
      type: "value/change",
      value: v
    }), popoverMouseWithinRef.current = !1, onSelect && onSelect(v), valueRef.current = v, onChange && onChange(v), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, $[58] = onChange, $[59] = onQueryChange, $[60] = onSelect, $[61] = t20) : t20 = $[61];
  const handleOptionSelect = t20;
  let t21;
  $[62] !== activeValue || $[63] !== filteredOptions || $[64] !== filteredOptionsLen || $[65] !== onQueryChange ? (t21 = (event_1) => {
    if (event_1.key === "ArrowDown") {
      if (event_1.preventDefault(), !filteredOptionsLen)
        return;
      const activeOption = filteredOptions.find((o_0) => o_0.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      nextActiveOption && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption.value,
        listFocused: !0
      });
      return;
    }
    if (event_1.key === "ArrowUp") {
      if (event_1.preventDefault(), !filteredOptionsLen)
        return;
      const activeOption_0 = filteredOptions.find((o_1) => o_1.value === activeValue), activeIndex_0 = activeOption_0 ? filteredOptions.indexOf(activeOption_0) : -1, nextActiveOption_0 = filteredOptions[activeIndex_0 === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex_0 - 1) % filteredOptionsLen];
      nextActiveOption_0 && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption_0.value,
        listFocused: !0
      });
      return;
    }
    if (event_1.key === "Escape") {
      dispatch({
        type: "root/escape"
      }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
      return;
    }
    const target = event_1.target, listEl = listBoxElementRef.current;
    if ((listEl === target || listEl?.contains(target)) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event_1.key)) {
      inputElementRef.current?.focus();
      return;
    }
  }, $[62] = activeValue, $[63] = filteredOptions, $[64] = filteredOptionsLen, $[65] = onQueryChange, $[66] = t21) : t21 = $[66];
  const handleRootKeyDown = t21;
  let t22;
  $[67] !== onQueryChange ? (t22 = (event_2) => {
    const nextQuery = event_2.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    }), onQueryChange && onQueryChange(nextQuery);
  }, $[67] = onQueryChange, $[68] = t22) : t22 = $[68];
  const handleInputChange = t22;
  let t23;
  $[69] !== currentOption || $[70] !== renderValue || $[71] !== value ? (t23 = () => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
  }, $[69] = currentOption, $[70] = renderValue, $[71] = value, $[72] = t23) : t23 = $[72];
  const dispatchOpen = t23;
  let t24;
  $[73] !== dispatchOpen || $[74] !== focused || $[75] !== onFocus || $[76] !== openOnFocus ? (t24 = (event_3) => {
    focused || (dispatch({
      type: "input/focus"
    }), onFocus && onFocus(event_3), openOnFocus && dispatchOpen());
  }, $[73] = dispatchOpen, $[74] = focused, $[75] = onFocus, $[76] = openOnFocus, $[77] = t24) : t24 = $[77];
  const handleInputFocus = t24;
  let t25;
  $[78] === Symbol.for("react.memo_cache_sentinel") ? (t25 = () => {
    popoverMouseWithinRef.current = !0;
  }, $[78] = t25) : t25 = $[78];
  const handlePopoverMouseEnter = t25;
  let t26;
  $[79] === Symbol.for("react.memo_cache_sentinel") ? (t26 = () => {
    popoverMouseWithinRef.current = !1;
  }, $[79] = t26) : t26 = $[79];
  const handlePopoverMouseLeave = t26;
  let t27;
  $[80] !== onChange || $[81] !== onQueryChange ? (t27 = () => {
    dispatch({
      type: "root/clear"
    }), valueRef.current = "", onChange && onChange(""), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, $[80] = onChange, $[81] = onQueryChange, $[82] = t27) : t27 = $[82];
  const handleClearButtonClick = t27;
  let t28;
  $[83] === Symbol.for("react.memo_cache_sentinel") ? (t28 = () => {
    dispatch({
      type: "input/focus"
    });
  }, $[83] = t28) : t28 = $[83];
  const handleClearButtonFocus = t28;
  let t29, t30;
  $[84] !== valueProp ? (t29 = () => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp, valueProp !== void 0 && (dispatch({
        type: "value/change",
        value: valueProp
      }), valueRef.current = valueProp);
      return;
    }
    valueProp !== valueRef.current && (valueRef.current = valueProp || null, dispatch({
      type: "value/change",
      value: valueProp || null
    }));
  }, t30 = [valueProp], $[84] = valueProp, $[85] = t29, $[86] = t30) : (t29 = $[85], t30 = $[86]), useEffect(t29, t30);
  let t31, t32;
  $[87] !== focused ? (t31 = () => {
    !focused && valueRef.current && dispatch({
      type: "root/setActiveValue",
      value: valueRef.current
    });
  }, t32 = [focused], $[87] = focused, $[88] = t31, $[89] = t32) : (t31 = $[88], t32 = $[89]), useEffect(t31, t32);
  let t33, t34;
  $[90] !== activeValue || $[91] !== filteredOptions ? (t33 = () => {
    const listElement = listBoxElementRef.current;
    if (!listElement)
      return;
    const activeOption_1 = filteredOptions.find((o_2) => o_2.value === activeValue);
    if (activeOption_1) {
      const activeIndex_1 = filteredOptions.indexOf(activeOption_1), activeItemElement = listElement.childNodes[activeIndex_1];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement))
          return;
        focusFirstDescendant(activeItemElement);
      }
    }
  }, t34 = [activeValue, filteredOptions], $[90] = activeValue, $[91] = filteredOptions, $[92] = t33, $[93] = t34) : (t33 = $[92], t34 = $[93]), useEffect(t33, t34);
  let t35;
  bb0: {
    if (!loading && !disabled && value) {
      let t362;
      $[94] === Symbol.for("react.memo_cache_sentinel") ? (t362 = {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      }, $[94] = t362) : t362 = $[94], t35 = t362;
      break bb0;
    }
    t35 = void 0;
  }
  const clearButton = t35, openButtonBoxPadding = padding.map(_temp$3), openButtonPadding = padding.map(_temp2$1), openButtonProps = typeof openButton == "object" ? openButton : EMPTY_RECORD;
  let t36;
  $[95] !== dispatchOpen || $[96] !== openButtonProps ? (t36 = (event_4) => {
    dispatchOpen(), openButtonProps.onClick && openButtonProps.onClick(event_4), _raf(() => inputElementRef.current?.focus());
  }, $[95] = dispatchOpen, $[96] = openButtonProps, $[97] = t36) : t36 = $[97];
  const handleOpenClick = t36;
  let t37;
  $[98] !== disabled || $[99] !== expanded || $[100] !== fontSize || $[101] !== handleOpenClick || $[102] !== openButton || $[103] !== openButtonBoxPadding || $[104] !== openButtonPadding || $[105] !== openButtonProps || $[106] !== readOnly ? (t37 = !disabled && !readOnly && openButton ? /* @__PURE__ */ jsx(Box, { "aria-hidden": expanded, padding: openButtonBoxPadding, children: /* @__PURE__ */ jsx(Button, { "aria-label": "Open", disabled: expanded, fontSize, icon: ChevronDownIcon, mode: "bleed", padding: openButtonPadding, ...openButtonProps, onClick: handleOpenClick }) }) : void 0, $[98] = disabled, $[99] = expanded, $[100] = fontSize, $[101] = handleOpenClick, $[102] = openButton, $[103] = openButtonBoxPadding, $[104] = openButtonPadding, $[105] = openButtonProps, $[106] = readOnly, $[107] = t37) : t37 = $[107];
  const openButtonNode = t37;
  let t38;
  bb1: {
    if (query === null) {
      if (value !== null) {
        let t392;
        $[108] !== currentOption || $[109] !== renderValue || $[110] !== value ? (t392 = renderValue(value, currentOption), $[108] = currentOption, $[109] = renderValue, $[110] = value, $[111] = t392) : t392 = $[111], t38 = t392;
        break bb1;
      }
      t38 = "";
      break bb1;
    }
    t38 = query;
  }
  const inputValue = t38;
  let t39;
  $[112] !== listFocused ? (t39 = (event_5) => {
    event_5.key === "Tab" && listFocused && inputElementRef.current?.focus();
  }, $[112] = listFocused, $[113] = t39) : t39 = $[113];
  const handleListBoxKeyDown = t39;
  let t40;
  bb2: {
    if (filteredOptions.length === 0) {
      t40 = null;
      break bb2;
    }
    let t412;
    if ($[114] !== activeValue || $[115] !== currentOption || $[116] !== filteredOptions || $[117] !== handleOptionSelect || $[118] !== id || $[119] !== listFocused || $[120] !== loading || $[121] !== renderOption) {
      let t423;
      $[123] !== activeValue || $[124] !== currentOption || $[125] !== handleOptionSelect || $[126] !== id || $[127] !== listFocused || $[128] !== loading || $[129] !== renderOption ? (t423 = (option_0) => {
        const active = activeValue !== null ? option_0.value === activeValue : currentOption === option_0;
        return /* @__PURE__ */ jsx(AutocompleteOption, { id: `${id}-option-${option_0.value}`, onSelect: handleOptionSelect, selected: active, value: option_0.value, children: cloneElement(renderOption(option_0), {
          disabled: loading,
          selected: active,
          tabIndex: listFocused && active ? 0 : -1
        }) }, option_0.value);
      }, $[123] = activeValue, $[124] = currentOption, $[125] = handleOptionSelect, $[126] = id, $[127] = listFocused, $[128] = loading, $[129] = renderOption, $[130] = t423) : t423 = $[130], t412 = filteredOptions.map(t423), $[114] = activeValue, $[115] = currentOption, $[116] = filteredOptions, $[117] = handleOptionSelect, $[118] = id, $[119] = listFocused, $[120] = loading, $[121] = renderOption, $[122] = t412;
    } else
      t412 = $[122];
    let t422;
    $[131] !== listBoxId || $[132] !== t412 ? (t422 = /* @__PURE__ */ jsx(Stack, { as: "ul", "aria-multiselectable": !1, "data-ui": "AutoComplete__resultsList", id: listBoxId, ref: listBoxElementRef, role: "listbox", space: 1, children: t412 }), $[131] = listBoxId, $[132] = t412, $[133] = t422) : t422 = $[133];
    let t432;
    $[134] !== handleListBoxKeyDown || $[135] !== listBox || $[136] !== t422 ? (t432 = /* @__PURE__ */ jsx(ListBox, { "data-ui": "AutoComplete__results", onKeyDown: handleListBoxKeyDown, padding: 1, ...listBox, tabIndex: -1, children: t422 }), $[134] = handleListBoxKeyDown, $[135] = listBox, $[136] = t422, $[137] = t432) : t432 = $[137], t40 = t432;
  }
  const content2 = t40;
  let t41;
  bb3: {
    if (renderPopover) {
      const t423 = !expanded;
      let t432;
      $[138] !== content2 || $[139] !== handlePopoverMouseEnter || $[140] !== handlePopoverMouseLeave || $[141] !== inputElement || $[142] !== renderPopover || $[143] !== t423 ? (t432 = /* @__PURE__ */ jsx(RenderPopover, { content: content2, hidden: t423, inputElement, onMouseEnter: handlePopoverMouseEnter, onMouseLeave: handlePopoverMouseLeave, resultsPopoverElementRef, renderPopover }), $[138] = content2, $[139] = handlePopoverMouseEnter, $[140] = handlePopoverMouseLeave, $[141] = inputElement, $[142] = renderPopover, $[143] = t423, $[144] = t432) : t432 = $[144], t41 = t432;
      break bb3;
    }
    if (filteredOptionsLen === 0) {
      t41 = null;
      break bb3;
    }
    let t422;
    $[145] !== content2 || $[146] !== expanded || $[147] !== handlePopoverMouseEnter || $[148] !== handlePopoverMouseLeave || $[149] !== inputElement || $[150] !== popover || $[151] !== radius ? (t422 = /* @__PURE__ */ jsx(Popover, { arrow: !1, constrainSize: !0, content: content2, fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS, matchReferenceWidth: !0, onMouseEnter: handlePopoverMouseEnter, onMouseLeave: handlePopoverMouseLeave, open: expanded, overflow: "auto", placement: AUTOCOMPLETE_POPOVER_PLACEMENT, portal: !0, radius, ref: resultsPopoverElementRef, referenceElement: inputElement, ...popover }), $[145] = content2, $[146] = expanded, $[147] = handlePopoverMouseEnter, $[148] = handlePopoverMouseLeave, $[149] = inputElement, $[150] = popover, $[151] = radius, $[152] = t422) : t422 = $[152], t41 = t422;
  }
  const results = t41, t42 = loading && AnimatedSpinnerIcon, t43 = suffix || openButtonNode;
  let t44;
  $[153] !== activeItemId || $[154] !== border || $[155] !== clearButton || $[156] !== customValidity || $[157] !== disabled || $[158] !== expanded || $[159] !== fontSize || $[160] !== handleClearButtonClick || $[161] !== handleInputChange || $[162] !== handleInputFocus || $[163] !== icon || $[164] !== id || $[165] !== inputValue || $[166] !== listBoxId || $[167] !== padding || $[168] !== prefix || $[169] !== radius || $[170] !== readOnly || $[171] !== restProps || $[172] !== t42 || $[173] !== t43 ? (t44 = /* @__PURE__ */ jsx(TextInput, { ...restProps, "aria-activedescendant": activeItemId, "aria-autocomplete": "list", "aria-expanded": expanded, "aria-owns": listBoxId, autoCapitalize: "off", autoComplete: "off", autoCorrect: "off", border, clearButton, customValidity, disabled, fontSize, icon, iconRight: t42, id, inputMode: "search", onChange: handleInputChange, onClear: handleClearButtonClick, onFocus: handleInputFocus, padding, prefix, radius, readOnly, ref: setInputElement, role: "combobox", spellCheck: !1, suffix: t43, value: inputValue }), $[153] = activeItemId, $[154] = border, $[155] = clearButton, $[156] = customValidity, $[157] = disabled, $[158] = expanded, $[159] = fontSize, $[160] = handleClearButtonClick, $[161] = handleInputChange, $[162] = handleInputFocus, $[163] = icon, $[164] = id, $[165] = inputValue, $[166] = listBoxId, $[167] = padding, $[168] = prefix, $[169] = radius, $[170] = readOnly, $[171] = restProps, $[172] = t42, $[173] = t43, $[174] = t44) : t44 = $[174];
  let t45;
  return $[175] !== handleRootBlur || $[176] !== handleRootFocus || $[177] !== handleRootKeyDown || $[178] !== results || $[179] !== t44 ? (t45 = /* @__PURE__ */ jsxs(StyledAutocomplete, { "data-ui": "Autocomplete", onBlur: handleRootBlur, onFocus: handleRootFocus, onKeyDown: handleRootKeyDown, ref: rootElementRef, children: [
    t44,
    results
  ] }), $[175] = handleRootBlur, $[176] = handleRootFocus, $[177] = handleRootKeyDown, $[178] = results, $[179] = t44, $[180] = t45) : t45 = $[180], t45;
});
function RenderPopover({
  renderPopover,
  content: content2,
  hidden,
  inputElement,
  onMouseEnter,
  onMouseLeave,
  resultsPopoverElementRef
}) {
  return renderPopover({
    content: content2,
    hidden,
    inputElement,
    onMouseEnter,
    onMouseLeave
  }, resultsPopoverElementRef);
}
InnerAutocomplete.displayName = "ForwardRef(Autocomplete)";
const Autocomplete = InnerAutocomplete;
function _temp$3(v_0) {
  return v_0 === 0 ? 0 : v_0 === 1 || v_0 === 2 ? 1 : v_0 - 2;
}
function _temp2$1(v_1) {
  return Math.max(v_1 - 1, 0);
}
const StyledBreadcrumbs = styled.ol.withConfig({
  displayName: "StyledBreadcrumbs",
  componentId: "sc-1es8h8q-0"
})`margin:0;padding:0;display:flex;list-style:none;align-items:center;white-space:nowrap;line-height:0;`, ExpandButton = styled(Button).withConfig({
  displayName: "ExpandButton",
  componentId: "sc-1es8h8q-1"
})`appearance:none;margin:-4px;`, Breadcrumbs = forwardRef(function(props, ref) {
  const $ = c(29);
  let children, maxLength, restProps, separator, t0;
  $[0] !== props ? ({
    children,
    maxLength,
    separator,
    space: t0,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = maxLength, $[3] = restProps, $[4] = separator, $[5] = t0) : (children = $[1], maxLength = $[2], restProps = $[3], separator = $[4], t0 = $[5]);
  const spaceRaw = t0 === void 0 ? 2 : t0;
  let t1;
  $[6] !== spaceRaw ? (t1 = _getArrayProp(spaceRaw), $[6] = spaceRaw, $[7] = t1) : t1 = $[7];
  const space = t1, [open, setOpen] = useState(!1), expandElementRef = useRef(null), popoverElementRef = useRef(null);
  let t2;
  $[8] === Symbol.for("react.memo_cache_sentinel") ? (t2 = () => setOpen(!1), $[8] = t2) : t2 = $[8];
  const collapse = t2;
  let t3;
  $[9] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => setOpen(!0), $[9] = t3) : t3 = $[9];
  const expand = t3;
  let t4;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => [expandElementRef.current, popoverElementRef.current], $[10] = t4) : t4 = $[10], useClickOutsideEvent(collapse, t4);
  let t5;
  $[11] !== children ? (t5 = Children.toArray(children).filter(isValidElement), $[11] = children, $[12] = t5) : t5 = $[12];
  const rawItems = t5;
  let t6;
  $[13] !== maxLength || $[14] !== open || $[15] !== rawItems || $[16] !== space ? (t6 = {
    collapse,
    expand,
    expandElementRef,
    maxLength,
    open,
    popoverElementRef,
    rawItems,
    space
  }, $[13] = maxLength, $[14] = open, $[15] = rawItems, $[16] = space, $[17] = t6) : t6 = $[17];
  const items = useItems(t6);
  let t7;
  if ($[18] !== items || $[19] !== separator || $[20] !== space) {
    let t82;
    $[22] !== separator || $[23] !== space ? (t82 = (item, itemIndex) => /* @__PURE__ */ jsxs(Fragment, { children: [
      itemIndex > 0 && /* @__PURE__ */ jsx(Box, { "aria-hidden": !0, as: "li", paddingX: space, children: separator || /* @__PURE__ */ jsx(Text, { muted: !0, children: "/" }) }),
      /* @__PURE__ */ jsx(Box, { as: "li", children: item })
    ] }, itemIndex), $[22] = separator, $[23] = space, $[24] = t82) : t82 = $[24], t7 = items.map(t82), $[18] = items, $[19] = separator, $[20] = space, $[21] = t7;
  } else
    t7 = $[21];
  let t8;
  return $[25] !== ref || $[26] !== restProps || $[27] !== t7 ? (t8 = /* @__PURE__ */ jsx(StyledBreadcrumbs, { "data-ui": "Breadcrumbs", ...restProps, ref, children: t7 }), $[25] = ref, $[26] = restProps, $[27] = t7, $[28] = t8) : t8 = $[28], t8;
});
Breadcrumbs.displayName = "ForwardRef(Breadcrumbs)";
function useItems(t0) {
  const $ = c(28), {
    collapse,
    expand,
    expandElementRef,
    maxLength,
    open,
    popoverElementRef,
    rawItems,
    space
  } = t0, len = rawItems.length;
  if (maxLength && len > maxLength) {
    const beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
    let t1;
    if ($[0] !== afterLength || $[1] !== beforeLength || $[2] !== collapse || $[3] !== expand || $[4] !== expandElementRef || $[5] !== len || $[6] !== open || $[7] !== popoverElementRef || $[8] !== rawItems || $[9] !== space) {
      const t2 = rawItems.slice(0, beforeLength - 1);
      let t3;
      $[11] !== afterLength || $[12] !== beforeLength || $[13] !== len || $[14] !== rawItems ? (t3 = rawItems.slice(beforeLength - 1, len - afterLength), $[11] = afterLength, $[12] = beforeLength, $[13] = len, $[14] = rawItems, $[15] = t3) : t3 = $[15];
      let t4;
      $[16] !== space || $[17] !== t3 ? (t4 = /* @__PURE__ */ jsx(Stack, { as: "ol", overflow: "auto", padding: space, space, children: t3 }), $[16] = space, $[17] = t3, $[18] = t4) : t4 = $[18];
      const t5 = open ? collapse : expand;
      let t6;
      $[19] !== expandElementRef || $[20] !== open || $[21] !== t5 ? (t6 = /* @__PURE__ */ jsx(ExpandButton, { fontSize: 1, mode: "bleed", onClick: t5, padding: 1, ref: expandElementRef, selected: open, text: "\u2026" }), $[19] = expandElementRef, $[20] = open, $[21] = t5, $[22] = t6) : t6 = $[22];
      let t7;
      $[23] !== open || $[24] !== popoverElementRef || $[25] !== t4 || $[26] !== t6 ? (t7 = /* @__PURE__ */ jsx(Popover, { constrainSize: !0, content: t4, open, placement: "top", portal: !0, ref: popoverElementRef, children: t6 }, "button"), $[23] = open, $[24] = popoverElementRef, $[25] = t4, $[26] = t6, $[27] = t7) : t7 = $[27], t1 = [...t2, t7, ...rawItems.slice(len - afterLength)], $[0] = afterLength, $[1] = beforeLength, $[2] = collapse, $[3] = expand, $[4] = expandElementRef, $[5] = len, $[6] = open, $[7] = popoverElementRef, $[8] = rawItems, $[9] = space, $[10] = t1;
    } else
      t1 = $[10];
    return t1;
  }
  return rawItems;
}
function dialogStyle({
  theme
}) {
  const {
    color
  } = getTheme_v2(theme);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$position, (position) => ({
    "&&": {
      position
    }
  }));
}
function animationDialogStyle(props) {
  return props.$animate ? css`
    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    animation: fadeIn 200ms ease-out;
    // Animates the dialog card.
    & > [data-ui='DialogCard'] {
      animation: zoomIn 200ms ease-out;
    }
  ` : css``;
}
const DialogContext = createGlobalScopedContext("@sanity/ui/context/dialog", {
  version: 0
});
function useDialog() {
  return useContext(DialogContext);
}
function isTargetWithinScope(boundaryElement, portalElement, target) {
  return !boundaryElement || !portalElement ? !0 : containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
const StyledDialog = /* @__PURE__ */ styled(Layer).withConfig({
  displayName: "StyledDialog",
  componentId: "sc-4n4xb3-0"
})(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle), DialogContainer = styled(Container).withConfig({
  displayName: "DialogContainer",
  componentId: "sc-4n4xb3-1"
})`&:not([hidden]){display:flex;}width:100%;height:100%;flex-direction:column;align-items:center;justify-content:center;`, DialogCardRoot = styled(Card).withConfig({
  displayName: "DialogCardRoot",
  componentId: "sc-4n4xb3-2"
})`&:not([hidden]){display:flex;}width:100%;min-height:0;max-height:100%;overflow:hidden;overflow:clip;`, DialogLayout = styled(Flex).withConfig({
  displayName: "DialogLayout",
  componentId: "sc-4n4xb3-3"
})`flex:1;min-height:0;width:100%;`, DialogHeader = styled(Box).withConfig({
  displayName: "DialogHeader",
  componentId: "sc-4n4xb3-4"
})`position:relative;z-index:2;`, DialogContent = styled(Box).withConfig({
  displayName: "DialogContent",
  componentId: "sc-4n4xb3-5"
})`position:relative;z-index:1;overflow:auto;outline:none;`, DialogFooter = styled(Box).withConfig({
  displayName: "DialogFooter",
  componentId: "sc-4n4xb3-6"
})`position:relative;z-index:3;`, DialogCard = forwardRef(function(props, forwardedRef) {
  const $ = c(44), {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef: forwardedContentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props, portal = usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = useBoundaryElement().element;
  let t0;
  $[0] !== radiusProp ? (t0 = _getArrayProp(radiusProp), $[0] = radiusProp, $[1] = t0) : t0 = $[1];
  const radius = t0;
  let t1;
  $[2] !== shadowProp ? (t1 = _getArrayProp(shadowProp), $[2] = shadowProp, $[3] = t1) : t1 = $[3];
  const shadow = t1;
  let t2;
  $[4] !== widthProp ? (t2 = _getArrayProp(widthProp), $[4] = widthProp, $[5] = t2) : t2 = $[5];
  const width = t2, ref = useRef(null), contentRef = useRef(null), layer = useLayer(), {
    isTopLayer
  } = layer, labelId = `${id}_label`, showCloseButton = !!onClose && hideCloseButton === !1, showHeader = !!header || showCloseButton;
  let t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => ref.current, $[6] = t3) : t3 = $[6], useImperativeHandle(forwardedRef, t3);
  let t4;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => contentRef.current, $[7] = t4) : t4 = $[7], useImperativeHandle(forwardedContentRef, t4);
  let t5, t6;
  $[8] !== autoFocus ? (t5 = () => {
    autoFocus && ref.current && focusFirstDescendant(ref.current);
  }, t6 = [autoFocus, ref], $[8] = autoFocus, $[9] = t5, $[10] = t6) : (t5 = $[9], t6 = $[10]), useEffect(t5, t6);
  let t7;
  $[11] !== boundaryElement || $[12] !== isTopLayer || $[13] !== onClose || $[14] !== portalElement ? (t7 = (event) => {
    if (!isTopLayer || !onClose)
      return;
    const target = document.activeElement;
    target && !isTargetWithinScope(boundaryElement, portalElement, target) || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClose());
  }, $[11] = boundaryElement, $[12] = isTopLayer, $[13] = onClose, $[14] = portalElement, $[15] = t7) : t7 = $[15], useGlobalKeyDown(t7);
  let t8;
  $[16] !== boundaryElement || $[17] !== isTopLayer || $[18] !== onClickOutside || $[19] !== portalElement ? (t8 = isTopLayer && onClickOutside && ((event_0) => {
    const target_0 = event_0.target;
    target_0 && !isTargetWithinScope(boundaryElement, portalElement, target_0) || onClickOutside();
  }), $[16] = boundaryElement, $[17] = isTopLayer, $[18] = onClickOutside, $[19] = portalElement, $[20] = t8) : t8 = $[20];
  let t9;
  $[21] === Symbol.for("react.memo_cache_sentinel") ? (t9 = () => [ref.current], $[21] = t9) : t9 = $[21], useClickOutsideEvent(t8, t9);
  let t10;
  $[22] !== header || $[23] !== labelId || $[24] !== onClose || $[25] !== showCloseButton || $[26] !== showHeader ? (t10 = showHeader && /* @__PURE__ */ jsx(DialogHeader, { children: /* @__PURE__ */ jsxs(Flex, { align: "flex-start", padding: 3, children: [
    /* @__PURE__ */ jsx(Box, { flex: 1, padding: 2, children: header && /* @__PURE__ */ jsx(Text, { id: labelId, size: 1, weight: "semibold", children: header }) }),
    showCloseButton && /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Button, { "aria-label": "Close dialog", disabled: !onClose, icon: CloseIcon, mode: "bleed", onClick: onClose, padding: 2 }) })
  ] }) }), $[22] = header, $[23] = labelId, $[24] = onClose, $[25] = showCloseButton, $[26] = showHeader, $[27] = t10) : t10 = $[27];
  let t11;
  $[28] !== children ? (t11 = /* @__PURE__ */ jsx(DialogContent, { flex: 1, ref: contentRef, tabIndex: -1, children }), $[28] = children, $[29] = t11) : t11 = $[29];
  let t12;
  $[30] !== footer ? (t12 = footer && /* @__PURE__ */ jsx(DialogFooter, { children: footer }), $[30] = footer, $[31] = t12) : t12 = $[31];
  let t13;
  $[32] !== t10 || $[33] !== t11 || $[34] !== t12 ? (t13 = /* @__PURE__ */ jsxs(DialogLayout, { direction: "column", children: [
    t10,
    t11,
    t12
  ] }), $[32] = t10, $[33] = t11, $[34] = t12, $[35] = t13) : t13 = $[35];
  let t14;
  $[36] !== radius || $[37] !== scheme || $[38] !== shadow || $[39] !== t13 ? (t14 = /* @__PURE__ */ jsx(DialogCardRoot, { radius, ref, scheme, shadow, children: t13 }), $[36] = radius, $[37] = scheme, $[38] = shadow, $[39] = t13, $[40] = t14) : t14 = $[40];
  let t15;
  return $[41] !== t14 || $[42] !== width ? (t15 = /* @__PURE__ */ jsx(DialogContainer, { "data-ui": "DialogCard", width, children: t14 }), $[41] = t14, $[42] = width, $[43] = t15) : t15 = $[43], t15;
});
DialogCard.displayName = "ForwardRef(DialogCard)";
const Dialog = forwardRef(function(props, ref) {
  const $ = c(70), dialog = useDialog(), {
    layer
  } = useTheme_v2();
  let _positionProp, _zOffsetProp, children, contentRef, footer, header, id, onActivate, onClickOutside, onClose, onFocus, portalProp, restProps, scheme, t0, t1, t2, t3, t4, t5, t6;
  $[0] !== props ? ({
    __unstable_autoFocus: t0,
    __unstable_hideCloseButton: t1,
    cardRadius: t2,
    cardShadow: t3,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: t4,
    portal: portalProp,
    position: _positionProp,
    scheme,
    width: t5,
    zOffset: _zOffsetProp,
    animate: t6,
    ...restProps
  } = props, $[0] = props, $[1] = _positionProp, $[2] = _zOffsetProp, $[3] = children, $[4] = contentRef, $[5] = footer, $[6] = header, $[7] = id, $[8] = onActivate, $[9] = onClickOutside, $[10] = onClose, $[11] = onFocus, $[12] = portalProp, $[13] = restProps, $[14] = scheme, $[15] = t0, $[16] = t1, $[17] = t2, $[18] = t3, $[19] = t4, $[20] = t5, $[21] = t6) : (_positionProp = $[1], _zOffsetProp = $[2], children = $[3], contentRef = $[4], footer = $[5], header = $[6], id = $[7], onActivate = $[8], onClickOutside = $[9], onClose = $[10], onFocus = $[11], portalProp = $[12], restProps = $[13], scheme = $[14], t0 = $[15], t1 = $[16], t2 = $[17], t3 = $[18], t4 = $[19], t5 = $[20], t6 = $[21]);
  const autoFocus = t0 === void 0 ? !0 : t0, hideCloseButton = t1 === void 0 ? !1 : t1, cardRadiusProp = t2 === void 0 ? 4 : t2, cardShadow = t3 === void 0 ? 3 : t3, paddingProp = t4 === void 0 ? 3 : t4, widthProp = t5 === void 0 ? 0 : t5, _animate = t6 === void 0 ? !1 : t6, positionProp = _positionProp ?? (dialog.position || "fixed"), zOffsetProp = _zOffsetProp ?? (dialog.zOffset || layer.dialog.zOffset), animate = usePrefersReducedMotion() ? !1 : _animate, portal = usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = useBoundaryElement().element;
  let t7;
  $[22] !== cardRadiusProp ? (t7 = _getArrayProp(cardRadiusProp), $[22] = cardRadiusProp, $[23] = t7) : t7 = $[23];
  const cardRadius = t7;
  let t8;
  $[24] !== paddingProp ? (t8 = _getArrayProp(paddingProp), $[24] = paddingProp, $[25] = t8) : t8 = $[25];
  const padding = t8;
  let t9;
  $[26] !== positionProp ? (t9 = _getArrayProp(positionProp), $[26] = positionProp, $[27] = t9) : t9 = $[27];
  const position = t9;
  let t10;
  $[28] !== widthProp ? (t10 = _getArrayProp(widthProp), $[28] = widthProp, $[29] = t10) : t10 = $[29];
  const width = t10;
  let t11;
  $[30] !== zOffsetProp ? (t11 = _getArrayProp(zOffsetProp), $[30] = zOffsetProp, $[31] = t11) : t11 = $[31];
  const zOffset = t11, preDivRef = useRef(null), postDivRef = useRef(null), cardRef = useRef(null), focusedElementRef = useRef(null);
  let t12;
  $[32] !== onFocus ? (t12 = (event) => {
    onFocus?.(event);
    const target = event.target, cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    isHTMLElement(event.target) && (focusedElementRef.current = event.target);
  }, $[32] = onFocus, $[33] = t12) : t12 = $[33];
  const handleFocus = t12, labelId = `${id}_label`, rootClickTimeoutRef = useRef(void 0);
  let t13;
  $[34] !== boundaryElement || $[35] !== portalElement ? (t13 = () => {
    rootClickTimeoutRef.current && clearTimeout(rootClickTimeoutRef.current), rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target_0 = focusedElementRef.current;
        if (!target_0 || !document.body.contains(target_0)) {
          const cardElement_0 = cardRef.current;
          cardElement_0 && focusFirstDescendant(cardElement_0);
          return;
        }
        target_0.focus();
      }
    }, 0);
  }, $[34] = boundaryElement, $[35] = portalElement, $[36] = t13) : t13 = $[36];
  const handleRootClick = t13;
  let t14;
  $[37] === Symbol.for("react.memo_cache_sentinel") ? (t14 = /* @__PURE__ */ jsx("div", { ref: preDivRef, tabIndex: 0 }), $[37] = t14) : t14 = $[37];
  let t15;
  $[38] !== autoFocus || $[39] !== cardRadius || $[40] !== cardShadow || $[41] !== children || $[42] !== contentRef || $[43] !== footer || $[44] !== header || $[45] !== hideCloseButton || $[46] !== id || $[47] !== onClickOutside || $[48] !== onClose || $[49] !== portalProp || $[50] !== scheme || $[51] !== width ? (t15 = /* @__PURE__ */ jsx(DialogCard, { __unstable_autoFocus: autoFocus, __unstable_hideCloseButton: hideCloseButton, contentRef, footer, header, id, onClickOutside, onClose, portal: portalProp, radius: cardRadius, ref: cardRef, scheme, shadow: cardShadow, width, children }), $[38] = autoFocus, $[39] = cardRadius, $[40] = cardShadow, $[41] = children, $[42] = contentRef, $[43] = footer, $[44] = header, $[45] = hideCloseButton, $[46] = id, $[47] = onClickOutside, $[48] = onClose, $[49] = portalProp, $[50] = scheme, $[51] = width, $[52] = t15) : t15 = $[52];
  let t16;
  $[53] === Symbol.for("react.memo_cache_sentinel") ? (t16 = /* @__PURE__ */ jsx("div", { ref: postDivRef, tabIndex: 0 }), $[53] = t16) : t16 = $[53];
  let t17;
  $[54] !== animate || $[55] !== handleFocus || $[56] !== handleRootClick || $[57] !== id || $[58] !== labelId || $[59] !== onActivate || $[60] !== padding || $[61] !== position || $[62] !== ref || $[63] !== restProps || $[64] !== t15 || $[65] !== zOffset ? (t17 = /* @__PURE__ */ jsxs(StyledDialog, { ...restProps, $animate: animate, $padding: padding, $position: position, "aria-labelledby": labelId, "aria-modal": !0, "data-ui": "Dialog", id, onActivate, onClick: handleRootClick, onFocus: handleFocus, ref, role: "dialog", zOffset, children: [
    t14,
    t15,
    t16
  ] }), $[54] = animate, $[55] = handleFocus, $[56] = handleRootClick, $[57] = id, $[58] = labelId, $[59] = onActivate, $[60] = padding, $[61] = position, $[62] = ref, $[63] = restProps, $[64] = t15, $[65] = zOffset, $[66] = t17) : t17 = $[66];
  let t18;
  return $[67] !== portalProp || $[68] !== t17 ? (t18 = /* @__PURE__ */ jsx(Portal, { __unstable_name: portalProp, children: t17 }), $[67] = portalProp, $[68] = t17, $[69] = t18) : t18 = $[69], t18;
});
Dialog.displayName = "ForwardRef(Dialog)";
function DialogProvider(props) {
  const $ = c(6), {
    children,
    position,
    zOffset
  } = props;
  let t0;
  $[0] !== position || $[1] !== zOffset ? (t0 = {
    version: 0,
    position,
    zOffset
  }, $[0] = position, $[1] = zOffset, $[2] = t0) : t0 = $[2];
  const contextValue = t0;
  let t1;
  return $[3] !== children || $[4] !== contextValue ? (t1 = /* @__PURE__ */ jsx(DialogContext.Provider, { value: contextValue, children }), $[3] = children, $[4] = contextValue, $[5] = t1) : t1 = $[5], t1;
}
DialogProvider.displayName = "DialogProvider";
const MenuButton = forwardRef(function(props, forwardedRef) {
  const $ = c(62), {
    __unstable_disableRestoreFocusOnClose: t0,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: t1,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props, disableRestoreFocusOnClose = t0 === void 0 ? !1 : t0, deprecated_portal = t1 === void 0 ? !0 : t1, [open, setOpen] = useState(!1), [shouldFocus, setShouldFocus] = useState(null), [buttonElement, setButtonElement] = useState(null);
  let t2;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [], $[0] = t2) : t2 = $[0];
  const [menuElements, setChildMenuElements] = useState(t2), openRef = useRef(open);
  let t3, t4;
  $[1] !== onOpen || $[2] !== open ? (t3 = () => {
    onOpen && open && !openRef.current && onOpen();
  }, t4 = [onOpen, open], $[1] = onOpen, $[2] = open, $[3] = t3, $[4] = t4) : (t3 = $[3], t4 = $[4]), useEffect(t3, t4);
  let t5, t6;
  $[5] !== onClose || $[6] !== open ? (t5 = () => {
    onClose && !open && openRef.current && onClose();
  }, t6 = [onClose, open], $[5] = onClose, $[6] = open, $[7] = t5, $[8] = t6) : (t5 = $[7], t6 = $[8]), useEffect(t5, t6);
  let t7, t8;
  $[9] !== open ? (t7 = () => {
    openRef.current = open;
  }, t8 = [open], $[9] = open, $[10] = t7, $[11] = t8) : (t7 = $[10], t8 = $[11]), useEffect(t7, t8);
  let t9;
  $[12] === Symbol.for("react.memo_cache_sentinel") ? (t9 = () => {
    setOpen(_temp$2), setShouldFocus(null);
  }, $[12] = t9) : t9 = $[12];
  const handleButtonClick = t9;
  let t10;
  $[13] !== open ? (t10 = (event) => {
    open && event.preventDefault();
  }, $[13] = open, $[14] = t10) : t10 = $[14];
  const handleMouseDown = t10;
  let t11;
  $[15] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (event_0) => {
    if (event_0.key === "ArrowDown" || event_0.key === "Enter" || event_0.key === " ") {
      event_0.preventDefault(), setOpen(!0), setShouldFocus("first");
      return;
    }
    if (event_0.key === "ArrowUp") {
      event_0.preventDefault(), setOpen(!0), setShouldFocus("last");
      return;
    }
  }, $[15] = t11) : t11 = $[15];
  const handleButtonKeyDown = t11;
  let t12;
  $[16] !== buttonElement || $[17] !== menuElements ? (t12 = (event_1) => {
    const target = event_1.target;
    if (target instanceof Node && !(buttonElement && (target === buttonElement || buttonElement.contains(target)))) {
      for (const el of menuElements)
        if (target === el || el.contains(target))
          return;
      setOpen(!1);
    }
  }, $[16] = buttonElement, $[17] = menuElements, $[18] = t12) : t12 = $[18];
  const handleMenuClickOutside = t12;
  let t13;
  $[19] !== buttonElement || $[20] !== disableRestoreFocusOnClose ? (t13 = () => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, $[19] = buttonElement, $[20] = disableRestoreFocusOnClose, $[21] = t13) : t13 = $[21];
  const handleMenuEscape = t13;
  let t14;
  $[22] !== menuElements ? (t14 = (event_2) => {
    const target_0 = event_2.relatedTarget;
    if (target_0 instanceof Node) {
      for (const el_0 of menuElements)
        if (el_0 === target_0 || el_0.contains(target_0))
          return;
      setOpen(!1);
    }
  }, $[22] = menuElements, $[23] = t14) : t14 = $[23];
  const handleBlur = t14;
  let t15;
  $[24] !== buttonElement || $[25] !== disableRestoreFocusOnClose ? (t15 = () => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, $[24] = buttonElement, $[25] = disableRestoreFocusOnClose, $[26] = t15) : t15 = $[26];
  const handleItemClick = t15;
  let t16;
  $[27] === Symbol.for("react.memo_cache_sentinel") ? (t16 = (el_1) => (setChildMenuElements((els) => els.concat([el_1])), () => setChildMenuElements((els_0) => els_0.filter((_el) => _el !== el_1))), $[27] = t16) : t16 = $[27];
  const registerElement = t16;
  let t17;
  $[28] !== buttonElement || $[29] !== handleBlur || $[30] !== handleItemClick || $[31] !== handleMenuClickOutside || $[32] !== handleMenuEscape || $[33] !== id || $[34] !== menuProp || $[35] !== shouldFocus ? (t17 = menuProp && cloneElement(menuProp, {
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), $[28] = buttonElement, $[29] = handleBlur, $[30] = handleItemClick, $[31] = handleMenuClickOutside, $[32] = handleMenuEscape, $[33] = id, $[34] = menuProp, $[35] = shouldFocus, $[36] = t17) : t17 = $[36];
  const menu = t17;
  let t18;
  $[37] !== buttonProp || $[38] !== handleMouseDown || $[39] !== id || $[40] !== open ? (t18 = buttonProp && cloneElement(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    onMouseDown: handleMouseDown,
    "aria-haspopup": !0,
    "aria-expanded": open,
    ref: setButtonElement,
    selected: buttonProp.props.selected ?? open
  }), $[37] = buttonProp, $[38] = handleMouseDown, $[39] = id, $[40] = open, $[41] = t18) : t18 = $[41];
  const button = t18;
  let t19, t20;
  $[42] !== buttonElement ? (t19 = () => buttonElement, t20 = [buttonElement], $[42] = buttonElement, $[43] = t19, $[44] = t20) : (t19 = $[43], t20 = $[44]), useImperativeHandle(forwardedRef, t19, t20);
  let t21;
  $[45] !== popover ? (t21 = popover || {}, $[45] = popover, $[46] = t21) : t21 = $[46];
  let t22;
  $[47] !== deprecated_boundaryElement || $[48] !== deprecated_placement || $[49] !== deprecated_popoverRadius || $[50] !== deprecated_popoverScheme || $[51] !== deprecated_portal || $[52] !== deprecated_preventOverflow || $[53] !== t21 ? (t22 = {
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...t21
  }, $[47] = deprecated_boundaryElement, $[48] = deprecated_placement, $[49] = deprecated_popoverRadius, $[50] = deprecated_popoverScheme, $[51] = deprecated_portal, $[52] = deprecated_preventOverflow, $[53] = t21, $[54] = t22) : t22 = $[54];
  const popoverProps = t22;
  let t23;
  $[55] !== button ? (t23 = button || /* @__PURE__ */ jsx(Fragment$1, {}), $[55] = button, $[56] = t23) : t23 = $[56];
  let t24;
  return $[57] !== menu || $[58] !== open || $[59] !== popoverProps || $[60] !== t23 ? (t24 = /* @__PURE__ */ jsx(Popover, { "data-ui": "MenuButton__popover", ...popoverProps, content: menu, open, children: t23 }), $[57] = menu, $[58] = open, $[59] = popoverProps, $[60] = t23, $[61] = t24) : t24 = $[61], t24;
});
MenuButton.displayName = "ForwardRef(MenuButton)";
function _temp$2(v) {
  return !v;
}
const keyframe = keyframes`
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
`, animation = css`
  background-image: linear-gradient(
    to right,
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-to),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from)
  );
  background-position: 100%;
  background-size: 200% 100%;
  background-attachment: fixed;
  animation-name: ${keyframe};
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
  animation-duration: 2000ms;
`, skeletonStyle = css`
  opacity: ${({
  $visible
}) => $visible ? 1 : 0};
  transition: opacity 200ms ease-in;

  @media screen and (prefers-reduced-motion: no-preference) {
    ${({
  $animated
}) => $animated ? animation : css`
            background-color: var(--card-skeleton-color-from);
          `}
  }

  @media screen and (prefers-reduced-motion: reduce) {
    background-color: var(--card-skeleton-color-from);
  }
`, StyledSkeleton$1 = /* @__PURE__ */ styled(Box).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-ebtpni-0"
})(responsiveRadiusStyle, skeletonStyle), Skeleton = forwardRef(function(props, ref) {
  const $ = c(16);
  let delay, radius, restProps, t0;
  $[0] !== props ? ({
    animated: t0,
    delay,
    radius,
    ...restProps
  } = props, $[0] = props, $[1] = delay, $[2] = radius, $[3] = restProps, $[4] = t0) : (delay = $[1], radius = $[2], restProps = $[3], t0 = $[4]);
  const animated = t0 === void 0 ? !1 : t0, [visible, setVisible] = useState(!delay);
  let t1, t2;
  $[5] !== delay ? (t1 = () => {
    if (!delay)
      return;
    const timeout = setTimeout(() => {
      setVisible(!0);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, t2 = [delay], $[5] = delay, $[6] = t1, $[7] = t2) : (t1 = $[6], t2 = $[7]), useEffect(t1, t2);
  let t3;
  $[8] !== radius ? (t3 = _getArrayProp(radius), $[8] = radius, $[9] = t3) : t3 = $[9];
  const t4 = delay ? visible : !0;
  let t5;
  return $[10] !== animated || $[11] !== ref || $[12] !== restProps || $[13] !== t3 || $[14] !== t4 ? (t5 = /* @__PURE__ */ jsx(StyledSkeleton$1, { ...restProps, $animated: animated, $radius: t3, $visible: t4, ref }), $[10] = animated, $[11] = ref, $[12] = restProps, $[13] = t3, $[14] = t4, $[15] = t5) : t5 = $[15], t5;
});
Skeleton.displayName = "ForwardRef(Skeleton)";
const StyledSkeleton = /* @__PURE__ */ styled(Skeleton).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-2p7a1v-0"
})((props) => {
  const {
    $size,
    $style
  } = props, {
    font,
    media
  } = getTheme_v2(props.theme), fontStyle = font[$style];
  return _responsive(media, $size, (sizeIndex) => {
    const fontSize = fontStyle.sizes[sizeIndex];
    return {
      height: fontSize.lineHeight - fontSize.ascenderHeight - fontSize.descenderHeight
    };
  });
}), TextSkeleton = forwardRef(function(props, ref) {
  const $ = c(9);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const size = t0 === void 0 ? 2 : t0;
  let t1;
  $[3] !== size ? (t1 = _getArrayProp(size), $[3] = size, $[4] = t1) : t1 = $[4];
  const $size = t1;
  let t2;
  return $[5] !== $size || $[6] !== ref || $[7] !== restProps ? (t2 = /* @__PURE__ */ jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "text" }), $[5] = $size, $[6] = ref, $[7] = restProps, $[8] = t2) : t2 = $[8], t2;
});
TextSkeleton.displayName = "ForwardRef(TextSkeleton)";
const LabelSkeleton = forwardRef(function(props, ref) {
  const $ = c(9);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const size = t0 === void 0 ? 2 : t0;
  let t1;
  $[3] !== size ? (t1 = _getArrayProp(size), $[3] = size, $[4] = t1) : t1 = $[4];
  const $size = t1;
  let t2;
  return $[5] !== $size || $[6] !== ref || $[7] !== restProps ? (t2 = /* @__PURE__ */ jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "label" }), $[5] = $size, $[6] = ref, $[7] = restProps, $[8] = t2) : t2 = $[8], t2;
});
LabelSkeleton.displayName = "ForwardRef(LabelSkeleton)";
const HeadingSkeleton = forwardRef(function(props, ref) {
  const $ = c(9);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const size = t0 === void 0 ? 2 : t0;
  let t1;
  $[3] !== size ? (t1 = _getArrayProp(size), $[3] = size, $[4] = t1) : t1 = $[4];
  const $size = t1;
  let t2;
  return $[5] !== $size || $[6] !== ref || $[7] !== restProps ? (t2 = /* @__PURE__ */ jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "heading" }), $[5] = $size, $[6] = ref, $[7] = restProps, $[8] = t2) : t2 = $[8], t2;
});
HeadingSkeleton.displayName = "ForwardRef(HeadingSkeleton)";
const CodeSkeleton = forwardRef(function(props, ref) {
  const $ = c(9);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const size = t0 === void 0 ? 2 : t0;
  let t1;
  $[3] !== size ? (t1 = _getArrayProp(size), $[3] = size, $[4] = t1) : t1 = $[4];
  const $size = t1;
  let t2;
  return $[5] !== $size || $[6] !== ref || $[7] !== restProps ? (t2 = /* @__PURE__ */ jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "code" }), $[5] = $size, $[6] = ref, $[7] = restProps, $[8] = t2) : t2 = $[8], t2;
});
CodeSkeleton.displayName = "ForwardRef(CodeSkeleton)";
const TabPanel = forwardRef(function(props, ref) {
  const $ = c(9);
  let flex, restProps;
  $[0] !== props ? ({
    flex,
    ...restProps
  } = props, $[0] = props, $[1] = flex, $[2] = restProps) : (flex = $[1], restProps = $[2]);
  const t0 = props.tabIndex === void 0 ? 0 : props.tabIndex;
  let t1;
  return $[3] !== flex || $[4] !== props.children || $[5] !== ref || $[6] !== restProps || $[7] !== t0 ? (t1 = /* @__PURE__ */ jsx(Box, { "data-ui": "TabPanel", ...restProps, flex, ref, role: "tabpanel", tabIndex: t0, children: props.children }), $[3] = flex, $[4] = props.children, $[5] = ref, $[6] = restProps, $[7] = t0, $[8] = t1) : t1 = $[8], t1;
});
TabPanel.displayName = "ForwardRef(TabPanel)";
const LOADING_BAR_HEIGHT = 2, STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
}, BUTTON_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
}, TextBox = styled(Flex).withConfig({
  displayName: "TextBox",
  componentId: "sc-1rr7rxo-0"
})`overflow-x:auto;`, StyledToast = styled(Card).withConfig({
  displayName: "StyledToast",
  componentId: "sc-1rr7rxo-1"
})`pointer-events:all;width:100%;position:relative;overflow:hidden;overflow:clip;&[data-has-duration]{padding-bottom:calc(${LOADING_BAR_HEIGHT}px / 2);}`, LoadingBar = styled.div.withConfig({
  displayName: "LoadingBar",
  componentId: "sc-1rr7rxo-2"
})`display:flex;position:absolute;bottom:0px;top:0px;left:0px;right:0px;pointer-events:none;z-index:-1;overflow:hidden;overflow:clip;background:transparent;align-items:flex-end;will-change:opacity;`, LoadingBarMask = styled(Card).withConfig({
  displayName: "LoadingBarMask",
  componentId: "sc-1rr7rxo-3"
})`position:absolute;top:0;left:-${LOADING_BAR_HEIGHT}px;right:-${LOADING_BAR_HEIGHT}px;bottom:${LOADING_BAR_HEIGHT}px;z-index:1;`, LoadingBarProgress = styled(Card).withConfig({
  displayName: "LoadingBarProgress",
  componentId: "sc-1rr7rxo-4"
})`display:block;height:100%;width:100%;transform-origin:0% 50%;background-color:${(props) => {
  const {
    color
  } = getTheme_v2(props.theme);
  return color.button.default[props.tone].enabled.bg;
}};`, ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
}, LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function Toast(props) {
  const $ = c(50);
  let closable, description, duration, onClose, restProps, status, t0, title, updatedAt;
  $[0] !== props ? ({
    closable,
    description,
    duration,
    onClose,
    radius: t0,
    title,
    status,
    updatedAt,
    ...restProps
  } = props, $[0] = props, $[1] = closable, $[2] = description, $[3] = duration, $[4] = onClose, $[5] = restProps, $[6] = status, $[7] = t0, $[8] = title, $[9] = updatedAt) : (closable = $[1], description = $[2], duration = $[3], onClose = $[4], restProps = $[5], status = $[6], t0 = $[7], title = $[8], updatedAt = $[9]);
  const radius = t0 === void 0 ? 3 : t0, cardTone = status ? STATUS_CARD_TONE[status] : "default", buttonTone = status ? BUTTON_TONE[status] : "default", role = status ? ROLES[status] : "status", visualDuration = usePrefersReducedMotion() ? 0 : 0.26;
  let t1;
  $[10] !== visualDuration ? (t1 = visualDuration ? {
    type: "spring",
    visualDuration,
    bounce: 0.25
  } : {
    duration: 0
  }, $[10] = visualDuration, $[11] = t1) : t1 = $[11];
  const transition = t1, hasDuration = duration && isFinite(duration) && duration < LONG_ENOUGH_BUT_NOT_TOO_LONG;
  let t2;
  $[12] === Symbol.for("react.memo_cache_sentinel") ? (t2 = ["hidden", "initial"], $[12] = t2) : t2 = $[12];
  const initial = t2;
  let t3;
  $[13] === Symbol.for("react.memo_cache_sentinel") ? (t3 = ["visible", "slideIn"], $[13] = t3) : t3 = $[13];
  const animate = t3;
  let t4;
  $[14] === Symbol.for("react.memo_cache_sentinel") ? (t4 = ["hidden", "slideOut"], $[14] = t4) : t4 = $[14];
  const exit = t4, t5 = hasDuration ? "" : void 0;
  let t6;
  $[15] !== title ? (t6 = title && /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: title }), $[15] = title, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] !== description || $[18] !== transition ? (t7 = description && /* @__PURE__ */ jsx(MotionText, { muted: !0, size: 1, variants: content, transition, children: description }), $[17] = description, $[18] = transition, $[19] = t7) : t7 = $[19];
  let t8;
  $[20] !== t6 || $[21] !== t7 ? (t8 = /* @__PURE__ */ jsx(TextBox, { flex: 1, padding: 3, children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    t6,
    t7
  ] }) }), $[20] = t6, $[21] = t7, $[22] = t8) : t8 = $[22];
  let t9;
  $[23] !== buttonTone || $[24] !== closable || $[25] !== onClose ? (t9 = closable && /* @__PURE__ */ jsx(Box, { padding: 1, children: /* @__PURE__ */ jsx(Button, { as: "button", icon: CloseIcon, mode: "bleed", padding: 2, tone: buttonTone, onClick: onClose, style: {
    verticalAlign: "top"
  } }) }), $[23] = buttonTone, $[24] = closable, $[25] = onClose, $[26] = t9) : t9 = $[26];
  let t10;
  $[27] !== t8 || $[28] !== t9 || $[29] !== transition ? (t10 = /* @__PURE__ */ jsxs(MotionFlex, { align: "flex-start", variants: content, transition, children: [
    t8,
    t9
  ] }), $[27] = t8, $[28] = t9, $[29] = transition, $[30] = t10) : t10 = $[30];
  let t11;
  $[31] !== cardTone || $[32] !== duration || $[33] !== hasDuration || $[34] !== onClose || $[35] !== radius || $[36] !== transition || $[37] !== updatedAt || $[38] !== visualDuration ? (t11 = hasDuration && /* @__PURE__ */ jsxs(MotionLoadingBar, { variants: content, transition, children: [
    /* @__PURE__ */ jsx(LoadingBarMask, { tone: cardTone, radius }),
    /* @__PURE__ */ jsx(MotionLoadingBarProgress, { tone: cardTone, initial: {
      scaleX: 0
    }, animate: {
      scaleX: 1
    }, transition: {
      delay: visualDuration,
      duration: duration / 1e3,
      ease: "linear"
    }, onAnimationComplete: onClose }, `progress-${updatedAt}`)
  ] }), $[31] = cardTone, $[32] = duration, $[33] = hasDuration, $[34] = onClose, $[35] = radius, $[36] = transition, $[37] = updatedAt, $[38] = visualDuration, $[39] = t11) : t11 = $[39];
  let t12;
  return $[40] !== cardTone || $[41] !== radius || $[42] !== restProps || $[43] !== role || $[44] !== t10 || $[45] !== t11 || $[46] !== t5 || $[47] !== transition || $[48] !== visualDuration ? (t12 = /* @__PURE__ */ jsxs(MotionToast, { "data-ui": "Toast", role, ...restProps, "data-has-duration": t5, custom: visualDuration, radius, shadow: 2, tone: cardTone, forwardedAs: "li", layout: "position", variants: container, initial, animate, exit, transition, children: [
    t10,
    t11
  ] }), $[40] = cardTone, $[41] = radius, $[42] = restProps, $[43] = role, $[44] = t10, $[45] = t11, $[46] = t5, $[47] = transition, $[48] = visualDuration, $[49] = t12) : t12 = $[49], t12;
}
Toast.displayName = "Toast";
const container = {
  initial: {
    y: 32,
    scale: 0.5,
    zIndex: 1
  },
  hidden: {
    opacity: 0
  },
  visible: (visualDuration) => visualDuration ? {
    opacity: 1,
    transition: {
      when: "beforeChildren",
      staggerChildren: visualDuration / 3,
      duration: visualDuration / 3
    }
  } : {
    opacity: 1
  },
  slideIn: {
    y: 0,
    scale: 1
  },
  slideOut: {
    zIndex: 0,
    scale: 0.75
  }
}, content = {
  initial: {
    willChange: "transform"
  },
  hidden: {
    opacity: 0
  },
  visible: {
    opacity: 1
  }
}, MotionToast = motion.create(StyledToast), MotionFlex = motion.create(Flex), MotionText = motion.create(Text), MotionLoadingBar = motion.create(LoadingBar), MotionLoadingBarProgress = motion.create(LoadingBarProgress);
function useMounted() {
  return useSyncExternalStore(subscribe, _temp$1, _temp2);
}
function _temp2() {
  return !1;
}
function _temp$1() {
  return !0;
}
const subscribe = () => () => {
}, ToastContext = createGlobalScopedContext("@sanity/ui/context/toast", null);
function ToastLayer(props) {
  const $ = c(9), {
    children,
    padding: t0,
    paddingX,
    paddingY,
    gap: t1
  } = props, padding = t0 === void 0 ? 4 : t0, gap = t1 === void 0 ? 3 : t1, {
    zIndex
  } = useLayer();
  let t2;
  $[0] !== zIndex ? (t2 = {
    zIndex
  }, $[0] = zIndex, $[1] = t2) : t2 = $[1];
  let t3;
  return $[2] !== children || $[3] !== gap || $[4] !== padding || $[5] !== paddingX || $[6] !== paddingY || $[7] !== t2 ? (t3 = /* @__PURE__ */ jsx(StyledLayer, { forwardedAs: "ul", "data-ui": "ToastProvider", padding, paddingX, paddingY, gap, columns: 1, style: t2, children }), $[2] = children, $[3] = gap, $[4] = padding, $[5] = paddingX, $[6] = paddingY, $[7] = t2, $[8] = t3) : t3 = $[8], t3;
}
ToastLayer.displayName = "ToastLayer";
const StyledLayer = styled(Grid).withConfig({
  displayName: "StyledLayer",
  componentId: "sc-1tbwn58-0"
})`box-sizing:border-box;position:fixed;right:0;bottom:0;list-style:none;pointer-events:none;max-width:420px;width:100%;`;
let toastId = 0;
function generateToastId() {
  return String(toastId++);
}
function ToastProvider(props) {
  const $ = c(13), {
    children,
    padding,
    paddingX,
    paddingY,
    gap,
    zOffset: t0
  } = props, zOffset = t0 === void 0 ? 1 : t0;
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $[0] = t1) : t1 = $[0];
  const [state, setState] = useState(t1), mounted = useMounted();
  let t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    version: 0,
    push: (params) => {
      const id = params.id || generateToastId(), duration = params.duration || 5e3;
      return startTransition(() => {
        setState((prevState) => {
          if (duration === 0.01)
            return prevState.filter((toast) => toast.id !== id);
          const dismiss = () => startTransition(() => setState((currentState) => currentState.filter((toast_0) => toast_0.id !== id)));
          return [...prevState.filter((toast_1) => toast_1.id !== id), {
            dismiss,
            id,
            updatedAt: Date.now(),
            params: {
              ...params,
              duration
            }
          }];
        });
      }), id;
    }
  }, $[1] = t2) : t2 = $[1];
  const value = t2;
  let t3;
  $[2] !== gap || $[3] !== mounted || $[4] !== padding || $[5] !== paddingX || $[6] !== paddingY || $[7] !== state || $[8] !== zOffset ? (t3 = mounted && /* @__PURE__ */ jsx(LayerProvider, { zOffset, children: /* @__PURE__ */ jsx(ToastLayer, { padding, paddingX, paddingY, gap, children: /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, mode: "popLayout", children: state.map(_temp) }) }) }), $[2] = gap, $[3] = mounted, $[4] = padding, $[5] = paddingX, $[6] = paddingY, $[7] = state, $[8] = zOffset, $[9] = t3) : t3 = $[9];
  let t4;
  return $[10] !== children || $[11] !== t3 ? (t4 = /* @__PURE__ */ jsxs(ToastContext.Provider, { value, children: [
    children,
    t3
  ] }), $[10] = children, $[11] = t3, $[12] = t4) : t4 = $[12], t4;
}
function _temp(t0) {
  const {
    dismiss: dismiss_0,
    id: id_0,
    params: params_0,
    updatedAt
  } = t0;
  return /* @__PURE__ */ jsx(Toast, { closable: params_0.closable, description: params_0.description, onClose: dismiss_0, status: params_0.status, title: params_0.title, duration: params_0.duration, updatedAt }, id_0);
}
ToastProvider.displayName = "ToastProvider";
function useToast() {
  const value = useContext(ToastContext);
  if (!value)
    throw new Error("useToast(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("useToast(): the context value is not compatible");
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(0, idx), len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!state[k]?.expanded) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(idx), len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i])
      continue;
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!state[k]?.expanded) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem" && el.focus(), el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    firstChild && firstChild instanceof HTMLElement && firstChild.focus();
  }
}
const TreeContext = createGlobalScopedContext("@sanity/ui/context/tree", null), Tree = forwardRef(function(props, forwardedRef) {
  const $ = c(37);
  let children, onFocus, restProps, t0;
  $[0] !== props ? ({
    children,
    space: t0,
    onFocus,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = onFocus, $[3] = restProps, $[4] = t0) : (children = $[1], onFocus = $[2], restProps = $[3], t0 = $[4]);
  const space = t0 === void 0 ? 1 : t0, ref = useRef(null), [focusedElement, setFocusedElement] = useState(null), focusedElementRef = useRef(focusedElement);
  let t1;
  $[5] === Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $[5] = t1) : t1 = $[5];
  const path = t1;
  let t2;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [], $[6] = t2) : t2 = $[6];
  const [itemElements, setItemElements] = useState(t2);
  let t3;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {}, $[7] = t3) : t3 = $[7];
  const [state, setState] = useState(t3), stateRef = useRef(state);
  let t4;
  $[8] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $[8] = t4) : t4 = $[8], useImperativeHandle(forwardedRef, t4);
  let t5, t6;
  $[9] !== focusedElement ? (t5 = () => {
    focusedElementRef.current = focusedElement;
  }, t6 = [focusedElement], $[9] = focusedElement, $[10] = t5, $[11] = t6) : (t5 = $[10], t6 = $[11]), useEffect(t5, t6);
  let t7, t8;
  $[12] !== state ? (t7 = () => {
    stateRef.current = state;
  }, t8 = [state], $[12] = state, $[13] = t7, $[14] = t8) : (t7 = $[13], t8 = $[14]), useEffect(t7, t8);
  let t9;
  $[15] === Symbol.for("react.memo_cache_sentinel") ? (t9 = (element, path_0, expanded, selected) => (setState((s) => ({
    ...s,
    [path_0]: {
      element,
      expanded
    }
  })), selected && setFocusedElement(element), () => {
    setState((s_0) => {
      const newState = {
        ...s_0
      };
      return delete newState[path_0], newState;
    });
  }), $[15] = t9) : t9 = $[15];
  const registerItem = t9;
  let t10;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t10 = (path_1, expanded_0) => {
    setState((s_1) => {
      const itemState = s_1[path_1];
      return itemState ? {
        ...s_1,
        [path_1]: {
          ...itemState,
          expanded: expanded_0
        }
      } : s_1;
    });
  }, $[16] = t10) : t10 = $[16];
  const setExpanded = t10, t11 = focusedElement || itemElements[0] || null;
  let t12;
  $[17] !== space || $[18] !== state || $[19] !== t11 ? (t12 = {
    version: 0,
    focusedElement: t11,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }, $[17] = space, $[18] = state, $[19] = t11, $[20] = t12) : t12 = $[20];
  const contextValue = t12;
  let t13;
  $[21] !== itemElements ? (t13 = (event) => {
    if (focusedElementRef.current) {
      if (event.key === "ArrowDown") {
        event.preventDefault();
        const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
        nextEl && (_focusItemElement(nextEl), setFocusedElement(nextEl));
        return;
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
        prevEl && (_focusItemElement(prevEl), setFocusedElement(prevEl));
        return;
      }
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!itemKey)
          return;
        const itemState_0 = stateRef.current[itemKey];
        if (!itemState_0)
          return;
        if (itemState_0.expanded)
          setState((s_2) => {
            const itemState_1 = s_2[itemKey];
            return itemState_1 ? {
              ...s_2,
              [itemKey]: {
                ...itemState_1,
                expanded: !1
              }
            } : s_2;
          });
        else {
          const itemPath = itemKey.split("/");
          itemPath.pop();
          const parentKey = itemPath.join("/"), parentState = parentKey && stateRef.current[parentKey];
          parentState && (parentState.element.focus(), setFocusedElement(parentState.element));
        }
        return;
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!focusedKey)
          return;
        stateRef.current[focusedKey]?.expanded || setState((s_3) => {
          const itemState_2 = s_3[focusedKey];
          return itemState_2 ? {
            ...s_3,
            [focusedKey]: {
              ...itemState_2,
              expanded: !0
            }
          } : s_3;
        });
        return;
      }
    }
  }, $[21] = itemElements, $[22] = t13) : t13 = $[22];
  const handleKeyDown = t13;
  let t14;
  $[23] !== onFocus ? (t14 = (event_0) => {
    setFocusedElement(event_0.target), onFocus?.(event_0);
  }, $[23] = onFocus, $[24] = t14) : t14 = $[24];
  const handleFocus = t14;
  let t15;
  $[25] === Symbol.for("react.memo_cache_sentinel") ? (t15 = () => {
    if (!ref.current)
      return;
    const _itemElements = Array.from(ref.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, $[25] = t15) : t15 = $[25];
  let t16;
  $[26] !== children ? (t16 = [children], $[26] = children, $[27] = t16) : t16 = $[27], useEffect(t15, t16);
  let t17;
  $[28] !== children || $[29] !== handleFocus || $[30] !== handleKeyDown || $[31] !== restProps || $[32] !== space ? (t17 = /* @__PURE__ */ jsx(Stack, { as: "ul", "data-ui": "Tree", ...restProps, onFocus: handleFocus, onKeyDown: handleKeyDown, ref, role: "tree", space, children }), $[28] = children, $[29] = handleFocus, $[30] = handleKeyDown, $[31] = restProps, $[32] = space, $[33] = t17) : t17 = $[33];
  let t18;
  return $[34] !== contextValue || $[35] !== t17 ? (t18 = /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: t17 }), $[34] = contextValue, $[35] = t17, $[36] = t18) : t18 = $[36], t18;
});
Tree.displayName = "ForwardRef(Tree)";
function treeItemRootStyle() {
  return css`
    &[role='none'] > [role='treeitem'] {
      outline: none;
      cursor: default;
      border-radius: 3px;

      background-color: var(--card-bg-color);
      color: var(--treeitem-fg-color);

      &:focus {
        position: relative;
      }
    }

    &[role='treeitem'] {
      outline: none;

      & > div {
        cursor: default;
        border-radius: 3px;

        background-color: var(--card-bg-color);
        color: var(--treeitem-fg-color);
      }

      &:focus > div {
        position: relative;
      }
    }
  `;
}
function treeItemRootColorStyle(props) {
  const $tone = "default", {
    color
  } = getTheme_v2(props.theme), tone = color.selectable[$tone];
  return css`
    &[role='none'] {
      & > [role='treeitem'] {
        ${_cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [role='treeitem'] {
        ${_cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {
          ${_cardColorStyle(color, tone.hovered)}
        }

        & > [role='treeitem']:focus {
          ${_cardColorStyle(color, tone.selected)}
        }
      }
    }

    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {
          ${_cardColorStyle(color, tone.hovered)}
        }

        &:focus > [data-ui='TreeItem__box'] {
          ${_cardColorStyle(color, tone.selected)}
        }
      }
    }
  `;
}
function treeItemBoxStyle(props) {
  const {
    $level
  } = props, {
    space
  } = getTheme_v2(props.theme);
  return css`
    padding-left: ${rem(space[2] * $level)};

    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function useTree() {
  const tree = useContext(TreeContext);
  if (!tree)
    throw new Error("Tree: missing context value");
  return tree;
}
function TreeGroup(props) {
  const $ = c(9);
  let children, restProps, t0;
  $[0] !== props ? ({
    children,
    expanded: t0,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = restProps, $[3] = t0) : (children = $[1], restProps = $[2], t0 = $[3]);
  const expanded = t0 === void 0 ? !1 : t0, tree = useTree(), t1 = !expanded;
  let t2;
  return $[4] !== children || $[5] !== restProps || $[6] !== t1 || $[7] !== tree.space ? (t2 = /* @__PURE__ */ jsx(Stack, { as: "ul", "data-ui": "TreeGroup", ...restProps, hidden: t1, marginTop: tree.space, role: "group", space: tree.space, children }), $[4] = children, $[5] = restProps, $[6] = t1, $[7] = tree.space, $[8] = t2) : t2 = $[8], t2;
}
const StyledTreeItem = /* @__PURE__ */ styled.li.withConfig({
  displayName: "StyledTreeItem",
  componentId: "sc-iiskig-0"
})(treeItemRootStyle, treeItemRootColorStyle), TreeItemBox = /* @__PURE__ */ styled(Box).attrs({
  forwardedAs: "a"
}).withConfig({
  displayName: "TreeItemBox",
  componentId: "sc-iiskig-1"
})(treeItemBoxStyle), ToggleArrowText = styled(Text).withConfig({
  displayName: "ToggleArrowText",
  componentId: "sc-iiskig-2"
})`& > svg{transition:transform 100ms;}`;
function TreeItem(props) {
  const $ = c(113);
  let IconComponent, children, href, idProp, linkAs, muted, onClick, restProps, t0, t1, t2, t3, t4, text, weight;
  $[0] !== props ? ({
    children,
    expanded: t0,
    fontSize: t1,
    href,
    icon: IconComponent,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding: t2,
    selected: t3,
    space: t4,
    text,
    weight,
    ...restProps
  } = props, $[0] = props, $[1] = IconComponent, $[2] = children, $[3] = href, $[4] = idProp, $[5] = linkAs, $[6] = muted, $[7] = onClick, $[8] = restProps, $[9] = t0, $[10] = t1, $[11] = t2, $[12] = t3, $[13] = t4, $[14] = text, $[15] = weight) : (IconComponent = $[1], children = $[2], href = $[3], idProp = $[4], linkAs = $[5], muted = $[6], onClick = $[7], restProps = $[8], t0 = $[9], t1 = $[10], t2 = $[11], t3 = $[12], t4 = $[13], text = $[14], weight = $[15]);
  const expandedProp = t0 === void 0 ? !1 : t0, fontSize = t1 === void 0 ? 1 : t1, padding = t2 === void 0 ? 2 : t2, selected = t3 === void 0 ? !1 : t3, space = t4 === void 0 ? 2 : t4, [rootElement, _setRootElement] = useState(null);
  let t5;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t5 = (node) => {
    startTransition(() => _setRootElement(node));
  }, $[16] = t5) : t5 = $[16];
  const setRootElement = t5, treeitemRef = useRef(null), tree = useTree(), {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree, _id = useId(), id = idProp || _id;
  let t6, t7;
  if ($[17] !== id || $[18] !== path) {
    const itemPath = path.concat([id || ""]);
    t6 = itemPath, t7 = itemPath.join("/"), $[17] = id, $[18] = path, $[19] = t6, $[20] = t7;
  } else
    t6 = $[19], t7 = $[20];
  let t8;
  $[21] !== t6 || $[22] !== t7 ? (t8 = [t6, t7], $[21] = t6, $[22] = t7, $[23] = t8) : t8 = $[23];
  const [itemPath_0, itemKey] = t8, itemState = tree.state[itemKey], focused = tree.focusedElement === rootElement, expanded = itemState?.expanded === void 0 ? expandedProp : itemState?.expanded || !1, tabIndex = tree.focusedElement && tree.focusedElement === rootElement ? 0 : -1, t9 = tree.level + 1;
  let t10;
  $[24] !== itemPath_0 || $[25] !== t9 || $[26] !== tree ? (t10 = {
    ...tree,
    level: t9,
    path: itemPath_0
  }, $[24] = itemPath_0, $[25] = t9, $[26] = tree, $[27] = t10) : t10 = $[27];
  const contextValue = t10;
  let t11;
  $[28] !== expanded || $[29] !== itemKey || $[30] !== onClick || $[31] !== rootElement || $[32] !== setExpanded || $[33] !== setFocusedElement ? (t11 = (event) => {
    onClick && onClick(event);
    const target = event.target;
    target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]')) && (event.stopPropagation(), setExpanded(itemKey, !expanded), setFocusedElement(rootElement));
  }, $[28] = expanded, $[29] = itemKey, $[30] = onClick, $[31] = rootElement, $[32] = setExpanded, $[33] = setFocusedElement, $[34] = t11) : t11 = $[34];
  const handleClick = t11;
  let t12;
  $[35] !== focused || $[36] !== rootElement ? (t12 = (event_0) => {
    focused && event_0.key === "Enter" && (treeitemRef.current || rootElement)?.click();
  }, $[35] = focused, $[36] = rootElement, $[37] = t12) : t12 = $[37];
  const handleKeyDown = t12;
  let t13, t14;
  $[38] !== expanded || $[39] !== itemKey || $[40] !== registerItem || $[41] !== rootElement || $[42] !== selected ? (t13 = () => {
    if (rootElement)
      return registerItem(rootElement, itemKey, expanded, selected);
  }, t14 = [expanded, itemKey, registerItem, rootElement, selected], $[38] = expanded, $[39] = itemKey, $[40] = registerItem, $[41] = rootElement, $[42] = selected, $[43] = t13, $[44] = t14) : (t13 = $[43], t14 = $[44]), useEffect(t13, t14);
  const t15 = IconComponent || children ? "visible" : "hidden";
  let t16;
  $[45] !== t15 ? (t16 = {
    visibility: t15,
    pointerEvents: "none"
  }, $[45] = t15, $[46] = t16) : t16 = $[46];
  let t17;
  $[47] !== IconComponent || $[48] !== fontSize || $[49] !== muted || $[50] !== weight ? (t17 = IconComponent && /* @__PURE__ */ jsx(Text, { muted, size: fontSize, weight, children: /* @__PURE__ */ jsx(IconComponent, {}) }), $[47] = IconComponent, $[48] = fontSize, $[49] = muted, $[50] = weight, $[51] = t17) : t17 = $[51];
  let t18;
  $[52] !== IconComponent || $[53] !== expanded || $[54] !== fontSize || $[55] !== muted || $[56] !== weight ? (t18 = !IconComponent && /* @__PURE__ */ jsx(ToggleArrowText, { muted, size: fontSize, weight, children: /* @__PURE__ */ jsx(ToggleArrowRightIcon, { style: {
    transform: expanded ? "rotate(90deg)" : void 0
  } }) }), $[52] = IconComponent, $[53] = expanded, $[54] = fontSize, $[55] = muted, $[56] = weight, $[57] = t18) : t18 = $[57];
  let t19;
  $[58] !== space || $[59] !== t16 || $[60] !== t17 || $[61] !== t18 ? (t19 = /* @__PURE__ */ jsxs(Box, { marginRight: space, style: t16, children: [
    t17,
    t18
  ] }), $[58] = space, $[59] = t16, $[60] = t17, $[61] = t18, $[62] = t19) : t19 = $[62];
  let t20;
  $[63] !== fontSize || $[64] !== muted || $[65] !== text || $[66] !== weight ? (t20 = /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { muted, size: fontSize, textOverflow: "ellipsis", weight, children: text }) }), $[63] = fontSize, $[64] = muted, $[65] = text, $[66] = weight, $[67] = t20) : t20 = $[67];
  let t21;
  $[68] !== padding || $[69] !== t19 || $[70] !== t20 ? (t21 = /* @__PURE__ */ jsxs(Flex, { padding, children: [
    t19,
    t20
  ] }), $[68] = padding, $[69] = t19, $[70] = t20, $[71] = t21) : t21 = $[71];
  const content2 = t21;
  if (href) {
    const t222 = selected ? "" : void 0;
    let t232;
    $[72] !== content2 || $[73] !== expanded || $[74] !== href || $[75] !== linkAs || $[76] !== tabIndex || $[77] !== tree.level ? (t232 = /* @__PURE__ */ jsx(TreeItemBox, { $level: tree.level, "aria-expanded": expanded, as: linkAs, "data-ui": "TreeItem__box", href, ref: treeitemRef, role: "treeitem", tabIndex, children: content2 }), $[72] = content2, $[73] = expanded, $[74] = href, $[75] = linkAs, $[76] = tabIndex, $[77] = tree.level, $[78] = t232) : t232 = $[78];
    let t242;
    $[79] !== children || $[80] !== expanded ? (t242 = children && /* @__PURE__ */ jsx(TreeGroup, { hidden: !expanded, children }), $[79] = children, $[80] = expanded, $[81] = t242) : t242 = $[81];
    let t252;
    $[82] !== contextValue || $[83] !== t242 ? (t252 = /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: t242 }), $[82] = contextValue, $[83] = t242, $[84] = t252) : t252 = $[84];
    let t262;
    return $[85] !== handleClick || $[86] !== id || $[87] !== itemKey || $[88] !== restProps || $[89] !== t222 || $[90] !== t232 || $[91] !== t252 ? (t262 = /* @__PURE__ */ jsxs(StyledTreeItem, { "data-selected": t222, "data-tree-id": id, "data-tree-key": itemKey, "data-ui": "TreeItem", ...restProps, onClick: handleClick, ref: setRootElement, role: "none", children: [
      t232,
      t252
    ] }), $[85] = handleClick, $[86] = id, $[87] = itemKey, $[88] = restProps, $[89] = t222, $[90] = t232, $[91] = t252, $[92] = t262) : t262 = $[92], t262;
  }
  const t22 = selected ? "" : void 0;
  let t23;
  $[93] !== content2 || $[94] !== tree.level ? (t23 = /* @__PURE__ */ jsx(TreeItemBox, { $level: tree.level, as: "div", "data-ui": "TreeItem__box", children: content2 }), $[93] = content2, $[94] = tree.level, $[95] = t23) : t23 = $[95];
  let t24;
  $[96] !== children || $[97] !== expanded ? (t24 = children && /* @__PURE__ */ jsx(TreeGroup, { expanded, children }), $[96] = children, $[97] = expanded, $[98] = t24) : t24 = $[98];
  let t25;
  $[99] !== contextValue || $[100] !== t24 ? (t25 = /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: t24 }), $[99] = contextValue, $[100] = t24, $[101] = t25) : t25 = $[101];
  let t26;
  return $[102] !== expanded || $[103] !== handleClick || $[104] !== handleKeyDown || $[105] !== id || $[106] !== itemKey || $[107] !== restProps || $[108] !== t22 || $[109] !== t23 || $[110] !== t25 || $[111] !== tabIndex ? (t26 = /* @__PURE__ */ jsxs(StyledTreeItem, { "data-selected": t22, "data-ui": "TreeItem", "data-tree-id": id, "data-tree-key": itemKey, ...restProps, "aria-expanded": expanded, onClick: handleClick, onKeyDown: handleKeyDown, ref: setRootElement, role: "treeitem", tabIndex, children: [
    t23,
    t25
  ] }), $[102] = expanded, $[103] = handleClick, $[104] = handleKeyDown, $[105] = id, $[106] = itemKey, $[107] = restProps, $[108] = t22, $[109] = t23, $[110] = t25, $[111] = tabIndex, $[112] = t26) : t26 = $[112], t26;
}
TreeItem.displayName = "TreeItem";
export {
  Arrow,
  Autocomplete,
  Avatar,
  AvatarCounter,
  AvatarStack,
  Badge,
  BoundaryElementProvider,
  Box,
  Breadcrumbs,
  Button,
  Card,
  Checkbox,
  Code,
  CodeSkeleton,
  ConditionalWrapper,
  Container,
  Dialog,
  DialogContext,
  DialogProvider,
  ElementQuery,
  ErrorBoundary,
  Flex,
  Grid,
  Heading,
  HeadingSkeleton,
  Hotkeys,
  Inline,
  KBD,
  Label,
  LabelSkeleton,
  Layer,
  LayerProvider,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuItem,
  Popover,
  Portal,
  PortalProvider,
  Radio,
  Select,
  Skeleton,
  Spinner,
  SrOnly,
  Stack,
  Switch,
  Tab,
  TabList,
  TabPanel,
  Text,
  TextArea,
  TextInput,
  TextSkeleton,
  ThemeColorProvider,
  ThemeProvider,
  Toast,
  ToastProvider,
  Tooltip,
  TooltipDelayGroupContext,
  TooltipDelayGroupProvider,
  Tree,
  TreeItem,
  VirtualList,
  _ResizeObserver,
  _elementSizeObserver,
  _fillCSSObject,
  _getArrayProp,
  _getResponsiveSpace,
  _hasFocus,
  _isEnterToClickElement,
  _isScrollable,
  _raf,
  _raf2,
  _responsive,
  attemptFocus,
  containsOrEqualsElement,
  createColorTheme,
  focusFirstDescendant,
  focusLastDescendant,
  hexToRgb,
  hslToRgb,
  isFocusable,
  isHTMLAnchorElement,
  isHTMLButtonElement,
  isHTMLElement,
  isHTMLInputElement,
  isHTMLSelectElement,
  isHTMLTextAreaElement,
  multiply,
  parseColor,
  rem,
  responsiveCodeFontStyle,
  responsiveHeadingFont,
  responsiveLabelFont,
  responsiveTextAlignStyle,
  responsiveTextFont,
  rgbToHex,
  rgbToHsl,
  rgba,
  screen,
  studioTheme,
  useArrayProp,
  useBoundaryElement,
  useClickOutside,
  useClickOutsideEvent,
  useCustomValidity,
  useDialog,
  useElementRect,
  useElementSize,
  useForwardedRef,
  useGlobalKeyDown,
  useLayer,
  useMatchMedia,
  useMediaIndex,
  usePortal,
  usePrefersDark,
  usePrefersReducedMotion,
  useRootTheme,
  useTheme,
  useTheme_v2,
  useToast,
  useTooltipDelayGroup,
  useTree
};
//# sourceMappingURL=index.mjs.map
