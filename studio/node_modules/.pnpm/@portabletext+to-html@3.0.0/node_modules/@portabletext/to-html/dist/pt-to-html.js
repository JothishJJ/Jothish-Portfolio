"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var toolkit = require("@portabletext/toolkit");
const allowedProtocols = ["http", "https", "mailto", "tel"], charMap = {
  "&": "amp",
  "<": "lt",
  ">": "gt",
  '"': "quot",
  "'": "#x27"
};
function escapeHTML(str) {
  return replaceMultipleSpaces(str.replace(/[&<>"']/g, (s) => `&${charMap[s]};`));
}
function replaceMultipleSpaces(str) {
  return str.replace(/ {2,}/g, (match) => `${"&nbsp;".repeat(match.length - 1)} `);
}
function uriLooksSafe(uri) {
  const url = (uri || "").trim(), first = url.charAt(0);
  if (first === "#" || first === "/")
    return !0;
  const colonIndex = url.indexOf(":");
  if (colonIndex === -1)
    return !0;
  const proto = url.slice(0, colonIndex).toLowerCase();
  if (allowedProtocols.indexOf(proto) !== -1)
    return !0;
  const queryIndex = url.indexOf("?");
  if (queryIndex !== -1 && colonIndex > queryIndex)
    return !0;
  const hashIndex = url.indexOf("#");
  return hashIndex !== -1 && colonIndex > hashIndex;
}
const defaultLists = {
  number: ({ children }) => `<ol>${children}</ol>`,
  bullet: ({ children }) => `<ul>${children}</ul>`
}, DefaultListItem = ({ children }) => `<li>${children}</li>`, link = ({ children, value }) => {
  const href = (value == null ? void 0 : value.href) || "";
  return uriLooksSafe(href) ? `<a href="${escapeHTML(href)}">${children}</a>` : children;
}, defaultMarks = {
  em: ({ children }) => `<em>${children}</em>`,
  strong: ({ children }) => `<strong>${children}</strong>`,
  code: ({ children }) => `<code>${children}</code>`,
  underline: ({ children }) => `<span style="text-decoration:underline">${children}</span>`,
  "strike-through": ({ children }) => `<del>${children}</del>`,
  link
}, getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \`components.${prop}\` option`, unknownTypeWarning = (typeName) => getTemplate(`block type "${typeName}"`, "types"), unknownMarkWarning = (markType) => getTemplate(`mark type "${markType}"`, "marks"), unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style "${blockStyle}"`, "block"), unknownListStyleWarning = (listStyle) => getTemplate(`list style "${listStyle}"`, "list"), unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
  console.warn(message);
}
const DefaultUnknownType = ({
  value,
  isInline
}) => {
  const warning = unknownTypeWarning(value._type);
  return isInline ? `<span style="display:none">${warning}</span>` : `<div style="display:none">${warning}</div>`;
}, DefaultUnknownMark = ({
  markType,
  children
}) => `<span class="unknown__pt__mark__${markType}">${children}</span>`, DefaultUnknownBlockStyle = ({
  children
}) => `<p>${children}</p>`, DefaultUnknownList = ({ children }) => `<ul>${children}</ul>`, DefaultUnknownListItem = ({
  children
}) => `<li>${children}</li>`, DefaultHardBreak = () => "<br/>", defaultPortableTextBlockStyles = {
  normal: ({ children }) => `<p>${children}</p>`,
  blockquote: ({ children }) => `<blockquote>${children}</blockquote>`,
  h1: ({ children }) => `<h1>${children}</h1>`,
  h2: ({ children }) => `<h2>${children}</h2>`,
  h3: ({ children }) => `<h3>${children}</h3>`,
  h4: ({ children }) => `<h4>${children}</h4>`,
  h5: ({ children }) => `<h5>${children}</h5>`,
  h6: ({ children }) => `<h6>${children}</h6>`
}, defaultComponents = {
  types: {},
  block: defaultPortableTextBlockStyles,
  marks: defaultMarks,
  list: defaultLists,
  listItem: DefaultListItem,
  hardBreak: DefaultHardBreak,
  escapeHTML,
  unknownType: DefaultUnknownType,
  unknownMark: DefaultUnknownMark,
  unknownList: DefaultUnknownList,
  unknownListItem: DefaultUnknownListItem,
  unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
  const { block, list, listItem, marks, types, ...rest } = overrides;
  return {
    ...parent,
    block: mergeDeeply(parent, overrides, "block"),
    list: mergeDeeply(parent, overrides, "list"),
    listItem: mergeDeeply(parent, overrides, "listItem"),
    marks: mergeDeeply(parent, overrides, "marks"),
    types: mergeDeeply(parent, overrides, "types"),
    ...rest
  };
}
function mergeDeeply(parent, overrides, key) {
  const override = overrides[key], parentVal = parent[key];
  return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? { ...parentVal, ...override } : parentVal;
}
function toHTML(value, options = {}) {
  const {
    components: componentOverrides,
    onMissingComponent: missingComponentHandler = printWarning
  } = options, handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(value) ? value : [value], nested = toolkit.nestLists(blocks, "html"), components = componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, renderNode = getNodeRenderer(components, handleMissingComponent);
  return nested.map(
    (node, index) => renderNode({ node, index, isInline: !1, renderNode })
  ).join("");
}
const getNodeRenderer = (components, handleMissingComponent) => {
  function renderNode(options) {
    const { node, index, isInline } = options;
    return toolkit.isPortableTextToolkitList(node) ? renderList(node, index) : toolkit.isPortableTextListItemBlock(node) ? renderListItem(node, index) : toolkit.isPortableTextToolkitSpan(node) ? renderSpan(node) : toolkit.isPortableTextBlock(node) ? renderBlock(node, index, isInline) : toolkit.isPortableTextToolkitTextNode(node) ? renderText(node) : renderCustomBlock(node, index, isInline);
  }
  function renderListItem(node, index) {
    const tree = serializeBlock({ node, index, isInline: !1, renderNode }), renderer = components.listItem, itemHandler = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
    if (itemHandler === components.unknownListItem) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListItemStyleWarning(style), {
        type: style,
        nodeType: "listItemStyle"
      });
    }
    let children = tree.children;
    if (node.style && node.style !== "normal") {
      const { listItem, ...blockNode } = node;
      children = renderNode({ node: blockNode, index, isInline: !1 });
    }
    return itemHandler({ value: node, index, isInline: !1, renderNode, children });
  }
  function renderList(node, index) {
    const children = node.children.map(
      (child, childIndex) => renderNode({
        node: child._key ? child : { ...child, _key: `li-${index}-${childIndex}` },
        index: childIndex,
        isInline: !1
      })
    ), component = components.list, list = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
    if (list === components.unknownList) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListStyleWarning(style), { nodeType: "listStyle", type: style });
    }
    return list({ value: node, index, isInline: !1, renderNode, children: children.join("") });
  }
  function renderSpan(node) {
    const { markDef, markType, markKey } = node, span = components.marks[markType] || components.unknownMark, children = node.children.map(
      (child, childIndex) => renderNode({ node: child, index: childIndex, isInline: !0 })
    );
    return span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), { nodeType: "mark", type: markType }), span({
      text: toolkit.spanToPlainText(node),
      value: markDef,
      markType,
      markKey,
      renderNode,
      children: children.join("")
    });
  }
  function renderBlock(node, index, isInline) {
    const { _key, ...props } = serializeBlock({ node, index, isInline, renderNode }), style = props.node.style || "normal", block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
    return block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
      nodeType: "blockStyle",
      type: style
    }), block({ ...props, value: props.node, renderNode });
  }
  function renderText(node) {
    if (node.text === `
`) {
      const hardBreak = components.hardBreak;
      return hardBreak ? hardBreak() : `
`;
    }
    return components.escapeHTML(node.text);
  }
  function renderCustomBlock(value, index, isInline) {
    const node = components.types[value._type];
    return node || handleMissingComponent(unknownTypeWarning(value._type), {
      nodeType: "block",
      type: value._type
    }), (node || components.unknownType)({
      value,
      isInline,
      index,
      renderNode
    });
  }
  return renderNode;
};
function serializeBlock(options) {
  const { node, index, isInline, renderNode } = options, children = toolkit.buildMarksTree(node).map(
    (child, i) => renderNode({ node: child, isInline: !0, index: i, renderNode })
  );
  return {
    _key: node._key || `block-${index}`,
    children: children.join(""),
    index,
    isInline,
    node
  };
}
function noop() {
}
exports.defaultComponents = defaultComponents;
exports.escapeHTML = escapeHTML;
exports.mergeComponents = mergeComponents;
exports.toHTML = toHTML;
exports.uriLooksSafe = uriLooksSafe;
//# sourceMappingURL=pt-to-html.js.map
