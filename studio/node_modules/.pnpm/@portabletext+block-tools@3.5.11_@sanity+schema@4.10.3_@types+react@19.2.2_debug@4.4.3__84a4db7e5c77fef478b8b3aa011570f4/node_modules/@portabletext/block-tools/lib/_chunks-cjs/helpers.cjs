"use strict";
var schema = require("@portabletext/schema"), isEqual = require("lodash/isEqual.js"), uniq = require("lodash/uniq.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq);
const objectToString = Object.prototype.toString;
function resolveJsType(val) {
  switch (objectToString.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  return val === null ? "null" : val === void 0 ? "undefined" : val && typeof val == "object" && "nodeType" in val && val.nodeType === 1 ? "element" : val === Object(val) ? "object" : typeof val;
}
function isArbitraryTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function flattenNestedBlocks(context, blocks) {
  return blocks.flatMap((block) => {
    if (isBlockContainer(block))
      return flattenNestedBlocks(context, [block.block]);
    if (schema.isTextBlock(context, block)) {
      const hasBlockObjects = block.children.some((child) => context.schema.blockObjects.some(
        (blockObject) => blockObject.name === child._type
      )), hasBlocks = block.children.some(
        (child) => child._type === "__block" || child._type === "block"
      );
      if (hasBlockObjects || hasBlocks) {
        const splitChildren = getSplitChildren(context, block);
        return splitChildren.length === 1 && splitChildren[0].type === "children" && isEqual__default.default(splitChildren[0].children, block.children) ? [block] : splitChildren.flatMap((slice) => slice.type === "block object" ? [slice.block] : slice.type === "block" ? flattenNestedBlocks(context, [
          slice.block
        ]) : slice.children.length > 0 ? slice.children.every(
          (child) => schema.isSpan(context, child) && child.text.trim() === ""
        ) ? [] : flattenNestedBlocks(context, [
          {
            ...block,
            children: slice.children
          }
        ]) : []);
      }
      return [block];
    }
    return [block];
  });
}
function isBlockContainer(block) {
  return block._type === "__block" && isArbitraryTypedObject(block.block);
}
function getSplitChildren(context, block) {
  return block.children.reduce(
    (slices, child) => {
      const knownInlineObject = context.schema.inlineObjects.some(
        (inlineObject) => inlineObject.name === child._type
      ), knownBlockObject = context.schema.blockObjects.some(
        (blockObject) => blockObject.name === child._type
      ), lastSlice = slices.pop();
      return !schema.isSpan(context, child) && !knownInlineObject && knownBlockObject ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "block object", block: child }
      ] : child._type === "__block" ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        {
          type: "block object",
          block: child.block
        }
      ] : child._type === "block" ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "block", block: child }
      ] : lastSlice && lastSlice.type === "children" ? [
        ...slices,
        {
          type: "children",
          children: [...lastSlice.children, child]
        }
      ] : [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "children", children: [child] }
      ];
    },
    []
  );
}
var s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 };
new Array(4).fill(String.fromCodePoint(c[0])).join("");
Object.fromEntries(Object.entries(c).map((t) => t.reverse()));
Object.fromEntries(Object.entries(s).map((t) => t.reverse()));
var S = `${Object.values(s).map((t) => `\\u{${t.toString(16)}}`).join("")}`, f = new RegExp(`[${S}]{4,}`, "gu");
function _(t) {
  var e;
  return { cleaned: t.replace(f, ""), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || "" };
}
function O(t) {
  return t && JSON.parse(_(JSON.stringify(t)).cleaned);
}
const PRESERVE_WHITESPACE_TAGS = ["pre", "textarea", "code"], BLOCK_DEFAULT_STYLE = "normal", DEFAULT_BLOCK = Object.freeze({
  _type: "block",
  markDefs: [],
  style: BLOCK_DEFAULT_STYLE
}), DEFAULT_SPAN = Object.freeze({
  _type: "span",
  marks: []
}), HTML_BLOCK_TAGS = {
  p: DEFAULT_BLOCK,
  blockquote: { ...DEFAULT_BLOCK, style: "blockquote" }
}, HTML_SPAN_TAGS = {
  span: { object: "text" }
}, HTML_LIST_CONTAINER_TAGS = {
  ol: { object: null },
  ul: { object: null }
}, HTML_HEADER_TAGS = {
  h1: { ...DEFAULT_BLOCK, style: "h1" },
  h2: { ...DEFAULT_BLOCK, style: "h2" },
  h3: { ...DEFAULT_BLOCK, style: "h3" },
  h4: { ...DEFAULT_BLOCK, style: "h4" },
  h5: { ...DEFAULT_BLOCK, style: "h5" },
  h6: { ...DEFAULT_BLOCK, style: "h6" }
}, HTML_MISC_TAGS = {
  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }
}, HTML_DECORATOR_TAGS = {
  b: "strong",
  strong: "strong",
  i: "em",
  em: "em",
  u: "underline",
  s: "strike-through",
  strike: "strike-through",
  del: "strike-through",
  code: "code",
  sup: "sup",
  sub: "sub",
  ins: "ins",
  mark: "mark",
  small: "small"
}, HTML_LIST_ITEM_TAGS = {
  li: {
    ...DEFAULT_BLOCK,
    style: BLOCK_DEFAULT_STYLE,
    level: 1,
    listItem: "bullet"
  }
}, ELEMENT_MAP = {
  ...HTML_BLOCK_TAGS,
  ...HTML_SPAN_TAGS,
  ...HTML_LIST_CONTAINER_TAGS,
  ...HTML_LIST_ITEM_TAGS,
  ...HTML_HEADER_TAGS,
  ...HTML_MISC_TAGS
};
uniq__default.default(
  Object.values(ELEMENT_MAP).filter((tag) => "style" in tag).map((tag) => tag.style)
);
uniq__default.default(
  Object.values(HTML_DECORATOR_TAGS)
);
const _XPathResult = {
  BOOLEAN_TYPE: 3,
  ORDERED_NODE_ITERATOR_TYPE: 5,
  UNORDERED_NODE_SNAPSHOT_TYPE: 6
};
var preprocessGDocs = (_html, doc, options) => {
  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || "preserve";
  let gDocsRootOrSiblingNode = doc.evaluate(
    '//*[@id and contains(@id, "docs-internal-guid")]',
    doc,
    null,
    _XPathResult.ORDERED_NODE_ITERATOR_TYPE,
    null
  ).iterateNext();
  if (gDocsRootOrSiblingNode) {
    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === "b";
    switch (isWrappedRootTag || (gDocsRootOrSiblingNode = doc.body), whitespaceOnPasteMode) {
      case "normalize":
        normalizeWhitespace(gDocsRootOrSiblingNode);
        break;
      case "remove":
        removeAllWhitespace(gDocsRootOrSiblingNode);
        break;
    }
    const childNodes = doc.evaluate(
      "//*",
      doc,
      null,
      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
      null
    );
    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {
      const elm = childNodes.snapshotItem(i);
      elm?.setAttribute("data-is-google-docs", "true"), (elm?.parentElement === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) && (elm?.setAttribute("data-is-root-node", "true"), tagName(elm)), tagName(elm) === "li" && elm.firstChild && tagName(elm?.firstChild) === "img" && elm.removeChild(elm.firstChild);
    }
    return isWrappedRootTag && doc.body.firstElementChild?.replaceWith(
      ...Array.from(gDocsRootOrSiblingNode.childNodes)
    ), doc;
  }
  return doc;
};
const unwantedWordDocumentPaths = [
  "/html/text()",
  "/html/head/text()",
  "/html/body/text()",
  "/html/body/ul/text()",
  "/html/body/ol/text()",
  "//comment()",
  "//style",
  "//xml",
  "//script",
  "//meta",
  "//link"
];
var preprocessHTML = (_html, doc) => {
  const bodyTextNodes = doc.evaluate(
    "/html/body/text()",
    doc,
    null,
    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
    null
  );
  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {
    const node = bodyTextNodes.snapshotItem(i), text = node.textContent || "";
    if (text.replace(/[^\S\n]+$/g, "")) {
      const newNode = doc.createElement("span");
      newNode.appendChild(doc.createTextNode(text)), node.parentNode?.replaceChild(newNode, node);
    } else
      node.parentNode?.removeChild(node);
  }
  const unwantedNodes = doc.evaluate(
    unwantedWordDocumentPaths.join("|"),
    doc,
    null,
    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
    null
  );
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    unwanted && unwanted.parentNode?.removeChild(unwanted);
  }
  return doc;
}, preprocessNotion = (html, doc) => {
  const NOTION_REGEX = /<!-- notionvc:.*?-->/g;
  if (html.match(NOTION_REGEX)) {
    const childNodes = doc.evaluate(
      "//*",
      doc,
      null,
      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
      null
    );
    for (let i = childNodes.snapshotLength - 1; i >= 0; i--)
      childNodes.snapshotItem(i)?.setAttribute("data-is-notion", "true");
    return doc;
  }
  return doc;
}, preprocessWhitespace = (_2, doc) => {
  function processNode(node) {
    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(
      node.parentElement?.tagName.toLowerCase() || ""
    ))
      node.textContent = node.textContent?.replace(/\s\s+/g, " ").replace(/[\r\n]+/g, " ") || "";
    else
      for (let i = 0; i < node.childNodes.length; i++)
        processNode(node.childNodes[i]);
  }
  return processNode(doc.body), doc;
};
const WORD_HTML_REGEX = /(class="?Mso|style=(?:"|')[^"]*?\bmso-|w:WordDocument|<o:\w+>|<\/font>)/, unwantedPaths = [
  "//o:p",
  "//span[@style='mso-list:Ignore']",
  "//span[@style='mso-list: Ignore']"
], mappedPaths = [
  "//p[@class='MsoTocHeading']",
  "//p[@class='MsoTitle']",
  "//p[@class='MsoToaHeading']",
  "//p[@class='MsoSubtitle']",
  "//span[@class='MsoSubtleEmphasis']",
  "//span[@class='MsoIntenseEmphasis']"
], elementMap = {
  MsoTocHeading: ["h3"],
  MsoTitle: ["h1"],
  MsoToaHeading: ["h2"],
  MsoSubtitle: ["h5"],
  MsoSubtleEmphasis: ["span", "em"],
  MsoIntenseEmphasis: ["span", "em", "strong"]
  // Remove cruft
};
function isWordHtml(html) {
  return WORD_HTML_REGEX.test(html);
}
var preprocessWord = (html, doc) => {
  if (!isWordHtml(html))
    return doc;
  const unwantedNodes = doc.evaluate(
    unwantedPaths.join("|"),
    doc,
    (prefix) => prefix === "o" ? "urn:schemas-microsoft-com:office:office" : null,
    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
    null
  );
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    unwanted?.parentNode && unwanted.parentNode.removeChild(unwanted);
  }
  const mappedElements = doc.evaluate(
    mappedPaths.join("|"),
    doc,
    null,
    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
    null
  );
  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {
    const mappedElm = mappedElements.snapshotItem(i), tags = elementMap[mappedElm.className], text = doc.createTextNode(mappedElm.textContent || "");
    if (!tags)
      continue;
    const parentElement = doc.createElement(tags[0]);
    let parent = parentElement, child = parentElement;
    tags.slice(1).forEach((tag) => {
      child = doc.createElement(tag), parent.appendChild(child), parent = child;
    }), child.appendChild(text), mappedElm?.parentNode?.replaceChild(parentElement, mappedElm);
  }
  return doc;
}, preprocessors = [
  preprocessWhitespace,
  preprocessNotion,
  preprocessWord,
  preprocessGDocs,
  preprocessHTML
];
function tagName(el) {
  if (el && "tagName" in el)
    return el.tagName.toLowerCase();
}
function preprocess(html, parseHtml, options) {
  const cleanHTML = O(html), doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML));
  return preprocessors.forEach((processor) => {
    processor(cleanHTML, doc, options);
  }), doc;
}
function normalizeHtmlBeforePreprocess(html) {
  return html.trim();
}
function defaultParseHtml() {
  if (resolveJsType(DOMParser) === "undefined")
    throw new Error(
      "The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead."
    );
  return (html) => new DOMParser().parseFromString(html, "text/html");
}
function nextSpan(block, index) {
  const next = block.children[index + 1];
  return next && next._type === "span" ? next : null;
}
function prevSpan(block, index) {
  const prev = block.children[index - 1];
  return prev && prev._type === "span" ? prev : null;
}
function isWhiteSpaceChar(text) {
  return ["\xA0", " "].includes(text);
}
function trimWhitespace(schema$1, blocks) {
  return blocks.forEach((block) => {
    schema.isTextBlock({ schema: schema$1 }, block) && block.children.forEach((child, index) => {
      if (!isMinimalSpan(child))
        return;
      const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);
      index === 0 && (child.text = child.text.replace(/^[^\S\n]+/g, "")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\S\n]+$/g, "")), /\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\S\n]+$/g, "")), /\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\S\n]+/g, "")), child.text || block.children.splice(index, 1), prevChild && isEqual__default.default(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += " ", block.children.splice(index, 1)) : nextChild && isEqual__default.default(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = ` ${nextChild.text}`, block.children.splice(index, 1));
    });
  }), blocks;
}
function ensureRootIsBlocks(schema$1, objects) {
  return objects.reduce((blocks, node, i, original) => {
    if (node._type === "block")
      return blocks.push(node), blocks;
    if (node._type === "__block")
      return blocks.push(node.block), blocks;
    const lastBlock = blocks[blocks.length - 1];
    if (i > 0 && !schema.isTextBlock({ schema: schema$1 }, original[i - 1]) && schema.isTextBlock({ schema: schema$1 }, lastBlock))
      return lastBlock.children.push(node), blocks;
    const block = {
      ...DEFAULT_BLOCK,
      children: [node]
    };
    return blocks.push(block), blocks;
  }, []);
}
function isNodeList(node) {
  return Object.prototype.toString.call(node) === "[object NodeList]";
}
function isMinimalSpan(node) {
  return node._type === "span";
}
function isMinimalBlock(node) {
  return node._type === "block";
}
function isPlaceholderDecorator(node) {
  return node._type === "__decorator";
}
function isPlaceholderAnnotation(node) {
  return node._type === "__annotation";
}
function isElement(node) {
  return node.nodeType === 1;
}
function normalizeWhitespace(rootNode) {
  let emptyBlockCount = 0, lastParent = null;
  const nodesToRemove = [];
  for (let child = rootNode.firstChild; child; child = child.nextSibling) {
    if (!isElement(child)) {
      normalizeWhitespace(child), emptyBlockCount = 0;
      continue;
    }
    const elm = child;
    isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);
  }
  nodesToRemove.forEach((node) => {
    node.parentElement?.removeChild(node);
  });
}
function removeAllWhitespace(rootNode) {
  const nodesToRemove = [];
  function collectNodesToRemove(currentNode) {
    if (isElement(currentNode)) {
      const elm = currentNode;
      if (tagName(elm) === "br" && (tagName(elm.nextElementSibling) === "p" || tagName(elm.previousElementSibling) === "p")) {
        nodesToRemove.push(elm);
        return;
      }
      if ((tagName(elm) === "p" || tagName(elm) === "br") && elm?.firstChild?.textContent?.trim() === "") {
        nodesToRemove.push(elm);
        return;
      }
      for (let child = elm.firstChild; child; child = child.nextSibling)
        collectNodesToRemove(child);
    }
  }
  collectNodesToRemove(rootNode), nodesToRemove.forEach((node) => {
    node.parentElement?.removeChild(node);
  });
}
function isWhitespaceBlock(elm) {
  return ["p", "br"].includes(tagName(elm) || "") && !elm.textContent?.trim();
}
exports.BLOCK_DEFAULT_STYLE = BLOCK_DEFAULT_STYLE;
exports.DEFAULT_BLOCK = DEFAULT_BLOCK;
exports.DEFAULT_SPAN = DEFAULT_SPAN;
exports.HTML_BLOCK_TAGS = HTML_BLOCK_TAGS;
exports.HTML_DECORATOR_TAGS = HTML_DECORATOR_TAGS;
exports.HTML_HEADER_TAGS = HTML_HEADER_TAGS;
exports.HTML_LIST_CONTAINER_TAGS = HTML_LIST_CONTAINER_TAGS;
exports.HTML_LIST_ITEM_TAGS = HTML_LIST_ITEM_TAGS;
exports.HTML_SPAN_TAGS = HTML_SPAN_TAGS;
exports.defaultParseHtml = defaultParseHtml;
exports.ensureRootIsBlocks = ensureRootIsBlocks;
exports.flattenNestedBlocks = flattenNestedBlocks;
exports.isElement = isElement;
exports.isMinimalBlock = isMinimalBlock;
exports.isMinimalSpan = isMinimalSpan;
exports.isNodeList = isNodeList;
exports.isPlaceholderAnnotation = isPlaceholderAnnotation;
exports.isPlaceholderDecorator = isPlaceholderDecorator;
exports.preprocess = preprocess;
exports.resolveJsType = resolveJsType;
exports.tagName = tagName;
exports.trimWhitespace = trimWhitespace;
//# sourceMappingURL=helpers.cjs.map
