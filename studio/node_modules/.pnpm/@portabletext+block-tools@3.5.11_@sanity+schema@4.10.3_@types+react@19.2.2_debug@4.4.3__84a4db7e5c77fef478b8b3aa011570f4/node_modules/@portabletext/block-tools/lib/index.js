import { sanitySchemaToPortableTextSchema } from "@portabletext/sanity-bridge";
import { isTextBlock, isSpan } from "@portabletext/schema";
import flatten from "lodash/flatten.js";
import getRandomValues from "get-random-values-esm";
import { isElement, tagName, DEFAULT_SPAN, DEFAULT_BLOCK, HTML_HEADER_TAGS, HTML_BLOCK_TAGS, BLOCK_DEFAULT_STYLE, HTML_LIST_CONTAINER_TAGS, HTML_SPAN_TAGS, HTML_LIST_ITEM_TAGS, HTML_DECORATOR_TAGS, defaultParseHtml, preprocess, trimWhitespace, flattenNestedBlocks, ensureRootIsBlocks, resolveJsType, isPlaceholderDecorator, isPlaceholderAnnotation, isMinimalBlock, isMinimalSpan, isNodeList } from "./_chunks-es/helpers.js";
import isEqual from "lodash/isEqual.js";
function keyGenerator() {
  return randomKey(12);
}
function whatwgRNG(length = 16) {
  const rnds8 = new Uint8Array(length);
  return getRandomValues(rnds8), rnds8;
}
const byteToHex = [];
for (let i = 0; i < 256; ++i)
  byteToHex[i] = (i + 256).toString(16).slice(1);
function randomKey(length) {
  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], "").slice(0, length);
}
const LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);
function isEmphasis$1(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-style\s*:\s*italic/.test(style || "");
}
function isStrong$1(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-weight\s*:\s*700/.test(style || "");
}
function isUnderline$1(el) {
  if (!isElement(el) || tagName(el.parentNode) === "a")
    return !1;
  const style = isElement(el) && el.getAttribute("style");
  return /text-decoration\s*:\s*underline/.test(style || "");
}
function isStrikethrough(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /text-decoration\s*:\s*(?:.*line-through.*;)/.test(style || "");
}
function isGoogleDocs(el) {
  return isElement(el) && !!el.getAttribute("data-is-google-docs");
}
function isRootNode(el) {
  return isElement(el) && !!el.getAttribute("data-is-root-node");
}
function getListItemStyle$1(el) {
  const parentTag = tagName(el.parentNode);
  if (!(parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)))
    return tagName(el.parentNode) === "ul" ? "bullet" : "number";
}
function getListItemLevel$1(el) {
  let level = 0;
  if (tagName(el) === "li") {
    let parentNode = el.parentNode;
    for (; parentNode; ) {
      const parentTag = tagName(parentNode);
      parentTag && LIST_CONTAINER_TAGS.includes(parentTag) && level++, parentNode = parentNode.parentNode;
    }
  } else
    level = 1;
  return level;
}
const blocks = {
  ...HTML_BLOCK_TAGS,
  ...HTML_HEADER_TAGS
};
function getBlockStyle(schema, el) {
  const childTag = tagName(el.firstChild), block = childTag && blocks[childTag];
  return block ? schema.styles.some((style) => style.name === block.style) ? block.style : BLOCK_DEFAULT_STYLE : BLOCK_DEFAULT_STYLE;
}
function createGDocsRules(schema) {
  return [
    {
      deserialize(el, next) {
        if (isElement(el) && tagName(el) === "span" && isGoogleDocs(el)) {
          if (!el.textContent)
            return !el.previousSibling && !el.nextSibling && el.setAttribute("data-lonely-child", "true"), next(el.childNodes);
          const span = {
            ...DEFAULT_SPAN,
            marks: [],
            text: el.textContent
          };
          return isStrong$1(el) && span.marks.push("strong"), isUnderline$1(el) && span.marks.push("underline"), isStrikethrough(el) && span.marks.push("strike-through"), isEmphasis$1(el) && span.marks.push("em"), span;
        }
      }
    },
    {
      deserialize(el, next) {
        if (tagName(el) === "li" && isGoogleDocs(el))
          return {
            ...DEFAULT_BLOCK,
            listItem: getListItemStyle$1(el),
            level: getListItemLevel$1(el),
            style: getBlockStyle(schema, el),
            children: next(el.firstChild?.childNodes || [])
          };
      }
    },
    {
      deserialize(el) {
        if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && el.classList.contains("apple-interchange-newline"))
          return {
            ...DEFAULT_SPAN,
            text: ""
          };
        if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && el?.parentNode?.textContent === "")
          return {
            ...DEFAULT_SPAN,
            text: ""
          };
        if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && isRootNode(el))
          return {
            ...DEFAULT_SPAN,
            text: ""
          };
      }
    }
  ];
}
const whitespaceTextNodeRule = {
  deserialize(node) {
    return node.nodeName === "#text" && isWhitespaceTextNode(node) ? {
      ...DEFAULT_SPAN,
      marks: [],
      text: (node.textContent ?? "").replace(/\s\s+/g, " ")
    } : void 0;
  }
};
function isWhitespaceTextNode(node) {
  return (node.nodeType === 3 && (node.textContent || "").replace(/[\r\n]/g, " ").replace(/\s\s+/g, " ") === " " && node.nextSibling && node.nextSibling.nodeType !== 3 && node.previousSibling && node.previousSibling.nodeType !== 3 || node.textContent !== " ") && tagName(node.parentNode) !== "body";
}
function resolveListItem(schema, listNodeTagName) {
  if (listNodeTagName === "ul" && schema.lists.some((list) => list.name === "bullet"))
    return "bullet";
  if (listNodeTagName === "ol" && schema.lists.some((list) => list.name === "number"))
    return "number";
}
function createHTMLRules(schema, options) {
  return [
    whitespaceTextNodeRule,
    {
      // Pre element
      deserialize(el) {
        if (tagName(el) !== "pre")
          return;
        const isCodeEnabled = schema.styles.some(
          (style) => style.name === "code"
        );
        return {
          _type: "block",
          style: "normal",
          markDefs: [],
          children: [
            {
              ...DEFAULT_SPAN,
              marks: isCodeEnabled ? ["code"] : [],
              text: el.textContent || ""
            }
          ]
        };
      }
    },
    // Blockquote element
    {
      deserialize(el, next) {
        if (tagName(el) !== "blockquote")
          return;
        const blocks2 = {
          ...HTML_BLOCK_TAGS,
          ...HTML_HEADER_TAGS
        };
        delete blocks2.blockquote;
        const nonBlockquoteBlocks = Object.keys(blocks2), children = [];
        return el.childNodes.forEach((node, index) => {
          if (el.ownerDocument)
            if (node.nodeType === 1 && nonBlockquoteBlocks.includes(
              node.localName.toLowerCase()
            )) {
              const span = el.ownerDocument.createElement("span"), previousChild = children[children.length - 1];
              previousChild && previousChild.nodeType === 3 && previousChild.textContent?.trim() && span.appendChild(el.ownerDocument.createTextNode("\r")), node.childNodes.forEach((cn) => {
                span.appendChild(cn.cloneNode(!0));
              }), index !== el.childNodes.length && span.appendChild(el.ownerDocument.createTextNode("\r")), children.push(span);
            } else
              children.push(node);
        }), {
          _type: "block",
          style: "blockquote",
          markDefs: [],
          children: next(children)
        };
      }
    },
    // Block elements
    {
      deserialize(el, next) {
        const blocks2 = {
          ...HTML_BLOCK_TAGS,
          ...HTML_HEADER_TAGS
        }, tag = tagName(el);
        let block = tag ? blocks2[tag] : void 0;
        if (!block)
          return;
        if (el.parentNode && tagName(el.parentNode) === "li")
          return next(el.childNodes);
        const blockStyle = block.style;
        return schema.styles.some((style) => style.name === blockStyle) || (block = DEFAULT_BLOCK), {
          ...block,
          children: next(el.childNodes)
        };
      }
    },
    // Ignore span tags
    {
      deserialize(el, next) {
        const tag = tagName(el);
        if (!(!tag || !(tag in HTML_SPAN_TAGS)))
          return next(el.childNodes);
      }
    },
    // Ignore div tags
    {
      deserialize(el, next) {
        if (tagName(el) === "div")
          return next(el.childNodes);
      }
    },
    // Ignore list containers
    {
      deserialize(el, next) {
        const tag = tagName(el);
        if (!(!tag || !(tag in HTML_LIST_CONTAINER_TAGS)))
          return next(el.childNodes);
      }
    },
    // Deal with br's
    {
      deserialize(el) {
        if (tagName(el) === "br")
          return {
            ...DEFAULT_SPAN,
            text: `
`
          };
      }
    },
    // Deal with list items
    {
      deserialize(el, next, block) {
        const tag = tagName(el), listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0, parentTag = tagName(el.parentNode) || "";
        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag])
          return;
        const enabledListItem = resolveListItem(schema, parentTag);
        return enabledListItem ? (listItem.listItem = enabledListItem, {
          ...listItem,
          children: next(el.childNodes)
        }) : block({ _type: "block", children: next(el.childNodes) });
      }
    },
    // Deal with decorators - this is a limited set of known html elements that we know how to deserialize
    {
      deserialize(el, next) {
        const decorator = HTML_DECORATOR_TAGS[tagName(el) || ""];
        if (!(!decorator || !schema.decorators.some(
          (decoratorType) => decoratorType.name === decorator
        )))
          return {
            _type: "__decorator",
            name: decorator,
            children: next(el.childNodes)
          };
      }
    },
    // Special case for hyperlinks, add annotation (if allowed by schema),
    // If not supported just write out the link text and href in plain text.
    {
      deserialize(el, next) {
        if (tagName(el) !== "a")
          return;
        const linkEnabled = schema.annotations.some(
          (annotation) => annotation.name === "link"
        ), href = isElement(el) && el.getAttribute("href");
        return href ? linkEnabled ? {
          _type: "__annotation",
          markDef: {
            _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),
            _type: "link",
            href
          },
          children: next(el.childNodes)
        } : el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes) : next(el.childNodes);
      }
    },
    {
      deserialize(el, next) {
        if (isElement(el) && (tagName(el) === "td" || tagName(el) === "th"))
          return {
            ...DEFAULT_BLOCK,
            children: next(el.childNodes)
          };
      }
    },
    {
      deserialize(el) {
        if (isElement(el) && tagName(el) === "img") {
          const src = el.getAttribute("src") ?? void 0, alt = el.getAttribute("alt") ?? void 0, props = Object.fromEntries(
            Array.from(el.attributes).map((attr) => [attr.name, attr.value])
          ), ancestorOfLonelyChild = el?.parentElement?.parentElement?.getAttribute("data-lonely-child"), ancestorOfListItem = el.closest("li") !== null;
          if (ancestorOfLonelyChild && !ancestorOfListItem) {
            const image2 = options.matchers?.image?.({
              context: {
                schema,
                keyGenerator: options.keyGenerator ?? keyGenerator
              },
              props: {
                ...props,
                ...src ? { src } : {},
                ...alt ? { alt } : {}
              }
            });
            if (image2)
              return {
                _type: "__block",
                block: image2
              };
          }
          const inlineImage = options.matchers?.inlineImage?.({
            context: {
              schema,
              keyGenerator: options.keyGenerator ?? keyGenerator
            },
            props: {
              ...props,
              ...src ? { src } : {},
              ...alt ? { alt } : {}
            }
          });
          if (inlineImage)
            return inlineImage;
          const image = options.matchers?.image?.({
            context: {
              schema,
              keyGenerator: options.keyGenerator ?? keyGenerator
            },
            props: {
              ...props,
              ...src ? { src } : {},
              ...alt ? { alt } : {}
            }
          });
          if (image)
            return {
              _type: "__block",
              block: image
            };
        }
      }
    }
  ];
}
function isEmphasis(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-style:italic/.test(style || "");
}
function isStrong(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-weight:700/.test(style || "") || /font-weight:600/.test(style || "");
}
function isUnderline(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /text-decoration:underline/.test(style || "");
}
function isNotion(el) {
  return isElement(el) && !!el.getAttribute("data-is-notion");
}
function createNotionRules() {
  return [
    {
      deserialize(el) {
        if (isElement(el) && tagName(el) === "span" && isNotion(el)) {
          const span = {
            ...DEFAULT_SPAN,
            marks: [],
            text: el.textContent
          };
          return isStrong(el) && span.marks.push("strong"), isUnderline(el) && span.marks.push("underline"), isEmphasis(el) && span.marks.push("em"), span;
        }
      }
    }
  ];
}
function getListItemStyle(el) {
  const style = isElement(el) && el.getAttribute("style");
  if (style && style.match(/lfo\d+/))
    return style.match("lfo1") ? "bullet" : "number";
}
function getListItemLevel(el) {
  const style = isElement(el) && el.getAttribute("style");
  if (!style)
    return;
  const levelMatch = style.match(/level\d+/);
  if (!levelMatch)
    return;
  const [level] = levelMatch[0].match(/\d/) || [];
  return (level ? Number.parseInt(level, 10) : 1) || 1;
}
function isWordListElement(el) {
  return isElement(el) && el.className ? el.className === "MsoListParagraphCxSpFirst" || el.className === "MsoListParagraphCxSpMiddle" || el.className === "MsoListParagraphCxSpLast" : !1;
}
function createWordRules() {
  return [
    {
      deserialize(el, next) {
        if (tagName(el) === "p" && isWordListElement(el))
          return {
            ...DEFAULT_BLOCK,
            listItem: getListItemStyle(el),
            level: getListItemLevel(el),
            style: BLOCK_DEFAULT_STYLE,
            children: next(el.childNodes)
          };
      }
    }
  ];
}
function createRules(schema, options) {
  return [
    ...createWordRules(),
    ...createNotionRules(),
    ...createGDocsRules(schema),
    ...createHTMLRules(schema, options)
  ];
}
class HtmlDeserializer {
  keyGenerator;
  schema;
  rules;
  parseHtml;
  _markDefs = [];
  /**
   * Create a new serializer respecting a Sanity block content type's schema
   *
   * @param blockContentType - Schema type for array containing _at least_ a block child type
   * @param options - Options for the deserialization process
   */
  constructor(schema, options = {}) {
    const { rules = [], unstable_whitespaceOnPasteMode = "preserve" } = options, standardRules = createRules(schema, {
      keyGenerator: options.keyGenerator,
      matchers: options.matchers
    });
    this.schema = schema, this.keyGenerator = options.keyGenerator ?? keyGenerator, this.rules = [...rules, ...standardRules];
    const parseHtml = options.parseHtml || defaultParseHtml();
    this.parseHtml = (html) => preprocess(html, parseHtml, { unstable_whitespaceOnPasteMode }).body;
  }
  /**
   * Deserialize HTML.
   *
   * @param html - The HTML to deserialize, as a string
   * @returns Array of blocks - either portable text blocks or other allowed blocks
   */
  deserialize = (html) => {
    this._markDefs = [];
    const { parseHtml } = this, fragment = parseHtml(html), children = Array.from(fragment.childNodes), blocks2 = trimWhitespace(
      this.schema,
      flattenNestedBlocks(
        { schema: this.schema },
        ensureRootIsBlocks(
          this.schema,
          this.deserializeElements(children)
        )
      )
    );
    return this._markDefs.length > 0 && blocks2.filter((block) => isTextBlock({ schema: this.schema }, block)).forEach((block) => {
      block.markDefs = block.markDefs || [], block.markDefs = block.markDefs.concat(
        this._markDefs.filter((def) => flatten(
          block.children.map((child) => child.marks || [])
        ).includes(def._key))
      );
    }), blocks2.map((block) => (block._type === "block" && (block._type = this.schema.block.name), block));
  };
  /**
   * Deserialize an array of DOM elements.
   *
   * @param elements - Array of DOM elements to deserialize
   * @returns
   */
  deserializeElements = (elements = []) => {
    let nodes = [];
    return elements.forEach((element) => {
      nodes = nodes.concat(this.deserializeElement(element));
    }), nodes;
  };
  /**
   * Deserialize a DOM element
   *
   * @param element - Deserialize a DOM element
   * @returns
   */
  deserializeElement = (element) => {
    const next = (elements) => {
      if (isNodeList(elements))
        return this.deserializeElements(Array.from(elements));
      if (Array.isArray(elements))
        return this.deserializeElements(elements);
      if (elements)
        return this.deserializeElement(elements);
    }, block = (props) => ({
      _type: "__block",
      block: props
    });
    let node;
    for (let i = 0; i < this.rules.length; i++) {
      const rule = this.rules[i];
      if (!rule.deserialize)
        continue;
      const ret = rule.deserialize(element, next, block), type = resolveJsType(ret);
      if (type !== "array" && type !== "object" && type !== "null" && type !== "undefined")
        throw new Error(
          `A rule returned an invalid deserialized representation: "${node}".`
        );
      if (ret !== void 0) {
        {
          if (ret === null)
            throw new Error("Deserializer rule returned `null`");
          Array.isArray(ret) ? node = ret : isPlaceholderDecorator(ret) ? node = this.deserializeDecorator(ret) : isPlaceholderAnnotation(ret) ? node = this.deserializeAnnotation(ret) : node = ret;
        }
        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && "listItem" in ret) {
          let parent = element.parentNode?.parentNode;
          for (; parent && tagName(parent) === "li"; )
            parent = parent.parentNode?.parentNode, ret.level = ret.level ? ret.level + 1 : 1;
        }
        ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === "blockquote" && ret.children.forEach((child, index) => {
          isMinimalSpan(child) && child.text === "\r" && (child.text = `
`, (index === 0 || index === ret.children.length - 1) && ret.children.splice(index, 1));
        });
        break;
      }
    }
    return node || next(element.childNodes) || [];
  };
  /**
   * Deserialize a `__decorator` type
   * (an internal made up type to process decorators exclusively)
   *
   * @param decorator -
   * @returns array of ...
   */
  deserializeDecorator = (decorator) => {
    const { name } = decorator, applyDecorator = (node) => {
      if (isPlaceholderDecorator(node))
        return this.deserializeDecorator(node);
      if (isMinimalSpan(node))
        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(name);
      else if ("children" in node && Array.isArray(node.children)) {
        const block = node;
        block.children = block.children.map(applyDecorator);
      }
      return node;
    };
    return decorator.children.reduce((children, node) => {
      const ret = applyDecorator(node);
      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);
    }, []);
  };
  /**
   * Deserialize a `__annotation` object.
   * (an internal made up type to process annotations exclusively)
   *
   * @param annotation -
   * @returns Array of...
   */
  deserializeAnnotation = (annotation) => {
    const { markDef } = annotation;
    this._markDefs.push(markDef);
    const applyAnnotation = (node) => {
      if (isPlaceholderAnnotation(node))
        return this.deserializeAnnotation(node);
      if (isMinimalSpan(node))
        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(markDef._key);
      else if ("children" in node && Array.isArray(node.children)) {
        const block = node;
        block.children = block.children.map(applyAnnotation);
      }
      return node;
    };
    return annotation.children.reduce((children, node) => {
      const ret = applyAnnotation(node);
      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);
    }, []);
  };
}
function normalizeBlock(node, options = {}) {
  const schema = {
    block: {
      name: options.blockTypeName || "block"
    },
    span: {
      name: "span"
    },
    styles: [],
    lists: [],
    decorators: [],
    annotations: [],
    blockObjects: [],
    inlineObjects: []
  };
  if (node._type !== (options.blockTypeName || "block"))
    return "_key" in node ? node : {
      ...node,
      _key: options.keyGenerator ? options.keyGenerator() : keyGenerator()
    };
  const block = {
    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),
    children: [],
    markDefs: [],
    ...node
  }, lastChild = block.children[block.children.length - 1];
  if (!lastChild)
    return block.children = [
      {
        _type: "span",
        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),
        text: "",
        marks: []
      }
    ], block;
  const usedMarkDefs = [], allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : !1;
  return block.children = block.children.reduce(
    (acc, child) => {
      const previousChild = acc[acc.length - 1];
      return previousChild && isSpan({ schema }, child) && isSpan({ schema }, previousChild) && isEqual(previousChild.marks, child.marks) ? (lastChild && lastChild === child && child.text === "" && block.children.length > 1 || (previousChild.text += child.text), acc) : (acc.push(child), acc);
    },
    []
  ).map((child) => {
    if (!child)
      throw new Error("missing child");
    return child._key = options.keyGenerator ? options.keyGenerator() : keyGenerator(), isSpan({ schema }, child) && (child.marks ? allowedDecorators && (child.marks = child.marks.filter((mark) => {
      const isAllowed = allowedDecorators.includes(mark), isUsed = block.markDefs?.some((def) => def._key === mark);
      return isAllowed || isUsed;
    })) : child.marks = [], usedMarkDefs.push(...child.marks)), child;
  }), block.markDefs = (block.markDefs || []).filter(
    (markDef) => usedMarkDefs.includes(markDef._key)
  ), block;
}
function htmlToBlocks(html, schemaType, options = {}) {
  const schema = isSanitySchema(schemaType) ? sanitySchemaToPortableTextSchema(schemaType) : schemaType;
  return new HtmlDeserializer(schema, options).deserialize(html).map((block) => normalizeBlock(block, { keyGenerator: options.keyGenerator }));
}
function isSanitySchema(schema) {
  return schema.hasOwnProperty("jsonType");
}
export {
  htmlToBlocks,
  normalizeBlock,
  randomKey
};
//# sourceMappingURL=index.js.map
