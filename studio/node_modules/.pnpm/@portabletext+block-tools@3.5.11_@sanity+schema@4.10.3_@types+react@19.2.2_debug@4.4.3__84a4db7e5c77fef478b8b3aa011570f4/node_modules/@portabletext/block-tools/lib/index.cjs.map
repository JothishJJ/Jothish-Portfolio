{"version":3,"file":"index.cjs","sources":["../src/util/randomKey.ts","../src/HtmlDeserializer/rules/gdocs.ts","../src/HtmlDeserializer/rules/whitespace-text-node.ts","../src/HtmlDeserializer/rules/html.ts","../src/HtmlDeserializer/rules/notion.ts","../src/HtmlDeserializer/rules/word.ts","../src/HtmlDeserializer/rules/index.ts","../src/HtmlDeserializer/index.ts","../src/util/normalizeBlock.ts","../src/index.ts"],"sourcesContent":["import getRandomValues from 'get-random-values-esm'\n\nexport function keyGenerator() {\n  return randomKey(12)\n}\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).slice(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style\\s*:\\s*italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight\\s*:\\s*700/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  if (!isElement(el) || tagName(el.parentNode) === 'a') {\n    return false\n  }\n\n  const style = isElement(el) && el.getAttribute('style')\n\n  return /text-decoration\\s*:\\s*underline/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for strike-through in their html\n// allows for line-through regex to be more lineient to allow for other text-decoration before or after\nfunction isStrikethrough(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction isRootNode(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-root-node'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(schema: Schema, el: Node): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!schema.styles.some((style) => style.name === block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport default function createGDocsRules(schema: Schema): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          if (!el.textContent) {\n            if (!el.previousSibling && !el.nextSibling) {\n              el.setAttribute('data-lonely-child', 'true')\n            }\n\n            return next(el.childNodes)\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isStrikethrough(el)) {\n            span.marks.push('strike-through')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(schema, el),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el.classList.contains('apple-interchange-newline')\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs inside empty paragraphs\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el?.parentNode?.textContent === ''\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs on the root\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          isRootNode(el)\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {tagName} from '../helpers'\n\nexport const whitespaceTextNodeRule: DeserializerRule = {\n  deserialize(node) {\n    return node.nodeName === '#text' && isWhitespaceTextNode(node)\n      ? {\n          ...DEFAULT_SPAN,\n          marks: [],\n          text: (node.textContent ?? '').replace(/\\s\\s+/g, ' '),\n        }\n      : undefined\n  },\n}\n\nfunction isWhitespaceTextNode(node: Node) {\n  const isValidWhiteSpace =\n    node.nodeType === 3 &&\n    (node.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') ===\n      ' ' &&\n    node.nextSibling &&\n    node.nextSibling.nodeType !== 3 &&\n    node.previousSibling &&\n    node.previousSibling.nodeType !== 3\n\n  return (\n    (isValidWhiteSpace || node.textContent !== ' ') &&\n    tagName(node.parentNode) !== 'body'\n  )\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_DECORATOR_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_SPAN_TAGS,\n  type PartialBlock,\n} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {whitespaceTextNodeRule} from './whitespace-text-node'\n\nexport function resolveListItem(\n  schema: Schema,\n  listNodeTagName: string,\n): string | undefined {\n  if (\n    listNodeTagName === 'ul' &&\n    schema.lists.some((list) => list.name === 'bullet')\n  ) {\n    return 'bullet'\n  }\n  if (\n    listNodeTagName === 'ol' &&\n    schema.lists.some((list) => list.name === 'number')\n  ) {\n    return 'number'\n  }\n  return undefined\n}\n\nexport default function createHTMLRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== 'pre') {\n          return undefined\n        }\n\n        const isCodeEnabled = schema.styles.some(\n          (style) => style.name === 'code',\n        )\n\n        return {\n          _type: 'block',\n          style: 'normal',\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? ['code'] : [],\n              text: el.textContent || '',\n            },\n          ],\n        }\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n        const nonBlockquoteBlocks = Object.keys(blocks)\n\n        const children: HTMLElement[] = []\n\n        el.childNodes.forEach((node, index) => {\n          if (!el.ownerDocument) {\n            return\n          }\n\n          if (\n            node.nodeType === 1 &&\n            nonBlockquoteBlocks.includes(\n              (node as Element).localName.toLowerCase(),\n            )\n          ) {\n            const span = el.ownerDocument.createElement('span')\n\n            const previousChild = children[children.length - 1]\n\n            if (\n              previousChild &&\n              previousChild.nodeType === 3 &&\n              previousChild.textContent?.trim()\n            ) {\n              // Only prepend line break if the previous node is a non-empty\n              // text node.\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n\n            if (index !== el.childNodes.length) {\n              // Only append line break if this is not the last child\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el.parentNode) === 'li') {\n          return next(el.childNodes)\n        }\n        const blockStyle = block.style\n        // If style is not supported, return a defaultBlockType\n        if (!schema.styles.some((style) => style.name === blockStyle)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        const parentTag = tagName(el.parentNode) || ''\n        if (\n          !listItem ||\n          !el.parentNode ||\n          !HTML_LIST_CONTAINER_TAGS[parentTag]\n        ) {\n          return undefined\n        }\n        const enabledListItem = resolveListItem(schema, parentTag)\n        // If the list item style is not supported, return a new default block\n        if (!enabledListItem) {\n          return block({_type: 'block', children: next(el.childNodes)})\n        }\n        listItem.listItem = enabledListItem\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (\n          !decorator ||\n          !schema.decorators.some(\n            (decoratorType) => decoratorType.name === decorator,\n          )\n        ) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'a') {\n          return undefined\n        }\n        const linkEnabled = schema.annotations.some(\n          (annotation) => annotation.name === 'link',\n        )\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        if (linkEnabled) {\n          return {\n            _type: '__annotation',\n            markDef: {\n              _key: options.keyGenerator\n                ? options.keyGenerator()\n                : keyGenerator(),\n              _type: 'link',\n              href: href,\n            },\n            children: next(el.childNodes),\n          }\n        }\n        return (\n          el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) &&\n          next(el.childNodes)\n        )\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (isElement(el) && (tagName(el) === 'td' || tagName(el) === 'th')) {\n          return {\n            ...DEFAULT_BLOCK,\n            children: next(el.childNodes),\n          }\n        }\n\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'img') {\n          const src = el.getAttribute('src') ?? undefined\n          const alt = el.getAttribute('alt') ?? undefined\n\n          const props = Object.fromEntries(\n            Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n          )\n\n          const ancestorOfLonelyChild =\n            el?.parentElement?.parentElement?.getAttribute('data-lonely-child')\n          const ancestorOfListItem = el.closest('li') !== null\n\n          if (ancestorOfLonelyChild && !ancestorOfListItem) {\n            const image = options.matchers?.image?.({\n              context: {\n                schema,\n                keyGenerator: options.keyGenerator ?? keyGenerator,\n              },\n              props: {\n                ...props,\n                ...(src ? {src} : {}),\n                ...(alt ? {alt} : {}),\n              },\n            })\n\n            if (image) {\n              return {\n                _type: '__block',\n                block: image,\n              }\n            }\n          }\n\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n\n          const image = options.matchers?.image?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (image) {\n            return {\n              _type: '__block',\n              block: image,\n            }\n          }\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 or 600 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return (\n    /font-weight:700/.test(style || '') || /font-weight:600/.test(style || '')\n  )\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration:underline/.test(style || '')\n}\n\n// Check for attribute given by the Notion preprocessor\nfunction isNotion(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-notion'))\n}\n\nexport default function createNotionRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        // Notion normally exports semantic HTML. However, if you copy a single block, the formatting will be inline styles\n        // This handles a limited set of styles\n        if (isElement(el) && tagName(el) === 'span' && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {BLOCK_DEFAULT_STYLE, DEFAULT_BLOCK} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? Number.parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  return isElement(el) && el.className\n    ? el.className === 'MsoListParagraphCxSpFirst' ||\n        el.className === 'MsoListParagraphCxSpMiddle' ||\n        el.className === 'MsoListParagraphCxSpLast'\n    : false\n}\n\nexport default function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'p' && isWordListElement(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport createGDocsRules from './gdocs'\nimport createHTMLRules from './html'\nimport createNotionRules from './notion'\nimport createWordRules from './word'\n\nexport function createRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(),\n    ...createGDocsRules(schema),\n    ...createHTMLRules(schema, options),\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n} from '@portabletext/schema'\nimport {flatten} from 'lodash'\nimport type {\n  ArbitraryTypedObject,\n  DeserializerRule,\n  HtmlDeserializerOptions,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {keyGenerator} from '../util/randomKey'\nimport {resolveJsType} from '../util/resolveJsType'\nimport {flattenNestedBlocks} from './flatten-nested-blocks'\nimport {\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  isMinimalBlock,\n  isMinimalSpan,\n  isNodeList,\n  isPlaceholderAnnotation,\n  isPlaceholderDecorator,\n  preprocess,\n  tagName,\n  trimWhitespace,\n} from './helpers'\nimport {createRules} from './rules'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  keyGenerator: () => string\n  schema: Schema\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  _markDefs: PortableTextObject[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(schema: Schema, options: HtmlDeserializerOptions = {}) {\n    const {rules = [], unstable_whitespaceOnPasteMode = 'preserve'} = options\n    const standardRules = createRules(schema, {\n      keyGenerator: options.keyGenerator,\n      matchers: options.matchers,\n    })\n    this.schema = schema\n    this.keyGenerator = options.keyGenerator ?? keyGenerator\n    this.rules = [...rules, ...standardRules]\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.parseHtml = (html) => {\n      const doc = preprocess(html, parseHtml, {unstable_whitespaceOnPasteMode})\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n    // Ensure that there are no blocks within blocks, and trim whitespace\n    const blocks = trimWhitespace(\n      this.schema,\n      flattenNestedBlocks(\n        {schema: this.schema},\n        ensureRootIsBlocks(\n          this.schema,\n          this.deserializeElements(children) as Array<ArbitraryTypedObject>,\n        ),\n      ),\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block) => isTextBlock({schema: this.schema}, block))\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return flatten(\n                block.children.map((child) => child.marks || []),\n              ).includes(def._key)\n            }),\n          )\n        })\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = this.schema.block.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (\n      elements: Node | Node[] | NodeList,\n    ): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node: TypedObject | Array<TypedObject> | undefined\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (\n        type !== 'array' &&\n        type !== 'object' &&\n        type !== 'null' &&\n        type !== 'undefined'\n      ) {\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`,\n        )\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        'listItem' in ret\n      ) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        ret.style === 'blockquote'\n      ) {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (\n    annotation: PlaceholderAnnotation,\n  ): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqual} from 'lodash'\nimport type {TypedObject} from '../types'\nimport {keyGenerator} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n\n  /**\n   * Custom key generator function\n   */\n  keyGenerator?: () => string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {},\n): Omit<\n  TypedObject | PortableTextTextBlock<TypedObject | PortableTextSpan>,\n  '_key'\n> & {\n  _key: string\n} {\n  const schema: Schema = {\n    block: {\n      name: options.blockTypeName || 'block',\n    },\n    span: {\n      name: 'span',\n    },\n    styles: [],\n    lists: [],\n    decorators: [],\n    annotations: [],\n    blockObjects: [],\n    inlineObjects: [],\n  }\n\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node\n      ? (node as TypedObject & {_key: string})\n      : {\n          ...node,\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        }\n  }\n\n  const block: Omit<\n    PortableTextTextBlock<TypedObject | PortableTextSpan>,\n    'style'\n  > = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce(\n      (acc, child) => {\n        const previousChild = acc[acc.length - 1]\n        if (\n          previousChild &&\n          isSpan({schema}, child) &&\n          isSpan({schema}, previousChild) &&\n          isEqual(previousChild.marks, child.marks)\n        ) {\n          if (\n            lastChild &&\n            lastChild === child &&\n            child.text === '' &&\n            block.children.length > 1\n          ) {\n            return acc\n          }\n\n          previousChild.text += child.text\n          return acc\n        }\n        acc.push(child)\n        return acc\n      },\n      [] as (TypedObject | PortableTextSpan)[],\n    )\n    .map((child) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = options.keyGenerator\n        ? options.keyGenerator()\n        : keyGenerator()\n\n      if (isSpan({schema}, child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs?.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = (block.markDefs || []).filter((markDef) =>\n    usedMarkDefs.includes(markDef._key),\n  )\n\n  return block\n}\n","import {sanitySchemaToPortableTextSchema} from '@portabletext/sanity-bridge'\nimport type {Schema} from '@portabletext/schema'\nimport type {ArraySchemaType} from '@sanity/types'\nimport HtmlDeserializer from './HtmlDeserializer'\nimport type {HtmlDeserializerOptions, TypedObject} from './types'\nimport {normalizeBlock} from './util/normalizeBlock'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param schemaType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  schemaType: ArraySchemaType | Schema,\n  options: HtmlDeserializerOptions = {},\n) {\n  const schema = isSanitySchema(schemaType)\n    ? sanitySchemaToPortableTextSchema(schemaType)\n    : schemaType\n\n  const deserializer = new HtmlDeserializer(schema, options)\n  return deserializer\n    .deserialize(html)\n    .map((block) => normalizeBlock(block, {keyGenerator: options.keyGenerator}))\n}\n\nexport type {ImageSchemaMatcher, SchemaMatchers} from './schema-matchers'\nexport type {ArbitraryTypedObject, DeserializerRule, HtmlParser} from './types'\nexport type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@portabletext/schema'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\nexport {randomKey} from './util/randomKey'\nexport {normalizeBlock}\nexport type {HtmlDeserializerOptions, TypedObject}\n\nfunction isSanitySchema(\n  schema: ArraySchemaType | Schema,\n): schema is ArraySchemaType {\n  return schema.hasOwnProperty('jsonType')\n}\n"],"names":["getRandomValues","HTML_LIST_CONTAINER_TAGS","isEmphasis","isElement","isStrong","isUnderline","tagName","getListItemStyle","getListItemLevel","HTML_BLOCK_TAGS","HTML_HEADER_TAGS","schema","BLOCK_DEFAULT_STYLE","DEFAULT_SPAN","DEFAULT_BLOCK","blocks","HTML_SPAN_TAGS","HTML_LIST_ITEM_TAGS","HTML_DECORATOR_TAGS","image","defaultParseHtml","preprocess","trimWhitespace","flattenNestedBlocks","ensureRootIsBlocks","isTextBlock","flatten","isNodeList","resolveJsType","isPlaceholderDecorator","isPlaceholderAnnotation","isMinimalBlock","isMinimalSpan","isSpan","isEqual","sanitySchemaToPortableTextSchema"],"mappings":"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"}