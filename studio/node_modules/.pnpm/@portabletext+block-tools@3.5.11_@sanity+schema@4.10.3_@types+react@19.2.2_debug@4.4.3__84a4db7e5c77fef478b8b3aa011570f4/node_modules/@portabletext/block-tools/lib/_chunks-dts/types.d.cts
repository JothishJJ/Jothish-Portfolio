import { PortableTextObject, Schema } from "@portabletext/schema";
/**
 * Use the current `Schema` as well as the potential element props to determine
 * what Portable Text Object to use to represent the element.
 */
type ObjectSchemaMatcher<TProps extends Record<string, unknown>> = ({
  context,
  props
}: {
  context: {
    schema: Schema;
    keyGenerator: () => string;
  };
  props: TProps;
}) => ArbitraryTypedObject | undefined;
/**
 * Use the current `Schema` as well as the potential img element props to
 * determine what Portable Text Object to use to represent the image.
 * @beta
 */
type ImageSchemaMatcher = ObjectSchemaMatcher<{
  src?: string;
  alt?: string;
  [key: string]: string | undefined;
}>;
/**
 * @beta
 */
type SchemaMatchers = {
  /**
   * Called whenever the HTML parsing encounters an `<img>` element that is
   * inferred to be a block element.
   */
  image?: ImageSchemaMatcher;
  /**
   * Called whenever the HTML parsing encounters an `<img>` element that is
   * inferred to be an inline element.
   */
  inlineImage?: ImageSchemaMatcher;
};
/**
 * @public
 */
interface TypedObject {
  _type: string;
  _key?: string;
}
/**
 * @public
 */
interface ArbitraryTypedObject extends TypedObject {
  [key: string]: unknown;
}
/**
 * @public
 */
type HtmlParser = (html: string) => Document;
/**
 * @public
 */
type WhiteSpacePasteMode = 'preserve' | 'remove' | 'normalize';
/**
 * @public
 */
interface HtmlDeserializerOptions {
  keyGenerator?: () => string;
  rules?: DeserializerRule[];
  parseHtml?: HtmlParser;
  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode;
  /**
   * Custom schema matchers to use when deserializing HTML to Portable Text.
   * @beta
   */
  matchers?: SchemaMatchers;
}
/**
 * @public
 */
interface DeserializerRule {
  deserialize: (el: Node, next: (elements: Node | Node[] | NodeList) => TypedObject | TypedObject[] | undefined, createBlock: (props: ArbitraryTypedObject) => {
    _type: string;
    block: ArbitraryTypedObject;
  }) => TypedObject | TypedObject[] | undefined;
}
export { ArbitraryTypedObject, DeserializerRule, HtmlDeserializerOptions, HtmlParser, ImageSchemaMatcher, SchemaMatchers, TypedObject };