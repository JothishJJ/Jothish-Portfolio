{"version":3,"file":"helpers.cjs","sources":["../../src/util/resolveJsType.ts","../../src/types.ts","../../src/HtmlDeserializer/flatten-nested-blocks.ts","../../../../node_modules/.pnpm/@vercel+stega@0.1.2/node_modules/@vercel/stega/dist/index.mjs","../../src/constants.ts","../../src/HtmlDeserializer/preprocessors/xpathResult.ts","../../src/HtmlDeserializer/preprocessors/gdocs.ts","../../src/HtmlDeserializer/preprocessors/html.ts","../../src/HtmlDeserializer/preprocessors/notion.ts","../../src/HtmlDeserializer/preprocessors/whitespace.ts","../../src/HtmlDeserializer/preprocessors/word.ts","../../src/HtmlDeserializer/preprocessors/index.ts","../../src/HtmlDeserializer/helpers.ts"],"sourcesContent":["const objectToString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (objectToString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","import type {PortableTextObject} from '@portabletext/schema'\nimport type {SchemaMatchers} from './schema-matchers'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  _type: string\n  _key?: string\n}\n\n/**\n * @public\n */\nexport interface ArbitraryTypedObject extends TypedObject {\n  [key: string]: unknown\n}\n\nexport function isArbitraryTypedObject(\n  object: unknown,\n): object is ArbitraryTypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\nexport interface MinimalSpan {\n  _type: 'span'\n  _key?: string\n  text: string\n  marks?: string[]\n}\n\nexport interface MinimalBlock extends TypedObject {\n  _type: 'block'\n  children: TypedObject[]\n  markDefs?: TypedObject[]\n  style?: string\n  level?: number\n  listItem?: string\n}\n\nexport interface PlaceholderDecorator {\n  _type: '__decorator'\n  name: string\n  children: TypedObject[]\n}\n\nexport interface PlaceholderAnnotation {\n  _type: '__annotation'\n  markDef: PortableTextObject\n  children: TypedObject[]\n}\n\n/**\n * @public\n */\nexport type HtmlParser = (html: string) => Document\n\n/**\n * @public\n */\nexport type WhiteSpacePasteMode = 'preserve' | 'remove' | 'normalize'\n\n/**\n * @public\n */\nexport interface HtmlDeserializerOptions {\n  keyGenerator?: () => string\n  rules?: DeserializerRule[]\n  parseHtml?: HtmlParser\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n  /**\n   * Custom schema matchers to use when deserializing HTML to Portable Text.\n   * @beta\n   */\n  matchers?: SchemaMatchers\n}\n\nexport interface HtmlPreprocessorOptions {\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n}\n\n/**\n * @public\n */\nexport interface DeserializerRule {\n  deserialize: (\n    el: Node,\n    next: (\n      elements: Node | Node[] | NodeList,\n    ) => TypedObject | TypedObject[] | undefined,\n    createBlock: (props: ArbitraryTypedObject) => {\n      _type: string\n      block: ArbitraryTypedObject\n    },\n  ) => TypedObject | TypedObject[] | undefined\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqual} from 'lodash'\nimport {\n  isArbitraryTypedObject,\n  type ArbitraryTypedObject,\n  type TypedObject,\n} from '../types'\n\nexport function flattenNestedBlocks(\n  context: {\n    schema: Schema\n  },\n  blocks: Array<ArbitraryTypedObject>,\n): TypedObject[] {\n  const flattened = blocks.flatMap((block) => {\n    if (isBlockContainer(block)) {\n      return flattenNestedBlocks(context, [block.block])\n    }\n\n    if (isTextBlock(context, block)) {\n      const hasBlockObjects = block.children.some((child) => {\n        const knownBlockObject = context.schema.blockObjects.some(\n          (blockObject) => blockObject.name === child._type,\n        )\n        return knownBlockObject\n      })\n      const hasBlocks = block.children.some(\n        (child) => child._type === '__block' || child._type === 'block',\n      )\n\n      if (hasBlockObjects || hasBlocks) {\n        const splitChildren = getSplitChildren(context, block)\n\n        if (\n          splitChildren.length === 1 &&\n          splitChildren[0].type === 'children' &&\n          isEqual(splitChildren[0].children, block.children)\n        ) {\n          return [block]\n        }\n\n        return splitChildren.flatMap((slice) => {\n          if (slice.type === 'block object') {\n            return [slice.block]\n          }\n\n          if (slice.type === 'block') {\n            return flattenNestedBlocks(context, [\n              slice.block as ArbitraryTypedObject,\n            ])\n          }\n\n          if (slice.children.length > 0) {\n            if (\n              slice.children.every(\n                (child) => isSpan(context, child) && child.text.trim() === '',\n              )\n            ) {\n              return []\n            }\n\n            return flattenNestedBlocks(context, [\n              {\n                ...block,\n                children: slice.children,\n              },\n            ])\n          }\n\n          return []\n        })\n      }\n\n      return [block]\n    }\n\n    return [block]\n  })\n\n  return flattened\n}\n\nfunction isBlockContainer(\n  block: ArbitraryTypedObject,\n): block is BlockContainer {\n  return block._type === '__block' && isArbitraryTypedObject(block.block)\n}\n\ntype BlockContainer = {\n  _type: '__block'\n  block: ArbitraryTypedObject\n}\n\nfunction getSplitChildren(\n  context: {schema: Schema},\n  block: PortableTextTextBlock,\n) {\n  return block.children.reduce(\n    (slices, child) => {\n      const knownInlineObject = context.schema.inlineObjects.some(\n        (inlineObject) => inlineObject.name === child._type,\n      )\n      const knownBlockObject = context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type,\n      )\n\n      const lastSlice = slices.pop()\n\n      if (!isSpan(context, child) && !knownInlineObject) {\n        if (knownBlockObject) {\n          return [\n            ...slices,\n            ...(lastSlice ? [lastSlice] : []),\n            {type: 'block object' as const, block: child},\n          ]\n        }\n      }\n\n      if (child._type === '__block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {\n            type: 'block object' as const,\n            block: (child as any).block,\n          },\n        ]\n      }\n\n      if (child._type === 'block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {type: 'block' as const, block: child},\n        ]\n      }\n\n      if (lastSlice) {\n        if (lastSlice.type === 'children') {\n          return [\n            ...slices,\n            {\n              type: 'children' as const,\n              children: [...lastSlice.children, child],\n            },\n          ]\n        }\n      }\n\n      return [\n        ...slices,\n        ...(lastSlice ? [lastSlice] : []),\n        {type: 'children' as const, children: [child]},\n      ]\n    },\n    [] as Array<\n      | {\n          type: 'children'\n          children: Array<PortableTextSpan | PortableTextObject>\n        }\n      | {type: 'block object'; block: PortableTextObject}\n      | {type: 'block'; block: PortableTextBlock}\n    >,\n  )\n}\n","var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {uniq} from 'lodash'\n\nexport interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<\n  string,\n  {object: null} | undefined\n> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = uniq(\n  Object.values(ELEMENT_MAP)\n    .filter((tag): tag is PartialBlock => 'style' in tag)\n    .map((tag) => tag.style),\n)\n\nexport const DEFAULT_SUPPORTED_DECORATORS = uniq(\n  Object.values(HTML_DECORATOR_TAGS),\n)\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import type {HtmlPreprocessorOptions} from '../../types'\nimport {normalizeWhitespace, removeAllWhitespace, tagName} from '../helpers'\nimport {_XPathResult} from './xpathResult'\n\nexport default (\n  _html: string,\n  doc: Document,\n  options: HtmlPreprocessorOptions,\n): Document => {\n  const whitespaceOnPasteMode =\n    options?.unstable_whitespaceOnPasteMode || 'preserve'\n  let gDocsRootOrSiblingNode = doc\n    .evaluate(\n      '//*[@id and contains(@id, \"docs-internal-guid\")]',\n      doc,\n      null,\n      _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n      null,\n    )\n    .iterateNext()\n\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === 'b'\n\n    // If this document isn't wrapped in a 'b' tag, then assume all siblings live on the root level\n    if (!isWrappedRootTag) {\n      gDocsRootOrSiblingNode = doc.body\n    }\n\n    switch (whitespaceOnPasteMode) {\n      case 'normalize':\n        // Keep only 1 empty block between content nodes\n        normalizeWhitespace(gDocsRootOrSiblingNode)\n        break\n      case 'remove':\n        // Remove all whitespace nodes\n        removeAllWhitespace(gDocsRootOrSiblingNode)\n        break\n      default:\n        break\n    }\n\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n\n      if (\n        elm?.parentElement === gDocsRootOrSiblingNode ||\n        (!isWrappedRootTag && elm.parentElement === doc.body)\n      ) {\n        elm?.setAttribute('data-is-root-node', 'true')\n        tagName(elm)\n      }\n\n      // Handle checkmark lists - The first child of a list item is an image with a checkmark, and the serializer\n      // expects the first child to be the text node\n      if (\n        tagName(elm) === 'li' &&\n        elm.firstChild &&\n        tagName(elm?.firstChild) === 'img'\n      ) {\n        elm.removeChild(elm.firstChild)\n      }\n    }\n\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    if (isWrappedRootTag) {\n      doc.body.firstElementChild?.replaceWith(\n        ...Array.from(gDocsRootOrSiblingNode.childNodes),\n      )\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport default (_html: string, doc: Document): Document => {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nexport default (html: string, doc: Document): Document => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g\n\n  if (html.match(NOTION_REGEX)) {\n    // Tag every child with attribute 'is-notion' so that the Notion rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-notion', 'true')\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {PRESERVE_WHITESPACE_TAGS} from '../../constants'\nimport {_XPathResult} from './xpathResult'\n\nexport default (_: string, doc: Document): Document => {\n  // Recursively process all nodes.\n  function processNode(node: Node) {\n    // If this is a text node and not inside a tag where whitespace should be preserved, process it.\n    if (\n      node.nodeType === _XPathResult.BOOLEAN_TYPE &&\n      !PRESERVE_WHITESPACE_TAGS.includes(\n        node.parentElement?.tagName.toLowerCase() || '',\n      )\n    ) {\n      node.textContent =\n        node.textContent\n          ?.replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n          .replace(/[\\r\\n]+/g, ' ') || '' // Replace newlines with spaces\n    }\n    // Otherwise, if this node has children, process them.\n    else {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        processNode(node.childNodes[i])\n      }\n    }\n  }\n\n  // Process all nodes starting from the root.\n  processNode(doc.body)\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX =\n  /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport default (html: string, doc: Document): Document => {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = doc.createTextNode(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = doc.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import preprocessGDocs from './gdocs'\nimport preprocessHTML from './html'\nimport preprocessNotion from './notion'\nimport preprocessWhitespace from './whitespace'\nimport preprocessWord from './word'\n\nexport default [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML,\n]\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isTextBlock,\n  type PortableTextObject,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {vercelStegaClean} from '@vercel/stega'\nimport {isEqual} from 'lodash'\nimport {DEFAULT_BLOCK} from '../constants'\nimport type {\n  ArbitraryTypedObject,\n  HtmlParser,\n  HtmlPreprocessorOptions,\n  MinimalBlock,\n  MinimalSpan,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {resolveJsType} from '../util/resolveJsType'\nimport preprocessors from './preprocessors'\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n// TODO: make this plugin-style\nexport function preprocess(\n  html: string,\n  parseHtml: HtmlParser,\n  options: HtmlPreprocessorOptions,\n): Document {\n  const cleanHTML = vercelStegaClean(html)\n  const doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML))\n  preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options)\n  })\n  return doc\n}\n\nfunction normalizeHtmlBeforePreprocess(html: string): string {\n  return html.trim()\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nfunction nextSpan(block: PortableTextTextBlock, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: PortableTextTextBlock, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n\n/**\n * NOTE: _mutates_ passed blocks!\n *\n * @param blocks - Array of blocks to trim whitespace for\n * @returns\n */\nexport function trimWhitespace(\n  schema: Schema,\n  blocks: TypedObject[],\n): TypedObject[] {\n  blocks.forEach((block) => {\n    if (!isTextBlock({schema}, block)) {\n      return\n    }\n\n    // eslint-disable-next-line complexity\n    block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child)) {\n        return\n      }\n      const nextChild = nextSpan(block, index)\n      const prevChild = prevSpan(block, index)\n      if (index === 0) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (index === block.children.length - 1) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) &&\n        nextChild &&\n        isMinimalSpan(nextChild) &&\n        /\\s/.test(nextChild.text.slice(0, 1))\n      ) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.slice(0, 1)) &&\n        prevChild &&\n        isMinimalSpan(prevChild) &&\n        /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1)))\n      ) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (!child.text) {\n        block.children.splice(index, 1)\n      }\n      if (\n        prevChild &&\n        isEqual(prevChild.marks, child.marks) &&\n        isWhiteSpaceChar(child.text)\n      ) {\n        prevChild.text += ' '\n        block.children.splice(index, 1)\n      } else if (\n        nextChild &&\n        isEqual(nextChild.marks, child.marks) &&\n        isWhiteSpaceChar(child.text)\n      ) {\n        nextChild.text = ` ${nextChild.text}`\n        block.children.splice(index, 1)\n      }\n    })\n  })\n\n  return blocks\n}\n\nexport function ensureRootIsBlocks(\n  schema: Schema,\n  objects: Array<ArbitraryTypedObject>,\n): ArbitraryTypedObject[] {\n  return objects.reduce((blocks, node, i, original) => {\n    if (node._type === 'block') {\n      blocks.push(node)\n      return blocks\n    }\n\n    if (node._type === '__block') {\n      blocks.push((node as any).block)\n      return blocks\n    }\n\n    const lastBlock = blocks[blocks.length - 1]\n    if (\n      i > 0 &&\n      !isTextBlock({schema}, original[i - 1]) &&\n      isTextBlock({schema}, lastBlock)\n    ) {\n      lastBlock.children.push(node as PortableTextObject)\n      return blocks\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    blocks.push(block)\n    return blocks\n  }, [] as ArbitraryTypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) === '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(\n  node: TypedObject,\n): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(\n  node: TypedObject,\n): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n\n/**\n * Helper to normalize whitespace to only 1 empty block between content nodes\n * @param node - Root node to process\n */\nexport function normalizeWhitespace(rootNode: Node) {\n  let emptyBlockCount = 0\n  let lastParent = null\n  const nodesToRemove: Node[] = []\n\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child)\n      emptyBlockCount = 0\n      continue\n    }\n\n    const elm = child as HTMLElement\n\n    if (isWhitespaceBlock(elm)) {\n      if (lastParent && elm.parentElement === lastParent) {\n        emptyBlockCount++\n        if (emptyBlockCount > 1) {\n          nodesToRemove.push(elm)\n        }\n      } else {\n        // Different parent, reset counter\n        emptyBlockCount = 1\n      }\n\n      lastParent = elm.parentElement\n    } else {\n      // Recurse into child nodes\n      normalizeWhitespace(child)\n      // Reset counter for siblings\n      emptyBlockCount = 0\n    }\n  }\n\n  // Remove marked nodes\n  nodesToRemove.forEach((node) => {\n    node.parentElement?.removeChild(node)\n  })\n}\n\n/**\n * Helper to remove all whitespace nodes\n * @param node - Root node to process\n */\nexport function removeAllWhitespace(rootNode: Node) {\n  const nodesToRemove: Node[] = []\n\n  function collectNodesToRemove(currentNode: Node) {\n    if (isElement(currentNode)) {\n      const elm = currentNode as HTMLElement\n\n      // Handle <br> tags that is between <p> tags\n      if (\n        tagName(elm) === 'br' &&\n        (tagName(elm.nextElementSibling) === 'p' ||\n          tagName(elm.previousElementSibling) === 'p')\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Handle empty blocks\n      if (\n        (tagName(elm) === 'p' || tagName(elm) === 'br') &&\n        elm?.firstChild?.textContent?.trim() === ''\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Recursively process child nodes\n      for (let child = elm.firstChild; child; child = child.nextSibling) {\n        collectNodesToRemove(child)\n      }\n    }\n  }\n\n  collectNodesToRemove(rootNode)\n\n  // Remove the collected nodes\n  nodesToRemove.forEach((node) => {\n    node.parentElement?.removeChild(node)\n  })\n}\n\nfunction isWhitespaceBlock(elm: HTMLElement): boolean {\n  return ['p', 'br'].includes(tagName(elm) || '') && !elm.textContent?.trim()\n}\n"],"names":["isTextBlock","isEqual","isSpan","uniq","_","vercelStegaClean","schema"],"mappings":"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","x_google_ignoreList":[3]}